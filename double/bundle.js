/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */
!function (e, t) { "use strict"; "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) { if (!e.document) throw new Error("jQuery requires a window with a document"); return t(e); } : t(e); }("undefined" != typeof window ? window : this, function (C, e) { "use strict"; var t = [], r = Object.getPrototypeOf, s = t.slice, g = t.flat ? function (e) { return t.flat.call(e); } : function (e) { return t.concat.apply([], e); }, u = t.push, i = t.indexOf, n = {}, o = n.toString, v = n.hasOwnProperty, a = v.toString, l = a.call(Object), y = {}, m = function (e) { return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item; }, x = function (e) { return null != e && e === e.window; }, E = C.document, c = { type: !0, src: !0, nonce: !0, noModule: !0 }; function b(e, t, n) { var r, i, o = (n = n || E).createElement("script"); if (o.text = e, t) for (r in c) (i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i); n.head.appendChild(o).parentNode.removeChild(o); } function w(e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[o.call(e)] || "object" : typeof e; } var f = "3.6.0", S = function (e, t) { return new S.fn.init(e, t); }; function p(e) { var t = !!e && "length" in e && e.length, n = w(e); return !m(e) && !x(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e); } S.fn = S.prototype = { jquery: f, constructor: S, length: 0, toArray: function () { return s.call(this); }, get: function (e) { return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e]; }, pushStack: function (e) { var t = S.merge(this.constructor(), e); return t.prevObject = this, t; }, each: function (e) { return S.each(this, e); }, map: function (n) { return this.pushStack(S.map(this, function (e, t) { return n.call(e, t, e); })); }, slice: function () { return this.pushStack(s.apply(this, arguments)); }, first: function () { return this.eq(0); }, last: function () { return this.eq(-1); }, even: function () { return this.pushStack(S.grep(this, function (e, t) { return (t + 1) % 2; })); }, odd: function () { return this.pushStack(S.grep(this, function (e, t) { return t % 2; })); }, eq: function (e) { var t = this.length, n = +e + (e < 0 ? t : 0); return this.pushStack(0 <= n && n < t ? [this[n]] : []); }, end: function () { return this.prevObject || this.constructor(); }, push: u, sort: t.sort, splice: t.splice }, S.extend = S.fn.extend = function () { var e, t, n, r, i, o, a = arguments[0] || {}, s = 1, u = arguments.length, l = !1; for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || m(a) || (a = {}), s === u && (a = this, s--); s < u; s++)if (null != (e = arguments[s])) for (t in e) r = e[t], "__proto__" !== t && a !== r && (l && r && (S.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || S.isPlainObject(n) ? n : {}, i = !1, a[t] = S.extend(l, o, r)) : void 0 !== r && (a[t] = r)); return a; }, S.extend({ expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (e) { throw new Error(e); }, noop: function () { }, isPlainObject: function (e) { var t, n; return !(!e || "[object Object]" !== o.call(e)) && (!(t = r(e)) || "function" == typeof (n = v.call(t, "constructor") && t.constructor) && a.call(n) === l); }, isEmptyObject: function (e) { var t; for (t in e) return !1; return !0; }, globalEval: function (e, t, n) { b(e, { nonce: t && t.nonce }, n); }, each: function (e, t) { var n, r = 0; if (p(e)) { for (n = e.length; r < n; r++)if (!1 === t.call(e[r], r, e[r])) break; } else for (r in e) if (!1 === t.call(e[r], r, e[r])) break; return e; }, makeArray: function (e, t) { var n = t || []; return null != e && (p(Object(e)) ? S.merge(n, "string" == typeof e ? [e] : e) : u.call(n, e)), n; }, inArray: function (e, t, n) { return null == t ? -1 : i.call(t, e, n); }, merge: function (e, t) { for (var n = +t.length, r = 0, i = e.length; r < n; r++)e[i++] = t[r]; return e.length = i, e; }, grep: function (e, t, n) { for (var r = [], i = 0, o = e.length, a = !n; i < o; i++)!t(e[i], i) !== a && r.push(e[i]); return r; }, map: function (e, t, n) { var r, i, o = 0, a = []; if (p(e)) for (r = e.length; o < r; o++)null != (i = t(e[o], o, n)) && a.push(i); else for (o in e) null != (i = t(e[o], o, n)) && a.push(i); return g(a); }, guid: 1, support: y }), "function" == typeof Symbol && (S.fn[Symbol.iterator] = t[Symbol.iterator]), S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) { n["[object " + t + "]"] = t.toLowerCase(); }); var d = function (n) { var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E, v, s, c, y, S = "sizzle" + 1 * new Date, p = n.document, k = 0, r = 0, m = ue(), x = ue(), A = ue(), N = ue(), j = function (e, t) { return e === t && (l = !0), 0; }, D = {}.hasOwnProperty, t = [], q = t.pop, L = t.push, H = t.push, O = t.slice, P = function (e, t) { for (var n = 0, r = e.length; n < r; n++)if (e[n] === t) return n; return -1; }, R = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", M = "[\\x20\\t\\r\\n\\f]", I = "(?:\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", W = "\\[" + M + "*(" + I + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + M + "*\\]", F = ":(" + I + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + W + ")*)|.*)\\)|)", B = new RegExp(M + "+", "g"), $ = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"), _ = new RegExp("^" + M + "*," + M + "*"), z = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"), U = new RegExp(M + "|>"), X = new RegExp(F), V = new RegExp("^" + I + "$"), G = { ID: new RegExp("^#(" + I + ")"), CLASS: new RegExp("^\\.(" + I + ")"), TAG: new RegExp("^(" + I + "|[*])"), ATTR: new RegExp("^" + W), PSEUDO: new RegExp("^" + F), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"), bool: new RegExp("^(?:" + R + ")$", "i"), needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i") }, Y = /HTML$/i, Q = /^(?:input|select|textarea|button)$/i, J = /^h\d$/i, K = /^[^{]+\{\s*\[native \w/, Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ee = /[+~]/, te = new RegExp("\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\([^\\r\\n\\f])", "g"), ne = function (e, t) { var n = "0x" + e.slice(1) - 65536; return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)); }, re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, ie = function (e, t) { return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e; }, oe = function () { T(); }, ae = be(function (e) { return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase(); }, { dir: "parentNode", next: "legend" }); try { H.apply(t = O.call(p.childNodes), p.childNodes), t[p.childNodes.length].nodeType; } catch (e) { H = { apply: t.length ? function (e, t) { L.apply(e, O.call(t)); } : function (e, t) { var n = e.length, r = 0; while (e[n++] = t[r++]); e.length = n - 1; } }; } function se(t, e, n, r) { var i, o, a, s, u, l, c, f = e && e.ownerDocument, p = e ? e.nodeType : 9; if (n = n || [], "string" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p) return n; if (!r && (T(e), e = e || C, E)) { if (11 !== p && (u = Z.exec(t))) if (i = u[1]) { if (9 === p) { if (!(a = e.getElementById(i))) return n; if (a.id === i) return n.push(a), n; } else if (f && (a = f.getElementById(i)) && y(e, a) && a.id === i) return n.push(a), n; } else { if (u[2]) return H.apply(n, e.getElementsByTagName(t)), n; if ((i = u[3]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply(n, e.getElementsByClassName(i)), n; } if (d.qsa && !N[t + " "] && (!v || !v.test(t)) && (1 !== p || "object" !== e.nodeName.toLowerCase())) { if (c = t, f = e, 1 === p && (U.test(t) || z.test(t))) { (f = ee.test(t) && ye(e.parentNode) || e) === e && d.scope || ((s = e.getAttribute("id")) ? s = s.replace(re, ie) : e.setAttribute("id", s = S)), o = (l = h(t)).length; while (o--) l[o] = (s ? "#" + s : ":scope") + " " + xe(l[o]); c = l.join(","); } try { return H.apply(n, f.querySelectorAll(c)), n; } catch (e) { N(t, !0); } finally { s === S && e.removeAttribute("id"); } } } return g(t.replace($, "$1"), e, n, r); } function ue() { var r = []; return function e(t, n) { return r.push(t + " ") > b.cacheLength && delete e[r.shift()], e[t + " "] = n; }; } function le(e) { return e[S] = !0, e; } function ce(e) { var t = C.createElement("fieldset"); try { return !!e(t); } catch (e) { return !1; } finally { t.parentNode && t.parentNode.removeChild(t), t = null; } } function fe(e, t) { var n = e.split("|"), r = n.length; while (r--) b.attrHandle[n[r]] = t; } function pe(e, t) { var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex; if (r) return r; if (n) while (n = n.nextSibling) if (n === t) return -1; return e ? 1 : -1; } function de(t) { return function (e) { return "input" === e.nodeName.toLowerCase() && e.type === t; }; } function he(n) { return function (e) { var t = e.nodeName.toLowerCase(); return ("input" === t || "button" === t) && e.type === n; }; } function ge(t) { return function (e) { return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ae(e) === t : e.disabled === t : "label" in e && e.disabled === t; }; } function ve(a) { return le(function (o) { return o = +o, le(function (e, t) { var n, r = a([], e.length, o), i = r.length; while (i--) e[n = r[i]] && (e[n] = !(t[n] = e[n])); }); }); } function ye(e) { return e && "undefined" != typeof e.getElementsByTagName && e; } for (e in d = se.support = {}, i = se.isXML = function (e) { var t = e && e.namespaceURI, n = e && (e.ownerDocument || e).documentElement; return !Y.test(t || n && n.nodeName || "HTML"); }, T = se.setDocument = function (e) { var t, n, r = e ? e.ownerDocument || e : p; return r != C && 9 === r.nodeType && r.documentElement && (a = (C = r).documentElement, E = !i(C), p != C && (n = C.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", oe, !1) : n.attachEvent && n.attachEvent("onunload", oe)), d.scope = ce(function (e) { return a.appendChild(e).appendChild(C.createElement("div")), "undefined" != typeof e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length; }), d.attributes = ce(function (e) { return e.className = "i", !e.getAttribute("className"); }), d.getElementsByTagName = ce(function (e) { return e.appendChild(C.createComment("")), !e.getElementsByTagName("*").length; }), d.getElementsByClassName = K.test(C.getElementsByClassName), d.getById = ce(function (e) { return a.appendChild(e).id = S, !C.getElementsByName || !C.getElementsByName(S).length; }), d.getById ? (b.filter.ID = function (e) { var t = e.replace(te, ne); return function (e) { return e.getAttribute("id") === t; }; }, b.find.ID = function (e, t) { if ("undefined" != typeof t.getElementById && E) { var n = t.getElementById(e); return n ? [n] : []; } }) : (b.filter.ID = function (e) { var n = e.replace(te, ne); return function (e) { var t = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id"); return t && t.value === n; }; }, b.find.ID = function (e, t) { if ("undefined" != typeof t.getElementById && E) { var n, r, i, o = t.getElementById(e); if (o) { if ((n = o.getAttributeNode("id")) && n.value === e) return [o]; i = t.getElementsByName(e), r = 0; while (o = i[r++]) if ((n = o.getAttributeNode("id")) && n.value === e) return [o]; } return []; } }), b.find.TAG = d.getElementsByTagName ? function (e, t) { return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0; } : function (e, t) { var n, r = [], i = 0, o = t.getElementsByTagName(e); if ("*" === e) { while (n = o[i++]) 1 === n.nodeType && r.push(n); return r; } return o; }, b.find.CLASS = d.getElementsByClassName && function (e, t) { if ("undefined" != typeof t.getElementsByClassName && E) return t.getElementsByClassName(e); }, s = [], v = [], (d.qsa = K.test(C.querySelectorAll)) && (ce(function (e) { var t; a.appendChild(e).innerHTML = "<a id='" + S + "'></a><select id='" + S + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || v.push("\\[" + M + "*(?:value|" + R + ")"), e.querySelectorAll("[id~=" + S + "-]").length || v.push("~="), (t = C.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || v.push("\\[" + M + "*name" + M + "*=" + M + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || v.push(":checked"), e.querySelectorAll("a#" + S + "+*").length || v.push(".#.+[+~]"), e.querySelectorAll("\\\f"), v.push("[\\r\\n\\f]"); }), ce(function (e) { e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; var t = C.createElement("input"); t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && v.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), v.push(",.*:"); })), (d.matchesSelector = K.test(c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function (e) { d.disconnectedMatch = c.call(e, "*"), c.call(e, "[s!='']:x"), s.push("!=", F); }), v = v.length && new RegExp(v.join("|")), s = s.length && new RegExp(s.join("|")), t = K.test(a.compareDocumentPosition), y = t || K.test(a.contains) ? function (e, t) { var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode; return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))); } : function (e, t) { if (t) while (t = t.parentNode) if (t === e) return !0; return !1; }, j = t ? function (e, t) { if (e === t) return l = !0, 0; var n = !e.compareDocumentPosition - !t.compareDocumentPosition; return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === n ? e == C || e.ownerDocument == p && y(p, e) ? -1 : t == C || t.ownerDocument == p && y(p, t) ? 1 : u ? P(u, e) - P(u, t) : 0 : 4 & n ? -1 : 1); } : function (e, t) { if (e === t) return l = !0, 0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; if (!i || !o) return e == C ? -1 : t == C ? 1 : i ? -1 : o ? 1 : u ? P(u, e) - P(u, t) : 0; if (i === o) return pe(e, t); n = e; while (n = n.parentNode) a.unshift(n); n = t; while (n = n.parentNode) s.unshift(n); while (a[r] === s[r]) r++; return r ? pe(a[r], s[r]) : a[r] == p ? -1 : s[r] == p ? 1 : 0; }), C; }, se.matches = function (e, t) { return se(e, null, null, t); }, se.matchesSelector = function (e, t) { if (T(e), d.matchesSelector && E && !N[t + " "] && (!s || !s.test(t)) && (!v || !v.test(t))) try { var n = c.call(e, t); if (n || d.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n; } catch (e) { N(t, !0); } return 0 < se(t, C, null, [e]).length; }, se.contains = function (e, t) { return (e.ownerDocument || e) != C && T(e), y(e, t); }, se.attr = function (e, t) { (e.ownerDocument || e) != C && T(e); var n = b.attrHandle[t.toLowerCase()], r = n && D.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !E) : void 0; return void 0 !== r ? r : d.attributes || !E ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null; }, se.escape = function (e) { return (e + "").replace(re, ie); }, se.error = function (e) { throw new Error("Syntax error, unrecognized expression: " + e); }, se.uniqueSort = function (e) { var t, n = [], r = 0, i = 0; if (l = !d.detectDuplicates, u = !d.sortStable && e.slice(0), e.sort(j), l) { while (t = e[i++]) t === e[i] && (r = n.push(i)); while (r--) e.splice(n[r], 1); } return u = null, e; }, o = se.getText = function (e) { var t, n = "", r = 0, i = e.nodeType; if (i) { if (1 === i || 9 === i || 11 === i) { if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)n += o(e); } else if (3 === i || 4 === i) return e.nodeValue; } else while (t = e[r++]) n += o(t); return n; }, (b = se.selectors = { cacheLength: 50, createPseudo: le, match: G, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (e) { return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4); }, CHILD: function (e) { return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e; }, PSEUDO: function (e) { var t, n = !e[6] && e[2]; return G.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = h(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)); } }, filter: { TAG: function (e) { var t = e.replace(te, ne).toLowerCase(); return "*" === e ? function () { return !0; } : function (e) { return e.nodeName && e.nodeName.toLowerCase() === t; }; }, CLASS: function (e) { var t = m[e + " "]; return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && m(e, function (e) { return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || ""); }); }, ATTR: function (n, r, i) { return function (e) { var t = se.attr(e, n); return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(B, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-")); }; }, CHILD: function (h, e, t, g, v) { var y = "nth" !== h.slice(0, 3), m = "last" !== h.slice(-4), x = "of-type" === e; return 1 === g && 0 === v ? function (e) { return !!e.parentNode; } : function (e, t, n) { var r, i, o, a, s, u, l = y !== m ? "nextSibling" : "previousSibling", c = e.parentNode, f = x && e.nodeName.toLowerCase(), p = !n && !x, d = !1; if (c) { if (y) { while (l) { a = e; while (a = a[l]) if (x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) return !1; u = l = "only" === h && !u && "nextSibling"; } return !0; } if (u = [m ? c.firstChild : c.lastChild], m && p) { d = (s = (r = (i = (o = (a = c)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]) && r[2], a = s && c.childNodes[s]; while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if (1 === a.nodeType && ++d && a === e) { i[h] = [k, s, d]; break; } } else if (p && (d = s = (r = (i = (o = (a = e)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]), !1 === d) while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) if ((x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) && ++d && (p && ((i = (o = a[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] = [k, d]), a === e)) break; return (d -= v) === g || d % g == 0 && 0 <= d / g; } }; }, PSEUDO: function (e, o) { var t, a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e); return a[S] ? a(o) : 1 < a.length ? (t = [e, e, "", o], b.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function (e, t) { var n, r = a(e, o), i = r.length; while (i--) e[n = P(e, r[i])] = !(t[n] = r[i]); }) : function (e) { return a(e, 0, t); }) : a; } }, pseudos: { not: le(function (e) { var r = [], i = [], s = f(e.replace($, "$1")); return s[S] ? le(function (e, t, n, r) { var i, o = s(e, null, r, []), a = e.length; while (a--) (i = o[a]) && (e[a] = !(t[a] = i)); }) : function (e, t, n) { return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop(); }; }), has: le(function (t) { return function (e) { return 0 < se(t, e).length; }; }), contains: le(function (t) { return t = t.replace(te, ne), function (e) { return -1 < (e.textContent || o(e)).indexOf(t); }; }), lang: le(function (n) { return V.test(n || "") || se.error("unsupported lang: " + n), n = n.replace(te, ne).toLowerCase(), function (e) { var t; do { if (t = E ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-"); } while ((e = e.parentNode) && 1 === e.nodeType); return !1; }; }), target: function (e) { var t = n.location && n.location.hash; return t && t.slice(1) === e.id; }, root: function (e) { return e === a; }, focus: function (e) { return e === C.activeElement && (!C.hasFocus || C.hasFocus()) && !!(e.type || e.href || ~e.tabIndex); }, enabled: ge(!1), disabled: ge(!0), checked: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && !!e.checked || "option" === t && !!e.selected; }, selected: function (e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected; }, empty: function (e) { for (e = e.firstChild; e; e = e.nextSibling)if (e.nodeType < 6) return !1; return !0; }, parent: function (e) { return !b.pseudos.empty(e); }, header: function (e) { return J.test(e.nodeName); }, input: function (e) { return Q.test(e.nodeName); }, button: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && "button" === e.type || "button" === t; }, text: function (e) { var t; return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase()); }, first: ve(function () { return [0]; }), last: ve(function (e, t) { return [t - 1]; }), eq: ve(function (e, t, n) { return [n < 0 ? n + t : n]; }), even: ve(function (e, t) { for (var n = 0; n < t; n += 2)e.push(n); return e; }), odd: ve(function (e, t) { for (var n = 1; n < t; n += 2)e.push(n); return e; }), lt: ve(function (e, t, n) { for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r;)e.push(r); return e; }), gt: ve(function (e, t, n) { for (var r = n < 0 ? n + t : n; ++r < t;)e.push(r); return e; }) } }).pseudos.nth = b.pseudos.eq, { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) b.pseudos[e] = de(e); for (e in { submit: !0, reset: !0 }) b.pseudos[e] = he(e); function me() { } function xe(e) { for (var t = 0, n = e.length, r = ""; t < n; t++)r += e[t].value; return r; } function be(s, e, t) { var u = e.dir, l = e.next, c = l || u, f = t && "parentNode" === c, p = r++; return e.first ? function (e, t, n) { while (e = e[u]) if (1 === e.nodeType || f) return s(e, t, n); return !1; } : function (e, t, n) { var r, i, o, a = [k, p]; if (n) { while (e = e[u]) if ((1 === e.nodeType || f) && s(e, t, n)) return !0; } else while (e = e[u]) if (1 === e.nodeType || f) if (i = (o = e[S] || (e[S] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase()) e = e[u] || e; else { if ((r = i[c]) && r[0] === k && r[1] === p) return a[2] = r[2]; if ((i[c] = a)[2] = s(e, t, n)) return !0; } return !1; }; } function we(i) { return 1 < i.length ? function (e, t, n) { var r = i.length; while (r--) if (!i[r](e, t, n)) return !1; return !0; } : i[0]; } function Te(e, t, n, r, i) { for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s))); return a; } function Ce(d, h, g, v, y, e) { return v && !v[S] && (v = Ce(v)), y && !y[S] && (y = Ce(y, e)), le(function (e, t, n, r) { var i, o, a, s = [], u = [], l = t.length, c = e || function (e, t, n) { for (var r = 0, i = t.length; r < i; r++)se(e, t[r], n); return n; }(h || "*", n.nodeType ? [n] : n, []), f = !d || !e && h ? c : Te(c, s, d, n, r), p = g ? y || (e ? d : l || v) ? [] : t : f; if (g && g(f, p, n, r), v) { i = Te(p, u), v(i, [], n, r), o = i.length; while (o--) (a = i[o]) && (p[u[o]] = !(f[u[o]] = a)); } if (e) { if (y || d) { if (y) { i = [], o = p.length; while (o--) (a = p[o]) && i.push(f[o] = a); y(null, p = [], i, r); } o = p.length; while (o--) (a = p[o]) && -1 < (i = y ? P(e, a) : s[o]) && (e[i] = !(t[i] = a)); } } else p = Te(p === t ? p.splice(l, p.length) : p), y ? y(null, t, p, r) : H.apply(t, p); }); } function Ee(e) { for (var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, u = be(function (e) { return e === i; }, a, !0), l = be(function (e) { return -1 < P(i, e); }, a, !0), c = [function (e, t, n) { var r = !o && (n || t !== w) || ((i = t).nodeType ? u(e, t, n) : l(e, t, n)); return i = null, r; }]; s < r; s++)if (t = b.relative[e[s].type]) c = [be(we(c), t)]; else { if ((t = b.filter[e[s].type].apply(null, e[s].matches))[S]) { for (n = ++s; n < r; n++)if (b.relative[e[n].type]) break; return Ce(1 < s && we(c), 1 < s && xe(e.slice(0, s - 1).concat({ value: " " === e[s - 2].type ? "*" : "" })).replace($, "$1"), t, s < n && Ee(e.slice(s, n)), n < r && Ee(e = e.slice(n)), n < r && xe(e)); } c.push(t); } return we(c); } return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function (e, t) { var n, r, i, o, a, s, u, l = x[e + " "]; if (l) return t ? 0 : l.slice(0); a = e, s = [], u = b.preFilter; while (a) { for (o in n && !(r = _.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = z.exec(a)) && (n = r.shift(), i.push({ value: n, type: r[0].replace($, " ") }), a = a.slice(n.length)), b.filter) !(r = G[o].exec(a)) || u[o] && !(r = u[o](r)) || (n = r.shift(), i.push({ value: n, type: o, matches: r }), a = a.slice(n.length)); if (!n) break; } return t ? a.length : a ? se.error(e) : x(e, s).slice(0); }, f = se.compile = function (e, t) { var n, v, y, m, x, r, i = [], o = [], a = A[e + " "]; if (!a) { t || (t = h(e)), n = t.length; while (n--) (a = Ee(t[n]))[S] ? i.push(a) : o.push(a); (a = A(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function (e, t, n, r, i) { var o, a, s, u = 0, l = "0", c = e && [], f = [], p = w, d = e || x && b.find.TAG("*", i), h = k += null == p ? 1 : Math.random() || .1, g = d.length; for (i && (w = t == C || t || i); l !== g && null != (o = d[l]); l++) { if (x && o) { a = 0, t || o.ownerDocument == C || (T(o), n = !E); while (s = v[a++]) if (s(o, t || C, n)) { r.push(o); break; } i && (k = h); } m && ((o = !s && o) && u--, e && c.push(o)); } if (u += l, m && l !== u) { a = 0; while (s = y[a++]) s(c, f, t, n); if (e) { if (0 < u) while (l--) c[l] || f[l] || (f[l] = q.call(r)); f = Te(f); } H.apply(r, f), i && !e && 0 < f.length && 1 < u + y.length && se.uniqueSort(r); } return i && (k = h, w = p), c; }, m ? le(r) : r))).selector = e; } return a; }, g = se.select = function (e, t, n, r) { var i, o, a, s, u, l = "function" == typeof e && e, c = !r && h(e = l.selector || e); if (n = n || [], 1 === c.length) { if (2 < (o = c[0] = c[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && E && b.relative[o[1].type]) { if (!(t = (b.find.ID(a.matches[0].replace(te, ne), t) || [])[0])) return n; l && (t = t.parentNode), e = e.slice(o.shift().value.length); } i = G.needsContext.test(e) ? 0 : o.length; while (i--) { if (a = o[i], b.relative[s = a.type]) break; if ((u = b.find[s]) && (r = u(a.matches[0].replace(te, ne), ee.test(o[0].type) && ye(t.parentNode) || t))) { if (o.splice(i, 1), !(e = r.length && xe(o))) return H.apply(n, r), n; break; } } } return (l || f(e, c))(r, t, !E, n, !t || ee.test(e) && ye(t.parentNode) || t), n; }, d.sortStable = S.split("").sort(j).join("") === S, d.detectDuplicates = !!l, T(), d.sortDetached = ce(function (e) { return 1 & e.compareDocumentPosition(C.createElement("fieldset")); }), ce(function (e) { return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href"); }) || fe("type|href|height|width", function (e, t, n) { if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2); }), d.attributes && ce(function (e) { return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value"); }) || fe("value", function (e, t, n) { if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue; }), ce(function (e) { return null == e.getAttribute("disabled"); }) || fe(R, function (e, t, n) { var r; if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null; }), se; }(C); S.find = d, S.expr = d.selectors, S.expr[":"] = S.expr.pseudos, S.uniqueSort = S.unique = d.uniqueSort, S.text = d.getText, S.isXMLDoc = d.isXML, S.contains = d.contains, S.escapeSelector = d.escape; var h = function (e, t, n) { var r = [], i = void 0 !== n; while ((e = e[t]) && 9 !== e.nodeType) if (1 === e.nodeType) { if (i && S(e).is(n)) break; r.push(e); } return r; }, T = function (e, t) { for (var n = []; e; e = e.nextSibling)1 === e.nodeType && e !== t && n.push(e); return n; }, k = S.expr.match.needsContext; function A(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase(); } var N = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; function j(e, n, r) { return m(n) ? S.grep(e, function (e, t) { return !!n.call(e, t, e) !== r; }) : n.nodeType ? S.grep(e, function (e) { return e === n !== r; }) : "string" != typeof n ? S.grep(e, function (e) { return -1 < i.call(n, e) !== r; }) : S.filter(n, e, r); } S.filter = function (e, t, n) { var r = t[0]; return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? S.find.matchesSelector(r, e) ? [r] : [] : S.find.matches(e, S.grep(t, function (e) { return 1 === e.nodeType; })); }, S.fn.extend({ find: function (e) { var t, n, r = this.length, i = this; if ("string" != typeof e) return this.pushStack(S(e).filter(function () { for (t = 0; t < r; t++)if (S.contains(i[t], this)) return !0; })); for (n = this.pushStack([]), t = 0; t < r; t++)S.find(e, i[t], n); return 1 < r ? S.uniqueSort(n) : n; }, filter: function (e) { return this.pushStack(j(this, e || [], !1)); }, not: function (e) { return this.pushStack(j(this, e || [], !0)); }, is: function (e) { return !!j(this, "string" == typeof e && k.test(e) ? S(e) : e || [], !1).length; } }); var D, q = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/; (S.fn.init = function (e, t, n) { var r, i; if (!e) return this; if (n = n || D, "string" == typeof e) { if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : q.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e); if (r[1]) { if (t = t instanceof S ? t[0] : t, S.merge(this, S.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), N.test(r[1]) && S.isPlainObject(t)) for (r in t) m(this[r]) ? this[r](t[r]) : this.attr(r, t[r]); return this; } return (i = E.getElementById(r[2])) && (this[0] = i, this.length = 1), this; } return e.nodeType ? (this[0] = e, this.length = 1, this) : m(e) ? void 0 !== n.ready ? n.ready(e) : e(S) : S.makeArray(e, this); }).prototype = S.fn, D = S(E); var L = /^(?:parents|prev(?:Until|All))/, H = { children: !0, contents: !0, next: !0, prev: !0 }; function O(e, t) { while ((e = e[t]) && 1 !== e.nodeType); return e; } S.fn.extend({ has: function (e) { var t = S(e, this), n = t.length; return this.filter(function () { for (var e = 0; e < n; e++)if (S.contains(this, t[e])) return !0; }); }, closest: function (e, t) { var n, r = 0, i = this.length, o = [], a = "string" != typeof e && S(e); if (!k.test(e)) for (; r < i; r++)for (n = this[r]; n && n !== t; n = n.parentNode)if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && S.find.matchesSelector(n, e))) { o.push(n); break; } return this.pushStack(1 < o.length ? S.uniqueSort(o) : o); }, index: function (e) { return e ? "string" == typeof e ? i.call(S(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1; }, add: function (e, t) { return this.pushStack(S.uniqueSort(S.merge(this.get(), S(e, t)))); }, addBack: function (e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)); } }), S.each({ parent: function (e) { var t = e.parentNode; return t && 11 !== t.nodeType ? t : null; }, parents: function (e) { return h(e, "parentNode"); }, parentsUntil: function (e, t, n) { return h(e, "parentNode", n); }, next: function (e) { return O(e, "nextSibling"); }, prev: function (e) { return O(e, "previousSibling"); }, nextAll: function (e) { return h(e, "nextSibling"); }, prevAll: function (e) { return h(e, "previousSibling"); }, nextUntil: function (e, t, n) { return h(e, "nextSibling", n); }, prevUntil: function (e, t, n) { return h(e, "previousSibling", n); }, siblings: function (e) { return T((e.parentNode || {}).firstChild, e); }, children: function (e) { return T(e.firstChild); }, contents: function (e) { return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (A(e, "template") && (e = e.content || e), S.merge([], e.childNodes)); } }, function (r, i) { S.fn[r] = function (e, t) { var n = S.map(this, i, e); return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = S.filter(t, n)), 1 < this.length && (H[r] || S.uniqueSort(n), L.test(r) && n.reverse()), this.pushStack(n); }; }); var P = /[^\x20\t\r\n\f]+/g; function R(e) { return e; } function M(e) { throw e; } function I(e, t, n, r) { var i; try { e && m(i = e.promise) ? i.call(e).done(t).fail(n) : e && m(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r)); } catch (e) { n.apply(void 0, [e]); } } S.Callbacks = function (r) { var e, n; r = "string" == typeof r ? (e = r, n = {}, S.each(e.match(P) || [], function (e, t) { n[t] = !0; }), n) : S.extend({}, r); var i, t, o, a, s = [], u = [], l = -1, c = function () { for (a = a || r.once, o = i = !0; u.length; l = -1) { t = u.shift(); while (++l < s.length) !1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1); } r.memory || (t = !1), i = !1, a && (s = t ? [] : ""); }, f = { add: function () { return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) { S.each(e, function (e, t) { m(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && "string" !== w(t) && n(t); }); }(arguments), t && !i && c()), this; }, remove: function () { return S.each(arguments, function (e, t) { var n; while (-1 < (n = S.inArray(t, s, n))) s.splice(n, 1), n <= l && l--; }), this; }, has: function (e) { return e ? -1 < S.inArray(e, s) : 0 < s.length; }, empty: function () { return s && (s = []), this; }, disable: function () { return a = u = [], s = t = "", this; }, disabled: function () { return !s; }, lock: function () { return a = u = [], t || i || (s = t = ""), this; }, locked: function () { return !!a; }, fireWith: function (e, t) { return a || (t = [e, (t = t || []).slice ? t.slice() : t], u.push(t), i || c()), this; }, fire: function () { return f.fireWith(this, arguments), this; }, fired: function () { return !!o; } }; return f; }, S.extend({ Deferred: function (e) { var o = [["notify", "progress", S.Callbacks("memory"), S.Callbacks("memory"), 2], ["resolve", "done", S.Callbacks("once memory"), S.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", S.Callbacks("once memory"), S.Callbacks("once memory"), 1, "rejected"]], i = "pending", a = { state: function () { return i; }, always: function () { return s.done(arguments).fail(arguments), this; }, "catch": function (e) { return a.then(null, e); }, pipe: function () { var i = arguments; return S.Deferred(function (r) { S.each(o, function (e, t) { var n = m(i[t[4]]) && i[t[4]]; s[t[1]](function () { var e = n && n.apply(this, arguments); e && m(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [e] : arguments); }); }), i = null; }).promise(); }, then: function (t, n, r) { var u = 0; function l(i, o, a, s) { return function () { var n = this, r = arguments, e = function () { var e, t; if (!(i < u)) { if ((e = a.apply(n, r)) === o.promise()) throw new TypeError("Thenable self-resolution"); t = e && ("object" == typeof e || "function" == typeof e) && e.then, m(t) ? s ? t.call(e, l(u, o, R, s), l(u, o, M, s)) : (u++, t.call(e, l(u, o, R, s), l(u, o, M, s), l(u, o, R, o.notifyWith))) : (a !== R && (n = void 0, r = [e]), (s || o.resolveWith)(n, r)); } }, t = s ? e : function () { try { e(); } catch (e) { S.Deferred.exceptionHook && S.Deferred.exceptionHook(e, t.stackTrace), u <= i + 1 && (a !== M && (n = void 0, r = [e]), o.rejectWith(n, r)); } }; i ? t() : (S.Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook()), C.setTimeout(t)); }; } return S.Deferred(function (e) { o[0][3].add(l(0, e, m(r) ? r : R, e.notifyWith)), o[1][3].add(l(0, e, m(t) ? t : R)), o[2][3].add(l(0, e, m(n) ? n : M)); }).promise(); }, promise: function (e) { return null != e ? S.extend(e, a) : a; } }, s = {}; return S.each(o, function (e, t) { var n = t[2], r = t[5]; a[t[1]] = n.add, r && n.add(function () { i = r; }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function () { return s[t[0] + "With"](this === s ? void 0 : this, arguments), this; }, s[t[0] + "With"] = n.fireWith; }), a.promise(s), e && e.call(s, s), s; }, when: function (e) { var n = arguments.length, t = n, r = Array(t), i = s.call(arguments), o = S.Deferred(), a = function (t) { return function (e) { r[t] = this, i[t] = 1 < arguments.length ? s.call(arguments) : e, --n || o.resolveWith(r, i); }; }; if (n <= 1 && (I(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || m(i[t] && i[t].then))) return o.then(); while (t--) I(i[t], a(t), o.reject); return o.promise(); } }); var W = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; S.Deferred.exceptionHook = function (e, t) { C.console && C.console.warn && e && W.test(e.name) && C.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t); }, S.readyException = function (e) { C.setTimeout(function () { throw e; }); }; var F = S.Deferred(); function B() { E.removeEventListener("DOMContentLoaded", B), C.removeEventListener("load", B), S.ready(); } S.fn.ready = function (e) { return F.then(e)["catch"](function (e) { S.readyException(e); }), this; }, S.extend({ isReady: !1, readyWait: 1, ready: function (e) { (!0 === e ? --S.readyWait : S.isReady) || (S.isReady = !0) !== e && 0 < --S.readyWait || F.resolveWith(E, [S]); } }), S.ready.then = F.then, "complete" === E.readyState || "loading" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(S.ready) : (E.addEventListener("DOMContentLoaded", B), C.addEventListener("load", B)); var $ = function (e, t, n, r, i, o, a) { var s = 0, u = e.length, l = null == n; if ("object" === w(n)) for (s in i = !0, n) $(e, t, s, n[s], !0, o, a); else if (void 0 !== r && (i = !0, m(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) { return l.call(S(e), n); })), t)) for (; s < u; s++)t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n))); return i ? e : l ? t.call(e) : u ? t(e[0], n) : o; }, _ = /^-ms-/, z = /-([a-z])/g; function U(e, t) { return t.toUpperCase(); } function X(e) { return e.replace(_, "ms-").replace(z, U); } var V = function (e) { return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType; }; function G() { this.expando = S.expando + G.uid++; } G.uid = 1, G.prototype = { cache: function (e) { var t = e[this.expando]; return t || (t = {}, V(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t; }, set: function (e, t, n) { var r, i = this.cache(e); if ("string" == typeof t) i[X(t)] = n; else for (r in t) i[X(r)] = t[r]; return i; }, get: function (e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][X(t)]; }, access: function (e, t, n) { return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t); }, remove: function (e, t) { var n, r = e[this.expando]; if (void 0 !== r) { if (void 0 !== t) { n = (t = Array.isArray(t) ? t.map(X) : (t = X(t)) in r ? [t] : t.match(P) || []).length; while (n--) delete r[t[n]]; } (void 0 === t || S.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]); } }, hasData: function (e) { var t = e[this.expando]; return void 0 !== t && !S.isEmptyObject(t); } }; var Y = new G, Q = new G, J = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, K = /[A-Z]/g; function Z(e, t, n) { var r, i; if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(K, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) { try { n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : J.test(i) ? JSON.parse(i) : i); } catch (e) { } Q.set(e, t, n); } else n = void 0; return n; } S.extend({ hasData: function (e) { return Q.hasData(e) || Y.hasData(e); }, data: function (e, t, n) { return Q.access(e, t, n); }, removeData: function (e, t) { Q.remove(e, t); }, _data: function (e, t, n) { return Y.access(e, t, n); }, _removeData: function (e, t) { Y.remove(e, t); } }), S.fn.extend({ data: function (n, e) { var t, r, i, o = this[0], a = o && o.attributes; if (void 0 === n) { if (this.length && (i = Q.get(o), 1 === o.nodeType && !Y.get(o, "hasDataAttrs"))) { t = a.length; while (t--) a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = X(r.slice(5)), Z(o, r, i[r])); Y.set(o, "hasDataAttrs", !0); } return i; } return "object" == typeof n ? this.each(function () { Q.set(this, n); }) : $(this, function (e) { var t; if (o && void 0 === e) return void 0 !== (t = Q.get(o, n)) ? t : void 0 !== (t = Z(o, n)) ? t : void 0; this.each(function () { Q.set(this, n, e); }); }, null, e, 1 < arguments.length, null, !0); }, removeData: function (e) { return this.each(function () { Q.remove(this, e); }); } }), S.extend({ queue: function (e, t, n) { var r; if (e) return t = (t || "fx") + "queue", r = Y.get(e, t), n && (!r || Array.isArray(n) ? r = Y.access(e, t, S.makeArray(n)) : r.push(n)), r || []; }, dequeue: function (e, t) { t = t || "fx"; var n = S.queue(e, t), r = n.length, i = n.shift(), o = S._queueHooks(e, t); "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function () { S.dequeue(e, t); }, o)), !r && o && o.empty.fire(); }, _queueHooks: function (e, t) { var n = t + "queueHooks"; return Y.get(e, n) || Y.access(e, n, { empty: S.Callbacks("once memory").add(function () { Y.remove(e, [t + "queue", n]); }) }); } }), S.fn.extend({ queue: function (t, n) { var e = 2; return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? S.queue(this[0], t) : void 0 === n ? this : this.each(function () { var e = S.queue(this, t, n); S._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && S.dequeue(this, t); }); }, dequeue: function (e) { return this.each(function () { S.dequeue(this, e); }); }, clearQueue: function (e) { return this.queue(e || "fx", []); }, promise: function (e, t) { var n, r = 1, i = S.Deferred(), o = this, a = this.length, s = function () { --r || i.resolveWith(o, [o]); }; "string" != typeof e && (t = e, e = void 0), e = e || "fx"; while (a--) (n = Y.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s)); return s(), i.promise(t); } }); var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"), ne = ["Top", "Right", "Bottom", "Left"], re = E.documentElement, ie = function (e) { return S.contains(e.ownerDocument, e); }, oe = { composed: !0 }; re.getRootNode && (ie = function (e) { return S.contains(e.ownerDocument, e) || e.getRootNode(oe) === e.ownerDocument; }); var ae = function (e, t) { return "none" === (e = t || e).style.display || "" === e.style.display && ie(e) && "none" === S.css(e, "display"); }; function se(e, t, n, r) { var i, o, a = 20, s = r ? function () { return r.cur(); } : function () { return S.css(e, t, ""); }, u = s(), l = n && n[3] || (S.cssNumber[t] ? "" : "px"), c = e.nodeType && (S.cssNumber[t] || "px" !== l && +u) && te.exec(S.css(e, t)); if (c && c[3] !== l) { u /= 2, l = l || c[3], c = +u || 1; while (a--) S.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o; c *= 2, S.style(e, t, c + l), n = n || []; } return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i; } var ue = {}; function le(e, t) { for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++)(r = e[c]).style && (n = r.style.display, t ? ("none" === n && (l[c] = Y.get(r, "display") || null, l[c] || (r.style.display = "")), "" === r.style.display && ae(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ue[s]) || (o = a.body.appendChild(a.createElement(s)), u = S.css(o, "display"), o.parentNode.removeChild(o), "none" === u && (u = "block"), ue[s] = u)))) : "none" !== n && (l[c] = "none", Y.set(r, "display", n))); for (c = 0; c < f; c++)null != l[c] && (e[c].style.display = l[c]); return e; } S.fn.extend({ show: function () { return le(this, !0); }, hide: function () { return le(this); }, toggle: function (e) { return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () { ae(this) ? S(this).show() : S(this).hide(); }); } }); var ce, fe, pe = /^(?:checkbox|radio)$/i, de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, he = /^$|^module$|\/(?:java|ecma)script/i; ce = E.createDocumentFragment().appendChild(E.createElement("div")), (fe = E.createElement("input")).setAttribute("type", "radio"), fe.setAttribute("checked", "checked"), fe.setAttribute("name", "t"), ce.appendChild(fe), y.checkClone = ce.cloneNode(!0).cloneNode(!0).lastChild.checked, ce.innerHTML = "<textarea>x</textarea>", y.noCloneChecked = !!ce.cloneNode(!0).lastChild.defaultValue, ce.innerHTML = "<option></option>", y.option = !!ce.lastChild; var ge = { thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] }; function ve(e, t) { var n; return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && A(e, t) ? S.merge([e], n) : n; } function ye(e, t) { for (var n = 0, r = e.length; n < r; n++)Y.set(e[n], "globalEval", !t || Y.get(t[n], "globalEval")); } ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td, y.option || (ge.optgroup = ge.option = [1, "<select multiple='multiple'>", "</select>"]); var me = /<|&#?\w+;/; function xe(e, t, n, r, i) { for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)if ((o = e[d]) || 0 === o) if ("object" === w(o)) S.merge(p, o.nodeType ? [o] : o); else if (me.test(o)) { a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + S.htmlPrefilter(o) + u[2], c = u[0]; while (c--) a = a.lastChild; S.merge(p, a.childNodes), (a = f.firstChild).textContent = ""; } else p.push(t.createTextNode(o)); f.textContent = "", d = 0; while (o = p[d++]) if (r && -1 < S.inArray(o, r)) i && i.push(o); else if (l = ie(o), a = ve(f.appendChild(o), "script"), l && ye(a), n) { c = 0; while (o = a[c++]) he.test(o.type || "") && n.push(o); } return f; } var be = /^([^.]*)(?:\.(.+)|)/; function we() { return !0; } function Te() { return !1; } function Ce(e, t) { return e === function () { try { return E.activeElement; } catch (e) { } }() == ("focus" === t); } function Ee(e, t, n, r, i, o) { var a, s; if ("object" == typeof t) { for (s in "string" != typeof n && (r = r || n, n = void 0), t) Ee(e, s, n, r, t[s], o); return e; } if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Te; else if (!i) return e; return 1 === o && (a = i, (i = function (e) { return S().off(e), a.apply(this, arguments); }).guid = a.guid || (a.guid = S.guid++)), e.each(function () { S.event.add(this, t, i, r, n); }); } function Se(e, i, o) { o ? (Y.set(e, i, !1), S.event.add(e, i, { namespace: !1, handler: function (e) { var t, n, r = Y.get(this, i); if (1 & e.isTrigger && this[i]) { if (r.length) (S.event.special[i] || {}).delegateType && e.stopPropagation(); else if (r = s.call(arguments), Y.set(this, i, r), t = o(this, i), this[i](), r !== (n = Y.get(this, i)) || t ? Y.set(this, i, !1) : n = {}, r !== n) return e.stopImmediatePropagation(), e.preventDefault(), n && n.value; } else r.length && (Y.set(this, i, { value: S.event.trigger(S.extend(r[0], S.Event.prototype), r.slice(1), this) }), e.stopImmediatePropagation()); } })) : void 0 === Y.get(e, i) && S.event.add(e, i, we); } S.event = { global: {}, add: function (t, e, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, v = Y.get(t); if (V(t)) { n.handler && (n = (o = n).handler, i = o.selector), i && S.find.matchesSelector(re, i), n.guid || (n.guid = S.guid++), (u = v.events) || (u = v.events = Object.create(null)), (a = v.handle) || (a = v.handle = function (e) { return "undefined" != typeof S && S.event.triggered !== e.type ? S.event.dispatch.apply(t, arguments) : void 0; }), l = (e = (e || "").match(P) || [""]).length; while (l--) d = g = (s = be.exec(e[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = S.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = S.event.special[d] || {}, c = S.extend({ type: d, origType: g, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && S.expr.match.needsContext.test(i), namespace: h.join(".") }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), S.event.global[d] = !0); } }, remove: function (e, t, n, r, i) { var o, a, s, u, l, c, f, p, d, h, g, v = Y.hasData(e) && Y.get(e); if (v && (u = v.events)) { l = (t = (t || "").match(P) || [""]).length; while (l--) if (d = g = (s = be.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d) { f = S.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length; while (o--) c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c)); a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || S.removeEvent(e, d, v.handle), delete u[d]); } else for (d in u) S.event.remove(e, d + t[l], n, r, !0); S.isEmptyObject(u) && Y.remove(e, "handle events"); } }, dispatch: function (e) { var t, n, r, i, o, a, s = new Array(arguments.length), u = S.event.fix(e), l = (Y.get(this, "events") || Object.create(null))[u.type] || [], c = S.event.special[u.type] || {}; for (s[0] = u, t = 1; t < arguments.length; t++)s[t] = arguments[t]; if (u.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, u)) { a = S.event.handlers.call(this, u, l), t = 0; while ((i = a[t++]) && !u.isPropagationStopped()) { u.currentTarget = i.elem, n = 0; while ((o = i.handlers[n++]) && !u.isImmediatePropagationStopped()) u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace) || (u.handleObj = o, u.data = o.data, void 0 !== (r = ((S.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (u.result = r) && (u.preventDefault(), u.stopPropagation())); } return c.postDispatch && c.postDispatch.call(this, u), u.result; } }, handlers: function (e, t) { var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType && !("click" === e.type && 1 <= e.button)) for (; l !== this; l = l.parentNode || this)if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) { for (o = [], a = {}, n = 0; n < u; n++)void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < S(i, this).index(l) : S.find(i, this, null, [l]).length), a[i] && o.push(r); o.length && s.push({ elem: l, handlers: o }); } return l = this, u < t.length && s.push({ elem: l, handlers: t.slice(u) }), s; }, addProp: function (t, e) { Object.defineProperty(S.Event.prototype, t, { enumerable: !0, configurable: !0, get: m(e) ? function () { if (this.originalEvent) return e(this.originalEvent); } : function () { if (this.originalEvent) return this.originalEvent[t]; }, set: function (e) { Object.defineProperty(this, t, { enumerable: !0, configurable: !0, writable: !0, value: e }); } }); }, fix: function (e) { return e[S.expando] ? e : new S.Event(e); }, special: { load: { noBubble: !0 }, click: { setup: function (e) { var t = this || e; return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click", we), !1; }, trigger: function (e) { var t = this || e; return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click"), !0; }, _default: function (e) { var t = e.target; return pe.test(t.type) && t.click && A(t, "input") && Y.get(t, "click") || A(t, "a"); } }, beforeunload: { postDispatch: function (e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result); } } } }, S.removeEvent = function (e, t, n) { e.removeEventListener && e.removeEventListener(t, n); }, S.Event = function (e, t) { if (!(this instanceof S.Event)) return new S.Event(e, t); e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? we : Te, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && S.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[S.expando] = !0; }, S.Event.prototype = { constructor: S.Event, isDefaultPrevented: Te, isPropagationStopped: Te, isImmediatePropagationStopped: Te, isSimulated: !1, preventDefault: function () { var e = this.originalEvent; this.isDefaultPrevented = we, e && !this.isSimulated && e.preventDefault(); }, stopPropagation: function () { var e = this.originalEvent; this.isPropagationStopped = we, e && !this.isSimulated && e.stopPropagation(); }, stopImmediatePropagation: function () { var e = this.originalEvent; this.isImmediatePropagationStopped = we, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation(); } }, S.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, "char": !0, code: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: !0 }, S.event.addProp), S.each({ focus: "focusin", blur: "focusout" }, function (e, t) { S.event.special[e] = { setup: function () { return Se(this, e, Ce), !1; }, trigger: function () { return Se(this, e), !0; }, _default: function () { return !0; }, delegateType: t }; }), S.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function (e, i) { S.event.special[e] = { delegateType: i, bindType: i, handle: function (e) { var t, n = e.relatedTarget, r = e.handleObj; return n && (n === this || S.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t; } }; }), S.fn.extend({ on: function (e, t, n, r) { return Ee(this, e, t, n, r); }, one: function (e, t, n, r) { return Ee(this, e, t, n, r, 1); }, off: function (e, t, n) { var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, S(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this; if ("object" == typeof e) { for (i in e) this.off(i, t, e[i]); return this; } return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Te), this.each(function () { S.event.remove(this, e, n, t); }); } }); var ke = /<script|<style|<link/i, Ae = /checked\s*(?:[^=]|=\s*.checked.)/i, Ne = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; function je(e, t) { return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && S(e).children("tbody")[0] || e; } function De(e) { return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e; } function qe(e) { return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e; } function Le(e, t) { var n, r, i, o, a, s; if (1 === t.nodeType) { if (Y.hasData(e) && (s = Y.get(e).events)) for (i in Y.remove(t, "handle events"), s) for (n = 0, r = s[i].length; n < r; n++)S.event.add(t, i, s[i][n]); Q.hasData(e) && (o = Q.access(e), a = S.extend({}, o), Q.set(t, a)); } } function He(n, r, i, o) { r = g(r); var e, t, a, s, u, l, c = 0, f = n.length, p = f - 1, d = r[0], h = m(d); if (h || 1 < f && "string" == typeof d && !y.checkClone && Ae.test(d)) return n.each(function (e) { var t = n.eq(e); h && (r[0] = d.call(this, e, t.html())), He(t, r, i, o); }); if (f && (t = (e = xe(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) { for (s = (a = S.map(ve(e, "script"), De)).length; c < f; c++)u = e, c !== p && (u = S.clone(u, !0, !0), s && S.merge(a, ve(u, "script"))), i.call(n[c], u, c); if (s) for (l = a[a.length - 1].ownerDocument, S.map(a, qe), c = 0; c < s; c++)u = a[c], he.test(u.type || "") && !Y.access(u, "globalEval") && S.contains(l, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? S._evalUrl && !u.noModule && S._evalUrl(u.src, { nonce: u.nonce || u.getAttribute("nonce") }, l) : b(u.textContent.replace(Ne, ""), u, l)); } return n; } function Oe(e, t, n) { for (var r, i = t ? S.filter(t, e) : e, o = 0; null != (r = i[o]); o++)n || 1 !== r.nodeType || S.cleanData(ve(r)), r.parentNode && (n && ie(r) && ye(ve(r, "script")), r.parentNode.removeChild(r)); return e; } S.extend({ htmlPrefilter: function (e) { return e; }, clone: function (e, t, n) { var r, i, o, a, s, u, l, c = e.cloneNode(!0), f = ie(e); if (!(y.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || S.isXMLDoc(e))) for (a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++)s = o[r], u = a[r], void 0, "input" === (l = u.nodeName.toLowerCase()) && pe.test(s.type) ? u.checked = s.checked : "input" !== l && "textarea" !== l || (u.defaultValue = s.defaultValue); if (t) if (n) for (o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++)Le(o[r], a[r]); else Le(e, c); return 0 < (a = ve(c, "script")).length && ye(a, !f && ve(e, "script")), c; }, cleanData: function (e) { for (var t, n, r, i = S.event.special, o = 0; void 0 !== (n = e[o]); o++)if (V(n)) { if (t = n[Y.expando]) { if (t.events) for (r in t.events) i[r] ? S.event.remove(n, r) : S.removeEvent(n, r, t.handle); n[Y.expando] = void 0; } n[Q.expando] && (n[Q.expando] = void 0); } } }), S.fn.extend({ detach: function (e) { return Oe(this, e, !0); }, remove: function (e) { return Oe(this, e); }, text: function (e) { return $(this, function (e) { return void 0 === e ? S.text(this) : this.empty().each(function () { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e); }); }, null, e, arguments.length); }, append: function () { return He(this, arguments, function (e) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || je(this, e).appendChild(e); }); }, prepend: function () { return He(this, arguments, function (e) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var t = je(this, e); t.insertBefore(e, t.firstChild); } }); }, before: function () { return He(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this); }); }, after: function () { return He(this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling); }); }, empty: function () { for (var e, t = 0; null != (e = this[t]); t++)1 === e.nodeType && (S.cleanData(ve(e, !1)), e.textContent = ""); return this; }, clone: function (e, t) { return e = null != e && e, t = null == t ? e : t, this.map(function () { return S.clone(this, e, t); }); }, html: function (e) { return $(this, function (e) { var t = this[0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e && !ke.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) { e = S.htmlPrefilter(e); try { for (; n < r; n++)1 === (t = this[n] || {}).nodeType && (S.cleanData(ve(t, !1)), t.innerHTML = e); t = 0; } catch (e) { } } t && this.empty().append(e); }, null, e, arguments.length); }, replaceWith: function () { var n = []; return He(this, arguments, function (e) { var t = this.parentNode; S.inArray(this, n) < 0 && (S.cleanData(ve(this)), t && t.replaceChild(e, this)); }, n); } }), S.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (e, a) { S.fn[e] = function (e) { for (var t, n = [], r = S(e), i = r.length - 1, o = 0; o <= i; o++)t = o === i ? this : this.clone(!0), S(r[o])[a](t), u.apply(n, t.get()); return this.pushStack(n); }; }); var Pe = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"), Re = function (e) { var t = e.ownerDocument.defaultView; return t && t.opener || (t = C), t.getComputedStyle(e); }, Me = function (e, t, n) { var r, i, o = {}; for (i in t) o[i] = e.style[i], e.style[i] = t[i]; for (i in r = n.call(e), t) e.style[i] = o[i]; return r; }, Ie = new RegExp(ne.join("|"), "i"); function We(e, t, n) { var r, i, o, a, s = e.style; return (n = n || Re(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || ie(e) || (a = S.style(e, t)), !y.pixelBoxStyles() && Pe.test(a) && Ie.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a; } function Fe(e, t) { return { get: function () { if (!e()) return (this.get = t).apply(this, arguments); delete this.get; } }; } !function () { function e() { if (l) { u.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", re.appendChild(u).appendChild(l); var e = C.getComputedStyle(l); n = "1%" !== e.top, s = 12 === t(e.marginLeft), l.style.right = "60%", o = 36 === t(e.right), r = 36 === t(e.width), l.style.position = "absolute", i = 12 === t(l.offsetWidth / 3), re.removeChild(u), l = null; } } function t(e) { return Math.round(parseFloat(e)); } var n, r, i, o, a, s, u = E.createElement("div"), l = E.createElement("div"); l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", y.clearCloneStyle = "content-box" === l.style.backgroundClip, S.extend(y, { boxSizingReliable: function () { return e(), r; }, pixelBoxStyles: function () { return e(), o; }, pixelPosition: function () { return e(), n; }, reliableMarginLeft: function () { return e(), s; }, scrollboxSize: function () { return e(), i; }, reliableTrDimensions: function () { var e, t, n, r; return null == a && (e = E.createElement("table"), t = E.createElement("tr"), n = E.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", n.style.height = "9px", n.style.display = "block", re.appendChild(e).appendChild(t).appendChild(n), r = C.getComputedStyle(t), a = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === t.offsetHeight, re.removeChild(e)), a; } })); }(); var Be = ["Webkit", "Moz", "ms"], $e = E.createElement("div").style, _e = {}; function ze(e) { var t = S.cssProps[e] || _e[e]; return t || (e in $e ? e : _e[e] = function (e) { var t = e[0].toUpperCase() + e.slice(1), n = Be.length; while (n--) if ((e = Be[n] + t) in $e) return e; }(e) || e); } var Ue = /^(none|table(?!-c[ea]).+)/, Xe = /^--/, Ve = { position: "absolute", visibility: "hidden", display: "block" }, Ge = { letterSpacing: "0", fontWeight: "400" }; function Ye(e, t, n) { var r = te.exec(t); return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t; } function Qe(e, t, n, r, i, o) { var a = "width" === t ? 1 : 0, s = 0, u = 0; if (n === (r ? "border" : "content")) return 0; for (; a < 4; a += 2)"margin" === n && (u += S.css(e, n + ne[a], !0, i)), r ? ("content" === n && (u -= S.css(e, "padding" + ne[a], !0, i)), "margin" !== n && (u -= S.css(e, "border" + ne[a] + "Width", !0, i))) : (u += S.css(e, "padding" + ne[a], !0, i), "padding" !== n ? u += S.css(e, "border" + ne[a] + "Width", !0, i) : s += S.css(e, "border" + ne[a] + "Width", !0, i)); return !r && 0 <= o && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u; } function Je(e, t, n) { var r = Re(e), i = (!y.boxSizingReliable() || n) && "border-box" === S.css(e, "boxSizing", !1, r), o = i, a = We(e, t, r), s = "offset" + t[0].toUpperCase() + t.slice(1); if (Pe.test(a)) { if (!n) return a; a = "auto"; } return (!y.boxSizingReliable() && i || !y.reliableTrDimensions() && A(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === S.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === S.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + Qe(e, t, n || (i ? "border" : "content"), o, r, a) + "px"; } function Ke(e, t, n, r, i) { return new Ke.prototype.init(e, t, n, r, i); } S.extend({ cssHooks: { opacity: { get: function (e, t) { if (t) { var n = We(e, "opacity"); return "" === n ? "1" : n; } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, gridArea: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnStart: !0, gridRow: !0, gridRowEnd: !0, gridRowStart: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: {}, style: function (e, t, n, r) { if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) { var i, o, a, s = X(t), u = Xe.test(t), l = e.style; if (u || (t = ze(s)), a = S.cssHooks[t] || S.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t]; "string" === (o = typeof n) && (i = te.exec(n)) && i[1] && (n = se(e, t, i), o = "number"), null != n && n == n && ("number" !== o || u || (n += i && i[3] || (S.cssNumber[s] ? "" : "px")), y.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n)); } }, css: function (e, t, n, r) { var i, o, a, s = X(t); return Xe.test(t) || (t = ze(s)), (a = S.cssHooks[t] || S.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = We(e, t, r)), "normal" === i && t in Ge && (i = Ge[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i; } }), S.each(["height", "width"], function (e, u) { S.cssHooks[u] = { get: function (e, t, n) { if (t) return !Ue.test(S.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Je(e, u, n) : Me(e, Ve, function () { return Je(e, u, n); }); }, set: function (e, t, n) { var r, i = Re(e), o = !y.scrollboxSize() && "absolute" === i.position, a = (o || n) && "border-box" === S.css(e, "boxSizing", !1, i), s = n ? Qe(e, u, n, a, i) : 0; return a && o && (s -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - Qe(e, u, "border", !1, i) - .5)), s && (r = te.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = S.css(e, u)), Ye(0, t, s); } }; }), S.cssHooks.marginLeft = Fe(y.reliableMarginLeft, function (e, t) { if (t) return (parseFloat(We(e, "marginLeft")) || e.getBoundingClientRect().left - Me(e, { marginLeft: 0 }, function () { return e.getBoundingClientRect().left; })) + "px"; }), S.each({ margin: "", padding: "", border: "Width" }, function (i, o) { S.cssHooks[i + o] = { expand: function (e) { for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++)n[i + ne[t] + o] = r[t] || r[t - 2] || r[0]; return n; } }, "margin" !== i && (S.cssHooks[i + o].set = Ye); }), S.fn.extend({ css: function (e, t) { return $(this, function (e, t, n) { var r, i, o = {}, a = 0; if (Array.isArray(t)) { for (r = Re(e), i = t.length; a < i; a++)o[t[a]] = S.css(e, t[a], !1, r); return o; } return void 0 !== n ? S.style(e, t, n) : S.css(e, t); }, e, t, 1 < arguments.length); } }), ((S.Tween = Ke).prototype = { constructor: Ke, init: function (e, t, n, r, i, o) { this.elem = e, this.prop = n, this.easing = i || S.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (S.cssNumber[n] ? "" : "px"); }, cur: function () { var e = Ke.propHooks[this.prop]; return e && e.get ? e.get(this) : Ke.propHooks._default.get(this); }, run: function (e) { var t, n = Ke.propHooks[this.prop]; return this.options.duration ? this.pos = t = S.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : Ke.propHooks._default.set(this), this; } }).init.prototype = Ke.prototype, (Ke.propHooks = { _default: { get: function (e) { var t; return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = S.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0; }, set: function (e) { S.fx.step[e.prop] ? S.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !S.cssHooks[e.prop] && null == e.elem.style[ze(e.prop)] ? e.elem[e.prop] = e.now : S.style(e.elem, e.prop, e.now + e.unit); } } }).scrollTop = Ke.propHooks.scrollLeft = { set: function (e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now); } }, S.easing = { linear: function (e) { return e; }, swing: function (e) { return .5 - Math.cos(e * Math.PI) / 2; }, _default: "swing" }, S.fx = Ke.prototype.init, S.fx.step = {}; var Ze, et, tt, nt, rt = /^(?:toggle|show|hide)$/, it = /queueHooks$/; function ot() { et && (!1 === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(ot) : C.setTimeout(ot, S.fx.interval), S.fx.tick()); } function at() { return C.setTimeout(function () { Ze = void 0; }), Ze = Date.now(); } function st(e, t) { var n, r = 0, i = { height: e }; for (t = t ? 1 : 0; r < 4; r += 2 - t)i["margin" + (n = ne[r])] = i["padding" + n] = e; return t && (i.opacity = i.width = e), i; } function ut(e, t, n) { for (var r, i = (lt.tweeners[t] || []).concat(lt.tweeners["*"]), o = 0, a = i.length; o < a; o++)if (r = i[o].call(n, t, e)) return r; } function lt(o, e, t) { var n, a, r = 0, i = lt.prefilters.length, s = S.Deferred().always(function () { delete u.elem; }), u = function () { if (a) return !1; for (var e = Ze || at(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++)l.tweens[r].run(n); return s.notifyWith(o, [l, n, t]), n < 1 && i ? t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1); }, l = s.promise({ elem: o, props: S.extend({}, e), opts: S.extend(!0, { specialEasing: {}, easing: S.easing._default }, t), originalProperties: e, originalOptions: t, startTime: Ze || at(), duration: t.duration, tweens: [], createTween: function (e, t) { var n = S.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing); return l.tweens.push(n), n; }, stop: function (e) { var t = 0, n = e ? l.tweens.length : 0; if (a) return this; for (a = !0; t < n; t++)l.tweens[t].run(1); return e ? (s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]), this; } }), c = l.props; for (!function (e, t) { var n, r, i, o, a; for (n in e) if (i = t[r = X(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = S.cssHooks[r]) && "expand" in a) for (n in o = a.expand(o), delete e[r], o) n in e || (e[n] = o[n], t[n] = i); else t[r] = i; }(c, l.opts.specialEasing); r < i; r++)if (n = lt.prefilters[r].call(l, o, c, l.opts)) return m(n.stop) && (S._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n; return S.map(c, ut, l), m(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), S.fx.timer(S.extend(u, { elem: o, anim: l, queue: l.opts.queue })), l; } S.Animation = S.extend(lt, { tweeners: { "*": [function (e, t) { var n = this.createTween(e, t); return se(n.elem, e, te.exec(t), n), n; }] }, tweener: function (e, t) { m(e) ? (t = e, e = ["*"]) : e = e.match(P); for (var n, r = 0, i = e.length; r < i; r++)n = e[r], lt.tweeners[n] = lt.tweeners[n] || [], lt.tweeners[n].unshift(t); }, prefilters: [function (e, t, n) { var r, i, o, a, s, u, l, c, f = "width" in t || "height" in t, p = this, d = {}, h = e.style, g = e.nodeType && ae(e), v = Y.get(e, "fxshow"); for (r in n.queue || (null == (a = S._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () { a.unqueued || s(); }), a.unqueued++, p.always(function () { p.always(function () { a.unqueued--, S.queue(e, "fx").length || a.empty.fire(); }); })), t) if (i = t[r], rt.test(i)) { if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) { if ("show" !== i || !v || void 0 === v[r]) continue; g = !0; } d[r] = v && v[r] || S.style(e, r); } if ((u = !S.isEmptyObject(t)) || !S.isEmptyObject(d)) for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Y.get(e, "display")), "none" === (c = S.css(e, "display")) && (l ? c = l : (le([e], !0), l = e.style.display || l, c = S.css(e, "display"), le([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === S.css(e, "float") && (u || (p.done(function () { h.display = l; }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function () { h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2]; })), u = !1, d) u || (v ? "hidden" in v && (g = v.hidden) : v = Y.access(e, "fxshow", { display: l }), o && (v.hidden = !g), g && le([e], !0), p.done(function () { for (r in g || le([e]), Y.remove(e, "fxshow"), d) S.style(e, r, d[r]); })), u = ut(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0)); }], prefilter: function (e, t) { t ? lt.prefilters.unshift(e) : lt.prefilters.push(e); } }), S.speed = function (e, t, n) { var r = e && "object" == typeof e ? S.extend({}, e) : { complete: n || !n && t || m(e) && e, duration: e, easing: n && t || t && !m(t) && t }; return S.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in S.fx.speeds ? r.duration = S.fx.speeds[r.duration] : r.duration = S.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () { m(r.old) && r.old.call(this), r.queue && S.dequeue(this, r.queue); }, r; }, S.fn.extend({ fadeTo: function (e, t, n, r) { return this.filter(ae).css("opacity", 0).show().end().animate({ opacity: t }, e, n, r); }, animate: function (t, e, n, r) { var i = S.isEmptyObject(t), o = S.speed(e, n, r), a = function () { var e = lt(this, S.extend({}, t), o); (i || Y.get(this, "finish")) && e.stop(!0); }; return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a); }, stop: function (i, e, o) { var a = function (e) { var t = e.stop; delete e.stop, t(o); }; return "string" != typeof i && (o = e, e = i, i = void 0), e && this.queue(i || "fx", []), this.each(function () { var e = !0, t = null != i && i + "queueHooks", n = S.timers, r = Y.get(this); if (t) r[t] && r[t].stop && a(r[t]); else for (t in r) r[t] && r[t].stop && it.test(t) && a(r[t]); for (t = n.length; t--;)n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1)); !e && o || S.dequeue(this, i); }); }, finish: function (a) { return !1 !== a && (a = a || "fx"), this.each(function () { var e, t = Y.get(this), n = t[a + "queue"], r = t[a + "queueHooks"], i = S.timers, o = n ? n.length : 0; for (t.finish = !0, S.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;)i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1)); for (e = 0; e < o; e++)n[e] && n[e].finish && n[e].finish.call(this); delete t.finish; }); } }), S.each(["toggle", "show", "hide"], function (e, r) { var i = S.fn[r]; S.fn[r] = function (e, t, n) { return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(st(r, !0), e, t, n); }; }), S.each({ slideDown: st("show"), slideUp: st("hide"), slideToggle: st("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (e, r) { S.fn[e] = function (e, t, n) { return this.animate(r, e, t, n); }; }), S.timers = [], S.fx.tick = function () { var e, t = 0, n = S.timers; for (Ze = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1); n.length || S.fx.stop(), Ze = void 0; }, S.fx.timer = function (e) { S.timers.push(e), S.fx.start(); }, S.fx.interval = 13, S.fx.start = function () { et || (et = !0, ot()); }, S.fx.stop = function () { et = null; }, S.fx.speeds = { slow: 600, fast: 200, _default: 400 }, S.fn.delay = function (r, e) { return r = S.fx && S.fx.speeds[r] || r, e = e || "fx", this.queue(e, function (e, t) { var n = C.setTimeout(e, r); t.stop = function () { C.clearTimeout(n); }; }); }, tt = E.createElement("input"), nt = E.createElement("select").appendChild(E.createElement("option")), tt.type = "checkbox", y.checkOn = "" !== tt.value, y.optSelected = nt.selected, (tt = E.createElement("input")).value = "t", tt.type = "radio", y.radioValue = "t" === tt.value; var ct, ft = S.expr.attrHandle; S.fn.extend({ attr: function (e, t) { return $(this, S.attr, e, t, 1 < arguments.length); }, removeAttr: function (e) { return this.each(function () { S.removeAttr(this, e); }); } }), S.extend({ attr: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? S.prop(e, t, n) : (1 === o && S.isXMLDoc(e) || (i = S.attrHooks[t.toLowerCase()] || (S.expr.match.bool.test(t) ? ct : void 0)), void 0 !== n ? null === n ? void S.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = S.find.attr(e, t)) ? void 0 : r); }, attrHooks: { type: { set: function (e, t) { if (!y.radioValue && "radio" === t && A(e, "input")) { var n = e.value; return e.setAttribute("type", t), n && (e.value = n), t; } } } }, removeAttr: function (e, t) { var n, r = 0, i = t && t.match(P); if (i && 1 === e.nodeType) while (n = i[r++]) e.removeAttribute(n); } }), ct = { set: function (e, t, n) { return !1 === t ? S.removeAttr(e, n) : e.setAttribute(n, n), n; } }, S.each(S.expr.match.bool.source.match(/\w+/g), function (e, t) { var a = ft[t] || S.find.attr; ft[t] = function (e, t, n) { var r, i, o = t.toLowerCase(); return n || (i = ft[o], ft[o] = r, r = null != a(e, t, n) ? o : null, ft[o] = i), r; }; }); var pt = /^(?:input|select|textarea|button)$/i, dt = /^(?:a|area)$/i; function ht(e) { return (e.match(P) || []).join(" "); } function gt(e) { return e.getAttribute && e.getAttribute("class") || ""; } function vt(e) { return Array.isArray(e) ? e : "string" == typeof e && e.match(P) || []; } S.fn.extend({ prop: function (e, t) { return $(this, S.prop, e, t, 1 < arguments.length); }, removeProp: function (e) { return this.each(function () { delete this[S.propFix[e] || e]; }); } }), S.extend({ prop: function (e, t, n) { var r, i, o = e.nodeType; if (3 !== o && 8 !== o && 2 !== o) return 1 === o && S.isXMLDoc(e) || (t = S.propFix[t] || t, i = S.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t]; }, propHooks: { tabIndex: { get: function (e) { var t = S.find.attr(e, "tabindex"); return t ? parseInt(t, 10) : pt.test(e.nodeName) || dt.test(e.nodeName) && e.href ? 0 : -1; } } }, propFix: { "for": "htmlFor", "class": "className" } }), y.optSelected || (S.propHooks.selected = { get: function (e) { var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null; }, set: function (e) { var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex); } }), S.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () { S.propFix[this.toLowerCase()] = this; }), S.fn.extend({ addClass: function (t) { var e, n, r, i, o, a, s, u = 0; if (m(t)) return this.each(function (e) { S(this).addClass(t.call(this, e, gt(this))); }); if ((e = vt(t)).length) while (n = this[u++]) if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") { a = 0; while (o = e[a++]) r.indexOf(" " + o + " ") < 0 && (r += o + " "); i !== (s = ht(r)) && n.setAttribute("class", s); } return this; }, removeClass: function (t) { var e, n, r, i, o, a, s, u = 0; if (m(t)) return this.each(function (e) { S(this).removeClass(t.call(this, e, gt(this))); }); if (!arguments.length) return this.attr("class", ""); if ((e = vt(t)).length) while (n = this[u++]) if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") { a = 0; while (o = e[a++]) while (-1 < r.indexOf(" " + o + " ")) r = r.replace(" " + o + " ", " "); i !== (s = ht(r)) && n.setAttribute("class", s); } return this; }, toggleClass: function (i, t) { var o = typeof i, a = "string" === o || Array.isArray(i); return "boolean" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : m(i) ? this.each(function (e) { S(this).toggleClass(i.call(this, e, gt(this), t), t); }) : this.each(function () { var e, t, n, r; if (a) { t = 0, n = S(this), r = vt(i); while (e = r[t++]) n.hasClass(e) ? n.removeClass(e) : n.addClass(e); } else void 0 !== i && "boolean" !== o || ((e = gt(this)) && Y.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === i ? "" : Y.get(this, "__className__") || "")); }); }, hasClass: function (e) { var t, n, r = 0; t = " " + e + " "; while (n = this[r++]) if (1 === n.nodeType && -1 < (" " + ht(gt(n)) + " ").indexOf(t)) return !0; return !1; } }); var yt = /\r/g; S.fn.extend({ val: function (n) { var r, e, i, t = this[0]; return arguments.length ? (i = m(n), this.each(function (e) { var t; 1 === this.nodeType && (null == (t = i ? n.call(this, e, S(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = S.map(t, function (e) { return null == e ? "" : e + ""; })), (r = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t)); })) : t ? (r = S.valHooks[t.type] || S.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof (e = t.value) ? e.replace(yt, "") : null == e ? "" : e : void 0; } }), S.extend({ valHooks: { option: { get: function (e) { var t = S.find.attr(e, "value"); return null != t ? t : ht(S.text(e)); } }, select: { get: function (e) { var t, n, r, i = e.options, o = e.selectedIndex, a = "select-one" === e.type, s = a ? null : [], u = a ? o + 1 : i.length; for (r = o < 0 ? u : a ? o : 0; r < u; r++)if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) { if (t = S(n).val(), a) return t; s.push(t); } return s; }, set: function (e, t) { var n, r, i = e.options, o = S.makeArray(t), a = i.length; while (a--) ((r = i[a]).selected = -1 < S.inArray(S.valHooks.option.get(r), o)) && (n = !0); return n || (e.selectedIndex = -1), o; } } } }), S.each(["radio", "checkbox"], function () { S.valHooks[this] = { set: function (e, t) { if (Array.isArray(t)) return e.checked = -1 < S.inArray(S(e).val(), t); } }, y.checkOn || (S.valHooks[this].get = function (e) { return null === e.getAttribute("value") ? "on" : e.value; }); }), y.focusin = "onfocusin" in C; var mt = /^(?:focusinfocus|focusoutblur)$/, xt = function (e) { e.stopPropagation(); }; S.extend(S.event, { trigger: function (e, t, n, r) { var i, o, a, s, u, l, c, f, p = [n || E], d = v.call(e, "type") ? e.type : e, h = v.call(e, "namespace") ? e.namespace.split(".") : []; if (o = f = a = n = n || E, 3 !== n.nodeType && 8 !== n.nodeType && !mt.test(d + S.event.triggered) && (-1 < d.indexOf(".") && (d = (h = d.split(".")).shift(), h.sort()), u = d.indexOf(":") < 0 && "on" + d, (e = e[S.expando] ? e : new S.Event(d, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : S.makeArray(t, [e]), c = S.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) { if (!r && !c.noBubble && !x(n)) { for (s = c.delegateType || d, mt.test(s + d) || (o = o.parentNode); o; o = o.parentNode)p.push(o), a = o; a === (n.ownerDocument || E) && p.push(a.defaultView || a.parentWindow || C); } i = 0; while ((o = p[i++]) && !e.isPropagationStopped()) f = o, e.type = 1 < i ? s : c.bindType || d, (l = (Y.get(o, "events") || Object.create(null))[e.type] && Y.get(o, "handle")) && l.apply(o, t), (l = u && o[u]) && l.apply && V(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault()); return e.type = d, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !V(n) || u && m(n[d]) && !x(n) && ((a = n[u]) && (n[u] = null), S.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, xt), n[d](), e.isPropagationStopped() && f.removeEventListener(d, xt), S.event.triggered = void 0, a && (n[u] = a)), e.result; } }, simulate: function (e, t, n) { var r = S.extend(new S.Event, n, { type: e, isSimulated: !0 }); S.event.trigger(r, null, t); } }), S.fn.extend({ trigger: function (e, t) { return this.each(function () { S.event.trigger(e, t, this); }); }, triggerHandler: function (e, t) { var n = this[0]; if (n) return S.event.trigger(e, t, n, !0); } }), y.focusin || S.each({ focus: "focusin", blur: "focusout" }, function (n, r) { var i = function (e) { S.event.simulate(r, e.target, S.event.fix(e)); }; S.event.special[r] = { setup: function () { var e = this.ownerDocument || this.document || this, t = Y.access(e, r); t || e.addEventListener(n, i, !0), Y.access(e, r, (t || 0) + 1); }, teardown: function () { var e = this.ownerDocument || this.document || this, t = Y.access(e, r) - 1; t ? Y.access(e, r, t) : (e.removeEventListener(n, i, !0), Y.remove(e, r)); } }; }); var bt = C.location, wt = { guid: Date.now() }, Tt = /\?/; S.parseXML = function (e) { var t, n; if (!e || "string" != typeof e) return null; try { t = (new C.DOMParser).parseFromString(e, "text/xml"); } catch (e) { } return n = t && t.getElementsByTagName("parsererror")[0], t && !n || S.error("Invalid XML: " + (n ? S.map(n.childNodes, function (e) { return e.textContent; }).join("\n") : e)), t; }; var Ct = /\[\]$/, Et = /\r?\n/g, St = /^(?:submit|button|image|reset|file)$/i, kt = /^(?:input|select|textarea|keygen)/i; function At(n, e, r, i) { var t; if (Array.isArray(e)) S.each(e, function (e, t) { r || Ct.test(n) ? i(n, t) : At(n + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, r, i); }); else if (r || "object" !== w(e)) i(n, e); else for (t in e) At(n + "[" + t + "]", e[t], r, i); } S.param = function (e, t) { var n, r = [], i = function (e, t) { var n = m(t) ? t() : t; r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n); }; if (null == e) return ""; if (Array.isArray(e) || e.jquery && !S.isPlainObject(e)) S.each(e, function () { i(this.name, this.value); }); else for (n in e) At(n, e[n], t, i); return r.join("&"); }, S.fn.extend({ serialize: function () { return S.param(this.serializeArray()); }, serializeArray: function () { return this.map(function () { var e = S.prop(this, "elements"); return e ? S.makeArray(e) : this; }).filter(function () { var e = this.type; return this.name && !S(this).is(":disabled") && kt.test(this.nodeName) && !St.test(e) && (this.checked || !pe.test(e)); }).map(function (e, t) { var n = S(this).val(); return null == n ? null : Array.isArray(n) ? S.map(n, function (e) { return { name: t.name, value: e.replace(Et, "\r\n") }; }) : { name: t.name, value: n.replace(Et, "\r\n") }; }).get(); } }); var Nt = /%20/g, jt = /#.*$/, Dt = /([?&])_=[^&]*/, qt = /^(.*?):[ \t]*([^\r\n]*)$/gm, Lt = /^(?:GET|HEAD)$/, Ht = /^\/\//, Ot = {}, Pt = {}, Rt = "*/".concat("*"), Mt = E.createElement("a"); function It(o) { return function (e, t) { "string" != typeof e && (t = e, e = "*"); var n, r = 0, i = e.toLowerCase().match(P) || []; if (m(t)) while (n = i[r++]) "+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t); }; } function Wt(t, i, o, a) { var s = {}, u = t === Pt; function l(e) { var r; return s[e] = !0, S.each(t[e] || [], function (e, t) { var n = t(i, o, a); return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1); }), r; } return l(i.dataTypes[0]) || !s["*"] && l("*"); } function Ft(e, t) { var n, r, i = S.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]); return r && S.extend(!0, e, r), e; } Mt.href = bt.href, S.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: bt.href, type: "GET", isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Rt, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": S.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (e, t) { return t ? Ft(Ft(e, S.ajaxSettings), t) : Ft(S.ajaxSettings, e); }, ajaxPrefilter: It(Ot), ajaxTransport: It(Pt), ajax: function (e, t) { "object" == typeof e && (t = e, e = void 0), t = t || {}; var c, f, p, n, d, r, h, g, i, o, v = S.ajaxSetup({}, t), y = v.context || v, m = v.context && (y.nodeType || y.jquery) ? S(y) : S.event, x = S.Deferred(), b = S.Callbacks("once memory"), w = v.statusCode || {}, a = {}, s = {}, u = "canceled", T = { readyState: 0, getResponseHeader: function (e) { var t; if (h) { if (!n) { n = {}; while (t = qt.exec(p)) n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2]); } t = n[e.toLowerCase() + " "]; } return null == t ? null : t.join(", "); }, getAllResponseHeaders: function () { return h ? p : null; }, setRequestHeader: function (e, t) { return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this; }, overrideMimeType: function (e) { return null == h && (v.mimeType = e), this; }, statusCode: function (e) { var t; if (e) if (h) T.always(e[T.status]); else for (t in e) w[t] = [w[t], e[t]]; return this; }, abort: function (e) { var t = e || u; return c && c.abort(t), l(0, t), this; } }; if (x.promise(T), v.url = ((e || v.url || bt.href) + "").replace(Ht, bt.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(P) || [""], null == v.crossDomain) { r = E.createElement("a"); try { r.href = v.url, r.href = r.href, v.crossDomain = Mt.protocol + "//" + Mt.host != r.protocol + "//" + r.host; } catch (e) { v.crossDomain = !0; } } if (v.data && v.processData && "string" != typeof v.data && (v.data = S.param(v.data, v.traditional)), Wt(Ot, v, t, T), h) return T; for (i in (g = S.event && v.global) && 0 == S.active++ && S.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Lt.test(v.type), f = v.url.replace(jt, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(Nt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (Tt.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(Dt, "$1"), o = (Tt.test(f) ? "&" : "?") + "_=" + wt.guid++ + o), v.url = f + o), v.ifModified && (S.lastModified[f] && T.setRequestHeader("If-Modified-Since", S.lastModified[f]), S.etag[f] && T.setRequestHeader("If-None-Match", S.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + Rt + "; q=0.01" : "") : v.accepts["*"]), v.headers) T.setRequestHeader(i, v.headers[i]); if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort(); if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = Wt(Pt, v, t, T)) { if (T.readyState = 1, g && m.trigger("ajaxSend", [T, v]), h) return T; v.async && 0 < v.timeout && (d = C.setTimeout(function () { T.abort("timeout"); }, v.timeout)); try { h = !1, c.send(a, l); } catch (e) { if (h) throw e; l(-1, e); } } else l(-1, "No Transport"); function l(e, t, n, r) { var i, o, a, s, u, l = t; h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function (e, t, n) { var r, i, o, a, s = e.contents, u = e.dataTypes; while ("*" === u[0]) u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type")); if (r) for (i in s) if (s[i] && s[i].test(r)) { u.unshift(i); break; } if (u[0] in n) o = u[0]; else { for (i in n) { if (!u[0] || e.converters[i + " " + u[0]]) { o = i; break; } a || (a = i); } o = o || a; } if (o) return o !== u[0] && u.unshift(o), n[o]; }(v, T, n)), !i && -1 < S.inArray("script", v.dataTypes) && S.inArray("json", v.dataTypes) < 0 && (v.converters["text script"] = function () { }), s = function (e, t, n, r) { var i, o, a, s, u, l = {}, c = e.dataTypes.slice(); if (c[1]) for (a in e.converters) l[a.toLowerCase()] = e.converters[a]; o = c.shift(); while (o) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) if ("*" === o) o = u; else if ("*" !== u && u !== o) { if (!(a = l[u + " " + o] || l["* " + o])) for (i in l) if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) { !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1])); break; } if (!0 !== a) if (a && e["throws"]) t = a(t); else try { t = a(t); } catch (e) { return { state: "parsererror", error: a ? e : "No conversion from " + u + " to " + o }; } } return { state: "success", data: t }; }(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (S.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (S.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [T, v, i ? o : a]), b.fireWith(y, [T, l]), g && (m.trigger("ajaxComplete", [T, v]), --S.active || S.event.trigger("ajaxStop"))); } return T; }, getJSON: function (e, t, n) { return S.get(e, t, n, "json"); }, getScript: function (e, t) { return S.get(e, void 0, t, "script"); } }), S.each(["get", "post"], function (e, i) { S[i] = function (e, t, n, r) { return m(t) && (r = r || n, n = t, t = void 0), S.ajax(S.extend({ url: e, type: i, dataType: r, data: t, success: n }, S.isPlainObject(e) && e)); }; }), S.ajaxPrefilter(function (e) { var t; for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || ""); }), S._evalUrl = function (e, t, n) { return S.ajax({ url: e, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, converters: { "text script": function () { } }, dataFilter: function (e) { S.globalEval(e, t, n); } }); }, S.fn.extend({ wrapAll: function (e) { var t; return this[0] && (m(e) && (e = e.call(this[0])), t = S(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () { var e = this; while (e.firstElementChild) e = e.firstElementChild; return e; }).append(this)), this; }, wrapInner: function (n) { return m(n) ? this.each(function (e) { S(this).wrapInner(n.call(this, e)); }) : this.each(function () { var e = S(this), t = e.contents(); t.length ? t.wrapAll(n) : e.append(n); }); }, wrap: function (t) { var n = m(t); return this.each(function (e) { S(this).wrapAll(n ? t.call(this, e) : t); }); }, unwrap: function (e) { return this.parent(e).not("body").each(function () { S(this).replaceWith(this.childNodes); }), this; } }), S.expr.pseudos.hidden = function (e) { return !S.expr.pseudos.visible(e); }, S.expr.pseudos.visible = function (e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length); }, S.ajaxSettings.xhr = function () { try { return new C.XMLHttpRequest; } catch (e) { } }; var Bt = { 0: 200, 1223: 204 }, $t = S.ajaxSettings.xhr(); y.cors = !!$t && "withCredentials" in $t, y.ajax = $t = !!$t, S.ajaxTransport(function (i) { var o, a; if (y.cors || $t && !i.crossDomain) return { send: function (e, t) { var n, r = i.xhr(); if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields) for (n in i.xhrFields) r[n] = i.xhrFields[n]; for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader(n, e[n]); o = function (e) { return function () { o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Bt[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? { binary: r.response } : { text: r.responseText }, r.getAllResponseHeaders())); }; }, r.onload = o(), a = r.onerror = r.ontimeout = o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function () { 4 === r.readyState && C.setTimeout(function () { o && a(); }); }, o = o("abort"); try { r.send(i.hasContent && i.data || null); } catch (e) { if (o) throw e; } }, abort: function () { o && o(); } }; }), S.ajaxPrefilter(function (e) { e.crossDomain && (e.contents.script = !1); }), S.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function (e) { return S.globalEval(e), e; } } }), S.ajaxPrefilter("script", function (e) { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET"); }), S.ajaxTransport("script", function (n) { var r, i; if (n.crossDomain || n.scriptAttrs) return { send: function (e, t) { r = S("<script>").attr(n.scriptAttrs || {}).prop({ charset: n.scriptCharset, src: n.url }).on("load error", i = function (e) { r.remove(), i = null, e && t("error" === e.type ? 404 : 200, e.type); }), E.head.appendChild(r[0]); }, abort: function () { i && i(); } }; }); var _t, zt = [], Ut = /(=)\?(?=&|$)|\?\?/; S.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var e = zt.pop() || S.expando + "_" + wt.guid++; return this[e] = !0, e; } }), S.ajaxPrefilter("json jsonp", function (e, t, n) { var r, i, o, a = !1 !== e.jsonp && (Ut.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ut.test(e.data) && "data"); if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Ut, "$1" + r) : !1 !== e.jsonp && (e.url += (Tt.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () { return o || S.error(r + " was not called"), o[0]; }, e.dataTypes[0] = "json", i = C[r], C[r] = function () { o = arguments; }, n.always(function () { void 0 === i ? S(C).removeProp(r) : C[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, zt.push(r)), o && m(i) && i(o[0]), o = i = void 0; }), "script"; }), y.createHTMLDocument = ((_t = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === _t.childNodes.length), S.parseHTML = function (e, t, n) { return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = N.exec(e)) ? [t.createElement(i[1])] : (i = xe([e], t, o), o && o.length && S(o).remove(), S.merge([], i.childNodes))); var r, i, o; }, S.fn.load = function (e, t, n) { var r, i, o, a = this, s = e.indexOf(" "); return -1 < s && (r = ht(e.slice(s)), e = e.slice(0, s)), m(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"), 0 < a.length && S.ajax({ url: e, type: i || "GET", dataType: "html", data: t }).done(function (e) { o = arguments, a.html(r ? S("<div>").append(S.parseHTML(e)).find(r) : e); }).always(n && function (e, t) { a.each(function () { n.apply(this, o || [e.responseText, t, e]); }); }), this; }, S.expr.pseudos.animated = function (t) { return S.grep(S.timers, function (e) { return t === e.elem; }).length; }, S.offset = { setOffset: function (e, t, n) { var r, i, o, a, s, u, l = S.css(e, "position"), c = S(e), f = {}; "static" === l && (e.style.position = "relative"), s = c.offset(), o = S.css(e, "top"), u = S.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), m(t) && (t = t.call(e, n, S.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : c.css(f); } }, S.fn.extend({ offset: function (t) { if (arguments.length) return void 0 === t ? this : this.each(function (e) { S.offset.setOffset(this, t, e); }); var e, n, r = this[0]; return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: e.top + n.pageYOffset, left: e.left + n.pageXOffset }) : { top: 0, left: 0 } : void 0; }, position: function () { if (this[0]) { var e, t, n, r = this[0], i = { top: 0, left: 0 }; if ("fixed" === S.css(r, "position")) t = r.getBoundingClientRect(); else { t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n.documentElement) && "static" === S.css(e, "position")) e = e.parentNode; e && e !== r && 1 === e.nodeType && ((i = S(e).offset()).top += S.css(e, "borderTopWidth", !0), i.left += S.css(e, "borderLeftWidth", !0)); } return { top: t.top - i.top - S.css(r, "marginTop", !0), left: t.left - i.left - S.css(r, "marginLeft", !0) }; } }, offsetParent: function () { return this.map(function () { var e = this.offsetParent; while (e && "static" === S.css(e, "position")) e = e.offsetParent; return e || re; }); } }), S.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (t, i) { var o = "pageYOffset" === i; S.fn[t] = function (e) { return $(this, function (e, t, n) { var r; if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t]; r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n; }, t, e, arguments.length); }; }), S.each(["top", "left"], function (e, n) { S.cssHooks[n] = Fe(y.pixelPosition, function (e, t) { if (t) return t = We(e, n), Pe.test(t) ? S(e).position()[n] + "px" : t; }); }), S.each({ Height: "height", Width: "width" }, function (a, s) { S.each({ padding: "inner" + a, content: s, "": "outer" + a }, function (r, o) { S.fn[o] = function (e, t) { var n = arguments.length && (r || "boolean" != typeof e), i = r || (!0 === e || !0 === t ? "margin" : "border"); return $(this, function (e, t, n) { var r; return x(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? S.css(e, t, i) : S.style(e, t, n, i); }, s, n ? e : void 0, n); }; }); }), S.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) { S.fn[t] = function (e) { return this.on(t, e); }; }), S.fn.extend({ bind: function (e, t, n) { return this.on(e, null, t, n); }, unbind: function (e, t) { return this.off(e, null, t); }, delegate: function (e, t, n, r) { return this.on(t, e, n, r); }, undelegate: function (e, t, n) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n); }, hover: function (e, t) { return this.mouseenter(e).mouseleave(t || e); } }), S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, n) { S.fn[n] = function (e, t) { return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n); }; }); var Xt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; S.proxy = function (e, t) { var n, r, i; if ("string" == typeof t && (n = e[t], t = e, e = n), m(e)) return r = s.call(arguments, 2), (i = function () { return e.apply(t || this, r.concat(s.call(arguments))); }).guid = e.guid = e.guid || S.guid++, i; }, S.holdReady = function (e) { e ? S.readyWait++ : S.ready(!0); }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function (e) { var t = S.type(e); return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e)); }, S.trim = function (e) { return null == e ? "" : (e + "").replace(Xt, ""); }, "function" == typeof define && define.amd && define("jquery", [], function () { return S; }); var Vt = C.jQuery, Gt = C.$; return S.noConflict = function (e) { return C.$ === S && (C.$ = Gt), e && C.jQuery === S && (C.jQuery = Vt), S; }, "undefined" == typeof e && (C.jQuery = C.$ = S), S; });/*
 jQuery Simple Slider

 Copyright (c) 2012 James Smith (http://loopj.com)

 Licensed under the MIT license (http://mit-license.org/)
*/

var __slice = [].slice,
  __indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

(function ($, window) {
  var SimpleSlider;
  SimpleSlider = (function () {

    function SimpleSlider(input, options) {
      var ratio,
        _this = this;
      this.input = input;
      this.defaultOptions = {
        animate: true,
        snapMid: false,
        classPrefix: null,
        classSuffix: null,
        theme: null,
        highlight: false
      };
      this.settings = $.extend({}, this.defaultOptions, options);
      if (this.settings.theme) {
        this.settings.classSuffix = "-" + this.settings.theme;
      }
      this.input.hide();
      this.slider = $("<div>").addClass("slider" + (this.settings.classSuffix || "")).css({
        position: "relative",
        userSelect: "none",
        boxSizing: "border-box"
      }).insertBefore(this.input);
      if (this.input.attr("id")) {
        this.slider.attr("id", this.input.attr("id") + "-slider");
      }
      this.track = this.createDivElement("track").css({
        width: "100%"
      });
      if (this.settings.highlight) {
        this.highlightTrack = this.createDivElement("highlight-track").css({
          width: "0"
        });
      }
      this.dragger = this.createDivElement("dragger");
      this.slider.css({
        minHeight: this.dragger.outerHeight(),
        marginLeft: this.dragger.outerWidth() / 2,
        marginRight: this.dragger.outerWidth() / 2
      });
      this.track.css({
        marginTop: this.track.outerHeight() / -2
      });
      if (this.settings.highlight) {
        this.highlightTrack.css({
          marginTop: this.track.outerHeight() / -2
        });
      }
      this.dragger.css({
        marginTop: this.dragger.outerWidth() / -2,
        marginLeft: this.dragger.outerWidth() / -2
      });
      this.track.mousedown(function (e) {
        return _this.trackEvent(e);
      });
      if (this.settings.highlight) {
        this.highlightTrack.mousedown(function (e) {
          return _this.trackEvent(e);
        });
      }
      this.dragger.mousedown(function (e) {
        if (e.which !== 1) {
          return;
        }
        _this.dragging = true;
        _this.dragger.addClass("dragging");
        _this.domDrag(e.pageX, e.pageY);
        return false;
      });
      $("body").mousemove(function (e) {
        if (_this.dragging) {
          _this.domDrag(e.pageX, e.pageY);
          return $("body").css({
            cursor: "pointer"
          });
        }
      }).mouseup(function (e) {
        if (_this.dragging) {
          _this.dragging = false;
          _this.dragger.removeClass("dragging");
          return $("body").css({
            cursor: "auto"
          });
        }
      });
      this.pagePos = 0;
      if (this.input.val() === "") {
        this.value = this.getRange().min;
        this.input.val(this.value);
      } else {
        this.value = this.nearestValidValue(this.input.val());
      }
      this.setSliderPositionFromValue(this.value);
      ratio = this.valueToRatio(this.value);
      this.input.trigger("slider:ready", {
        value: this.value,
        ratio: ratio,
        position: ratio * this.slider.outerWidth(),
        el: this.slider
      });
    }

    SimpleSlider.prototype.createDivElement = function (classname) {
      var item;
      item = $("<div>").addClass(classname).css({
        position: "absolute",
        top: "50%",
        userSelect: "none",
        cursor: "pointer"
      }).appendTo(this.slider);
      return item;
    };

    SimpleSlider.prototype.setRatio = function (ratio) {
      var value;
      ratio = Math.min(1, ratio);
      ratio = Math.max(0, ratio);
      value = this.ratioToValue(ratio);
      this.setSliderPositionFromValue(value);
      return this.valueChanged(value, ratio, "setRatio");
    };

    SimpleSlider.prototype.setValue = function (value) {
      var ratio;
      value = this.nearestValidValue(value);
      ratio = this.valueToRatio(value);
      this.setSliderPositionFromValue(value);
      return this.valueChanged(value, ratio, "setValue");
    };

    SimpleSlider.prototype.trackEvent = function (e) {
      if (e.which !== 1) {
        return;
      }
      this.domDrag(e.pageX, e.pageY, true);
      this.dragging = true;
      return false;
    };

    SimpleSlider.prototype.domDrag = function (pageX, pageY, animate) {
      var pagePos, ratio, value;
      if (animate == null) {
        animate = false;
      }
      pagePos = pageX - this.slider.offset().left;
      pagePos = Math.min(this.slider.outerWidth(), pagePos);
      pagePos = Math.max(0, pagePos);
      if (this.pagePos !== pagePos) {
        this.pagePos = pagePos;
        ratio = pagePos / this.slider.outerWidth();
        value = this.ratioToValue(ratio);
        this.valueChanged(value, ratio, "domDrag");
        if (this.settings.snap) {
          return this.setSliderPositionFromValue(value, animate);
        } else {
          return this.setSliderPosition(pagePos, animate);
        }
      }
    };

    SimpleSlider.prototype.setSliderPosition = function (position, animate) {
      if (animate == null) {
        animate = false;
      }
      if (animate && this.settings.animate) {
        this.dragger.animate({
          left: position
        }, 200);
        if (this.settings.highlight) {
          return this.highlightTrack.animate({
            width: position
          }, 200);
        }
      } else {
        this.dragger.css({
          left: position
        });
        if (this.settings.highlight) {
          return this.highlightTrack.css({
            width: position
          });
        }
      }
    };

    SimpleSlider.prototype.setSliderPositionFromValue = function (value, animate) {
      var ratio;
      if (animate == null) {
        animate = false;
      }
      ratio = this.valueToRatio(value);
      return this.setSliderPosition(ratio * this.slider.outerWidth(), animate);
    };

    SimpleSlider.prototype.getRange = function () {
      if (this.settings.allowedValues) {
        return {
          min: Math.min.apply(Math, this.settings.allowedValues),
          max: Math.max.apply(Math, this.settings.allowedValues)
        };
      } else if (this.settings.range) {
        return {
          min: parseFloat(this.settings.range[0]),
          max: parseFloat(this.settings.range[1])
        };
      } else {
        return {
          min: 0,
          max: 1
        };
      }
    };

    SimpleSlider.prototype.nearestValidValue = function (rawValue) {
      var closest, maxSteps, range, steps;
      range = this.getRange();
      rawValue = Math.min(range.max, rawValue);
      rawValue = Math.max(range.min, rawValue);
      if (this.settings.allowedValues) {
        closest = null;
        $.each(this.settings.allowedValues, function () {
          if (closest === null || Math.abs(this - rawValue) < Math.abs(closest - rawValue)) {
            return closest = this;
          }
        });
        return closest;
      } else if (this.settings.step) {
        maxSteps = (range.max - range.min) / this.settings.step;
        steps = Math.floor((rawValue - range.min) / this.settings.step);
        if ((rawValue - range.min) % this.settings.step > this.settings.step / 2 && steps < maxSteps) {
          steps += 1;
        }
        return steps * this.settings.step + range.min;
      } else {
        return rawValue;
      }
    };

    SimpleSlider.prototype.valueToRatio = function (value) {
      var allowedVal, closest, closestIdx, idx, range, _i, _len, _ref;
      if (this.settings.equalSteps) {
        _ref = this.settings.allowedValues;
        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
          allowedVal = _ref[idx];
          if (!(typeof closest !== "undefined" && closest !== null) || Math.abs(allowedVal - value) < Math.abs(closest - value)) {
            closest = allowedVal;
            closestIdx = idx;
          }
        }
        if (this.settings.snapMid) {
          return (closestIdx + 0.5) / this.settings.allowedValues.length;
        } else {
          return closestIdx / (this.settings.allowedValues.length - 1);
        }
      } else {
        range = this.getRange();
        return (value - range.min) / (range.max - range.min);
      }
    };

    SimpleSlider.prototype.ratioToValue = function (ratio) {
      var idx, range, rawValue, step, steps;
      if (this.settings.equalSteps) {
        steps = this.settings.allowedValues.length;
        step = Math.round(ratio * steps - 0.5);
        idx = Math.min(step, this.settings.allowedValues.length - 1);
        return this.settings.allowedValues[idx];
      } else {
        range = this.getRange();
        rawValue = ratio * (range.max - range.min) + range.min;
        return this.nearestValidValue(rawValue);
      }
    };

    SimpleSlider.prototype.valueChanged = function (value, ratio, trigger) {
      var eventData;
      if (value.toString() === this.value.toString()) {
        return;
      }
      this.value = value;
      eventData = {
        value: value,
        ratio: ratio,
        position: ratio * this.slider.outerWidth(),
        trigger: trigger,
        el: this.slider
      };
      return this.input.val(value).trigger($.Event("change", eventData)).trigger("slider:changed", eventData);
    };

    return SimpleSlider;

  })();
  $.extend($.fn, {
    simpleSlider: function () {
      var params, publicMethods, settingsOrMethod;
      settingsOrMethod = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      publicMethods = ["setRatio", "setValue"];
      return $(this).each(function () {
        var obj, settings;
        if (settingsOrMethod && __indexOf.call(publicMethods, settingsOrMethod) >= 0) {
          obj = $(this).data("slider-object");
          return obj[settingsOrMethod].apply(obj, params);
        } else {
          settings = settingsOrMethod;
          return $(this).data("slider-object", new SimpleSlider($(this), settings));
        }
      });
    }
  });
  return $(function () {
    return $("[data-slider]").each(function () {
      var $el, allowedValues, settings, x;
      $el = $(this);
      settings = {};
      allowedValues = $el.data("slider-values");
      if (allowedValues) {
        settings.allowedValues = (function () {
          var _i, _len, _ref, _results;
          _ref = allowedValues.split(",");
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            x = _ref[_i];
            _results.push(parseFloat(x));
          }
          return _results;
        })();
      }
      if ($el.data("slider-range")) {
        settings.range = $el.data("slider-range").split(",");
      }
      if ($el.data("slider-step")) {
        settings.step = $el.data("slider-step");
      }
      settings.snap = $el.data("slider-snap");
      settings.equalSteps = $el.data("slider-equal-steps");
      if ($el.data("slider-theme")) {
        settings.theme = $el.data("slider-theme");
      }
      if ($el.attr("data-slider-highlight")) {
        settings.highlight = $el.data("slider-highlight");
      }
      if ($el.data("slider-animate") != null) {
        settings.animate = $el.data("slider-animate");
      }
      return $el.simpleSlider(settings);
    });
  });
})(this.jQuery || this.Zepto, this);
(function (f) { if (typeof exports === "object" && typeof module !== "undefined") { module.exports = f(); } else if (typeof define === "function" && define.amd) { define([], f); } else { var g; if (typeof window !== "undefined") { g = window; } else if (typeof global !== "undefined") { g = global; } else if (typeof self !== "undefined") { g = self; } else { g = this; } g.adapter = f(); } })(function () {
  var define, module, exports; return (function () { function r(e, n, t) { function o(i, f) { if (!n[i]) { if (!e[i]) { var c = "function" == typeof require && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); var a = new Error("Cannot find module '" + i + "'"); throw a.code = "MODULE_NOT_FOUND", a; } var p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { var n = e[i][1][r]; return o(n || r); }, p, p.exports, r, e, n, t); } return n[i].exports; } for (var u = "function" == typeof require && require, i = 0; i < t.length; i++)o(t[i]); return o; } return r; })()({
    1: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */

      'use strict';

      var _adapter_factory = require('./adapter_factory.js');

      var adapter = (0, _adapter_factory.adapterFactory)({ window: window });
      module.exports = adapter; // this is the difference from adapter_core.

    }, { "./adapter_factory.js": 2 }], 2: [function (require, module, exports) {
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.adapterFactory = adapterFactory;

      var _utils = require('./utils');

      var utils = _interopRequireWildcard(_utils);

      var _chrome_shim = require('./chrome/chrome_shim');

      var chromeShim = _interopRequireWildcard(_chrome_shim);

      var _edge_shim = require('./edge/edge_shim');

      var edgeShim = _interopRequireWildcard(_edge_shim);

      var _firefox_shim = require('./firefox/firefox_shim');

      var firefoxShim = _interopRequireWildcard(_firefox_shim);

      var _safari_shim = require('./safari/safari_shim');

      var safariShim = _interopRequireWildcard(_safari_shim);

      var _common_shim = require('./common_shim');

      var commonShim = _interopRequireWildcard(_common_shim);

      function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

      // Shimming starts here.
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      function adapterFactory() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          window = _ref.window;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          shimChrome: true,
          shimFirefox: true,
          shimEdge: true,
          shimSafari: true
        };

        // Utils.
        var logging = utils.log;
        var browserDetails = utils.detectBrowser(window);

        var adapter = {
          browserDetails: browserDetails,
          commonShim: commonShim,
          extractVersion: utils.extractVersion,
          disableLog: utils.disableLog,
          disableWarnings: utils.disableWarnings
        };

        // Shim browser if found.
        switch (browserDetails.browser) {
          case 'chrome':
            if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
              logging('Chrome shim is not included in this adapter release.');
              return adapter;
            }
            logging('adapter.js shimming chrome.');
            // Export to the adapter global object visible in the browser.
            adapter.browserShim = chromeShim;

            chromeShim.shimGetUserMedia(window);
            chromeShim.shimMediaStream(window);
            chromeShim.shimPeerConnection(window);
            chromeShim.shimOnTrack(window);
            chromeShim.shimAddTrackRemoveTrack(window);
            chromeShim.shimGetSendersWithDtmf(window);
            chromeShim.shimGetStats(window);
            chromeShim.shimSenderReceiverGetStats(window);
            chromeShim.fixNegotiationNeeded(window);

            commonShim.shimRTCIceCandidate(window);
            commonShim.shimConnectionState(window);
            commonShim.shimMaxMessageSize(window);
            commonShim.shimSendThrowTypeError(window);
            commonShim.removeAllowExtmapMixed(window);
            break;
          case 'firefox':
            if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
              logging('Firefox shim is not included in this adapter release.');
              return adapter;
            }
            logging('adapter.js shimming firefox.');
            // Export to the adapter global object visible in the browser.
            adapter.browserShim = firefoxShim;

            firefoxShim.shimGetUserMedia(window);
            firefoxShim.shimPeerConnection(window);
            firefoxShim.shimOnTrack(window);
            firefoxShim.shimRemoveStream(window);
            firefoxShim.shimSenderGetStats(window);
            firefoxShim.shimReceiverGetStats(window);
            firefoxShim.shimRTCDataChannel(window);
            firefoxShim.shimAddTransceiver(window);
            firefoxShim.shimCreateOffer(window);
            firefoxShim.shimCreateAnswer(window);

            commonShim.shimRTCIceCandidate(window);
            commonShim.shimConnectionState(window);
            commonShim.shimMaxMessageSize(window);
            commonShim.shimSendThrowTypeError(window);
            break;
          case 'edge':
            if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
              logging('MS edge shim is not included in this adapter release.');
              return adapter;
            }
            logging('adapter.js shimming edge.');
            // Export to the adapter global object visible in the browser.
            adapter.browserShim = edgeShim;

            edgeShim.shimGetUserMedia(window);
            edgeShim.shimGetDisplayMedia(window);
            edgeShim.shimPeerConnection(window);
            edgeShim.shimReplaceTrack(window);

            // the edge shim implements the full RTCIceCandidate object.

            commonShim.shimMaxMessageSize(window);
            commonShim.shimSendThrowTypeError(window);
            break;
          case 'safari':
            if (!safariShim || !options.shimSafari) {
              logging('Safari shim is not included in this adapter release.');
              return adapter;
            }
            logging('adapter.js shimming safari.');
            // Export to the adapter global object visible in the browser.
            adapter.browserShim = safariShim;

            safariShim.shimRTCIceServerUrls(window);
            safariShim.shimCreateOfferLegacy(window);
            safariShim.shimCallbacksAPI(window);
            safariShim.shimLocalStreamsAPI(window);
            safariShim.shimRemoteStreamsAPI(window);
            safariShim.shimTrackEventTransceiver(window);
            safariShim.shimGetUserMedia(window);

            commonShim.shimRTCIceCandidate(window);
            commonShim.shimMaxMessageSize(window);
            commonShim.shimSendThrowTypeError(window);
            commonShim.removeAllowExtmapMixed(window);
            break;
          default:
            logging('Unsupported browser!');
            break;
        }

        return adapter;
      }

      // Browser shims.

    }, { "./chrome/chrome_shim": 3, "./common_shim": 6, "./edge/edge_shim": 7, "./firefox/firefox_shim": 11, "./safari/safari_shim": 14, "./utils": 15 }], 3: [function (require, module, exports) {

      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

      var _getusermedia = require('./getusermedia');

      Object.defineProperty(exports, 'shimGetUserMedia', {
        enumerable: true,
        get: function get() {
          return _getusermedia.shimGetUserMedia;
        }
      });

      var _getdisplaymedia = require('./getdisplaymedia');

      Object.defineProperty(exports, 'shimGetDisplayMedia', {
        enumerable: true,
        get: function get() {
          return _getdisplaymedia.shimGetDisplayMedia;
        }
      });
      exports.shimMediaStream = shimMediaStream;
      exports.shimOnTrack = shimOnTrack;
      exports.shimGetSendersWithDtmf = shimGetSendersWithDtmf;
      exports.shimGetStats = shimGetStats;
      exports.shimSenderReceiverGetStats = shimSenderReceiverGetStats;
      exports.shimAddTrackRemoveTrackWithNative = shimAddTrackRemoveTrackWithNative;
      exports.shimAddTrackRemoveTrack = shimAddTrackRemoveTrack;
      exports.shimPeerConnection = shimPeerConnection;
      exports.fixNegotiationNeeded = fixNegotiationNeeded;

      var _utils = require('../utils.js');

      var utils = _interopRequireWildcard(_utils);

      function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

      function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

      function shimMediaStream(window) {
        window.MediaStream = window.MediaStream || window.webkitMediaStream;
      }

      function shimOnTrack(window) {
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
          Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
            get: function get() {
              return this._ontrack;
            },
            set: function set(f) {
              if (this._ontrack) {
                this.removeEventListener('track', this._ontrack);
              }
              this.addEventListener('track', this._ontrack = f);
            },

            enumerable: true,
            configurable: true
          });
          var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
          window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
            var _this = this;

            if (!this._ontrackpoly) {
              this._ontrackpoly = function (e) {
                // onaddstream does not fire when a track is added to an existing
                // stream. But stream.onaddtrack is implemented so we use that.
                e.stream.addEventListener('addtrack', function (te) {
                  var receiver = void 0;
                  if (window.RTCPeerConnection.prototype.getReceivers) {
                    receiver = _this.getReceivers().find(function (r) {
                      return r.track && r.track.id === te.track.id;
                    });
                  } else {
                    receiver = { track: te.track };
                  }

                  var event = new Event('track');
                  event.track = te.track;
                  event.receiver = receiver;
                  event.transceiver = { receiver: receiver };
                  event.streams = [e.stream];
                  _this.dispatchEvent(event);
                });
                e.stream.getTracks().forEach(function (track) {
                  var receiver = void 0;
                  if (window.RTCPeerConnection.prototype.getReceivers) {
                    receiver = _this.getReceivers().find(function (r) {
                      return r.track && r.track.id === track.id;
                    });
                  } else {
                    receiver = { track: track };
                  }
                  var event = new Event('track');
                  event.track = track;
                  event.receiver = receiver;
                  event.transceiver = { receiver: receiver };
                  event.streams = [e.stream];
                  _this.dispatchEvent(event);
                });
              };
              this.addEventListener('addstream', this._ontrackpoly);
            }
            return origSetRemoteDescription.apply(this, arguments);
          };
        } else {
          // even if RTCRtpTransceiver is in window, it is only used and
          // emitted in unified-plan. Unfortunately this means we need
          // to unconditionally wrap the event.
          utils.wrapPeerConnectionEvent(window, 'track', function (e) {
            if (!e.transceiver) {
              Object.defineProperty(e, 'transceiver', { value: { receiver: e.receiver } });
            }
            return e;
          });
        }
      }

      function shimGetSendersWithDtmf(window) {
        // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
          var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {
            return {
              track: track,
              get dtmf() {
                if (this._dtmf === undefined) {
                  if (track.kind === 'audio') {
                    this._dtmf = pc.createDTMFSender(track);
                  } else {
                    this._dtmf = null;
                  }
                }
                return this._dtmf;
              },
              _pc: pc
            };
          };

          // augment addTrack when getSenders is not available.
          if (!window.RTCPeerConnection.prototype.getSenders) {
            window.RTCPeerConnection.prototype.getSenders = function getSenders() {
              this._senders = this._senders || [];
              return this._senders.slice(); // return a copy of the internal state.
            };
            var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
            window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
              var sender = origAddTrack.apply(this, arguments);
              if (!sender) {
                sender = shimSenderWithDtmf(this, track);
                this._senders.push(sender);
              }
              return sender;
            };

            var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
            window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
              origRemoveTrack.apply(this, arguments);
              var idx = this._senders.indexOf(sender);
              if (idx !== -1) {
                this._senders.splice(idx, 1);
              }
            };
          }
          var origAddStream = window.RTCPeerConnection.prototype.addStream;
          window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
            var _this2 = this;

            this._senders = this._senders || [];
            origAddStream.apply(this, [stream]);
            stream.getTracks().forEach(function (track) {
              _this2._senders.push(shimSenderWithDtmf(_this2, track));
            });
          };

          var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
          window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
            var _this3 = this;

            this._senders = this._senders || [];
            origRemoveStream.apply(this, [stream]);

            stream.getTracks().forEach(function (track) {
              var sender = _this3._senders.find(function (s) {
                return s.track === track;
              });
              if (sender) {
                // remove sender
                _this3._senders.splice(_this3._senders.indexOf(sender), 1);
              }
            });
          };
        } else if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
          var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
          window.RTCPeerConnection.prototype.getSenders = function getSenders() {
            var _this4 = this;

            var senders = origGetSenders.apply(this, []);
            senders.forEach(function (sender) {
              return sender._pc = _this4;
            });
            return senders;
          };

          Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
            get: function get() {
              if (this._dtmf === undefined) {
                if (this.track.kind === 'audio') {
                  this._dtmf = this._pc.createDTMFSender(this.track);
                } else {
                  this._dtmf = null;
                }
              }
              return this._dtmf;
            }
          });
        }
      }

      function shimGetStats(window) {
        if (!window.RTCPeerConnection) {
          return;
        }

        var origGetStats = window.RTCPeerConnection.prototype.getStats;
        window.RTCPeerConnection.prototype.getStats = function getStats() {
          var _this5 = this;

          var _arguments = Array.prototype.slice.call(arguments),
            selector = _arguments[0],
            onSucc = _arguments[1],
            onErr = _arguments[2];

          // If selector is a function then we are in the old style stats so just
          // pass back the original getStats format to avoid breaking old users.


          if (arguments.length > 0 && typeof selector === 'function') {
            return origGetStats.apply(this, arguments);
          }

          // When spec-style getStats is supported, return those when called with
          // either no arguments or the selector argument is null.
          if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {
            return origGetStats.apply(this, []);
          }

          var fixChromeStats_ = function fixChromeStats_(response) {
            var standardReport = {};
            var reports = response.result();
            reports.forEach(function (report) {
              var standardStats = {
                id: report.id,
                timestamp: report.timestamp,
                type: {
                  localcandidate: 'local-candidate',
                  remotecandidate: 'remote-candidate'
                }[report.type] || report.type
              };
              report.names().forEach(function (name) {
                standardStats[name] = report.stat(name);
              });
              standardReport[standardStats.id] = standardStats;
            });

            return standardReport;
          };

          // shim getStats with maplike support
          var makeMapStats = function makeMapStats(stats) {
            return new Map(Object.keys(stats).map(function (key) {
              return [key, stats[key]];
            }));
          };

          if (arguments.length >= 2) {
            var successCallbackWrapper_ = function successCallbackWrapper_(response) {
              onSucc(makeMapStats(fixChromeStats_(response)));
            };

            return origGetStats.apply(this, [successCallbackWrapper_, selector]);
          }

          // promise-support
          return new Promise(function (resolve, reject) {
            origGetStats.apply(_this5, [function (response) {
              resolve(makeMapStats(fixChromeStats_(response)));
            }, reject]);
          }).then(onSucc, onErr);
        };
      }

      function shimSenderReceiverGetStats(window) {
        if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {
          return;
        }

        // shim sender stats.
        if (!('getStats' in window.RTCRtpSender.prototype)) {
          var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
          if (origGetSenders) {
            window.RTCPeerConnection.prototype.getSenders = function getSenders() {
              var _this6 = this;

              var senders = origGetSenders.apply(this, []);
              senders.forEach(function (sender) {
                return sender._pc = _this6;
              });
              return senders;
            };
          }

          var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
          if (origAddTrack) {
            window.RTCPeerConnection.prototype.addTrack = function addTrack() {
              var sender = origAddTrack.apply(this, arguments);
              sender._pc = this;
              return sender;
            };
          }
          window.RTCRtpSender.prototype.getStats = function getStats() {
            var sender = this;
            return this._pc.getStats().then(function (result) {
              return (
                /* Note: this will include stats of all senders that
                 *   send a track with the same id as sender.track as
                 *   it is not possible to identify the RTCRtpSender.
                 */
                utils.filterStats(result, sender.track, true)
              );
            });
          };
        }

        // shim receiver stats.
        if (!('getStats' in window.RTCRtpReceiver.prototype)) {
          var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
          if (origGetReceivers) {
            window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
              var _this7 = this;

              var receivers = origGetReceivers.apply(this, []);
              receivers.forEach(function (receiver) {
                return receiver._pc = _this7;
              });
              return receivers;
            };
          }
          utils.wrapPeerConnectionEvent(window, 'track', function (e) {
            e.receiver._pc = e.srcElement;
            return e;
          });
          window.RTCRtpReceiver.prototype.getStats = function getStats() {
            var receiver = this;
            return this._pc.getStats().then(function (result) {
              return utils.filterStats(result, receiver.track, false);
            });
          };
        }

        if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {
          return;
        }

        // shim RTCPeerConnection.getStats(track).
        var origGetStats = window.RTCPeerConnection.prototype.getStats;
        window.RTCPeerConnection.prototype.getStats = function getStats() {
          if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
            var track = arguments[0];
            var sender = void 0;
            var receiver = void 0;
            var err = void 0;
            this.getSenders().forEach(function (s) {
              if (s.track === track) {
                if (sender) {
                  err = true;
                } else {
                  sender = s;
                }
              }
            });
            this.getReceivers().forEach(function (r) {
              if (r.track === track) {
                if (receiver) {
                  err = true;
                } else {
                  receiver = r;
                }
              }
              return r.track === track;
            });
            if (err || sender && receiver) {
              return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));
            } else if (sender) {
              return sender.getStats();
            } else if (receiver) {
              return receiver.getStats();
            }
            return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));
          }
          return origGetStats.apply(this, arguments);
        };
      }

      function shimAddTrackRemoveTrackWithNative(window) {
        // shim addTrack/removeTrack with native variants in order to make
        // the interactions with legacy getLocalStreams behave as in other browsers.
        // Keeps a mapping stream.id => [stream, rtpsenders...]
        window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
          var _this8 = this;

          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          return Object.keys(this._shimmedLocalStreams).map(function (streamId) {
            return _this8._shimmedLocalStreams[streamId][0];
          });
        };

        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
          if (!stream) {
            return origAddTrack.apply(this, arguments);
          }
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};

          var sender = origAddTrack.apply(this, arguments);
          if (!this._shimmedLocalStreams[stream.id]) {
            this._shimmedLocalStreams[stream.id] = [stream, sender];
          } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
            this._shimmedLocalStreams[stream.id].push(sender);
          }
          return sender;
        };

        var origAddStream = window.RTCPeerConnection.prototype.addStream;
        window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
          var _this9 = this;

          this._shimmedLocalStreams = this._shimmedLocalStreams || {};

          stream.getTracks().forEach(function (track) {
            var alreadyExists = _this9.getSenders().find(function (s) {
              return s.track === track;
            });
            if (alreadyExists) {
              throw new DOMException('Track already exists.', 'InvalidAccessError');
            }
          });
          var existingSenders = this.getSenders();
          origAddStream.apply(this, arguments);
          var newSenders = this.getSenders().filter(function (newSender) {
            return existingSenders.indexOf(newSender) === -1;
          });
          this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
        };

        var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
        window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          delete this._shimmedLocalStreams[stream.id];
          return origRemoveStream.apply(this, arguments);
        };

        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
          var _this10 = this;

          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          if (sender) {
            Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {
              var idx = _this10._shimmedLocalStreams[streamId].indexOf(sender);
              if (idx !== -1) {
                _this10._shimmedLocalStreams[streamId].splice(idx, 1);
              }
              if (_this10._shimmedLocalStreams[streamId].length === 1) {
                delete _this10._shimmedLocalStreams[streamId];
              }
            });
          }
          return origRemoveTrack.apply(this, arguments);
        };
      }

      function shimAddTrackRemoveTrack(window) {
        if (!window.RTCPeerConnection) {
          return;
        }
        var browserDetails = utils.detectBrowser(window);
        // shim addTrack and removeTrack.
        if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
          return shimAddTrackRemoveTrackWithNative(window);
        }

        // also shim pc.getLocalStreams when addTrack is shimmed
        // to return the original streams.
        var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;
        window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
          var _this11 = this;

          var nativeStreams = origGetLocalStreams.apply(this);
          this._reverseStreams = this._reverseStreams || {};
          return nativeStreams.map(function (stream) {
            return _this11._reverseStreams[stream.id];
          });
        };

        var origAddStream = window.RTCPeerConnection.prototype.addStream;
        window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
          var _this12 = this;

          this._streams = this._streams || {};
          this._reverseStreams = this._reverseStreams || {};

          stream.getTracks().forEach(function (track) {
            var alreadyExists = _this12.getSenders().find(function (s) {
              return s.track === track;
            });
            if (alreadyExists) {
              throw new DOMException('Track already exists.', 'InvalidAccessError');
            }
          });
          // Add identity mapping for consistency with addTrack.
          // Unless this is being used with a stream from addTrack.
          if (!this._reverseStreams[stream.id]) {
            var newStream = new window.MediaStream(stream.getTracks());
            this._streams[stream.id] = newStream;
            this._reverseStreams[newStream.id] = stream;
            stream = newStream;
          }
          origAddStream.apply(this, [stream]);
        };

        var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
        window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
          this._streams = this._streams || {};
          this._reverseStreams = this._reverseStreams || {};

          origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
          delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
          delete this._streams[stream.id];
        };

        window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
          var _this13 = this;

          if (this.signalingState === 'closed') {
            throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
          }
          var streams = [].slice.call(arguments, 1);
          if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {
            return t === track;
          })) {
            // this is not fully correct but all we can manage without
            // [[associated MediaStreams]] internal slot.
            throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
          }

          var alreadyExists = this.getSenders().find(function (s) {
            return s.track === track;
          });
          if (alreadyExists) {
            throw new DOMException('Track already exists.', 'InvalidAccessError');
          }

          this._streams = this._streams || {};
          this._reverseStreams = this._reverseStreams || {};
          var oldStream = this._streams[stream.id];
          if (oldStream) {
            // this is using odd Chrome behaviour, use with caution:
            // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
            // Note: we rely on the high-level addTrack/dtmf shim to
            // create the sender with a dtmf sender.
            oldStream.addTrack(track);

            // Trigger ONN async.
            Promise.resolve().then(function () {
              _this13.dispatchEvent(new Event('negotiationneeded'));
            });
          } else {
            var newStream = new window.MediaStream([track]);
            this._streams[stream.id] = newStream;
            this._reverseStreams[newStream.id] = stream;
            this.addStream(newStream);
          }
          return this.getSenders().find(function (s) {
            return s.track === track;
          });
        };

        // replace the internal stream id with the external one and
        // vice versa.
        function replaceInternalStreamId(pc, description) {
          var sdp = description.sdp;
          Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
            var externalStream = pc._reverseStreams[internalId];
            var internalStream = pc._streams[externalStream.id];
            sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
          });
          return new RTCSessionDescription({
            type: description.type,
            sdp: sdp
          });
        }
        function replaceExternalStreamId(pc, description) {
          var sdp = description.sdp;
          Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
            var externalStream = pc._reverseStreams[internalId];
            var internalStream = pc._streams[externalStream.id];
            sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
          });
          return new RTCSessionDescription({
            type: description.type,
            sdp: sdp
          });
        }
        ['createOffer', 'createAnswer'].forEach(function (method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          var methodObj = _defineProperty({}, method, function () {
            var _this14 = this;

            var args = arguments;
            var isLegacyCall = arguments.length && typeof arguments[0] === 'function';
            if (isLegacyCall) {
              return nativeMethod.apply(this, [function (description) {
                var desc = replaceInternalStreamId(_this14, description);
                args[0].apply(null, [desc]);
              }, function (err) {
                if (args[1]) {
                  args[1].apply(null, err);
                }
              }, arguments[2]]);
            }
            return nativeMethod.apply(this, arguments).then(function (description) {
              return replaceInternalStreamId(_this14, description);
            });
          });
          window.RTCPeerConnection.prototype[method] = methodObj[method];
        });

        var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
        window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
          if (!arguments.length || !arguments[0].type) {
            return origSetLocalDescription.apply(this, arguments);
          }
          arguments[0] = replaceExternalStreamId(this, arguments[0]);
          return origSetLocalDescription.apply(this, arguments);
        };

        // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

        var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');
        Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
          get: function get() {
            var description = origLocalDescription.get.apply(this);
            if (description.type === '') {
              return description;
            }
            return replaceInternalStreamId(this, description);
          }
        });

        window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
          var _this15 = this;

          if (this.signalingState === 'closed') {
            throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
          }
          // We can not yet check for sender instanceof RTCRtpSender
          // since we shim RTPSender. So we check if sender._pc is set.
          if (!sender._pc) {
            throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
          }
          var isLocal = sender._pc === this;
          if (!isLocal) {
            throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
          }

          // Search for the native stream the senders track belongs to.
          this._streams = this._streams || {};
          var stream = void 0;
          Object.keys(this._streams).forEach(function (streamid) {
            var hasTrack = _this15._streams[streamid].getTracks().find(function (track) {
              return sender.track === track;
            });
            if (hasTrack) {
              stream = _this15._streams[streamid];
            }
          });

          if (stream) {
            if (stream.getTracks().length === 1) {
              // if this is the last track of the stream, remove the stream. This
              // takes care of any shimmed _senders.
              this.removeStream(this._reverseStreams[stream.id]);
            } else {
              // relying on the same odd chrome behaviour as above.
              stream.removeTrack(sender.track);
            }
            this.dispatchEvent(new Event('negotiationneeded'));
          }
        };
      }

      function shimPeerConnection(window) {
        var browserDetails = utils.detectBrowser(window);

        if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
          // very basic support for old versions.
          window.RTCPeerConnection = window.webkitRTCPeerConnection;
        }
        if (!window.RTCPeerConnection) {
          return;
        }

        var addIceCandidateNullSupported = window.RTCPeerConnection.prototype.addIceCandidate.length === 0;

        // shim implicit creation of RTCSessionDescription/RTCIceCandidate
        if (browserDetails.version < 53) {
          ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];
            var methodObj = _defineProperty({}, method, function () {
              arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
              return nativeMethod.apply(this, arguments);
            });
            window.RTCPeerConnection.prototype[method] = methodObj[method];
          });
        }

        // support for addIceCandidate(null or undefined)
        var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
        window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
          if (!addIceCandidateNullSupported && !arguments[0]) {
            if (arguments[1]) {
              arguments[1].apply(null);
            }
            return Promise.resolve();
          }
          // Firefox 68+ emits and processes {candidate: "", ...}, ignore
          // in older versions. Native support planned for Chrome M77.
          if (browserDetails.version < 78 && arguments[0] && arguments[0].candidate === '') {
            return Promise.resolve();
          }
          return nativeAddIceCandidate.apply(this, arguments);
        };
      }

      function fixNegotiationNeeded(window) {
        utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function (e) {
          var pc = e.target;
          if (pc.signalingState !== 'stable') {
            return;
          }
          return e;
        });
      }

    }, { "../utils.js": 15, "./getdisplaymedia": 4, "./getusermedia": 5 }], 4: [function (require, module, exports) {
      /*
       *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shimGetDisplayMedia = shimGetDisplayMedia;
      function shimGetDisplayMedia(window, getSourceId) {
        if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
          return;
        }
        if (!window.navigator.mediaDevices) {
          return;
        }
        // getSourceId is a function that returns a promise resolving with
        // the sourceId of the screen/window/tab to be shared.
        if (typeof getSourceId !== 'function') {
          console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');
          return;
        }
        window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
          return getSourceId(constraints).then(function (sourceId) {
            var widthSpecified = constraints.video && constraints.video.width;
            var heightSpecified = constraints.video && constraints.video.height;
            var frameRateSpecified = constraints.video && constraints.video.frameRate;
            constraints.video = {
              mandatory: {
                chromeMediaSource: 'desktop',
                chromeMediaSourceId: sourceId,
                maxFrameRate: frameRateSpecified || 3
              }
            };
            if (widthSpecified) {
              constraints.video.mandatory.maxWidth = widthSpecified;
            }
            if (heightSpecified) {
              constraints.video.mandatory.maxHeight = heightSpecified;
            }
            return window.navigator.mediaDevices.getUserMedia(constraints);
          });
        };
      }

    }, {}], 5: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

      exports.shimGetUserMedia = shimGetUserMedia;

      var _utils = require('../utils.js');

      var utils = _interopRequireWildcard(_utils);

      function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

      var logging = utils.log;

      function shimGetUserMedia(window) {
        var navigator = window && window.navigator;

        if (!navigator.mediaDevices) {
          return;
        }

        var browserDetails = utils.detectBrowser(window);

        var constraintsToChrome_ = function constraintsToChrome_(c) {
          if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) !== 'object' || c.mandatory || c.optional) {
            return c;
          }
          var cc = {};
          Object.keys(c).forEach(function (key) {
            if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
              return;
            }
            var r = _typeof(c[key]) === 'object' ? c[key] : { ideal: c[key] };
            if (r.exact !== undefined && typeof r.exact === 'number') {
              r.min = r.max = r.exact;
            }
            var oldname_ = function oldname_(prefix, name) {
              if (prefix) {
                return prefix + name.charAt(0).toUpperCase() + name.slice(1);
              }
              return name === 'deviceId' ? 'sourceId' : name;
            };
            if (r.ideal !== undefined) {
              cc.optional = cc.optional || [];
              var oc = {};
              if (typeof r.ideal === 'number') {
                oc[oldname_('min', key)] = r.ideal;
                cc.optional.push(oc);
                oc = {};
                oc[oldname_('max', key)] = r.ideal;
                cc.optional.push(oc);
              } else {
                oc[oldname_('', key)] = r.ideal;
                cc.optional.push(oc);
              }
            }
            if (r.exact !== undefined && typeof r.exact !== 'number') {
              cc.mandatory = cc.mandatory || {};
              cc.mandatory[oldname_('', key)] = r.exact;
            } else {
              ['min', 'max'].forEach(function (mix) {
                if (r[mix] !== undefined) {
                  cc.mandatory = cc.mandatory || {};
                  cc.mandatory[oldname_(mix, key)] = r[mix];
                }
              });
            }
          });
          if (c.advanced) {
            cc.optional = (cc.optional || []).concat(c.advanced);
          }
          return cc;
        };

        var shimConstraints_ = function shimConstraints_(constraints, func) {
          if (browserDetails.version >= 61) {
            return func(constraints);
          }
          constraints = JSON.parse(JSON.stringify(constraints));
          if (constraints && _typeof(constraints.audio) === 'object') {
            var remap = function remap(obj, a, b) {
              if (a in obj && !(b in obj)) {
                obj[b] = obj[a];
                delete obj[a];
              }
            };
            constraints = JSON.parse(JSON.stringify(constraints));
            remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
            remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
            constraints.audio = constraintsToChrome_(constraints.audio);
          }
          if (constraints && _typeof(constraints.video) === 'object') {
            // Shim facingMode for mobile & surface pro.
            var face = constraints.video.facingMode;
            face = face && ((typeof face === 'undefined' ? 'undefined' : _typeof(face)) === 'object' ? face : { ideal: face });
            var getSupportedFacingModeLies = browserDetails.version < 66;

            if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
              delete constraints.video.facingMode;
              var matches = void 0;
              if (face.exact === 'environment' || face.ideal === 'environment') {
                matches = ['back', 'rear'];
              } else if (face.exact === 'user' || face.ideal === 'user') {
                matches = ['front'];
              }
              if (matches) {
                // Look for matches in label, or use last cam for back (typical).
                return navigator.mediaDevices.enumerateDevices().then(function (devices) {
                  devices = devices.filter(function (d) {
                    return d.kind === 'videoinput';
                  });
                  var dev = devices.find(function (d) {
                    return matches.some(function (match) {
                      return d.label.toLowerCase().includes(match);
                    });
                  });
                  if (!dev && devices.length && matches.includes('back')) {
                    dev = devices[devices.length - 1]; // more likely the back cam
                  }
                  if (dev) {
                    constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
                  }
                  constraints.video = constraintsToChrome_(constraints.video);
                  logging('chrome: ' + JSON.stringify(constraints));
                  return func(constraints);
                });
              }
            }
            constraints.video = constraintsToChrome_(constraints.video);
          }
          logging('chrome: ' + JSON.stringify(constraints));
          return func(constraints);
        };

        var shimError_ = function shimError_(e) {
          if (browserDetails.version >= 64) {
            return e;
          }
          return {
            name: {
              PermissionDeniedError: 'NotAllowedError',
              PermissionDismissedError: 'NotAllowedError',
              InvalidStateError: 'NotAllowedError',
              DevicesNotFoundError: 'NotFoundError',
              ConstraintNotSatisfiedError: 'OverconstrainedError',
              TrackStartError: 'NotReadableError',
              MediaDeviceFailedDueToShutdown: 'NotAllowedError',
              MediaDeviceKillSwitchOn: 'NotAllowedError',
              TabCaptureError: 'AbortError',
              ScreenCaptureError: 'AbortError',
              DeviceCaptureError: 'AbortError'
            }[e.name] || e.name,
            message: e.message,
            constraint: e.constraint || e.constraintName,
            toString: function toString() {
              return this.name + (this.message && ': ') + this.message;
            }
          };
        };

        var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
          shimConstraints_(constraints, function (c) {
            navigator.webkitGetUserMedia(c, onSuccess, function (e) {
              if (onError) {
                onError(shimError_(e));
              }
            });
          });
        };
        navigator.getUserMedia = getUserMedia_.bind(navigator);

        // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
        // function which returns a Promise, it does not accept spec-style
        // constraints.
        if (navigator.mediaDevices.getUserMedia) {
          var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
          navigator.mediaDevices.getUserMedia = function (cs) {
            return shimConstraints_(cs, function (c) {
              return origGetUserMedia(c).then(function (stream) {
                if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
                  stream.getTracks().forEach(function (track) {
                    track.stop();
                  });
                  throw new DOMException('', 'NotFoundError');
                }
                return stream;
              }, function (e) {
                return Promise.reject(shimError_(e));
              });
            });
          };
        }
      }

    }, { "../utils.js": 15 }], 6: [function (require, module, exports) {
      /*
       *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

      exports.shimRTCIceCandidate = shimRTCIceCandidate;
      exports.shimMaxMessageSize = shimMaxMessageSize;
      exports.shimSendThrowTypeError = shimSendThrowTypeError;
      exports.shimConnectionState = shimConnectionState;
      exports.removeAllowExtmapMixed = removeAllowExtmapMixed;

      var _sdp = require('sdp');

      var _sdp2 = _interopRequireDefault(_sdp);

      var _utils = require('./utils');

      var utils = _interopRequireWildcard(_utils);

      function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      function shimRTCIceCandidate(window) {
        // foundation is arbitrarily chosen as an indicator for full support for
        // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
        if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
          return;
        }

        var NativeRTCIceCandidate = window.RTCIceCandidate;
        window.RTCIceCandidate = function RTCIceCandidate(args) {
          // Remove the a= which shouldn't be part of the candidate string.
          if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
            args = JSON.parse(JSON.stringify(args));
            args.candidate = args.candidate.substr(2);
          }

          if (args.candidate && args.candidate.length) {
            // Augment the native candidate with the parsed fields.
            var nativeCandidate = new NativeRTCIceCandidate(args);
            var parsedCandidate = _sdp2.default.parseCandidate(args.candidate);
            var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);

            // Add a serializer that does not serialize the extra attributes.
            augmentedCandidate.toJSON = function toJSON() {
              return {
                candidate: augmentedCandidate.candidate,
                sdpMid: augmentedCandidate.sdpMid,
                sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
                usernameFragment: augmentedCandidate.usernameFragment
              };
            };
            return augmentedCandidate;
          }
          return new NativeRTCIceCandidate(args);
        };
        window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

        // Hook up the augmented candidate in onicecandidate and
        // addEventListener('icecandidate', ...)
        utils.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {
          if (e.candidate) {
            Object.defineProperty(e, 'candidate', {
              value: new window.RTCIceCandidate(e.candidate),
              writable: 'false'
            });
          }
          return e;
        });
      }

      function shimMaxMessageSize(window) {
        if (!window.RTCPeerConnection) {
          return;
        }
        var browserDetails = utils.detectBrowser(window);

        if (!('sctp' in window.RTCPeerConnection.prototype)) {
          Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
            get: function get() {
              return typeof this._sctp === 'undefined' ? null : this._sctp;
            }
          });
        }

        var sctpInDescription = function sctpInDescription(description) {
          if (!description || !description.sdp) {
            return false;
          }
          var sections = _sdp2.default.splitSections(description.sdp);
          sections.shift();
          return sections.some(function (mediaSection) {
            var mLine = _sdp2.default.parseMLine(mediaSection);
            return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
          });
        };

        var getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {
          // TODO: Is there a better solution for detecting Firefox?
          var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
          if (match === null || match.length < 2) {
            return -1;
          }
          var version = parseInt(match[1], 10);
          // Test for NaN (yes, this is ugly)
          return version !== version ? -1 : version;
        };

        var getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {
          // Every implementation we know can send at least 64 KiB.
          // Note: Although Chrome is technically able to send up to 256 KiB, the
          //       data does not reach the other peer reliably.
          //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
          var canSendMaxMessageSize = 65536;
          if (browserDetails.browser === 'firefox') {
            if (browserDetails.version < 57) {
              if (remoteIsFirefox === -1) {
                // FF < 57 will send in 16 KiB chunks using the deprecated PPID
                // fragmentation.
                canSendMaxMessageSize = 16384;
              } else {
                // However, other FF (and RAWRTC) can reassemble PPID-fragmented
                // messages. Thus, supporting ~2 GiB when sending.
                canSendMaxMessageSize = 2147483637;
              }
            } else if (browserDetails.version < 60) {
              // Currently, all FF >= 57 will reset the remote maximum message size
              // to the default value when a data channel is created at a later
              // stage. :(
              // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
              canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
            } else {
              // FF >= 60 supports sending ~2 GiB
              canSendMaxMessageSize = 2147483637;
            }
          }
          return canSendMaxMessageSize;
        };

        var getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {
          // Note: 65536 bytes is the default value from the SDP spec. Also,
          //       every implementation we know supports receiving 65536 bytes.
          var maxMessageSize = 65536;

          // FF 57 has a slightly incorrect default remote max message size, so
          // we need to adjust it here to avoid a failure when sending.
          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
          if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
            maxMessageSize = 65535;
          }

          var match = _sdp2.default.matchPrefix(description.sdp, 'a=max-message-size:');
          if (match.length > 0) {
            maxMessageSize = parseInt(match[0].substr(19), 10);
          } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
            // If the maximum message size is not present in the remote SDP and
            // both local and remote are Firefox, the remote peer can receive
            // ~2 GiB.
            maxMessageSize = 2147483637;
          }
          return maxMessageSize;
        };

        var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
        window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
          this._sctp = null;
          // Chrome decided to not expose .sctp in plan-b mode.
          // As usual, adapter.js has to do an 'ugly worakaround'
          // to cover up the mess.
          if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
            var _getConfiguration = this.getConfiguration(),
              sdpSemantics = _getConfiguration.sdpSemantics;

            if (sdpSemantics === 'plan-b') {
              Object.defineProperty(this, 'sctp', {
                get: function get() {
                  return typeof this._sctp === 'undefined' ? null : this._sctp;
                },

                enumerable: true,
                configurable: true
              });
            }
          }

          if (sctpInDescription(arguments[0])) {
            // Check if the remote is FF.
            var isFirefox = getRemoteFirefoxVersion(arguments[0]);

            // Get the maximum message size the local peer is capable of sending
            var canSendMMS = getCanSendMaxMessageSize(isFirefox);

            // Get the maximum message size of the remote peer.
            var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

            // Determine final maximum message size
            var maxMessageSize = void 0;
            if (canSendMMS === 0 && remoteMMS === 0) {
              maxMessageSize = Number.POSITIVE_INFINITY;
            } else if (canSendMMS === 0 || remoteMMS === 0) {
              maxMessageSize = Math.max(canSendMMS, remoteMMS);
            } else {
              maxMessageSize = Math.min(canSendMMS, remoteMMS);
            }

            // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
            // attribute.
            var sctp = {};
            Object.defineProperty(sctp, 'maxMessageSize', {
              get: function get() {
                return maxMessageSize;
              }
            });
            this._sctp = sctp;
          }

          return origSetRemoteDescription.apply(this, arguments);
        };
      }

      function shimSendThrowTypeError(window) {
        if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
          return;
        }

        // Note: Although Firefox >= 57 has a native implementation, the maximum
        //       message size can be reset for all data channels at a later stage.
        //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

        function wrapDcSend(dc, pc) {
          var origDataChannelSend = dc.send;
          dc.send = function send() {
            var data = arguments[0];
            var length = data.length || data.size || data.byteLength;
            if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
              throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');
            }
            return origDataChannelSend.apply(dc, arguments);
          };
        }
        var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;
        window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
          var dataChannel = origCreateDataChannel.apply(this, arguments);
          wrapDcSend(dataChannel, this);
          return dataChannel;
        };
        utils.wrapPeerConnectionEvent(window, 'datachannel', function (e) {
          wrapDcSend(e.channel, e.target);
          return e;
        });
      }

      /* shims RTCConnectionState by pretending it is the same as iceConnectionState.
       * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
       * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
       * since DTLS failures would be hidden. See
       * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
       * for the Firefox tracking bug.
       */
      function shimConnectionState(window) {
        if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {
          return;
        }
        var proto = window.RTCPeerConnection.prototype;
        Object.defineProperty(proto, 'connectionState', {
          get: function get() {
            return {
              completed: 'connected',
              checking: 'connecting'
            }[this.iceConnectionState] || this.iceConnectionState;
          },

          enumerable: true,
          configurable: true
        });
        Object.defineProperty(proto, 'onconnectionstatechange', {
          get: function get() {
            return this._onconnectionstatechange || null;
          },
          set: function set(cb) {
            if (this._onconnectionstatechange) {
              this.removeEventListener('connectionstatechange', this._onconnectionstatechange);
              delete this._onconnectionstatechange;
            }
            if (cb) {
              this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);
            }
          },

          enumerable: true,
          configurable: true
        });

        ['setLocalDescription', 'setRemoteDescription'].forEach(function (method) {
          var origMethod = proto[method];
          proto[method] = function () {
            if (!this._connectionstatechangepoly) {
              this._connectionstatechangepoly = function (e) {
                var pc = e.target;
                if (pc._lastConnectionState !== pc.connectionState) {
                  pc._lastConnectionState = pc.connectionState;
                  var newEvent = new Event('connectionstatechange', e);
                  pc.dispatchEvent(newEvent);
                }
                return e;
              };
              this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);
            }
            return origMethod.apply(this, arguments);
          };
        });
      }

      function removeAllowExtmapMixed(window) {
        /* remove a=extmap-allow-mixed for Chrome < M71 */
        if (!window.RTCPeerConnection) {
          return;
        }
        var browserDetails = utils.detectBrowser(window);
        if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
          return;
        }
        var nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
        window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
          if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
            desc.sdp = desc.sdp.split('\n').filter(function (line) {
              return line.trim() !== 'a=extmap-allow-mixed';
            }).join('\n');
          }
          return nativeSRD.apply(this, arguments);
        };
      }

    }, { "./utils": 15, "sdp": 17 }], 7: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

      var _getusermedia = require('./getusermedia');

      Object.defineProperty(exports, 'shimGetUserMedia', {
        enumerable: true,
        get: function get() {
          return _getusermedia.shimGetUserMedia;
        }
      });

      var _getdisplaymedia = require('./getdisplaymedia');

      Object.defineProperty(exports, 'shimGetDisplayMedia', {
        enumerable: true,
        get: function get() {
          return _getdisplaymedia.shimGetDisplayMedia;
        }
      });
      exports.shimPeerConnection = shimPeerConnection;
      exports.shimReplaceTrack = shimReplaceTrack;

      var _utils = require('../utils');

      var utils = _interopRequireWildcard(_utils);

      var _filtericeservers = require('./filtericeservers');

      var _rtcpeerconnectionShim = require('rtcpeerconnection-shim');

      var _rtcpeerconnectionShim2 = _interopRequireDefault(_rtcpeerconnectionShim);

      function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

      function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

      function shimPeerConnection(window) {
        var browserDetails = utils.detectBrowser(window);

        if (window.RTCIceGatherer) {
          if (!window.RTCIceCandidate) {
            window.RTCIceCandidate = function RTCIceCandidate(args) {
              return args;
            };
          }
          if (!window.RTCSessionDescription) {
            window.RTCSessionDescription = function RTCSessionDescription(args) {
              return args;
            };
          }
          // this adds an additional event listener to MediaStrackTrack that signals
          // when a tracks enabled property was changed. Workaround for a bug in
          // addStream, see below. No longer required in 15025+
          if (browserDetails.version < 15025) {
            var origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, 'enabled');
            Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
              set: function set(value) {
                origMSTEnabled.set.call(this, value);
                var ev = new Event('enabled');
                ev.enabled = value;
                this.dispatchEvent(ev);
              }
            });
          }
        }

        // ORTC defines the DTMF sender a bit different.
        // https://github.com/w3c/ortc/issues/714
        if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
          Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
            get: function get() {
              if (this._dtmf === undefined) {
                if (this.track.kind === 'audio') {
                  this._dtmf = new window.RTCDtmfSender(this);
                } else if (this.track.kind === 'video') {
                  this._dtmf = null;
                }
              }
              return this._dtmf;
            }
          });
        }
        // Edge currently only implements the RTCDtmfSender, not the
        // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
        if (window.RTCDtmfSender && !window.RTCDTMFSender) {
          window.RTCDTMFSender = window.RTCDtmfSender;
        }

        var RTCPeerConnectionShim = (0, _rtcpeerconnectionShim2.default)(window, browserDetails.version);
        window.RTCPeerConnection = function RTCPeerConnection(config) {
          if (config && config.iceServers) {
            config.iceServers = (0, _filtericeservers.filterIceServers)(config.iceServers, browserDetails.version);
            utils.log('ICE servers after filtering:', config.iceServers);
          }
          return new RTCPeerConnectionShim(config);
        };
        window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
      }

      function shimReplaceTrack(window) {
        // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
        if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {
          window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;
        }
      }

    }, { "../utils": 15, "./filtericeservers": 8, "./getdisplaymedia": 9, "./getusermedia": 10, "rtcpeerconnection-shim": 16 }], 8: [function (require, module, exports) {
      /*
       *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.filterIceServers = filterIceServers;

      var _utils = require('../utils');

      var utils = _interopRequireWildcard(_utils);

      function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

      // Edge does not like
      // 1) stun: filtered after 14393 unless ?transport=udp is present
      // 2) turn: that does not have all of turn:host:port?transport=udp
      // 3) turn: with ipv6 addresses
      // 4) turn: occurring muliple times
      function filterIceServers(iceServers, edgeVersion) {
        var hasTurn = false;
        iceServers = JSON.parse(JSON.stringify(iceServers));
        return iceServers.filter(function (server) {
          if (server && (server.urls || server.url)) {
            var urls = server.urls || server.url;
            if (server.url && !server.urls) {
              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            }
            var isString = typeof urls === 'string';
            if (isString) {
              urls = [urls];
            }
            urls = urls.filter(function (url) {
              // filter STUN unconditionally.
              if (url.indexOf('stun:') === 0) {
                return false;
              }

              var validTurn = url.startsWith('turn') && !url.startsWith('turn:[') && url.includes('transport=udp');
              if (validTurn && !hasTurn) {
                hasTurn = true;
                return true;
              }
              return validTurn && !hasTurn;
            });

            delete server.url;
            server.urls = isString ? urls[0] : urls;
            return !!urls.length;
          }
        });
      }

    }, { "../utils": 15 }], 9: [function (require, module, exports) {
      /*
       *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shimGetDisplayMedia = shimGetDisplayMedia;
      function shimGetDisplayMedia(window) {
        if (!('getDisplayMedia' in window.navigator)) {
          return;
        }
        if (!window.navigator.mediaDevices) {
          return;
        }
        if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
          return;
        }
        window.navigator.mediaDevices.getDisplayMedia = window.navigator.getDisplayMedia.bind(window.navigator);
      }

    }, {}], 10: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shimGetUserMedia = shimGetUserMedia;
      function shimGetUserMedia(window) {
        var navigator = window && window.navigator;

        var shimError_ = function shimError_(e) {
          return {
            name: { PermissionDeniedError: 'NotAllowedError' }[e.name] || e.name,
            message: e.message,
            constraint: e.constraint,
            toString: function toString() {
              return this.name;
            }
          };
        };

        // getUserMedia error shim.
        var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
        navigator.mediaDevices.getUserMedia = function (c) {
          return origGetUserMedia(c).catch(function (e) {
            return Promise.reject(shimError_(e));
          });
        };
      }

    }, {}], 11: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

      var _getusermedia = require('./getusermedia');

      Object.defineProperty(exports, 'shimGetUserMedia', {
        enumerable: true,
        get: function get() {
          return _getusermedia.shimGetUserMedia;
        }
      });

      var _getdisplaymedia = require('./getdisplaymedia');

      Object.defineProperty(exports, 'shimGetDisplayMedia', {
        enumerable: true,
        get: function get() {
          return _getdisplaymedia.shimGetDisplayMedia;
        }
      });
      exports.shimOnTrack = shimOnTrack;
      exports.shimPeerConnection = shimPeerConnection;
      exports.shimSenderGetStats = shimSenderGetStats;
      exports.shimReceiverGetStats = shimReceiverGetStats;
      exports.shimRemoveStream = shimRemoveStream;
      exports.shimRTCDataChannel = shimRTCDataChannel;
      exports.shimAddTransceiver = shimAddTransceiver;
      exports.shimCreateOffer = shimCreateOffer;
      exports.shimCreateAnswer = shimCreateAnswer;

      var _utils = require('../utils');

      var utils = _interopRequireWildcard(_utils);

      function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

      function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

      function shimOnTrack(window) {
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
          Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
            get: function get() {
              return { receiver: this.receiver };
            }
          });
        }
      }

      function shimPeerConnection(window) {
        var browserDetails = utils.detectBrowser(window);

        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
          return; // probably media.peerconnection.enabled=false in about:config
        }
        if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
          // very basic support for old versions.
          window.RTCPeerConnection = window.mozRTCPeerConnection;
        }

        if (browserDetails.version < 53) {
          // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
          ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];
            var methodObj = _defineProperty({}, method, function () {
              arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
              return nativeMethod.apply(this, arguments);
            });
            window.RTCPeerConnection.prototype[method] = methodObj[method];
          });
        }

        // support for addIceCandidate(null or undefined)
        // as well as ignoring {sdpMid, candidate: ""}
        if (browserDetails.version < 68) {
          var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
          window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
            if (!arguments[0]) {
              if (arguments[1]) {
                arguments[1].apply(null);
              }
              return Promise.resolve();
            }
            // Firefox 68+ emits and processes {candidate: "", ...}, ignore
            // in older versions.
            if (arguments[0] && arguments[0].candidate === '') {
              return Promise.resolve();
            }
            return nativeAddIceCandidate.apply(this, arguments);
          };
        }

        var modernStatsTypes = {
          inboundrtp: 'inbound-rtp',
          outboundrtp: 'outbound-rtp',
          candidatepair: 'candidate-pair',
          localcandidate: 'local-candidate',
          remotecandidate: 'remote-candidate'
        };

        var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
        window.RTCPeerConnection.prototype.getStats = function getStats() {
          var _arguments = Array.prototype.slice.call(arguments),
            selector = _arguments[0],
            onSucc = _arguments[1],
            onErr = _arguments[2];

          return nativeGetStats.apply(this, [selector || null]).then(function (stats) {
            if (browserDetails.version < 53 && !onSucc) {
              // Shim only promise getStats with spec-hyphens in type names
              // Leave callback version alone; misc old uses of forEach before Map
              try {
                stats.forEach(function (stat) {
                  stat.type = modernStatsTypes[stat.type] || stat.type;
                });
              } catch (e) {
                if (e.name !== 'TypeError') {
                  throw e;
                }
                // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
                stats.forEach(function (stat, i) {
                  stats.set(i, Object.assign({}, stat, {
                    type: modernStatsTypes[stat.type] || stat.type
                  }));
                });
              }
            }
            return stats;
          }).then(onSucc, onErr);
        };
      }

      function shimSenderGetStats(window) {
        if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
          return;
        }
        if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
          return;
        }
        var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
        if (origGetSenders) {
          window.RTCPeerConnection.prototype.getSenders = function getSenders() {
            var _this = this;

            var senders = origGetSenders.apply(this, []);
            senders.forEach(function (sender) {
              return sender._pc = _this;
            });
            return senders;
          };
        }

        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        if (origAddTrack) {
          window.RTCPeerConnection.prototype.addTrack = function addTrack() {
            var sender = origAddTrack.apply(this, arguments);
            sender._pc = this;
            return sender;
          };
        }
        window.RTCRtpSender.prototype.getStats = function getStats() {
          return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
        };
      }

      function shimReceiverGetStats(window) {
        if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
          return;
        }
        if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
          return;
        }
        var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
        if (origGetReceivers) {
          window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
            var _this2 = this;

            var receivers = origGetReceivers.apply(this, []);
            receivers.forEach(function (receiver) {
              return receiver._pc = _this2;
            });
            return receivers;
          };
        }
        utils.wrapPeerConnectionEvent(window, 'track', function (e) {
          e.receiver._pc = e.srcElement;
          return e;
        });
        window.RTCRtpReceiver.prototype.getStats = function getStats() {
          return this._pc.getStats(this.track);
        };
      }

      function shimRemoveStream(window) {
        if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
          return;
        }
        window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
          var _this3 = this;

          utils.deprecated('removeStream', 'removeTrack');
          this.getSenders().forEach(function (sender) {
            if (sender.track && stream.getTracks().includes(sender.track)) {
              _this3.removeTrack(sender);
            }
          });
        };
      }

      function shimRTCDataChannel(window) {
        // rename DataChannel to RTCDataChannel (native fix in FF60):
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
        if (window.DataChannel && !window.RTCDataChannel) {
          window.RTCDataChannel = window.DataChannel;
        }
      }

      function shimAddTransceiver(window) {
        // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
        // Firefox ignores the init sendEncodings options passed to addTransceiver
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
        if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
          return;
        }
        var origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;
        if (origAddTransceiver) {
          window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
            this.setParametersPromises = [];
            var initParameters = arguments[1];
            var shouldPerformCheck = initParameters && 'sendEncodings' in initParameters;
            if (shouldPerformCheck) {
              // If sendEncodings params are provided, validate grammar
              initParameters.sendEncodings.forEach(function (encodingParam) {
                if ('rid' in encodingParam) {
                  var ridRegex = /^[a-z0-9]{0,16}$/i;
                  if (!ridRegex.test(encodingParam.rid)) {
                    throw new TypeError('Invalid RID value provided.');
                  }
                }
                if ('scaleResolutionDownBy' in encodingParam) {
                  if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {
                    throw new RangeError('scale_resolution_down_by must be >= 1.0');
                  }
                }
                if ('maxFramerate' in encodingParam) {
                  if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
                    throw new RangeError('max_framerate must be >= 0.0');
                  }
                }
              });
            }
            var transceiver = origAddTransceiver.apply(this, arguments);
            if (shouldPerformCheck) {
              // Check if the init options were applied. If not we do this in an
              // asynchronous way and save the promise reference in a global object.
              // This is an ugly hack, but at the same time is way more robust than
              // checking the sender parameters before and after the createOffer
              // Also note that after the createoffer we are not 100% sure that
              // the params were asynchronously applied so we might miss the
              // opportunity to recreate offer.
              var sender = transceiver.sender;

              var params = sender.getParameters();
              if (!('encodings' in params)) {
                params.encodings = initParameters.sendEncodings;
                this.setParametersPromises.push(sender.setParameters(params).catch(function () { }));
              }
            }
            return transceiver;
          };
        }
      }

      function shimCreateOffer(window) {
        // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
        // Firefox ignores the init sendEncodings options passed to addTransceiver
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
        if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
          return;
        }
        var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
        window.RTCPeerConnection.prototype.createOffer = function createOffer() {
          var _this4 = this,
            _arguments2 = arguments;

          if (this.setParametersPromises && this.setParametersPromises.length) {
            return Promise.all(this.setParametersPromises).then(function () {
              return origCreateOffer.apply(_this4, _arguments2);
            }).finally(function () {
              _this4.setParametersPromises = [];
            });
          }
          return origCreateOffer.apply(this, arguments);
        };
      }

      function shimCreateAnswer(window) {
        // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
        // Firefox ignores the init sendEncodings options passed to addTransceiver
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
        if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
          return;
        }
        var origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;
        window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
          var _this5 = this,
            _arguments3 = arguments;

          if (this.setParametersPromises && this.setParametersPromises.length) {
            return Promise.all(this.setParametersPromises).then(function () {
              return origCreateAnswer.apply(_this5, _arguments3);
            }).finally(function () {
              _this5.setParametersPromises = [];
            });
          }
          return origCreateAnswer.apply(this, arguments);
        };
      }

    }, { "../utils": 15, "./getdisplaymedia": 12, "./getusermedia": 13 }], 12: [function (require, module, exports) {
      /*
       *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.shimGetDisplayMedia = shimGetDisplayMedia;
      function shimGetDisplayMedia(window, preferredMediaSource) {
        if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
          return;
        }
        if (!window.navigator.mediaDevices) {
          return;
        }
        window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
          if (!(constraints && constraints.video)) {
            var err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');
            err.name = 'NotFoundError';
            // from https://heycam.github.io/webidl/#idl-DOMException-error-names
            err.code = 8;
            return Promise.reject(err);
          }
          if (constraints.video === true) {
            constraints.video = { mediaSource: preferredMediaSource };
          } else {
            constraints.video.mediaSource = preferredMediaSource;
          }
          return window.navigator.mediaDevices.getUserMedia(constraints);
        };
      }

    }, {}], 13: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

      exports.shimGetUserMedia = shimGetUserMedia;

      var _utils = require('../utils');

      var utils = _interopRequireWildcard(_utils);

      function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

      function shimGetUserMedia(window) {
        var browserDetails = utils.detectBrowser(window);
        var navigator = window && window.navigator;
        var MediaStreamTrack = window && window.MediaStreamTrack;

        navigator.getUserMedia = function (constraints, onSuccess, onError) {
          // Replace Firefox 44+'s deprecation warning with unprefixed version.
          utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
          navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
        };

        if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
          var remap = function remap(obj, a, b) {
            if (a in obj && !(b in obj)) {
              obj[b] = obj[a];
              delete obj[a];
            }
          };

          var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
          navigator.mediaDevices.getUserMedia = function (c) {
            if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object' && _typeof(c.audio) === 'object') {
              c = JSON.parse(JSON.stringify(c));
              remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
              remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
            }
            return nativeGetUserMedia(c);
          };

          if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
            var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
            MediaStreamTrack.prototype.getSettings = function () {
              var obj = nativeGetSettings.apply(this, arguments);
              remap(obj, 'mozAutoGainControl', 'autoGainControl');
              remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
              return obj;
            };
          }

          if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
            var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
            MediaStreamTrack.prototype.applyConstraints = function (c) {
              if (this.kind === 'audio' && (typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {
                c = JSON.parse(JSON.stringify(c));
                remap(c, 'autoGainControl', 'mozAutoGainControl');
                remap(c, 'noiseSuppression', 'mozNoiseSuppression');
              }
              return nativeApplyConstraints.apply(this, [c]);
            };
          }
        }
      }

    }, { "../utils": 15 }], 14: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

      exports.shimLocalStreamsAPI = shimLocalStreamsAPI;
      exports.shimRemoteStreamsAPI = shimRemoteStreamsAPI;
      exports.shimCallbacksAPI = shimCallbacksAPI;
      exports.shimGetUserMedia = shimGetUserMedia;
      exports.shimConstraints = shimConstraints;
      exports.shimRTCIceServerUrls = shimRTCIceServerUrls;
      exports.shimTrackEventTransceiver = shimTrackEventTransceiver;
      exports.shimCreateOfferLegacy = shimCreateOfferLegacy;

      var _utils = require('../utils');

      var utils = _interopRequireWildcard(_utils);

      function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

      function shimLocalStreamsAPI(window) {
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
          return;
        }
        if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
          window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
            if (!this._localStreams) {
              this._localStreams = [];
            }
            return this._localStreams;
          };
        }
        if (!('addStream' in window.RTCPeerConnection.prototype)) {
          var _addTrack = window.RTCPeerConnection.prototype.addTrack;
          window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
            var _this = this;

            if (!this._localStreams) {
              this._localStreams = [];
            }
            if (!this._localStreams.includes(stream)) {
              this._localStreams.push(stream);
            }
            // Try to emulate Chrome's behaviour of adding in audio-video order.
            // Safari orders by track id.
            stream.getAudioTracks().forEach(function (track) {
              return _addTrack.call(_this, track, stream);
            });
            stream.getVideoTracks().forEach(function (track) {
              return _addTrack.call(_this, track, stream);
            });
          };

          window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
            var stream = arguments[1];
            if (stream) {
              if (!this._localStreams) {
                this._localStreams = [stream];
              } else if (!this._localStreams.includes(stream)) {
                this._localStreams.push(stream);
              }
            }
            return _addTrack.apply(this, arguments);
          };
        }
        if (!('removeStream' in window.RTCPeerConnection.prototype)) {
          window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
            var _this2 = this;

            if (!this._localStreams) {
              this._localStreams = [];
            }
            var index = this._localStreams.indexOf(stream);
            if (index === -1) {
              return;
            }
            this._localStreams.splice(index, 1);
            var tracks = stream.getTracks();
            this.getSenders().forEach(function (sender) {
              if (tracks.includes(sender.track)) {
                _this2.removeTrack(sender);
              }
            });
          };
        }
      }

      function shimRemoteStreamsAPI(window) {
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
          return;
        }
        if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
          window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
            return this._remoteStreams ? this._remoteStreams : [];
          };
        }
        if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
          Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
            get: function get() {
              return this._onaddstream;
            },
            set: function set(f) {
              var _this3 = this;

              if (this._onaddstream) {
                this.removeEventListener('addstream', this._onaddstream);
                this.removeEventListener('track', this._onaddstreampoly);
              }
              this.addEventListener('addstream', this._onaddstream = f);
              this.addEventListener('track', this._onaddstreampoly = function (e) {
                e.streams.forEach(function (stream) {
                  if (!_this3._remoteStreams) {
                    _this3._remoteStreams = [];
                  }
                  if (_this3._remoteStreams.includes(stream)) {
                    return;
                  }
                  _this3._remoteStreams.push(stream);
                  var event = new Event('addstream');
                  event.stream = stream;
                  _this3.dispatchEvent(event);
                });
              });
            }
          });
          var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
          window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
            var pc = this;
            if (!this._onaddstreampoly) {
              this.addEventListener('track', this._onaddstreampoly = function (e) {
                e.streams.forEach(function (stream) {
                  if (!pc._remoteStreams) {
                    pc._remoteStreams = [];
                  }
                  if (pc._remoteStreams.indexOf(stream) >= 0) {
                    return;
                  }
                  pc._remoteStreams.push(stream);
                  var event = new Event('addstream');
                  event.stream = stream;
                  pc.dispatchEvent(event);
                });
              });
            }
            return origSetRemoteDescription.apply(pc, arguments);
          };
        }
      }

      function shimCallbacksAPI(window) {
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
          return;
        }
        var prototype = window.RTCPeerConnection.prototype;
        var origCreateOffer = prototype.createOffer;
        var origCreateAnswer = prototype.createAnswer;
        var setLocalDescription = prototype.setLocalDescription;
        var setRemoteDescription = prototype.setRemoteDescription;
        var addIceCandidate = prototype.addIceCandidate;

        prototype.createOffer = function createOffer(successCallback, failureCallback) {
          var options = arguments.length >= 2 ? arguments[2] : arguments[0];
          var promise = origCreateOffer.apply(this, [options]);
          if (!failureCallback) {
            return promise;
          }
          promise.then(successCallback, failureCallback);
          return Promise.resolve();
        };

        prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
          var options = arguments.length >= 2 ? arguments[2] : arguments[0];
          var promise = origCreateAnswer.apply(this, [options]);
          if (!failureCallback) {
            return promise;
          }
          promise.then(successCallback, failureCallback);
          return Promise.resolve();
        };

        var withCallback = function withCallback(description, successCallback, failureCallback) {
          var promise = setLocalDescription.apply(this, [description]);
          if (!failureCallback) {
            return promise;
          }
          promise.then(successCallback, failureCallback);
          return Promise.resolve();
        };
        prototype.setLocalDescription = withCallback;

        withCallback = function withCallback(description, successCallback, failureCallback) {
          var promise = setRemoteDescription.apply(this, [description]);
          if (!failureCallback) {
            return promise;
          }
          promise.then(successCallback, failureCallback);
          return Promise.resolve();
        };
        prototype.setRemoteDescription = withCallback;

        withCallback = function withCallback(candidate, successCallback, failureCallback) {
          var promise = addIceCandidate.apply(this, [candidate]);
          if (!failureCallback) {
            return promise;
          }
          promise.then(successCallback, failureCallback);
          return Promise.resolve();
        };
        prototype.addIceCandidate = withCallback;
      }

      function shimGetUserMedia(window) {
        var navigator = window && window.navigator;

        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          // shim not needed in Safari 12.1
          var mediaDevices = navigator.mediaDevices;
          var _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
          navigator.mediaDevices.getUserMedia = function (constraints) {
            return _getUserMedia(shimConstraints(constraints));
          };
        }

        if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
          navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
            navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
          }.bind(navigator);
        }
      }

      function shimConstraints(constraints) {
        if (constraints && constraints.video !== undefined) {
          return Object.assign({}, constraints, { video: utils.compactObject(constraints.video) });
        }

        return constraints;
      }

      function shimRTCIceServerUrls(window) {
        // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
        var OrigPeerConnection = window.RTCPeerConnection;
        window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {
          if (pcConfig && pcConfig.iceServers) {
            var newIceServers = [];
            for (var i = 0; i < pcConfig.iceServers.length; i++) {
              var server = pcConfig.iceServers[i];
              if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
                utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
                server = JSON.parse(JSON.stringify(server));
                server.urls = server.url;
                delete server.url;
                newIceServers.push(server);
              } else {
                newIceServers.push(pcConfig.iceServers[i]);
              }
            }
            pcConfig.iceServers = newIceServers;
          }
          return new OrigPeerConnection(pcConfig, pcConstraints);
        };
        window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
        // wrap static methods. Currently just generateCertificate.
        if ('generateCertificate' in window.RTCPeerConnection) {
          Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
            get: function get() {
              return OrigPeerConnection.generateCertificate;
            }
          });
        }
      }

      function shimTrackEventTransceiver(window) {
        // Add event.transceiver member over deprecated event.receiver
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
          Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
            get: function get() {
              return { receiver: this.receiver };
            }
          });
        }
      }

      function shimCreateOfferLegacy(window) {
        var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
        window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
          if (offerOptions) {
            if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
              // support bit values
              offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
            }
            var audioTransceiver = this.getTransceivers().find(function (transceiver) {
              return transceiver.receiver.track.kind === 'audio';
            });
            if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
              if (audioTransceiver.direction === 'sendrecv') {
                if (audioTransceiver.setDirection) {
                  audioTransceiver.setDirection('sendonly');
                } else {
                  audioTransceiver.direction = 'sendonly';
                }
              } else if (audioTransceiver.direction === 'recvonly') {
                if (audioTransceiver.setDirection) {
                  audioTransceiver.setDirection('inactive');
                } else {
                  audioTransceiver.direction = 'inactive';
                }
              }
            } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
              this.addTransceiver('audio');
            }

            if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
              // support bit values
              offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
            }
            var videoTransceiver = this.getTransceivers().find(function (transceiver) {
              return transceiver.receiver.track.kind === 'video';
            });
            if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
              if (videoTransceiver.direction === 'sendrecv') {
                if (videoTransceiver.setDirection) {
                  videoTransceiver.setDirection('sendonly');
                } else {
                  videoTransceiver.direction = 'sendonly';
                }
              } else if (videoTransceiver.direction === 'recvonly') {
                if (videoTransceiver.setDirection) {
                  videoTransceiver.setDirection('inactive');
                } else {
                  videoTransceiver.direction = 'inactive';
                }
              }
            } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
              this.addTransceiver('video');
            }
          }
          return origCreateOffer.apply(this, arguments);
        };
      }

    }, { "../utils": 15 }], 15: [function (require, module, exports) {
      /*
       *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

      exports.extractVersion = extractVersion;
      exports.wrapPeerConnectionEvent = wrapPeerConnectionEvent;
      exports.disableLog = disableLog;
      exports.disableWarnings = disableWarnings;
      exports.log = log;
      exports.deprecated = deprecated;
      exports.detectBrowser = detectBrowser;
      exports.compactObject = compactObject;
      exports.walkStats = walkStats;
      exports.filterStats = filterStats;

      function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

      var logDisabled_ = true;
      var deprecationWarnings_ = true;

      /**
       * Extract browser version out of the provided user agent string.
       *
       * @param {!string} uastring userAgent string.
       * @param {!string} expr Regular expression used as match criteria.
       * @param {!number} pos position in the version string to be returned.
       * @return {!number} browser version.
       */
      function extractVersion(uastring, expr, pos) {
        var match = uastring.match(expr);
        return match && match.length >= pos && parseInt(match[pos], 10);
      }

      // Wraps the peerconnection event eventNameToWrap in a function
      // which returns the modified event object (or false to prevent
      // the event).
      function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
        if (!window.RTCPeerConnection) {
          return;
        }
        var proto = window.RTCPeerConnection.prototype;
        var nativeAddEventListener = proto.addEventListener;
        proto.addEventListener = function (nativeEventName, cb) {
          if (nativeEventName !== eventNameToWrap) {
            return nativeAddEventListener.apply(this, arguments);
          }
          var wrappedCallback = function wrappedCallback(e) {
            var modifiedEvent = wrapper(e);
            if (modifiedEvent) {
              cb(modifiedEvent);
            }
          };
          this._eventMap = this._eventMap || {};
          this._eventMap[cb] = wrappedCallback;
          return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
        };

        var nativeRemoveEventListener = proto.removeEventListener;
        proto.removeEventListener = function (nativeEventName, cb) {
          if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {
            return nativeRemoveEventListener.apply(this, arguments);
          }
          var unwrappedCb = this._eventMap[cb];
          delete this._eventMap[cb];
          return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
        };

        Object.defineProperty(proto, 'on' + eventNameToWrap, {
          get: function get() {
            return this['_on' + eventNameToWrap];
          },
          set: function set(cb) {
            if (this['_on' + eventNameToWrap]) {
              this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
              delete this['_on' + eventNameToWrap];
            }
            if (cb) {
              this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);
            }
          },

          enumerable: true,
          configurable: true
        });
      }

      function disableLog(bool) {
        if (typeof bool !== 'boolean') {
          return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
        }
        logDisabled_ = bool;
        return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
      }

      /**
       * Disable or enable deprecation warnings
       * @param {!boolean} bool set to true to disable warnings.
       */
      function disableWarnings(bool) {
        if (typeof bool !== 'boolean') {
          return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
        }
        deprecationWarnings_ = !bool;
        return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
      }

      function log() {
        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {
          if (logDisabled_) {
            return;
          }
          if (typeof console !== 'undefined' && typeof console.log === 'function') {
            console.log.apply(console, arguments);
          }
        }
      }

      /**
       * Shows a deprecation warning suggesting the modern and spec-compatible API.
       */
      function deprecated(oldMethod, newMethod) {
        if (!deprecationWarnings_) {
          return;
        }
        console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
      }

      /**
       * Browser detector.
       *
       * @return {object} result containing browser and version
       *     properties.
       */
      function detectBrowser(window) {
        var navigator = window.navigator;

        // Returned result object.

        var result = { browser: null, version: null };

        // Fail early if it's not a browser
        if (typeof window === 'undefined' || !window.navigator) {
          result.browser = 'Not a browser.';
          return result;
        }

        if (navigator.mozGetUserMedia) {
          // Firefox.
          result.browser = 'firefox';
          result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
        } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {
          // Chrome, Chromium, Webview, Opera.
          // Version matches Chrome/WebRTC version.
          // Chrome 74 removed webkitGetUserMedia on http as well so we need the
          // more complicated fallback to webkitRTCPeerConnection.
          result.browser = 'chrome';
          result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
        } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
          // Edge.
          result.browser = 'edge';
          result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
        } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
          // Safari.
          result.browser = 'safari';
          result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
          result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;
        } else {
          // Default fallthrough: not supported.
          result.browser = 'Not a supported browser.';
          return result;
        }

        return result;
      }

      /**
       * Checks if something is an object.
       *
       * @param {*} val The something you want to check.
       * @return true if val is an object, false otherwise.
       */
      function isObject(val) {
        return Object.prototype.toString.call(val) === '[object Object]';
      }

      /**
       * Remove all empty objects and undefined values
       * from a nested object -- an enhanced and vanilla version
       * of Lodash's `compact`.
       */
      function compactObject(data) {
        if (!isObject(data)) {
          return data;
        }

        return Object.keys(data).reduce(function (accumulator, key) {
          var isObj = isObject(data[key]);
          var value = isObj ? compactObject(data[key]) : data[key];
          var isEmptyObject = isObj && !Object.keys(value).length;
          if (value === undefined || isEmptyObject) {
            return accumulator;
          }
          return Object.assign(accumulator, _defineProperty({}, key, value));
        }, {});
      }

      /* iterates the stats graph recursively. */
      function walkStats(stats, base, resultSet) {
        if (!base || resultSet.has(base.id)) {
          return;
        }
        resultSet.set(base.id, base);
        Object.keys(base).forEach(function (name) {
          if (name.endsWith('Id')) {
            walkStats(stats, stats.get(base[name]), resultSet);
          } else if (name.endsWith('Ids')) {
            base[name].forEach(function (id) {
              walkStats(stats, stats.get(id), resultSet);
            });
          }
        });
      }

      /* filter getStats for a sender/receiver track. */
      function filterStats(result, track, outbound) {
        var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
        var filteredResult = new Map();
        if (track === null) {
          return filteredResult;
        }
        var trackStats = [];
        result.forEach(function (value) {
          if (value.type === 'track' && value.trackIdentifier === track.id) {
            trackStats.push(value);
          }
        });
        trackStats.forEach(function (trackStat) {
          result.forEach(function (stats) {
            if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
              walkStats(result, stats, filteredResult);
            }
          });
        });
        return filteredResult;
      }

    }, {}], 16: [function (require, module, exports) {
      /*
       *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
       *
       *  Use of this source code is governed by a BSD-style license
       *  that can be found in the LICENSE file in the root of the source
       *  tree.
       */
      /* eslint-env node */
      'use strict';

      var SDPUtils = require('sdp');

      function fixStatsType(stat) {
        return {
          inboundrtp: 'inbound-rtp',
          outboundrtp: 'outbound-rtp',
          candidatepair: 'candidate-pair',
          localcandidate: 'local-candidate',
          remotecandidate: 'remote-candidate'
        }[stat.type] || stat.type;
      }

      function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
        var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

        // Map ICE parameters (ufrag, pwd) to SDP.
        sdp += SDPUtils.writeIceParameters(
          transceiver.iceGatherer.getLocalParameters());

        // Map DTLS parameters to SDP.
        sdp += SDPUtils.writeDtlsParameters(
          transceiver.dtlsTransport.getLocalParameters(),
          type === 'offer' ? 'actpass' : dtlsRole || 'active');

        sdp += 'a=mid:' + transceiver.mid + '\r\n';

        if (transceiver.rtpSender && transceiver.rtpReceiver) {
          sdp += 'a=sendrecv\r\n';
        } else if (transceiver.rtpSender) {
          sdp += 'a=sendonly\r\n';
        } else if (transceiver.rtpReceiver) {
          sdp += 'a=recvonly\r\n';
        } else {
          sdp += 'a=inactive\r\n';
        }

        if (transceiver.rtpSender) {
          var trackId = transceiver.rtpSender._initialTrackId ||
            transceiver.rtpSender.track.id;
          transceiver.rtpSender._initialTrackId = trackId;
          // spec.
          var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +
            trackId + '\r\n';
          sdp += 'a=' + msid;
          // for Chrome. Legacy should no longer be required.
          sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
            ' ' + msid;

          // RTX
          if (transceiver.sendEncodingParameters[0].rtx) {
            sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
              ' ' + msid;
            sdp += 'a=ssrc-group:FID ' +
              transceiver.sendEncodingParameters[0].ssrc + ' ' +
              transceiver.sendEncodingParameters[0].rtx.ssrc +
              '\r\n';
          }
        }
        // FIXME: this should be written by writeRtpDescription.
        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
          ' cname:' + SDPUtils.localCName + '\r\n';
        if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
          sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
            ' cname:' + SDPUtils.localCName + '\r\n';
        }
        return sdp;
      }

      // Edge does not like
      // 1) stun: filtered after 14393 unless ?transport=udp is present
      // 2) turn: that does not have all of turn:host:port?transport=udp
      // 3) turn: with ipv6 addresses
      // 4) turn: occurring muliple times
      function filterIceServers(iceServers, edgeVersion) {
        var hasTurn = false;
        iceServers = JSON.parse(JSON.stringify(iceServers));
        return iceServers.filter(function (server) {
          if (server && (server.urls || server.url)) {
            var urls = server.urls || server.url;
            if (server.url && !server.urls) {
              console.warn('RTCIceServer.url is deprecated! Use urls instead.');
            }
            var isString = typeof urls === 'string';
            if (isString) {
              urls = [urls];
            }
            urls = urls.filter(function (url) {
              var validTurn = url.indexOf('turn:') === 0 &&
                url.indexOf('transport=udp') !== -1 &&
                url.indexOf('turn:[') === -1 &&
                !hasTurn;

              if (validTurn) {
                hasTurn = true;
                return true;
              }
              return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
                url.indexOf('?transport=udp') === -1;
            });

            delete server.url;
            server.urls = isString ? urls[0] : urls;
            return !!urls.length;
          }
        });
      }

      // Determines the intersection of local and remote capabilities.
      function getCommonCapabilities(localCapabilities, remoteCapabilities) {
        var commonCapabilities = {
          codecs: [],
          headerExtensions: [],
          fecMechanisms: []
        };

        var findCodecByPayloadType = function (pt, codecs) {
          pt = parseInt(pt, 10);
          for (var i = 0; i < codecs.length; i++) {
            if (codecs[i].payloadType === pt ||
              codecs[i].preferredPayloadType === pt) {
              return codecs[i];
            }
          }
        };

        var rtxCapabilityMatches = function (lRtx, rRtx, lCodecs, rCodecs) {
          var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
          var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
          return lCodec && rCodec &&
            lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
        };

        localCapabilities.codecs.forEach(function (lCodec) {
          for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
            var rCodec = remoteCapabilities.codecs[i];
            if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
              lCodec.clockRate === rCodec.clockRate) {
              if (lCodec.name.toLowerCase() === 'rtx' &&
                lCodec.parameters && rCodec.parameters.apt) {
                // for RTX we need to find the local rtx that has a apt
                // which points to the same local codec as the remote one.
                if (!rtxCapabilityMatches(lCodec, rCodec,
                  localCapabilities.codecs, remoteCapabilities.codecs)) {
                  continue;
                }
              }
              rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
              // number of channels is the highest common number of channels
              rCodec.numChannels = Math.min(lCodec.numChannels,
                rCodec.numChannels);
              // push rCodec so we reply with offerer payload type
              commonCapabilities.codecs.push(rCodec);

              // determine common feedback mechanisms
              rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function (fb) {
                for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
                  if (lCodec.rtcpFeedback[j].type === fb.type &&
                    lCodec.rtcpFeedback[j].parameter === fb.parameter) {
                    return true;
                  }
                }
                return false;
              });
              // FIXME: also need to determine .parameters
              //  see https://github.com/openpeer/ortc/issues/569
              break;
            }
          }
        });

        localCapabilities.headerExtensions.forEach(function (lHeaderExtension) {
          for (var i = 0; i < remoteCapabilities.headerExtensions.length;
            i++) {
            var rHeaderExtension = remoteCapabilities.headerExtensions[i];
            if (lHeaderExtension.uri === rHeaderExtension.uri) {
              commonCapabilities.headerExtensions.push(rHeaderExtension);
              break;
            }
          }
        });

        // FIXME: fecMechanisms
        return commonCapabilities;
      }

      // is action=setLocalDescription with type allowed in signalingState
      function isActionAllowedInSignalingState(action, type, signalingState) {
        return {
          offer: {
            setLocalDescription: ['stable', 'have-local-offer'],
            setRemoteDescription: ['stable', 'have-remote-offer']
          },
          answer: {
            setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
            setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
          }
        }[type][action].indexOf(signalingState) !== -1;
      }

      function maybeAddCandidate(iceTransport, candidate) {
        // Edge's internal representation adds some fields therefore
        // not all fieldѕ are taken into account.
        var alreadyAdded = iceTransport.getRemoteCandidates()
          .find(function (remoteCandidate) {
            return candidate.foundation === remoteCandidate.foundation &&
              candidate.ip === remoteCandidate.ip &&
              candidate.port === remoteCandidate.port &&
              candidate.priority === remoteCandidate.priority &&
              candidate.protocol === remoteCandidate.protocol &&
              candidate.type === remoteCandidate.type;
          });
        if (!alreadyAdded) {
          iceTransport.addRemoteCandidate(candidate);
        }
        return !alreadyAdded;
      }


      function makeError(name, description) {
        var e = new Error(description);
        e.name = name;
        // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
        e.code = {
          NotSupportedError: 9,
          InvalidStateError: 11,
          InvalidAccessError: 15,
          TypeError: undefined,
          OperationError: undefined
        }[name];
        return e;
      }

      module.exports = function (window, edgeVersion) {
        // https://w3c.github.io/mediacapture-main/#mediastream
        // Helper function to add the track to the stream and
        // dispatch the event ourselves.
        function addTrackToStreamAndFireEvent(track, stream) {
          stream.addTrack(track);
          stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',
            { track: track }));
        }

        function removeTrackFromStreamAndFireEvent(track, stream) {
          stream.removeTrack(track);
          stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',
            { track: track }));
        }

        function fireAddTrack(pc, track, receiver, streams) {
          var trackEvent = new Event('track');
          trackEvent.track = track;
          trackEvent.receiver = receiver;
          trackEvent.transceiver = { receiver: receiver };
          trackEvent.streams = streams;
          window.setTimeout(function () {
            pc._dispatchEvent('track', trackEvent);
          });
        }

        var RTCPeerConnection = function (config) {
          var pc = this;

          var _eventTarget = document.createDocumentFragment();
          ['addEventListener', 'removeEventListener', 'dispatchEvent']
            .forEach(function (method) {
              pc[method] = _eventTarget[method].bind(_eventTarget);
            });

          this.canTrickleIceCandidates = null;

          this.needNegotiation = false;

          this.localStreams = [];
          this.remoteStreams = [];

          this._localDescription = null;
          this._remoteDescription = null;

          this.signalingState = 'stable';
          this.iceConnectionState = 'new';
          this.connectionState = 'new';
          this.iceGatheringState = 'new';

          config = JSON.parse(JSON.stringify(config || {}));

          this.usingBundle = config.bundlePolicy === 'max-bundle';
          if (config.rtcpMuxPolicy === 'negotiate') {
            throw (makeError('NotSupportedError',
              'rtcpMuxPolicy \'negotiate\' is not supported'));
          } else if (!config.rtcpMuxPolicy) {
            config.rtcpMuxPolicy = 'require';
          }

          switch (config.iceTransportPolicy) {
            case 'all':
            case 'relay':
              break;
            default:
              config.iceTransportPolicy = 'all';
              break;
          }

          switch (config.bundlePolicy) {
            case 'balanced':
            case 'max-compat':
            case 'max-bundle':
              break;
            default:
              config.bundlePolicy = 'balanced';
              break;
          }

          config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

          this._iceGatherers = [];
          if (config.iceCandidatePoolSize) {
            for (var i = config.iceCandidatePoolSize; i > 0; i--) {
              this._iceGatherers.push(new window.RTCIceGatherer({
                iceServers: config.iceServers,
                gatherPolicy: config.iceTransportPolicy
              }));
            }
          } else {
            config.iceCandidatePoolSize = 0;
          }

          this._config = config;

          // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
          // everything that is needed to describe a SDP m-line.
          this.transceivers = [];

          this._sdpSessionId = SDPUtils.generateSessionId();
          this._sdpSessionVersion = 0;

          this._dtlsRole = undefined; // role for a=setup to use in answers.

          this._isClosed = false;
        };

        Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
          configurable: true,
          get: function () {
            return this._localDescription;
          }
        });
        Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
          configurable: true,
          get: function () {
            return this._remoteDescription;
          }
        });

        // set up event handlers on prototype
        RTCPeerConnection.prototype.onicecandidate = null;
        RTCPeerConnection.prototype.onaddstream = null;
        RTCPeerConnection.prototype.ontrack = null;
        RTCPeerConnection.prototype.onremovestream = null;
        RTCPeerConnection.prototype.onsignalingstatechange = null;
        RTCPeerConnection.prototype.oniceconnectionstatechange = null;
        RTCPeerConnection.prototype.onconnectionstatechange = null;
        RTCPeerConnection.prototype.onicegatheringstatechange = null;
        RTCPeerConnection.prototype.onnegotiationneeded = null;
        RTCPeerConnection.prototype.ondatachannel = null;

        RTCPeerConnection.prototype._dispatchEvent = function (name, event) {
          if (this._isClosed) {
            return;
          }
          this.dispatchEvent(event);
          if (typeof this['on' + name] === 'function') {
            this['on' + name](event);
          }
        };

        RTCPeerConnection.prototype._emitGatheringStateChange = function () {
          var event = new Event('icegatheringstatechange');
          this._dispatchEvent('icegatheringstatechange', event);
        };

        RTCPeerConnection.prototype.getConfiguration = function () {
          return this._config;
        };

        RTCPeerConnection.prototype.getLocalStreams = function () {
          return this.localStreams;
        };

        RTCPeerConnection.prototype.getRemoteStreams = function () {
          return this.remoteStreams;
        };

        // internal helper to create a transceiver object.
        // (which is not yet the same as the WebRTC 1.0 transceiver)
        RTCPeerConnection.prototype._createTransceiver = function (kind, doNotAdd) {
          var hasBundleTransport = this.transceivers.length > 0;
          var transceiver = {
            track: null,
            iceGatherer: null,
            iceTransport: null,
            dtlsTransport: null,
            localCapabilities: null,
            remoteCapabilities: null,
            rtpSender: null,
            rtpReceiver: null,
            kind: kind,
            mid: null,
            sendEncodingParameters: null,
            recvEncodingParameters: null,
            stream: null,
            associatedRemoteMediaStreams: [],
            wantReceive: true
          };
          if (this.usingBundle && hasBundleTransport) {
            transceiver.iceTransport = this.transceivers[0].iceTransport;
            transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
          } else {
            var transports = this._createIceAndDtlsTransports();
            transceiver.iceTransport = transports.iceTransport;
            transceiver.dtlsTransport = transports.dtlsTransport;
          }
          if (!doNotAdd) {
            this.transceivers.push(transceiver);
          }
          return transceiver;
        };

        RTCPeerConnection.prototype.addTrack = function (track, stream) {
          if (this._isClosed) {
            throw makeError('InvalidStateError',
              'Attempted to call addTrack on a closed peerconnection.');
          }

          var alreadyExists = this.transceivers.find(function (s) {
            return s.track === track;
          });

          if (alreadyExists) {
            throw makeError('InvalidAccessError', 'Track already exists.');
          }

          var transceiver;
          for (var i = 0; i < this.transceivers.length; i++) {
            if (!this.transceivers[i].track &&
              this.transceivers[i].kind === track.kind) {
              transceiver = this.transceivers[i];
            }
          }
          if (!transceiver) {
            transceiver = this._createTransceiver(track.kind);
          }

          this._maybeFireNegotiationNeeded();

          if (this.localStreams.indexOf(stream) === -1) {
            this.localStreams.push(stream);
          }

          transceiver.track = track;
          transceiver.stream = stream;
          transceiver.rtpSender = new window.RTCRtpSender(track,
            transceiver.dtlsTransport);
          return transceiver.rtpSender;
        };

        RTCPeerConnection.prototype.addStream = function (stream) {
          var pc = this;
          if (edgeVersion >= 15025) {
            stream.getTracks().forEach(function (track) {
              pc.addTrack(track, stream);
            });
          } else {
            // Clone is necessary for local demos mostly, attaching directly
            // to two different senders does not work (build 10547).
            // Fixed in 15025 (or earlier)
            var clonedStream = stream.clone();
            stream.getTracks().forEach(function (track, idx) {
              var clonedTrack = clonedStream.getTracks()[idx];
              track.addEventListener('enabled', function (event) {
                clonedTrack.enabled = event.enabled;
              });
            });
            clonedStream.getTracks().forEach(function (track) {
              pc.addTrack(track, clonedStream);
            });
          }
        };

        RTCPeerConnection.prototype.removeTrack = function (sender) {
          if (this._isClosed) {
            throw makeError('InvalidStateError',
              'Attempted to call removeTrack on a closed peerconnection.');
          }

          if (!(sender instanceof window.RTCRtpSender)) {
            throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
              'does not implement interface RTCRtpSender.');
          }

          var transceiver = this.transceivers.find(function (t) {
            return t.rtpSender === sender;
          });

          if (!transceiver) {
            throw makeError('InvalidAccessError',
              'Sender was not created by this connection.');
          }
          var stream = transceiver.stream;

          transceiver.rtpSender.stop();
          transceiver.rtpSender = null;
          transceiver.track = null;
          transceiver.stream = null;

          // remove the stream from the set of local streams
          var localStreams = this.transceivers.map(function (t) {
            return t.stream;
          });
          if (localStreams.indexOf(stream) === -1 &&
            this.localStreams.indexOf(stream) > -1) {
            this.localStreams.splice(this.localStreams.indexOf(stream), 1);
          }

          this._maybeFireNegotiationNeeded();
        };

        RTCPeerConnection.prototype.removeStream = function (stream) {
          var pc = this;
          stream.getTracks().forEach(function (track) {
            var sender = pc.getSenders().find(function (s) {
              return s.track === track;
            });
            if (sender) {
              pc.removeTrack(sender);
            }
          });
        };

        RTCPeerConnection.prototype.getSenders = function () {
          return this.transceivers.filter(function (transceiver) {
            return !!transceiver.rtpSender;
          })
            .map(function (transceiver) {
              return transceiver.rtpSender;
            });
        };

        RTCPeerConnection.prototype.getReceivers = function () {
          return this.transceivers.filter(function (transceiver) {
            return !!transceiver.rtpReceiver;
          })
            .map(function (transceiver) {
              return transceiver.rtpReceiver;
            });
        };


        RTCPeerConnection.prototype._createIceGatherer = function (sdpMLineIndex,
          usingBundle) {
          var pc = this;
          if (usingBundle && sdpMLineIndex > 0) {
            return this.transceivers[0].iceGatherer;
          } else if (this._iceGatherers.length) {
            return this._iceGatherers.shift();
          }
          var iceGatherer = new window.RTCIceGatherer({
            iceServers: this._config.iceServers,
            gatherPolicy: this._config.iceTransportPolicy
          });
          Object.defineProperty(iceGatherer, 'state',
            { value: 'new', writable: true }
          );

          this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
          this.transceivers[sdpMLineIndex].bufferCandidates = function (event) {
            var end = !event.candidate || Object.keys(event.candidate).length === 0;
            // polyfill since RTCIceGatherer.state is not implemented in
            // Edge 10547 yet.
            iceGatherer.state = end ? 'completed' : 'gathering';
            if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
              pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
            }
          };
          iceGatherer.addEventListener('localcandidate',
            this.transceivers[sdpMLineIndex].bufferCandidates);
          return iceGatherer;
        };

        // start gathering from an RTCIceGatherer.
        RTCPeerConnection.prototype._gather = function (mid, sdpMLineIndex) {
          var pc = this;
          var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
          if (iceGatherer.onlocalcandidate) {
            return;
          }
          var bufferedCandidateEvents =
            this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
          this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
          iceGatherer.removeEventListener('localcandidate',
            this.transceivers[sdpMLineIndex].bufferCandidates);
          iceGatherer.onlocalcandidate = function (evt) {
            if (pc.usingBundle && sdpMLineIndex > 0) {
              // if we know that we use bundle we can drop candidates with
              // ѕdpMLineIndex > 0. If we don't do this then our state gets
              // confused since we dispose the extra ice gatherer.
              return;
            }
            var event = new Event('icecandidate');
            event.candidate = { sdpMid: mid, sdpMLineIndex: sdpMLineIndex };

            var cand = evt.candidate;
            // Edge emits an empty object for RTCIceCandidateComplete‥
            var end = !cand || Object.keys(cand).length === 0;
            if (end) {
              // polyfill since RTCIceGatherer.state is not implemented in
              // Edge 10547 yet.
              if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
                iceGatherer.state = 'completed';
              }
            } else {
              if (iceGatherer.state === 'new') {
                iceGatherer.state = 'gathering';
              }
              // RTCIceCandidate doesn't have a component, needs to be added
              cand.component = 1;
              // also the usernameFragment. TODO: update SDP to take both variants.
              cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

              var serializedCandidate = SDPUtils.writeCandidate(cand);
              event.candidate = Object.assign(event.candidate,
                SDPUtils.parseCandidate(serializedCandidate));

              event.candidate.candidate = serializedCandidate;
              event.candidate.toJSON = function () {
                return {
                  candidate: event.candidate.candidate,
                  sdpMid: event.candidate.sdpMid,
                  sdpMLineIndex: event.candidate.sdpMLineIndex,
                  usernameFragment: event.candidate.usernameFragment
                };
              };
            }

            // update local description.
            var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);
            if (!end) {
              sections[event.candidate.sdpMLineIndex] +=
                'a=' + event.candidate.candidate + '\r\n';
            } else {
              sections[event.candidate.sdpMLineIndex] +=
                'a=end-of-candidates\r\n';
            }
            pc._localDescription.sdp =
              SDPUtils.getDescription(pc._localDescription.sdp) +
              sections.join('');
            var complete = pc.transceivers.every(function (transceiver) {
              return transceiver.iceGatherer &&
                transceiver.iceGatherer.state === 'completed';
            });

            if (pc.iceGatheringState !== 'gathering') {
              pc.iceGatheringState = 'gathering';
              pc._emitGatheringStateChange();
            }

            // Emit candidate. Also emit null candidate when all gatherers are
            // complete.
            if (!end) {
              pc._dispatchEvent('icecandidate', event);
            }
            if (complete) {
              pc._dispatchEvent('icecandidate', new Event('icecandidate'));
              pc.iceGatheringState = 'complete';
              pc._emitGatheringStateChange();
            }
          };

          // emit already gathered candidates.
          window.setTimeout(function () {
            bufferedCandidateEvents.forEach(function (e) {
              iceGatherer.onlocalcandidate(e);
            });
          }, 0);
        };

        // Create ICE transport and DTLS transport.
        RTCPeerConnection.prototype._createIceAndDtlsTransports = function () {
          var pc = this;
          var iceTransport = new window.RTCIceTransport(null);
          iceTransport.onicestatechange = function () {
            pc._updateIceConnectionState();
            pc._updateConnectionState();
          };

          var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
          dtlsTransport.ondtlsstatechange = function () {
            pc._updateConnectionState();
          };
          dtlsTransport.onerror = function () {
            // onerror does not set state to failed by itself.
            Object.defineProperty(dtlsTransport, 'state',
              { value: 'failed', writable: true });
            pc._updateConnectionState();
          };

          return {
            iceTransport: iceTransport,
            dtlsTransport: dtlsTransport
          };
        };

        // Destroy ICE gatherer, ICE transport and DTLS transport.
        // Without triggering the callbacks.
        RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function (
          sdpMLineIndex) {
          var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
          if (iceGatherer) {
            delete iceGatherer.onlocalcandidate;
            delete this.transceivers[sdpMLineIndex].iceGatherer;
          }
          var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
          if (iceTransport) {
            delete iceTransport.onicestatechange;
            delete this.transceivers[sdpMLineIndex].iceTransport;
          }
          var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
          if (dtlsTransport) {
            delete dtlsTransport.ondtlsstatechange;
            delete dtlsTransport.onerror;
            delete this.transceivers[sdpMLineIndex].dtlsTransport;
          }
        };

        // Start the RTP Sender and Receiver for a transceiver.
        RTCPeerConnection.prototype._transceive = function (transceiver,
          send, recv) {
          var params = getCommonCapabilities(transceiver.localCapabilities,
            transceiver.remoteCapabilities);
          if (send && transceiver.rtpSender) {
            params.encodings = transceiver.sendEncodingParameters;
            params.rtcp = {
              cname: SDPUtils.localCName,
              compound: transceiver.rtcpParameters.compound
            };
            if (transceiver.recvEncodingParameters.length) {
              params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
            }
            transceiver.rtpSender.send(params);
          }
          if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
            // remove RTX field in Edge 14942
            if (transceiver.kind === 'video'
              && transceiver.recvEncodingParameters
              && edgeVersion < 15019) {
              transceiver.recvEncodingParameters.forEach(function (p) {
                delete p.rtx;
              });
            }
            if (transceiver.recvEncodingParameters.length) {
              params.encodings = transceiver.recvEncodingParameters;
            } else {
              params.encodings = [{}];
            }
            params.rtcp = {
              compound: transceiver.rtcpParameters.compound
            };
            if (transceiver.rtcpParameters.cname) {
              params.rtcp.cname = transceiver.rtcpParameters.cname;
            }
            if (transceiver.sendEncodingParameters.length) {
              params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
            }
            transceiver.rtpReceiver.receive(params);
          }
        };

        RTCPeerConnection.prototype.setLocalDescription = function (description) {
          var pc = this;

          // Note: pranswer is not supported.
          if (['offer', 'answer'].indexOf(description.type) === -1) {
            return Promise.reject(makeError('TypeError',
              'Unsupported type "' + description.type + '"'));
          }

          if (!isActionAllowedInSignalingState('setLocalDescription',
            description.type, pc.signalingState) || pc._isClosed) {
            return Promise.reject(makeError('InvalidStateError',
              'Can not set local ' + description.type +
              ' in state ' + pc.signalingState));
          }

          var sections;
          var sessionpart;
          if (description.type === 'offer') {
            // VERY limited support for SDP munging. Limited to:
            // * changing the order of codecs
            sections = SDPUtils.splitSections(description.sdp);
            sessionpart = sections.shift();
            sections.forEach(function (mediaSection, sdpMLineIndex) {
              var caps = SDPUtils.parseRtpParameters(mediaSection);
              pc.transceivers[sdpMLineIndex].localCapabilities = caps;
            });

            pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
              pc._gather(transceiver.mid, sdpMLineIndex);
            });
          } else if (description.type === 'answer') {
            sections = SDPUtils.splitSections(pc._remoteDescription.sdp);
            sessionpart = sections.shift();
            var isIceLite = SDPUtils.matchPrefix(sessionpart,
              'a=ice-lite').length > 0;
            sections.forEach(function (mediaSection, sdpMLineIndex) {
              var transceiver = pc.transceivers[sdpMLineIndex];
              var iceGatherer = transceiver.iceGatherer;
              var iceTransport = transceiver.iceTransport;
              var dtlsTransport = transceiver.dtlsTransport;
              var localCapabilities = transceiver.localCapabilities;
              var remoteCapabilities = transceiver.remoteCapabilities;

              // treat bundle-only as not-rejected.
              var rejected = SDPUtils.isRejected(mediaSection) &&
                SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

              if (!rejected && !transceiver.rejected) {
                var remoteIceParameters = SDPUtils.getIceParameters(
                  mediaSection, sessionpart);
                var remoteDtlsParameters = SDPUtils.getDtlsParameters(
                  mediaSection, sessionpart);
                if (isIceLite) {
                  remoteDtlsParameters.role = 'server';
                }

                if (!pc.usingBundle || sdpMLineIndex === 0) {
                  pc._gather(transceiver.mid, sdpMLineIndex);
                  if (iceTransport.state === 'new') {
                    iceTransport.start(iceGatherer, remoteIceParameters,
                      isIceLite ? 'controlling' : 'controlled');
                  }
                  if (dtlsTransport.state === 'new') {
                    dtlsTransport.start(remoteDtlsParameters);
                  }
                }

                // Calculate intersection of capabilities.
                var params = getCommonCapabilities(localCapabilities,
                  remoteCapabilities);

                // Start the RTCRtpSender. The RTCRtpReceiver for this
                // transceiver has already been started in setRemoteDescription.
                pc._transceive(transceiver,
                  params.codecs.length > 0,
                  false);
              }
            });
          }

          pc._localDescription = {
            type: description.type,
            sdp: description.sdp
          };
          if (description.type === 'offer') {
            pc._updateSignalingState('have-local-offer');
          } else {
            pc._updateSignalingState('stable');
          }

          return Promise.resolve();
        };

        RTCPeerConnection.prototype.setRemoteDescription = function (description) {
          var pc = this;

          // Note: pranswer is not supported.
          if (['offer', 'answer'].indexOf(description.type) === -1) {
            return Promise.reject(makeError('TypeError',
              'Unsupported type "' + description.type + '"'));
          }

          if (!isActionAllowedInSignalingState('setRemoteDescription',
            description.type, pc.signalingState) || pc._isClosed) {
            return Promise.reject(makeError('InvalidStateError',
              'Can not set remote ' + description.type +
              ' in state ' + pc.signalingState));
          }

          var streams = {};
          pc.remoteStreams.forEach(function (stream) {
            streams[stream.id] = stream;
          });
          var receiverList = [];
          var sections = SDPUtils.splitSections(description.sdp);
          var sessionpart = sections.shift();
          var isIceLite = SDPUtils.matchPrefix(sessionpart,
            'a=ice-lite').length > 0;
          var usingBundle = SDPUtils.matchPrefix(sessionpart,
            'a=group:BUNDLE ').length > 0;
          pc.usingBundle = usingBundle;
          var iceOptions = SDPUtils.matchPrefix(sessionpart,
            'a=ice-options:')[0];
          if (iceOptions) {
            pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
              .indexOf('trickle') >= 0;
          } else {
            pc.canTrickleIceCandidates = false;
          }

          sections.forEach(function (mediaSection, sdpMLineIndex) {
            var lines = SDPUtils.splitLines(mediaSection);
            var kind = SDPUtils.getKind(mediaSection);
            // treat bundle-only as not-rejected.
            var rejected = SDPUtils.isRejected(mediaSection) &&
              SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
            var protocol = lines[0].substr(2).split(' ')[2];

            var direction = SDPUtils.getDirection(mediaSection, sessionpart);
            var remoteMsid = SDPUtils.parseMsid(mediaSection);

            var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

            // Reject datachannels which are not implemented yet.
            if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||
              protocol === 'UDP/DTLS/SCTP'))) {
              // TODO: this is dangerous in the case where a non-rejected m-line
              //     becomes rejected.
              pc.transceivers[sdpMLineIndex] = {
                mid: mid,
                kind: kind,
                protocol: protocol,
                rejected: true
              };
              return;
            }

            if (!rejected && pc.transceivers[sdpMLineIndex] &&
              pc.transceivers[sdpMLineIndex].rejected) {
              // recycle a rejected transceiver.
              pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
            }

            var transceiver;
            var iceGatherer;
            var iceTransport;
            var dtlsTransport;
            var rtpReceiver;
            var sendEncodingParameters;
            var recvEncodingParameters;
            var localCapabilities;

            var track;
            // FIXME: ensure the mediaSection has rtcp-mux set.
            var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
            var remoteIceParameters;
            var remoteDtlsParameters;
            if (!rejected) {
              remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
                sessionpart);
              remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
                sessionpart);
              remoteDtlsParameters.role = 'client';
            }
            recvEncodingParameters =
              SDPUtils.parseRtpEncodingParameters(mediaSection);

            var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

            var isComplete = SDPUtils.matchPrefix(mediaSection,
              'a=end-of-candidates', sessionpart).length > 0;
            var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
              .map(function (cand) {
                return SDPUtils.parseCandidate(cand);
              })
              .filter(function (cand) {
                return cand.component === 1;
              });

            // Check if we can use BUNDLE and dispose transports.
            if ((description.type === 'offer' || description.type === 'answer') &&
              !rejected && usingBundle && sdpMLineIndex > 0 &&
              pc.transceivers[sdpMLineIndex]) {
              pc._disposeIceAndDtlsTransports(sdpMLineIndex);
              pc.transceivers[sdpMLineIndex].iceGatherer =
                pc.transceivers[0].iceGatherer;
              pc.transceivers[sdpMLineIndex].iceTransport =
                pc.transceivers[0].iceTransport;
              pc.transceivers[sdpMLineIndex].dtlsTransport =
                pc.transceivers[0].dtlsTransport;
              if (pc.transceivers[sdpMLineIndex].rtpSender) {
                pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
                  pc.transceivers[0].dtlsTransport);
              }
              if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
                pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
                  pc.transceivers[0].dtlsTransport);
              }
            }
            if (description.type === 'offer' && !rejected) {
              transceiver = pc.transceivers[sdpMLineIndex] ||
                pc._createTransceiver(kind);
              transceiver.mid = mid;

              if (!transceiver.iceGatherer) {
                transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
                  usingBundle);
              }

              if (cands.length && transceiver.iceTransport.state === 'new') {
                if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
                  transceiver.iceTransport.setRemoteCandidates(cands);
                } else {
                  cands.forEach(function (candidate) {
                    maybeAddCandidate(transceiver.iceTransport, candidate);
                  });
                }
              }

              localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

              // filter RTX until additional stuff needed for RTX is implemented
              // in adapter.js
              if (edgeVersion < 15019) {
                localCapabilities.codecs = localCapabilities.codecs.filter(
                  function (codec) {
                    return codec.name !== 'rtx';
                  });
              }

              sendEncodingParameters = transceiver.sendEncodingParameters || [{
                ssrc: (2 * sdpMLineIndex + 2) * 1001
              }];

              // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
              var isNewTrack = false;
              if (direction === 'sendrecv' || direction === 'sendonly') {
                isNewTrack = !transceiver.rtpReceiver;
                rtpReceiver = transceiver.rtpReceiver ||
                  new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

                if (isNewTrack) {
                  var stream;
                  track = rtpReceiver.track;
                  // FIXME: does not work with Plan B.
                  if (remoteMsid && remoteMsid.stream === '-') {
                    // no-op. a stream id of '-' means: no associated stream.
                  } else if (remoteMsid) {
                    if (!streams[remoteMsid.stream]) {
                      streams[remoteMsid.stream] = new window.MediaStream();
                      Object.defineProperty(streams[remoteMsid.stream], 'id', {
                        get: function () {
                          return remoteMsid.stream;
                        }
                      });
                    }
                    Object.defineProperty(track, 'id', {
                      get: function () {
                        return remoteMsid.track;
                      }
                    });
                    stream = streams[remoteMsid.stream];
                  } else {
                    if (!streams.default) {
                      streams.default = new window.MediaStream();
                    }
                    stream = streams.default;
                  }
                  if (stream) {
                    addTrackToStreamAndFireEvent(track, stream);
                    transceiver.associatedRemoteMediaStreams.push(stream);
                  }
                  receiverList.push([track, rtpReceiver, stream]);
                }
              } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
                transceiver.associatedRemoteMediaStreams.forEach(function (s) {
                  var nativeTrack = s.getTracks().find(function (t) {
                    return t.id === transceiver.rtpReceiver.track.id;
                  });
                  if (nativeTrack) {
                    removeTrackFromStreamAndFireEvent(nativeTrack, s);
                  }
                });
                transceiver.associatedRemoteMediaStreams = [];
              }

              transceiver.localCapabilities = localCapabilities;
              transceiver.remoteCapabilities = remoteCapabilities;
              transceiver.rtpReceiver = rtpReceiver;
              transceiver.rtcpParameters = rtcpParameters;
              transceiver.sendEncodingParameters = sendEncodingParameters;
              transceiver.recvEncodingParameters = recvEncodingParameters;

              // Start the RTCRtpReceiver now. The RTPSender is started in
              // setLocalDescription.
              pc._transceive(pc.transceivers[sdpMLineIndex],
                false,
                isNewTrack);
            } else if (description.type === 'answer' && !rejected) {
              transceiver = pc.transceivers[sdpMLineIndex];
              iceGatherer = transceiver.iceGatherer;
              iceTransport = transceiver.iceTransport;
              dtlsTransport = transceiver.dtlsTransport;
              rtpReceiver = transceiver.rtpReceiver;
              sendEncodingParameters = transceiver.sendEncodingParameters;
              localCapabilities = transceiver.localCapabilities;

              pc.transceivers[sdpMLineIndex].recvEncodingParameters =
                recvEncodingParameters;
              pc.transceivers[sdpMLineIndex].remoteCapabilities =
                remoteCapabilities;
              pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

              if (cands.length && iceTransport.state === 'new') {
                if ((isIceLite || isComplete) &&
                  (!usingBundle || sdpMLineIndex === 0)) {
                  iceTransport.setRemoteCandidates(cands);
                } else {
                  cands.forEach(function (candidate) {
                    maybeAddCandidate(transceiver.iceTransport, candidate);
                  });
                }
              }

              if (!usingBundle || sdpMLineIndex === 0) {
                if (iceTransport.state === 'new') {
                  iceTransport.start(iceGatherer, remoteIceParameters,
                    'controlling');
                }
                if (dtlsTransport.state === 'new') {
                  dtlsTransport.start(remoteDtlsParameters);
                }
              }

              // If the offer contained RTX but the answer did not,
              // remove RTX from sendEncodingParameters.
              var commonCapabilities = getCommonCapabilities(
                transceiver.localCapabilities,
                transceiver.remoteCapabilities);

              var hasRtx = commonCapabilities.codecs.filter(function (c) {
                return c.name.toLowerCase() === 'rtx';
              }).length;
              if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
                delete transceiver.sendEncodingParameters[0].rtx;
              }

              pc._transceive(transceiver,
                direction === 'sendrecv' || direction === 'recvonly',
                direction === 'sendrecv' || direction === 'sendonly');

              // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
              if (rtpReceiver &&
                (direction === 'sendrecv' || direction === 'sendonly')) {
                track = rtpReceiver.track;
                if (remoteMsid) {
                  if (!streams[remoteMsid.stream]) {
                    streams[remoteMsid.stream] = new window.MediaStream();
                  }
                  addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
                  receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
                } else {
                  if (!streams.default) {
                    streams.default = new window.MediaStream();
                  }
                  addTrackToStreamAndFireEvent(track, streams.default);
                  receiverList.push([track, rtpReceiver, streams.default]);
                }
              } else {
                // FIXME: actually the receiver should be created later.
                delete transceiver.rtpReceiver;
              }
            }
          });

          if (pc._dtlsRole === undefined) {
            pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
          }

          pc._remoteDescription = {
            type: description.type,
            sdp: description.sdp
          };
          if (description.type === 'offer') {
            pc._updateSignalingState('have-remote-offer');
          } else {
            pc._updateSignalingState('stable');
          }
          Object.keys(streams).forEach(function (sid) {
            var stream = streams[sid];
            if (stream.getTracks().length) {
              if (pc.remoteStreams.indexOf(stream) === -1) {
                pc.remoteStreams.push(stream);
                var event = new Event('addstream');
                event.stream = stream;
                window.setTimeout(function () {
                  pc._dispatchEvent('addstream', event);
                });
              }

              receiverList.forEach(function (item) {
                var track = item[0];
                var receiver = item[1];
                if (stream.id !== item[2].id) {
                  return;
                }
                fireAddTrack(pc, track, receiver, [stream]);
              });
            }
          });
          receiverList.forEach(function (item) {
            if (item[2]) {
              return;
            }
            fireAddTrack(pc, item[0], item[1], []);
          });

          // check whether addIceCandidate({}) was called within four seconds after
          // setRemoteDescription.
          window.setTimeout(function () {
            if (!(pc && pc.transceivers)) {
              return;
            }
            pc.transceivers.forEach(function (transceiver) {
              if (transceiver.iceTransport &&
                transceiver.iceTransport.state === 'new' &&
                transceiver.iceTransport.getRemoteCandidates().length > 0) {
                console.warn('Timeout for addRemoteCandidate. Consider sending ' +
                  'an end-of-candidates notification');
                transceiver.iceTransport.addRemoteCandidate({});
              }
            });
          }, 4000);

          return Promise.resolve();
        };

        RTCPeerConnection.prototype.close = function () {
          this.transceivers.forEach(function (transceiver) {
            /* not yet
            if (transceiver.iceGatherer) {
              transceiver.iceGatherer.close();
            }
            */
            if (transceiver.iceTransport) {
              transceiver.iceTransport.stop();
            }
            if (transceiver.dtlsTransport) {
              transceiver.dtlsTransport.stop();
            }
            if (transceiver.rtpSender) {
              transceiver.rtpSender.stop();
            }
            if (transceiver.rtpReceiver) {
              transceiver.rtpReceiver.stop();
            }
          });
          // FIXME: clean up tracks, local streams, remote streams, etc
          this._isClosed = true;
          this._updateSignalingState('closed');
        };

        // Update the signaling state.
        RTCPeerConnection.prototype._updateSignalingState = function (newState) {
          this.signalingState = newState;
          var event = new Event('signalingstatechange');
          this._dispatchEvent('signalingstatechange', event);
        };

        // Determine whether to fire the negotiationneeded event.
        RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function () {
          var pc = this;
          if (this.signalingState !== 'stable' || this.needNegotiation === true) {
            return;
          }
          this.needNegotiation = true;
          window.setTimeout(function () {
            if (pc.needNegotiation) {
              pc.needNegotiation = false;
              var event = new Event('negotiationneeded');
              pc._dispatchEvent('negotiationneeded', event);
            }
          }, 0);
        };

        // Update the ice connection state.
        RTCPeerConnection.prototype._updateIceConnectionState = function () {
          var newState;
          var states = {
            'new': 0,
            closed: 0,
            checking: 0,
            connected: 0,
            completed: 0,
            disconnected: 0,
            failed: 0
          };
          this.transceivers.forEach(function (transceiver) {
            if (transceiver.iceTransport && !transceiver.rejected) {
              states[transceiver.iceTransport.state]++;
            }
          });

          newState = 'new';
          if (states.failed > 0) {
            newState = 'failed';
          } else if (states.checking > 0) {
            newState = 'checking';
          } else if (states.disconnected > 0) {
            newState = 'disconnected';
          } else if (states.new > 0) {
            newState = 'new';
          } else if (states.connected > 0) {
            newState = 'connected';
          } else if (states.completed > 0) {
            newState = 'completed';
          }

          if (newState !== this.iceConnectionState) {
            this.iceConnectionState = newState;
            var event = new Event('iceconnectionstatechange');
            this._dispatchEvent('iceconnectionstatechange', event);
          }
        };

        // Update the connection state.
        RTCPeerConnection.prototype._updateConnectionState = function () {
          var newState;
          var states = {
            'new': 0,
            closed: 0,
            connecting: 0,
            connected: 0,
            completed: 0,
            disconnected: 0,
            failed: 0
          };
          this.transceivers.forEach(function (transceiver) {
            if (transceiver.iceTransport && transceiver.dtlsTransport &&
              !transceiver.rejected) {
              states[transceiver.iceTransport.state]++;
              states[transceiver.dtlsTransport.state]++;
            }
          });
          // ICETransport.completed and connected are the same for this purpose.
          states.connected += states.completed;

          newState = 'new';
          if (states.failed > 0) {
            newState = 'failed';
          } else if (states.connecting > 0) {
            newState = 'connecting';
          } else if (states.disconnected > 0) {
            newState = 'disconnected';
          } else if (states.new > 0) {
            newState = 'new';
          } else if (states.connected > 0) {
            newState = 'connected';
          }

          if (newState !== this.connectionState) {
            this.connectionState = newState;
            var event = new Event('connectionstatechange');
            this._dispatchEvent('connectionstatechange', event);
          }
        };

        RTCPeerConnection.prototype.createOffer = function () {
          var pc = this;

          if (pc._isClosed) {
            return Promise.reject(makeError('InvalidStateError',
              'Can not call createOffer after close'));
          }

          var numAudioTracks = pc.transceivers.filter(function (t) {
            return t.kind === 'audio';
          }).length;
          var numVideoTracks = pc.transceivers.filter(function (t) {
            return t.kind === 'video';
          }).length;

          // Determine number of audio and video tracks we need to send/recv.
          var offerOptions = arguments[0];
          if (offerOptions) {
            // Reject Chrome legacy constraints.
            if (offerOptions.mandatory || offerOptions.optional) {
              throw new TypeError(
                'Legacy mandatory/optional constraints not supported.');
            }
            if (offerOptions.offerToReceiveAudio !== undefined) {
              if (offerOptions.offerToReceiveAudio === true) {
                numAudioTracks = 1;
              } else if (offerOptions.offerToReceiveAudio === false) {
                numAudioTracks = 0;
              } else {
                numAudioTracks = offerOptions.offerToReceiveAudio;
              }
            }
            if (offerOptions.offerToReceiveVideo !== undefined) {
              if (offerOptions.offerToReceiveVideo === true) {
                numVideoTracks = 1;
              } else if (offerOptions.offerToReceiveVideo === false) {
                numVideoTracks = 0;
              } else {
                numVideoTracks = offerOptions.offerToReceiveVideo;
              }
            }
          }

          pc.transceivers.forEach(function (transceiver) {
            if (transceiver.kind === 'audio') {
              numAudioTracks--;
              if (numAudioTracks < 0) {
                transceiver.wantReceive = false;
              }
            } else if (transceiver.kind === 'video') {
              numVideoTracks--;
              if (numVideoTracks < 0) {
                transceiver.wantReceive = false;
              }
            }
          });

          // Create M-lines for recvonly streams.
          while (numAudioTracks > 0 || numVideoTracks > 0) {
            if (numAudioTracks > 0) {
              pc._createTransceiver('audio');
              numAudioTracks--;
            }
            if (numVideoTracks > 0) {
              pc._createTransceiver('video');
              numVideoTracks--;
            }
          }

          var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
            pc._sdpSessionVersion++);
          pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
            // For each track, create an ice gatherer, ice transport,
            // dtls transport, potentially rtpsender and rtpreceiver.
            var track = transceiver.track;
            var kind = transceiver.kind;
            var mid = transceiver.mid || SDPUtils.generateIdentifier();
            transceiver.mid = mid;

            if (!transceiver.iceGatherer) {
              transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
                pc.usingBundle);
            }

            var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
            // filter RTX until additional stuff needed for RTX is implemented
            // in adapter.js
            if (edgeVersion < 15019) {
              localCapabilities.codecs = localCapabilities.codecs.filter(
                function (codec) {
                  return codec.name !== 'rtx';
                });
            }
            localCapabilities.codecs.forEach(function (codec) {
              // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
              // by adding level-asymmetry-allowed=1
              if (codec.name === 'H264' &&
                codec.parameters['level-asymmetry-allowed'] === undefined) {
                codec.parameters['level-asymmetry-allowed'] = '1';
              }

              // for subsequent offers, we might have to re-use the payload
              // type of the last offer.
              if (transceiver.remoteCapabilities &&
                transceiver.remoteCapabilities.codecs) {
                transceiver.remoteCapabilities.codecs.forEach(function (remoteCodec) {
                  if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
                    codec.clockRate === remoteCodec.clockRate) {
                    codec.preferredPayloadType = remoteCodec.payloadType;
                  }
                });
              }
            });
            localCapabilities.headerExtensions.forEach(function (hdrExt) {
              var remoteExtensions = transceiver.remoteCapabilities &&
                transceiver.remoteCapabilities.headerExtensions || [];
              remoteExtensions.forEach(function (rHdrExt) {
                if (hdrExt.uri === rHdrExt.uri) {
                  hdrExt.id = rHdrExt.id;
                }
              });
            });

            // generate an ssrc now, to be used later in rtpSender.send
            var sendEncodingParameters = transceiver.sendEncodingParameters || [{
              ssrc: (2 * sdpMLineIndex + 1) * 1001
            }];
            if (track) {
              // add RTX
              if (edgeVersion >= 15019 && kind === 'video' &&
                !sendEncodingParameters[0].rtx) {
                sendEncodingParameters[0].rtx = {
                  ssrc: sendEncodingParameters[0].ssrc + 1
                };
              }
            }

            if (transceiver.wantReceive) {
              transceiver.rtpReceiver = new window.RTCRtpReceiver(
                transceiver.dtlsTransport, kind);
            }

            transceiver.localCapabilities = localCapabilities;
            transceiver.sendEncodingParameters = sendEncodingParameters;
          });

          // always offer BUNDLE and dispose on return if not supported.
          if (pc._config.bundlePolicy !== 'max-compat') {
            sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function (t) {
              return t.mid;
            }).join(' ') + '\r\n';
          }
          sdp += 'a=ice-options:trickle\r\n';

          pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
            sdp += writeMediaSection(transceiver, transceiver.localCapabilities,
              'offer', transceiver.stream, pc._dtlsRole);
            sdp += 'a=rtcp-rsize\r\n';

            if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
              (sdpMLineIndex === 0 || !pc.usingBundle)) {
              transceiver.iceGatherer.getLocalCandidates().forEach(function (cand) {
                cand.component = 1;
                sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
              });

              if (transceiver.iceGatherer.state === 'completed') {
                sdp += 'a=end-of-candidates\r\n';
              }
            }
          });

          var desc = new window.RTCSessionDescription({
            type: 'offer',
            sdp: sdp
          });
          return Promise.resolve(desc);
        };

        RTCPeerConnection.prototype.createAnswer = function () {
          var pc = this;

          if (pc._isClosed) {
            return Promise.reject(makeError('InvalidStateError',
              'Can not call createAnswer after close'));
          }

          if (!(pc.signalingState === 'have-remote-offer' ||
            pc.signalingState === 'have-local-pranswer')) {
            return Promise.reject(makeError('InvalidStateError',
              'Can not call createAnswer in signalingState ' + pc.signalingState));
          }

          var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
            pc._sdpSessionVersion++);
          if (pc.usingBundle) {
            sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function (t) {
              return t.mid;
            }).join(' ') + '\r\n';
          }
          sdp += 'a=ice-options:trickle\r\n';

          var mediaSectionsInOffer = SDPUtils.getMediaSections(
            pc._remoteDescription.sdp).length;
          pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
            if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
              return;
            }
            if (transceiver.rejected) {
              if (transceiver.kind === 'application') {
                if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt
                  sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
                } else {
                  sdp += 'm=application 0 ' + transceiver.protocol +
                    ' webrtc-datachannel\r\n';
                }
              } else if (transceiver.kind === 'audio') {
                sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
                  'a=rtpmap:0 PCMU/8000\r\n';
              } else if (transceiver.kind === 'video') {
                sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
                  'a=rtpmap:120 VP8/90000\r\n';
              }
              sdp += 'c=IN IP4 0.0.0.0\r\n' +
                'a=inactive\r\n' +
                'a=mid:' + transceiver.mid + '\r\n';
              return;
            }

            // FIXME: look at direction.
            if (transceiver.stream) {
              var localTrack;
              if (transceiver.kind === 'audio') {
                localTrack = transceiver.stream.getAudioTracks()[0];
              } else if (transceiver.kind === 'video') {
                localTrack = transceiver.stream.getVideoTracks()[0];
              }
              if (localTrack) {
                // add RTX
                if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
                  !transceiver.sendEncodingParameters[0].rtx) {
                  transceiver.sendEncodingParameters[0].rtx = {
                    ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
                  };
                }
              }
            }

            // Calculate intersection of capabilities.
            var commonCapabilities = getCommonCapabilities(
              transceiver.localCapabilities,
              transceiver.remoteCapabilities);

            var hasRtx = commonCapabilities.codecs.filter(function (c) {
              return c.name.toLowerCase() === 'rtx';
            }).length;
            if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
              delete transceiver.sendEncodingParameters[0].rtx;
            }

            sdp += writeMediaSection(transceiver, commonCapabilities,
              'answer', transceiver.stream, pc._dtlsRole);
            if (transceiver.rtcpParameters &&
              transceiver.rtcpParameters.reducedSize) {
              sdp += 'a=rtcp-rsize\r\n';
            }
          });

          var desc = new window.RTCSessionDescription({
            type: 'answer',
            sdp: sdp
          });
          return Promise.resolve(desc);
        };

        RTCPeerConnection.prototype.addIceCandidate = function (candidate) {
          var pc = this;
          var sections;
          if (candidate && !(candidate.sdpMLineIndex !== undefined ||
            candidate.sdpMid)) {
            return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
          }

          // TODO: needs to go into ops queue.
          return new Promise(function (resolve, reject) {
            if (!pc._remoteDescription) {
              return reject(makeError('InvalidStateError',
                'Can not add ICE candidate without a remote description'));
            } else if (!candidate || candidate.candidate === '') {
              for (var j = 0; j < pc.transceivers.length; j++) {
                if (pc.transceivers[j].rejected) {
                  continue;
                }
                pc.transceivers[j].iceTransport.addRemoteCandidate({});
                sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
                sections[j] += 'a=end-of-candidates\r\n';
                pc._remoteDescription.sdp =
                  SDPUtils.getDescription(pc._remoteDescription.sdp) +
                  sections.join('');
                if (pc.usingBundle) {
                  break;
                }
              }
            } else {
              var sdpMLineIndex = candidate.sdpMLineIndex;
              if (candidate.sdpMid) {
                for (var i = 0; i < pc.transceivers.length; i++) {
                  if (pc.transceivers[i].mid === candidate.sdpMid) {
                    sdpMLineIndex = i;
                    break;
                  }
                }
              }
              var transceiver = pc.transceivers[sdpMLineIndex];
              if (transceiver) {
                if (transceiver.rejected) {
                  return resolve();
                }
                var cand = Object.keys(candidate.candidate).length > 0 ?
                  SDPUtils.parseCandidate(candidate.candidate) : {};
                // Ignore Chrome's invalid candidates since Edge does not like them.
                if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
                  return resolve();
                }
                // Ignore RTCP candidates, we assume RTCP-MUX.
                if (cand.component && cand.component !== 1) {
                  return resolve();
                }
                // when using bundle, avoid adding candidates to the wrong
                // ice transport. And avoid adding candidates added in the SDP.
                if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
                  transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
                  if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
                    return reject(makeError('OperationError',
                      'Can not add ICE candidate'));
                  }
                }

                // update the remoteDescription.
                var candidateString = candidate.candidate.trim();
                if (candidateString.indexOf('a=') === 0) {
                  candidateString = candidateString.substr(2);
                }
                sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
                sections[sdpMLineIndex] += 'a=' +
                  (cand.type ? candidateString : 'end-of-candidates')
                  + '\r\n';
                pc._remoteDescription.sdp =
                  SDPUtils.getDescription(pc._remoteDescription.sdp) +
                  sections.join('');
              } else {
                return reject(makeError('OperationError',
                  'Can not add ICE candidate'));
              }
            }
            resolve();
          });
        };

        RTCPeerConnection.prototype.getStats = function (selector) {
          if (selector && selector instanceof window.MediaStreamTrack) {
            var senderOrReceiver = null;
            this.transceivers.forEach(function (transceiver) {
              if (transceiver.rtpSender &&
                transceiver.rtpSender.track === selector) {
                senderOrReceiver = transceiver.rtpSender;
              } else if (transceiver.rtpReceiver &&
                transceiver.rtpReceiver.track === selector) {
                senderOrReceiver = transceiver.rtpReceiver;
              }
            });
            if (!senderOrReceiver) {
              throw makeError('InvalidAccessError', 'Invalid selector.');
            }
            return senderOrReceiver.getStats();
          }

          var promises = [];
          this.transceivers.forEach(function (transceiver) {
            ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
              'dtlsTransport'].forEach(function (method) {
                if (transceiver[method]) {
                  promises.push(transceiver[method].getStats());
                }
              });
          });
          return Promise.all(promises).then(function (allStats) {
            var results = new Map();
            allStats.forEach(function (stats) {
              stats.forEach(function (stat) {
                results.set(stat.id, stat);
              });
            });
            return results;
          });
        };

        // fix low-level stat names and return Map instead of object.
        var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',
          'RTCIceTransport', 'RTCDtlsTransport'];
        ortcObjects.forEach(function (ortcObjectName) {
          var obj = window[ortcObjectName];
          if (obj && obj.prototype && obj.prototype.getStats) {
            var nativeGetstats = obj.prototype.getStats;
            obj.prototype.getStats = function () {
              return nativeGetstats.apply(this)
                .then(function (nativeStats) {
                  var mapStats = new Map();
                  Object.keys(nativeStats).forEach(function (id) {
                    nativeStats[id].type = fixStatsType(nativeStats[id]);
                    mapStats.set(id, nativeStats[id]);
                  });
                  return mapStats;
                });
            };
          }
        });

        // legacy callback shims. Should be moved to adapter.js some days.
        var methods = ['createOffer', 'createAnswer'];
        methods.forEach(function (method) {
          var nativeMethod = RTCPeerConnection.prototype[method];
          RTCPeerConnection.prototype[method] = function () {
            var args = arguments;
            if (typeof args[0] === 'function' ||
              typeof args[1] === 'function') { // legacy
              return nativeMethod.apply(this, [arguments[2]])
                .then(function (description) {
                  if (typeof args[0] === 'function') {
                    args[0].apply(null, [description]);
                  }
                }, function (error) {
                  if (typeof args[1] === 'function') {
                    args[1].apply(null, [error]);
                  }
                });
            }
            return nativeMethod.apply(this, arguments);
          };
        });

        methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
        methods.forEach(function (method) {
          var nativeMethod = RTCPeerConnection.prototype[method];
          RTCPeerConnection.prototype[method] = function () {
            var args = arguments;
            if (typeof args[1] === 'function' ||
              typeof args[2] === 'function') { // legacy
              return nativeMethod.apply(this, arguments)
                .then(function () {
                  if (typeof args[1] === 'function') {
                    args[1].apply(null);
                  }
                }, function (error) {
                  if (typeof args[2] === 'function') {
                    args[2].apply(null, [error]);
                  }
                });
            }
            return nativeMethod.apply(this, arguments);
          };
        });

        // getStats is special. It doesn't have a spec legacy method yet we support
        // getStats(something, cb) without error callbacks.
        ['getStats'].forEach(function (method) {
          var nativeMethod = RTCPeerConnection.prototype[method];
          RTCPeerConnection.prototype[method] = function () {
            var args = arguments;
            if (typeof args[1] === 'function') {
              return nativeMethod.apply(this, arguments)
                .then(function () {
                  if (typeof args[1] === 'function') {
                    args[1].apply(null);
                  }
                });
            }
            return nativeMethod.apply(this, arguments);
          };
        });

        return RTCPeerConnection;
      };

    }, { "sdp": 17 }], 17: [function (require, module, exports) {
      /* eslint-env node */
      'use strict';

      // SDP helpers.
      var SDPUtils = {};

      // Generate an alphanumeric identifier for cname or mids.
      // TODO: use UUIDs instead? https://gist.github.com/jed/982883
      SDPUtils.generateIdentifier = function () {
        return Math.random().toString(36).substr(2, 10);
      };

      // The RTCP CNAME used by all peerconnections from the same JS.
      SDPUtils.localCName = SDPUtils.generateIdentifier();

      // Splits SDP into lines, dealing with both CRLF and LF.
      SDPUtils.splitLines = function (blob) {
        return blob.trim().split('\n').map(function (line) {
          return line.trim();
        });
      };
      // Splits SDP into sessionpart and mediasections. Ensures CRLF.
      SDPUtils.splitSections = function (blob) {
        var parts = blob.split('\nm=');
        return parts.map(function (part, index) {
          return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
        });
      };

      // returns the session description.
      SDPUtils.getDescription = function (blob) {
        var sections = SDPUtils.splitSections(blob);
        return sections && sections[0];
      };

      // returns the individual media sections.
      SDPUtils.getMediaSections = function (blob) {
        var sections = SDPUtils.splitSections(blob);
        sections.shift();
        return sections;
      };

      // Returns lines that start with a certain prefix.
      SDPUtils.matchPrefix = function (blob, prefix) {
        return SDPUtils.splitLines(blob).filter(function (line) {
          return line.indexOf(prefix) === 0;
        });
      };

      // Parses an ICE candidate line. Sample input:
      // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
      // rport 55996"
      SDPUtils.parseCandidate = function (line) {
        var parts;
        // Parse both variants.
        if (line.indexOf('a=candidate:') === 0) {
          parts = line.substring(12).split(' ');
        } else {
          parts = line.substring(10).split(' ');
        }

        var candidate = {
          foundation: parts[0],
          component: parseInt(parts[1], 10),
          protocol: parts[2].toLowerCase(),
          priority: parseInt(parts[3], 10),
          ip: parts[4],
          address: parts[4], // address is an alias for ip.
          port: parseInt(parts[5], 10),
          // skip parts[6] == 'typ'
          type: parts[7]
        };

        for (var i = 8; i < parts.length; i += 2) {
          switch (parts[i]) {
            case 'raddr':
              candidate.relatedAddress = parts[i + 1];
              break;
            case 'rport':
              candidate.relatedPort = parseInt(parts[i + 1], 10);
              break;
            case 'tcptype':
              candidate.tcpType = parts[i + 1];
              break;
            case 'ufrag':
              candidate.ufrag = parts[i + 1]; // for backward compability.
              candidate.usernameFragment = parts[i + 1];
              break;
            default: // extension handling, in particular ufrag
              candidate[parts[i]] = parts[i + 1];
              break;
          }
        }
        return candidate;
      };

      // Translates a candidate object into SDP candidate attribute.
      SDPUtils.writeCandidate = function (candidate) {
        var sdp = [];
        sdp.push(candidate.foundation);
        sdp.push(candidate.component);
        sdp.push(candidate.protocol.toUpperCase());
        sdp.push(candidate.priority);
        sdp.push(candidate.address || candidate.ip);
        sdp.push(candidate.port);

        var type = candidate.type;
        sdp.push('typ');
        sdp.push(type);
        if (type !== 'host' && candidate.relatedAddress &&
          candidate.relatedPort) {
          sdp.push('raddr');
          sdp.push(candidate.relatedAddress);
          sdp.push('rport');
          sdp.push(candidate.relatedPort);
        }
        if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
          sdp.push('tcptype');
          sdp.push(candidate.tcpType);
        }
        if (candidate.usernameFragment || candidate.ufrag) {
          sdp.push('ufrag');
          sdp.push(candidate.usernameFragment || candidate.ufrag);
        }
        return 'candidate:' + sdp.join(' ');
      };

      // Parses an ice-options line, returns an array of option tags.
      // a=ice-options:foo bar
      SDPUtils.parseIceOptions = function (line) {
        return line.substr(14).split(' ');
      };

      // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
      // a=rtpmap:111 opus/48000/2
      SDPUtils.parseRtpMap = function (line) {
        var parts = line.substr(9).split(' ');
        var parsed = {
          payloadType: parseInt(parts.shift(), 10) // was: id
        };

        parts = parts[0].split('/');

        parsed.name = parts[0];
        parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
        parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
        // legacy alias, got renamed back to channels in ORTC.
        parsed.numChannels = parsed.channels;
        return parsed;
      };

      // Generate an a=rtpmap line from RTCRtpCodecCapability or
      // RTCRtpCodecParameters.
      SDPUtils.writeRtpMap = function (codec) {
        var pt = codec.payloadType;
        if (codec.preferredPayloadType !== undefined) {
          pt = codec.preferredPayloadType;
        }
        var channels = codec.channels || codec.numChannels || 1;
        return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
          (channels !== 1 ? '/' + channels : '') + '\r\n';
      };

      // Parses an a=extmap line (headerextension from RFC 5285). Sample input:
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
      SDPUtils.parseExtmap = function (line) {
        var parts = line.substr(9).split(' ');
        return {
          id: parseInt(parts[0], 10),
          direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
          uri: parts[1]
        };
      };

      // Generates a=extmap line from RTCRtpHeaderExtensionParameters or
      // RTCRtpHeaderExtension.
      SDPUtils.writeExtmap = function (headerExtension) {
        return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
          (headerExtension.direction && headerExtension.direction !== 'sendrecv'
            ? '/' + headerExtension.direction
            : '') +
          ' ' + headerExtension.uri + '\r\n';
      };

      // Parses an ftmp line, returns dictionary. Sample input:
      // a=fmtp:96 vbr=on;cng=on
      // Also deals with vbr=on; cng=on
      SDPUtils.parseFmtp = function (line) {
        var parsed = {};
        var kv;
        var parts = line.substr(line.indexOf(' ') + 1).split(';');
        for (var j = 0; j < parts.length; j++) {
          kv = parts[j].trim().split('=');
          parsed[kv[0].trim()] = kv[1];
        }
        return parsed;
      };

      // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
      SDPUtils.writeFmtp = function (codec) {
        var line = '';
        var pt = codec.payloadType;
        if (codec.preferredPayloadType !== undefined) {
          pt = codec.preferredPayloadType;
        }
        if (codec.parameters && Object.keys(codec.parameters).length) {
          var params = [];
          Object.keys(codec.parameters).forEach(function (param) {
            if (codec.parameters[param]) {
              params.push(param + '=' + codec.parameters[param]);
            } else {
              params.push(param);
            }
          });
          line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
        }
        return line;
      };

      // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
      // a=rtcp-fb:98 nack rpsi
      SDPUtils.parseRtcpFb = function (line) {
        var parts = line.substr(line.indexOf(' ') + 1).split(' ');
        return {
          type: parts.shift(),
          parameter: parts.join(' ')
        };
      };
      // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
      SDPUtils.writeRtcpFb = function (codec) {
        var lines = '';
        var pt = codec.payloadType;
        if (codec.preferredPayloadType !== undefined) {
          pt = codec.preferredPayloadType;
        }
        if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
          // FIXME: special handling for trr-int?
          codec.rtcpFeedback.forEach(function (fb) {
            lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
              (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
              '\r\n';
          });
        }
        return lines;
      };

      // Parses an RFC 5576 ssrc media attribute. Sample input:
      // a=ssrc:3735928559 cname:something
      SDPUtils.parseSsrcMedia = function (line) {
        var sp = line.indexOf(' ');
        var parts = {
          ssrc: parseInt(line.substr(7, sp - 7), 10)
        };
        var colon = line.indexOf(':', sp);
        if (colon > -1) {
          parts.attribute = line.substr(sp + 1, colon - sp - 1);
          parts.value = line.substr(colon + 1);
        } else {
          parts.attribute = line.substr(sp + 1);
        }
        return parts;
      };

      SDPUtils.parseSsrcGroup = function (line) {
        var parts = line.substr(13).split(' ');
        return {
          semantics: parts.shift(),
          ssrcs: parts.map(function (ssrc) {
            return parseInt(ssrc, 10);
          })
        };
      };

      // Extracts the MID (RFC 5888) from a media section.
      // returns the MID or undefined if no mid line was found.
      SDPUtils.getMid = function (mediaSection) {
        var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
        if (mid) {
          return mid.substr(6);
        }
      };

      SDPUtils.parseFingerprint = function (line) {
        var parts = line.substr(14).split(' ');
        return {
          algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
          value: parts[1]
        };
      };

      // Extracts DTLS parameters from SDP media section or sessionpart.
      // FIXME: for consistency with other functions this should only
      //   get the fingerprint line as input. See also getIceParameters.
      SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {
        var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
          'a=fingerprint:');
        // Note: a=setup line is ignored since we use the 'auto' role.
        // Note2: 'algorithm' is not case sensitive except in Edge.
        return {
          role: 'auto',
          fingerprints: lines.map(SDPUtils.parseFingerprint)
        };
      };

      // Serializes DTLS parameters to SDP.
      SDPUtils.writeDtlsParameters = function (params, setupType) {
        var sdp = 'a=setup:' + setupType + '\r\n';
        params.fingerprints.forEach(function (fp) {
          sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
        });
        return sdp;
      };

      // Parses a=crypto lines into
      //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
      SDPUtils.parseCryptoLine = function (line) {
        var parts = line.substr(9).split(' ');
        return {
          tag: parseInt(parts[0], 10),
          cryptoSuite: parts[1],
          keyParams: parts[2],
          sessionParams: parts.slice(3),
        };
      };

      SDPUtils.writeCryptoLine = function (parameters) {
        return 'a=crypto:' + parameters.tag + ' ' +
          parameters.cryptoSuite + ' ' +
          (typeof parameters.keyParams === 'object'
            ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)
            : parameters.keyParams) +
          (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +
          '\r\n';
      };

      // Parses the crypto key parameters into
      //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
      SDPUtils.parseCryptoKeyParams = function (keyParams) {
        if (keyParams.indexOf('inline:') !== 0) {
          return null;
        }
        var parts = keyParams.substr(7).split('|');
        return {
          keyMethod: 'inline',
          keySalt: parts[0],
          lifeTime: parts[1],
          mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
          mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,
        };
      };

      SDPUtils.writeCryptoKeyParams = function (keyParams) {
        return keyParams.keyMethod + ':'
          + keyParams.keySalt +
          (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +
          (keyParams.mkiValue && keyParams.mkiLength
            ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength
            : '');
      };

      // Extracts all SDES paramters.
      SDPUtils.getCryptoParameters = function (mediaSection, sessionpart) {
        var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
          'a=crypto:');
        return lines.map(SDPUtils.parseCryptoLine);
      };

      // Parses ICE information from SDP media section or sessionpart.
      // FIXME: for consistency with other functions this should only
      //   get the ice-ufrag and ice-pwd lines as input.
      SDPUtils.getIceParameters = function (mediaSection, sessionpart) {
        var ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,
          'a=ice-ufrag:')[0];
        var pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,
          'a=ice-pwd:')[0];
        if (!(ufrag && pwd)) {
          return null;
        }
        return {
          usernameFragment: ufrag.substr(12),
          password: pwd.substr(10),
        };
      };

      // Serializes ICE parameters to SDP.
      SDPUtils.writeIceParameters = function (params) {
        return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
          'a=ice-pwd:' + params.password + '\r\n';
      };

      // Parses the SDP media section and returns RTCRtpParameters.
      SDPUtils.parseRtpParameters = function (mediaSection) {
        var description = {
          codecs: [],
          headerExtensions: [],
          fecMechanisms: [],
          rtcp: []
        };
        var lines = SDPUtils.splitLines(mediaSection);
        var mline = lines[0].split(' ');
        for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
          var pt = mline[i];
          var rtpmapline = SDPUtils.matchPrefix(
            mediaSection, 'a=rtpmap:' + pt + ' ')[0];
          if (rtpmapline) {
            var codec = SDPUtils.parseRtpMap(rtpmapline);
            var fmtps = SDPUtils.matchPrefix(
              mediaSection, 'a=fmtp:' + pt + ' ');
            // Only the first a=fmtp:<pt> is considered.
            codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
            codec.rtcpFeedback = SDPUtils.matchPrefix(
              mediaSection, 'a=rtcp-fb:' + pt + ' ')
              .map(SDPUtils.parseRtcpFb);
            description.codecs.push(codec);
            // parse FEC mechanisms from rtpmap lines.
            switch (codec.name.toUpperCase()) {
              case 'RED':
              case 'ULPFEC':
                description.fecMechanisms.push(codec.name.toUpperCase());
                break;
              default: // only RED and ULPFEC are recognized as FEC mechanisms.
                break;
            }
          }
        }
        SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function (line) {
          description.headerExtensions.push(SDPUtils.parseExtmap(line));
        });
        // FIXME: parse rtcp.
        return description;
      };

      // Generates parts of the SDP media section describing the capabilities /
      // parameters.
      SDPUtils.writeRtpDescription = function (kind, caps) {
        var sdp = '';

        // Build the mline.
        sdp += 'm=' + kind + ' ';
        sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
        sdp += ' UDP/TLS/RTP/SAVPF ';
        sdp += caps.codecs.map(function (codec) {
          if (codec.preferredPayloadType !== undefined) {
            return codec.preferredPayloadType;
          }
          return codec.payloadType;
        }).join(' ') + '\r\n';

        sdp += 'c=IN IP4 0.0.0.0\r\n';
        sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

        // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
        caps.codecs.forEach(function (codec) {
          sdp += SDPUtils.writeRtpMap(codec);
          sdp += SDPUtils.writeFmtp(codec);
          sdp += SDPUtils.writeRtcpFb(codec);
        });
        var maxptime = 0;
        caps.codecs.forEach(function (codec) {
          if (codec.maxptime > maxptime) {
            maxptime = codec.maxptime;
          }
        });
        if (maxptime > 0) {
          sdp += 'a=maxptime:' + maxptime + '\r\n';
        }
        sdp += 'a=rtcp-mux\r\n';

        if (caps.headerExtensions) {
          caps.headerExtensions.forEach(function (extension) {
            sdp += SDPUtils.writeExtmap(extension);
          });
        }
        // FIXME: write fecMechanisms.
        return sdp;
      };

      // Parses the SDP media section and returns an array of
      // RTCRtpEncodingParameters.
      SDPUtils.parseRtpEncodingParameters = function (mediaSection) {
        var encodingParameters = [];
        var description = SDPUtils.parseRtpParameters(mediaSection);
        var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
        var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

        // filter a=ssrc:... cname:, ignore PlanB-msid
        var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
          .map(function (line) {
            return SDPUtils.parseSsrcMedia(line);
          })
          .filter(function (parts) {
            return parts.attribute === 'cname';
          });
        var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
        var secondarySsrc;

        var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
          .map(function (line) {
            var parts = line.substr(17).split(' ');
            return parts.map(function (part) {
              return parseInt(part, 10);
            });
          });
        if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
          secondarySsrc = flows[0][1];
        }

        description.codecs.forEach(function (codec) {
          if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
            var encParam = {
              ssrc: primarySsrc,
              codecPayloadType: parseInt(codec.parameters.apt, 10)
            };
            if (primarySsrc && secondarySsrc) {
              encParam.rtx = { ssrc: secondarySsrc };
            }
            encodingParameters.push(encParam);
            if (hasRed) {
              encParam = JSON.parse(JSON.stringify(encParam));
              encParam.fec = {
                ssrc: primarySsrc,
                mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
              };
              encodingParameters.push(encParam);
            }
          }
        });
        if (encodingParameters.length === 0 && primarySsrc) {
          encodingParameters.push({
            ssrc: primarySsrc
          });
        }

        // we support both b=AS and b=TIAS but interpret AS as TIAS.
        var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
        if (bandwidth.length) {
          if (bandwidth[0].indexOf('b=TIAS:') === 0) {
            bandwidth = parseInt(bandwidth[0].substr(7), 10);
          } else if (bandwidth[0].indexOf('b=AS:') === 0) {
            // use formula from JSEP to convert b=AS to TIAS value.
            bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
              - (50 * 40 * 8);
          } else {
            bandwidth = undefined;
          }
          encodingParameters.forEach(function (params) {
            params.maxBitrate = bandwidth;
          });
        }
        return encodingParameters;
      };

      // parses http://draft.ortc.org/#rtcrtcpparameters*
      SDPUtils.parseRtcpParameters = function (mediaSection) {
        var rtcpParameters = {};

        // Gets the first SSRC. Note tha with RTX there might be multiple
        // SSRCs.
        var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
          .map(function (line) {
            return SDPUtils.parseSsrcMedia(line);
          })
          .filter(function (obj) {
            return obj.attribute === 'cname';
          })[0];
        if (remoteSsrc) {
          rtcpParameters.cname = remoteSsrc.value;
          rtcpParameters.ssrc = remoteSsrc.ssrc;
        }

        // Edge uses the compound attribute instead of reducedSize
        // compound is !reducedSize
        var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
        rtcpParameters.reducedSize = rsize.length > 0;
        rtcpParameters.compound = rsize.length === 0;

        // parses the rtcp-mux attrіbute.
        // Note that Edge does not support unmuxed RTCP.
        var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
        rtcpParameters.mux = mux.length > 0;

        return rtcpParameters;
      };

      // parses either a=msid: or a=ssrc:... msid lines and returns
      // the id of the MediaStream and MediaStreamTrack.
      SDPUtils.parseMsid = function (mediaSection) {
        var parts;
        var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
        if (spec.length === 1) {
          parts = spec[0].substr(7).split(' ');
          return { stream: parts[0], track: parts[1] };
        }
        var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
          .map(function (line) {
            return SDPUtils.parseSsrcMedia(line);
          })
          .filter(function (msidParts) {
            return msidParts.attribute === 'msid';
          });
        if (planB.length > 0) {
          parts = planB[0].value.split(' ');
          return { stream: parts[0], track: parts[1] };
        }
      };

      // SCTP
      // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
      // to draft-ietf-mmusic-sctp-sdp-05
      SDPUtils.parseSctpDescription = function (mediaSection) {
        var mline = SDPUtils.parseMLine(mediaSection);
        var maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
        var maxMessageSize;
        if (maxSizeLine.length > 0) {
          maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
        }
        if (isNaN(maxMessageSize)) {
          maxMessageSize = 65536;
        }
        var sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
        if (sctpPort.length > 0) {
          return {
            port: parseInt(sctpPort[0].substr(12), 10),
            protocol: mline.fmt,
            maxMessageSize: maxMessageSize
          };
        }
        var sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
        if (sctpMapLines.length > 0) {
          var parts = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:')[0]
            .substr(10)
            .split(' ');
          return {
            port: parseInt(parts[0], 10),
            protocol: parts[1],
            maxMessageSize: maxMessageSize
          };
        }
      };

      // SCTP
      // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
      // support by now receiving in this format, unless we originally parsed
      // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
      // protocol of DTLS/SCTP -- without UDP/ or TCP/)
      SDPUtils.writeSctpDescription = function (media, sctp) {
        var output = [];
        if (media.protocol !== 'DTLS/SCTP') {
          output = [
            'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
            'c=IN IP4 0.0.0.0\r\n',
            'a=sctp-port:' + sctp.port + '\r\n'
          ];
        } else {
          output = [
            'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
            'c=IN IP4 0.0.0.0\r\n',
            'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n'
          ];
        }
        if (sctp.maxMessageSize !== undefined) {
          output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
        }
        return output.join('');
      };

      // Generate a session ID for SDP.
      // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
      // recommends using a cryptographically random +ve 64-bit value
      // but right now this should be acceptable and within the right range
      SDPUtils.generateSessionId = function () {
        return Math.random().toString().substr(2, 21);
      };

      // Write boilder plate for start of SDP
      // sessId argument is optional - if not supplied it will
      // be generated randomly
      // sessVersion is optional and defaults to 2
      // sessUser is optional and defaults to 'thisisadapterortc'
      SDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {
        var sessionId;
        var version = sessVer !== undefined ? sessVer : 2;
        if (sessId) {
          sessionId = sessId;
        } else {
          sessionId = SDPUtils.generateSessionId();
        }
        var user = sessUser || 'thisisadapterortc';
        // FIXME: sess-id should be an NTP timestamp.
        return 'v=0\r\n' +
          'o=' + user + ' ' + sessionId + ' ' + version +
          ' IN IP4 127.0.0.1\r\n' +
          's=-\r\n' +
          't=0 0\r\n';
      };

      SDPUtils.writeMediaSection = function (transceiver, caps, type, stream) {
        var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

        // Map ICE parameters (ufrag, pwd) to SDP.
        sdp += SDPUtils.writeIceParameters(
          transceiver.iceGatherer.getLocalParameters());

        // Map DTLS parameters to SDP.
        sdp += SDPUtils.writeDtlsParameters(
          transceiver.dtlsTransport.getLocalParameters(),
          type === 'offer' ? 'actpass' : 'active');

        sdp += 'a=mid:' + transceiver.mid + '\r\n';

        if (transceiver.direction) {
          sdp += 'a=' + transceiver.direction + '\r\n';
        } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
          sdp += 'a=sendrecv\r\n';
        } else if (transceiver.rtpSender) {
          sdp += 'a=sendonly\r\n';
        } else if (transceiver.rtpReceiver) {
          sdp += 'a=recvonly\r\n';
        } else {
          sdp += 'a=inactive\r\n';
        }

        if (transceiver.rtpSender) {
          // spec.
          var msid = 'msid:' + stream.id + ' ' +
            transceiver.rtpSender.track.id + '\r\n';
          sdp += 'a=' + msid;

          // for Chrome.
          sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
            ' ' + msid;
          if (transceiver.sendEncodingParameters[0].rtx) {
            sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
              ' ' + msid;
            sdp += 'a=ssrc-group:FID ' +
              transceiver.sendEncodingParameters[0].ssrc + ' ' +
              transceiver.sendEncodingParameters[0].rtx.ssrc +
              '\r\n';
          }
        }
        // FIXME: this should be written by writeRtpDescription.
        sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
          ' cname:' + SDPUtils.localCName + '\r\n';
        if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
          sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
            ' cname:' + SDPUtils.localCName + '\r\n';
        }
        return sdp;
      };

      // Gets the direction from the mediaSection or the sessionpart.
      SDPUtils.getDirection = function (mediaSection, sessionpart) {
        // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
        var lines = SDPUtils.splitLines(mediaSection);
        for (var i = 0; i < lines.length; i++) {
          switch (lines[i]) {
            case 'a=sendrecv':
            case 'a=sendonly':
            case 'a=recvonly':
            case 'a=inactive':
              return lines[i].substr(2);
            default:
            // FIXME: What should happen here?
          }
        }
        if (sessionpart) {
          return SDPUtils.getDirection(sessionpart);
        }
        return 'sendrecv';
      };

      SDPUtils.getKind = function (mediaSection) {
        var lines = SDPUtils.splitLines(mediaSection);
        var mline = lines[0].split(' ');
        return mline[0].substr(2);
      };

      SDPUtils.isRejected = function (mediaSection) {
        return mediaSection.split(' ', 2)[1] === '0';
      };

      SDPUtils.parseMLine = function (mediaSection) {
        var lines = SDPUtils.splitLines(mediaSection);
        var parts = lines[0].substr(2).split(' ');
        return {
          kind: parts[0],
          port: parseInt(parts[1], 10),
          protocol: parts[2],
          fmt: parts.slice(3).join(' ')
        };
      };

      SDPUtils.parseOLine = function (mediaSection) {
        var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
        var parts = line.substr(2).split(' ');
        return {
          username: parts[0],
          sessionId: parts[1],
          sessionVersion: parseInt(parts[2], 10),
          netType: parts[3],
          addressType: parts[4],
          address: parts[5]
        };
      };

      // a very naive interpretation of a valid SDP.
      SDPUtils.isValidSDP = function (blob) {
        if (typeof blob !== 'string' || blob.length === 0) {
          return false;
        }
        var lines = SDPUtils.splitLines(blob);
        for (var i = 0; i < lines.length; i++) {
          if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
            return false;
          }
          // TODO: check the modifier a bit more.
        }
        return true;
      };

      // Expose public methods.
      if (typeof module === 'object') {
        module.exports = SDPUtils;
      }

    }, {}]
  }, {}, [1])(1);
});// DBLURLRequest

function DBLURLRequest() {
  this.URL = "";
  this.parameters = "";
  this.method = "GET";
}

function MakeDBLURLRequest(theURL, theParameters, theMethod) {
  var n = new DBLURLRequest();
  n.URL = theURL;
  n.parameters = theParameters;
  n.method = theMethod;
  return n;
}

DBLURLRequest.prototype.send = function (success, failure, withCredentials = true) {
  var settings = {
    url: this.URL,
    type: this.method,
    contentType: "application/json;charset=utf-8",
    data: (this.method == "POST") ? JSON.stringify(this.parameters) : toQueryString(this.parameters),
    dataType: "json"
  };
  if (withCredentials) {
    settings.crossDomain = true;
    settings.xhrFields = {
      withCredentials: true
    };
  }
  var request = $.ajax(settings);
  request.done(success);
  request.fail(failure);
};

function toQueryString(obj, prefix) {
  var str = [];
  for (var p in obj) {
    var k = prefix ? prefix + "[" + p + "]" : p, v = obj[p];
    str.push(typeof v == "object" ? toQueryString(v, k) : encodeURIComponent(k) + "=" + encodeURIComponent(v));
  }
  return str.join("&");
}
// DBLHTTPClient

// API Endpoints
var kAPIBaseURL = "https://api." + ROOT_DOMAIN + "/api/v1/";
var kAPIEndpointUserLogin = "user/login/";
var kAPIEndpointUserLogout = "user/logout/";
var kAPIEndpointUserSignup = "user/signup/";
var kAPIEndpointUserForgot = "user/forgot/";
var kAPIEndpointUserSetPassword = "user/set_password/";
var kAPIEndpointUserMatch = "user/match/";
var kAPIEndpointUserData = "user/user_data/";
var kAPIEndpointUserSharedRobots = "user/shared_robots/";
var kAPIEndpointInstallationSave = "installation/save/";
var kAPIEndpointTLS = "tempuser/connect/";
var kAPIEndpointSessionStat = "call/log/";
var kAPIEndpointConfiguration = "configuration/";

var kAdminBaseURL = "https://admin." + ROOT_DOMAIN + "/";
var kAdminEndpointCalendarEvents = "calendar-data-events";

var sharedDBLHTTPClient;
var sharedAdminDBLHTTPClient;

function DBLHTTPClient() {
  this.baseURL = "";
}

function getSharedDBLHTTPClient() {
  if (!sharedDBLHTTPClient) {
    sharedDBLHTTPClient = MakeDBLHTTPClient(kAPIBaseURL);
  }
  return sharedDBLHTTPClient;
}

function getSharedAdminDBLHTTPClient() {
  if (!sharedAdminDBLHTTPClient) {
    sharedAdminDBLHTTPClient = MakeDBLHTTPClient(kAdminBaseURL);
  }
  return sharedAdminDBLHTTPClient;
}

function MakeDBLHTTPClient(URL) {
  var n = new DBLHTTPClient();
  n.baseURL = URL;
  return n;
}

DBLHTTPClient.prototype.defaultParameters = function () {
  var params = new Object();

  params.installation_key = getCurrentInstallation().getKey();
  params.app_version = APP_VERSION_NUM;
  params.app_build = APP_BUILD_NUM;
  params.driverMode = !IS_ROBOT_MODE;
  params.is_ipad = false;
  params.device_version = navigator.userAgent;

  if (currentUser && currentUser.isLoggedIn()) {
    params.username = currentUser.username;
  }

  var connectedToNode = socketIsConnected();
  params.node_connected = connectedToNode;
  if (!connectedToNode) {
    params.node_server = nodeServer;
    params.node_port = nodePort;
  }

  return params;
};

DBLHTTPClient.prototype.request = function (method, path, parameters) {

  jQuery.extend(parameters, getSharedDBLHTTPClient().defaultParameters());

  var request = MakeDBLURLRequest(this.baseURL + path, parameters, method);
  return request;
};
// DBLInstallation

var currentInstallation;

function DBLInstallation() {
  this.installation_key = "";
}

function MakeInstallation() {
  var n = new DBLInstallation();
  return n;
}

function getCurrentInstallation() {
  if (!currentInstallation) {
    currentInstallation = MakeInstallation();
  }

  // create installationId cookie
  var id = getCookie('installationId') || makeInstallationId();
  setCookie('installationId', id, {
    expires: 10000,
    secure: ('https:' == document.location.protocol),
    domain: kDRCookieDomain,
    sameSite: "None"
  });
  currentInstallation.installation_key = getCookie('installationId');

  return currentInstallation;
}

function makeInstallationId() {
  var text = "";
  var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

  for (var i = 0; i < 25; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }

  return text;
}

DBLInstallation.prototype.getKey = function () {
  return this.installation_key;
};

DBLInstallation.prototype.save = function () {
  var request = getSharedDBLHTTPClient().request("POST", kAPIEndpointInstallationSave, { installation_key: this.getKey() });
  request.send(function () {
    // success
    // console.log("successfully saved DBLInstallation");
  }, function () {
    // failure
    console.log("failed to save DBLInstallation");
  });
};
// DBLUser

var currentUser;

function DBLUser() {
  this.username = "";
  this.email = "";
  this.organization = "";
  this.displayName = "";
  this.idpType = "";
}

function MakeDBLUser() {
  var n = new DBLUser();
  return n;
}

function getCurrentUser() {
  if (!currentUser) {
    var dict = getCookie("user");
    if (dict && dict != null && dict != "null") {
      dict = JSON.parse(dict);
      currentUser = MakeDBLUser();
      currentUser.username = dict.username;
      currentUser.displayName = dict.displayName || null;
      currentUser.idpType = dict.idpType || null;
    }
    getCurrentUserData();
  }
  return currentUser;
}

function getCurrentUserData(callback) {
  if (!currentUser || !currentUser.isLoggedIn()) {
    if (callback) callback();
    return;
  }
  var request = getSharedDBLHTTPClient().request("GET", kAPIEndpointUserData);
  request.send((data) => {
    if (data.user_data) {
      currentUser.email = data.user_data.email;
      currentUser.displayName = data.user_data.displayName;
      currentUser.idpType = data.user_data.idpType;
    }
    if (callback) {
      callback();
    }
  }, (httpObj, data) => {
    if (httpObj.status == 401) {
      logOut();
    }
  });
}

function DBLUserMatch(e, success, fail) {
  var request = getSharedDBLHTTPClient().request("GET", kAPIEndpointUserMatch, { email: e });
  request.send(success, fail);
}

function DBLUserLogin(u, p) {
  var request = getSharedDBLHTTPClient().request("POST", kAPIEndpointUserLogin, { username: u, password: p });
  request.send((data) => {
    if (data.success == true) {
      DBLUserDidLogin(data.user_data);
    }
  }, (data) => {
    didLogOut();
    var dict = JSON.parse(data.responseText);
    nonModalAlert("Log In Failed", dict.reason);
  });
}

function DBLUserValidateUsername(value) {
  if (!value || value.length < 3) {
    return false;
  }
  const re = /^[a-z0-9_]+$/i;
  return re.test(value);
}

function DBLUserCreateAccount(u, e, p) {
  var request = getSharedDBLHTTPClient().request("POST", kAPIEndpointUserSignup, { username: u, email: e, password: p });
  request.send((data) => {
    if (data.success == true) {
      DBLUserDidLogin(data.user_data);
    }
  }, (data) => {
    didLogOut();
    switchToCreateAccount();
    var dict = JSON.parse(data.responseText);
    nonModalAlert("Create Account Failed", dict.reason);
  });
}

function DBLUserDidLogin(data) {
  currentUser = MakeDBLUser();
  currentUser.username = data.username;
  currentUser.displayName = data.displayName;
  currentUser.idpType = data.idpType;
  didLogin(true);
  getCurrentInstallation().save();
}

function DBLUserSendForgotPasswordLink(e) {
  var request = getSharedDBLHTTPClient().request("POST", kAPIEndpointUserForgot, { email: e });
  request.send((data) => {
    if (data.success == true) {
      switchToSetPassword();
    }
  }, (data) => {
    switchToForgot();
    var dict = JSON.parse(data.responseText);
    nonModalAlert("Failed", "Failed to send password reset link: " + dict.reason);
  });
}

function DBLUserSetPassword(token, p, p2) {
  var request = getSharedDBLHTTPClient().request("POST", kAPIEndpointUserSetPassword, { token: token, password: p, confirmPassword: p2 });
  request.send((data) => {
    if (data.success == true) {
      if (currentUser && currentUser.username) {
        // changing password while logged in
        logOut();
      } else {
        switchToLogin();
      }
    }
  }, (data) => {
    var dict = JSON.parse(data.responseText);
    nonModalAlert("Failed", "Failed to set password: " + dict.reason);
  });
}

DBLUser.prototype.logout = function (callback) {
  if (currentUser && currentUser.isLoggedIn()) {
    var request = getSharedDBLHTTPClient().request("GET", kAPIEndpointUserLogout, { format: "json" });
    request.send(function () {
      if (callback) {
        callback();
      }
    }, function () {
      if (callback) {
        callback();
      }
    }, true);
  }
};

DBLUser.prototype.isLoggedIn = function () {
  return (this.username != "");
};

DBLUser.prototype.canChangePassword = function () {
  return (this.username != "public" && this.username == this.displayName);
};

DBLUser.prototype.canHandleInvite = function () {
  return (this.isLoggedIn() && !this.idpType);
};

DBLUser.prototype.resolvedDisplayName = function () {
  return this.displayName || this.username;
};
// Map
// Note: I'm using self instead of this here, so I can reference myself in callbacks.

var kDRMapZoomMin = 3;
var kDRMapZoomMax = 11;

function RobotsMap() {
  var self = this;
  this.mapboxMap = null;
  self.tiles_url = "https://tiles." + ROOT_DOMAIN + "/{z}/{x}/{y}.png";

  $("#map").css({ "background-color": "#FFFFFF" });

  this.setupMapboxWithId = function (id) {
    self.mapboxMap = mapbox.map('map');

    // make mapbox compatible with SSL
    var public_url = /http:\/\/\w.tiles.mapbox.com\/v3\/doublerobotics.map-d252hjfc\//;
    mapbox.MAPBOX_URL = "https://api." + ROOT_DOMAIN + "/api/v1/map/jsonp/";
    mapbox.markers.marker_baseurl = "https://api." + ROOT_DOMAIN + "/api/v1/map/blank/";
    var tj = wax.tilejson;
    wax.tilejson = function (u, c) {
      tj(u, function (x) {
        for (var i in x) {
          if (typeof x[i] === 'string') x[i] = x[i].replace(public_url, mapbox.MAPBOX_URL);
          if (typeof x[i] === 'object') {
            for (var j in x[i]) {
              if (typeof x[i][j] === 'string') x[i][j] = self.tiles_url;
            }
          }
        }
        c(x);
      });
    };

    self.mapboxMap.addLayer(mapbox.layer().id('doublerobotics.map-d252hjfc'));
    self.mapboxMap.setZoomRange(kDRMapZoomMin, kDRMapZoomMax);
    self.mapboxMap.smooth(true);
    self.mapboxMap.ui.zoomer.remove();

    // zooming
    self.mapboxMap.addCallback("zoomed", function (theMap, zoomOffset) {
      updateZoomers();
      if (zoomOffset == undefined) { return; }
      if (robots.length > 0) {
        self.calculateMarkers();
      }
    });

    // panning
    self.mapboxMap.addCallback("panned", function (theMap, panOffset) {
      if (robots.length > 0) {
        window.clearTimeout(panTimeout);
        panTimeout = window.setTimeout(self.calculateMarkers, 200);
      }
    });

    if (robots.length > 0) {
      window.setTimeout(function () {
        self.calculateMarkers();
        var extent = markerLayer.extent();
        if (JSON.stringify(extent[0]["lat"]) == "null") {
          // don't zoom
        } else {
          self.mapboxMap.setExtent(extent);
        }
        updateZoomers();
        self.calculateMarkers();
      }, 50);
    } else {
      window.setTimeout(function () {
        self.mapboxMap.center({ lat: 38, lon: -25 }, false);
      }, 50);
    }

    return self.mapboxMap;
  };

  this.removeAllMarkers = function () {
    self.mapboxMap.removeLayer(markerLayer);
  };

  this.calculateMarkers = function () {
    var indexesInClusters = [];
    var clusters = [];
    var noLocationCluster = new Cluster();
    noLocationCluster.noLocation = true;

    for (var i = 0; i < robots.length; i++) {
      if (robots[i].longitude == 0 && robots[i].latitude == 0) {
        noLocationCluster.addRobot(robots[i]);
        indexesInClusters.push(i);
      } else {
        // check for nearby clusters
        for (var k = 0; k < clusters.length; k++) {
          if (indexesInClusters.indexOf(i) < 0) {
            var distance = distanceBetween(robots[i].getPoint(), clusters[k].getPoint());
            if (distance < kDRClusterDistance) {
              clusters[k].addRobot(robots[i]);
              indexesInClusters.push(i);
            }
          }
        }

        // check for nearby solo robots
        for (var k = 0; k < robots.length; k++) {
          if (i != k && indexesInClusters.indexOf(i) < 0 && indexesInClusters.indexOf(k) < 0) {
            var distance = robots[i].distanceTo(robots[k]);
            if (distance < kDRClusterDistance) {
              var n = ClusterWithSetup(robots[i], robots[k]);
              clusters.push(n);
              indexesInClusters.push(i);
              indexesInClusters.push(k);
            }
          }
        }
      }
    }

    var markers = [];
    // add solo robots
    for (var i = 0; i < robots.length; i++) {
      if (indexesInClusters.indexOf(i) < 0) {
        var m = MarkerWithRobot(robots[i]);
        markers.push(m);
      }
    }
    // add clusters
    for (var i = 0; i < clusters.length; i++) {
      var m = MarkerWithCluster(clusters[i]);
      markers.push(m);
    }

    // setup the obstacles
    var obstacles = markers.slice();
    // add the logo rect, so we don't overlap it
    obstacles.push(MakeRect($("#logo").offset().left, $("#logo").offset().top, $("#logo").outerWidth(), $("#logo").outerHeight()));
    obstacles.push(MakeRect($("#map").outerWidth() - 290, 0, 290, 50));

    // add the noLocation marker
    if (noLocationCluster.robots.length > 0) {
      var html = "";
      for (var i = 0; i < noLocationCluster.robots.length; i++) {
        var r = noLocationCluster.robots[i];
        html += r.getHTML();
      }
      $("#noLocationBubble").css("height", heightForNumberOfRobots(noLocationCluster.robots.length) + "px");
      $("#noLocationRobotsList").html(html);
      $("#noLocationBubble").show();

      // TODO: add it as an obstacle
      var o = $("#noLocationBubble");
      obstacles.push(MakeRect(o.offset().left, o.offset().top - 20, o.outerWidth(), o.outerHeight()));
    } else {
      $("#noLocationBubble").hide();
      $("#noLocationRobotsList").html("");
    }

    var clipsScreenBorder = false;

    for (var start = 0; start < markers.length; start++) {
      // close all of the bubbles
      for (var i = 0; i < markers.length; i++) {
        markers[i].closeBubble();
      }

      // try opening them all
      var anyClosed = false;
      for (var i = start; i < markers.length + start; i++) {
        var key = i % markers.length;
        clipsScreenBorder = markers[key].calculateBubbleWithObstacles(obstacles);
        if (!markers[key].isOpen && markers[key].isOnScreen()) {
          anyClosed = true;
        }
      }

      // keep trying different orders until one has them all open
      if (!anyClosed) {
        break;
      }
    }

    if (markers.length == 1 && clipsScreenBorder) {
      var rect = markers[0].getBubbleObstacleRectForDirection(markers[0].direction);
      // console.log("y adjust map view to show full bubble: "+ rect.x +", "+ rect.y +", "+ rect.width +", "+ rect.height);
      if (rect.y < 0 && rect.height + 50 < $("#map").outerHeight()) {
        // this.mapboxMap.panBy(0, -rect.y);
      }
    }

    self.addMarkers(markers);
  };

  this.addMarkers = function (theMarkers) {
    // Look for changes and return, if none
    if (Array.isArray(theMarkers) && Array.isArray(this.lastMarkers) && theMarkers.length == this.lastMarkers.length) {
      var different = false;
      for (var i = 0; i < theMarkers.length; i++) {
        if (JSON.stringify(theMarkers[i]) != JSON.stringify(this.lastMarkers[i]) || (calendarEvents && calendarEvents.length > 0)) {
          different = true;
        }
      }
      if (!different) {
        return;
      }
    }
    this.lastMarkers = theMarkers;

    self.mapboxMap.removeLayer(markerLayer);

    var mmMarkers = [];
    for (var i = 0; i < theMarkers.length; i++) {
      var m = theMarkers[i].getMarkerDictionary();
      mmMarkers.push(m);
    }

    markerLayer = mapbox.markers.layer().features(mmMarkers).factory(function (f) {
      // Define a new factory function. This takes a GeoJSON object
      // as its input and returns an element - in this case an image -
      // that represents the point.
      var div = document.createElement("div");
      div.className = "marker-container " + f["properties"]["direction"];

      var imageDiv = document.createElement("div");
      imageDiv.className = "marker-image";
      if (f["properties"]["isOpen"]) {
        imageDiv.className += " stem";
      }
      div.appendChild(imageDiv);

      var count = f["properties"]["numberOfRobots"];
      var bubbleHeightCSS = heightForNumberOfRobots(count);
      var bubbleTopCSS;
      var bubbleBottomCSS;
      if (f["properties"]["direction"] == "topLeft" || f["properties"]["direction"] == "topRight") {
        bubbleTopCSS = (20 + ((count - 1) * -kDRHeightPerRobot)) + "px";
        bubbleBottomCSS = "auto";
      } else {
        bubbleTopCSS = "auto";
        bubbleBottomCSS = (20 + ((count - 1) * -kDRHeightPerRobot)) + "px";
      }
      var html = "";
      var robots = f["properties"]["robots"];
      for (var i = 0; i < robots.length; i++) {
        var r = robots[i];
        html += r["html"];
      }
      html = "<ul class=\"robotsList\">" + html + "</ul>";

      var div2 = document.createElement("div");
      div2.className = "marker-bubble";
      div2.style.height = bubbleHeightCSS + "px";
      div2.style.top = bubbleTopCSS;
      div2.style.bottom = bubbleBottomCSS;
      div2.innerHTML = html;
      div.appendChild(div2);

      var spot = document.createElement("div");
      spot.className = "spot";
      spot.onclick = function () {
        if (div.className.indexOf(" collapsed") >= 0) {
          // it's already collapsed, so expand
          div.className = div.className.replace(" collapsed", "");
        } else {
          // expanded, so collapse it
          div.className += " collapsed";
        }
      };
      div.appendChild(spot);

      return div;
    });
    markerLayer.DRMarkersCount = theMarkers.length;
    self.mapboxMap.addLayer(markerLayer);
  };
}

var kDRHeightPerRobot = 60.0;

function heightForNumberOfRobots(x) {
  return (x * kDRHeightPerRobot) + 10.0;
}
// Battery Link

function DRBatteryButton() {
  this.parentElementId = null;
  this.canvasElement = null;

  this.barContentOffset = { "x": 0, "y": 0 };
  this.iPadBatteryLevel = 0;
  this.robotBatteryLevel = 0;
  this.supportsiPadMeter = false;
  this.fillColor = "rgba(0, 0, 0, 1)";
  this.secondaryFillColor = "rgba(255, 255, 255, 1)";
  this.lowFillColor = "rgba(255, 0, 0, 1)";
  this.shadowColor = "rgba(255, 255, 255, 1)";
  this.shadowOffset = { "width": 0, "height": 0 };
  this.strokeThickness = 2.0;
  this.barContentSize = { "width": 40.0, "height": 18.0 };
  this.verticalPaddingBetweenBars = 2.0;
  this.cornerRadius = 1.0;
  this.showChargingIcon = false;

  var self = this;
  window.setTimeout(function () {
    self.calculatebarContentOffset();
    self.redraw();
  }, 10);
}

function BatteryButtonWithParentId(theParent) {
  var n = new DRBatteryButton();
  n.parentElementId = theParent;
  n.redraw();
  return n;
}

DRBatteryButton.prototype.calculatebarContentOffset = function () {
  var parent = $("." + this.parentElementId);
  this.barContentOffset = {
    "x": (parent.outerWidth() / 2.0) - (this.barContentSize.width / 2.0),
    "y": (parent.outerHeight() / 2.0) - (this.barContentSize.height / 2.0)
  };
};

DRBatteryButton.prototype.redraw = function () {
  if (this.parentElementId == null) { return; }

  var p = $("." + this.parentElementId);
  p.html("");

  this.canvasElement = document.createElement("canvas");
  this.canvasElement.width = p.outerWidth();
  this.canvasElement.height = p.outerHeight();
  p.append(this.canvasElement);

  var context = this.canvasElement.getContext("2d");
  context.clearRect(0, 0, context.width, context.height);

  if (this.showChargingIcon) {
    this.drawChargingIconWithContext(context);

  } else {
    var shadow = (this.shadowOffset.width != 0 || this.shadowOffset.height != 0);
    if (shadow) {
      this.drawBorderWithContextColorOffset(context, this.shadowColor, this.shadowOffset);
    }
    this.drawBorderWithContextColorOffset(context, this.fillColor, { "width": 0, "height": 0 });

    if (this.supportsiPadMeter) {

      // draw 2 bars
      var barHeight = (this.barContentSize.height - this.verticalPaddingBetweenBars) / 2.0;

      // iPad bar
      var barRect = MakeRect(this.barContentOffset.x, this.barContentOffset.y, this.barContentSize.width, barHeight);
      if (shadow) {
        this.drawBarInRectWithLevelColorOffsetContext(barRect, this.iPadBatteryLevel, this.shadowColor, this.shadowOffset, context);
      }
      this.drawBarInRectWithLevelColorOffsetContext(
        barRect,
        this.iPadBatteryLevel,
        (this.iPadBatteryLevel <= 0.2) ? this.lowFillColor : this.fillColor,
        { "width": 0, "height": 0 },
        context);

      // robot bar
      barRect = MakeRect(this.barContentOffset.x, this.barContentOffset.y + this.barContentSize.height - barHeight, this.barContentSize.width, barHeight);
      if (shadow) {
        this.drawBarInRectWithLevelColorOffsetContext(barRect, this.robotBatteryLevel, this.shadowColor, this.shadowOffset, context);
      }
      this.drawBarInRectWithLevelColorOffsetContext(
        barRect,
        this.robotBatteryLevel,
        (this.robotBatteryLevel <= 0.2) ? this.lowFillColor : this.fillColor,
        { "width": 0, "height": 0 },
        context);

    } else {
      // draw 1 bar
      var barRect = MakeRect(this.barContentOffset.x, this.barContentOffset.y, this.barContentSize.width, this.barContentSize.height);
      if (shadow) {
        this.drawBarInRectWithLevelColorOffsetContext(barRect, this.robotBatteryLevel, this.shadowColor, this.shadowOffset, context);
      }
      this.drawBarInRectWithLevelColorOffsetContext(
        barRect,
        this.robotBatteryLevel,
        (this.robotBatteryLevel <= 0.2) ? this.lowFillColor : this.fillColor,
        { "width": 0, "height": 0 },
        context);
    }
  }

  var self = this;
  setTimeout(() => {
    var pMapCanvas = $("#map ." + self.parentElementId + " canvas");
    if (pMapCanvas.length == 1 && pMapCanvas != self.canvasElement) {
      var mapContext = pMapCanvas.get(0).getContext("2d");
      mapContext.clearRect(0, 0, mapContext.width, mapContext.height);
      var context = this.canvasElement.getContext("2d");
      mapContext.drawImage(context.canvas, 0, 0);
    }
  }, 100);
};

DRBatteryButton.prototype.drawBorderWithContextColorOffset = function (context, theColor, theOffset) {

  var borderRect = MakeRect(this.barContentOffset.x - (this.strokeThickness * 1.5),
    this.barContentOffset.y - (this.strokeThickness * 1.5),
    this.barContentSize.width + (this.strokeThickness * 3.0),
    this.barContentSize.height + (this.strokeThickness * 3.0));
  var nubRect = MakeRect(borderRect.x + borderRect.width,
    borderRect.y + (borderRect.height * 0.25),
    borderRect.width * 0.075,
    borderRect.height * 0.5);

  // TODO:DEBUG [theColor setStroke];
  context.strokeStyle = theColor;
  context.fillStyle = theColor;

  // add offset
  borderRect = MakeRect(theOffset.width + borderRect.x, theOffset.height + borderRect.y, borderRect.width, borderRect.height);
  nubRect = MakeRect(theOffset.width + nubRect.x, theOffset.height + nubRect.y, nubRect.width, nubRect.height);

  // draw border
  roundRect(context, borderRect.x, borderRect.y, borderRect.width, borderRect.height, this.cornerRadius);
  context.lineWidth = this.strokeThickness;
  context.stroke();

  // draw nub
  roundRect(context, nubRect.x, nubRect.y, nubRect.width, nubRect.height, this.cornerRadius);
  context.lineWidth = this.strokeThickness;
  context.fill();
};

DRBatteryButton.prototype.drawBarInRectWithLevelColorOffsetContext = function (theRect, theLevel, theColor, theOffset, context) {
  context.fillStyle = theColor;

  // draw the bar scaled to the current battery percent
  context.fillRect(theRect.x + theOffset.width,
    theRect.y + theOffset.height,
    theRect.width * theLevel,
    theRect.height);
};

DRBatteryButton.prototype.drawChargingIconWithContext = function (context) {
  // draw the icon centered on top
  var img = new Image();

  var self = this;
  img.onload = function () {
    var shadow = (self.shadowOffset.width != 0 || self.shadowOffset.height != 0);
    if (shadow) {
      self.drawBorderWithContextColorOffset(context, self.shadowColor, self.shadowOffset);
    }
    self.drawBorderWithContextColorOffset(context, self.fillColor, { "width": 0, "height": 0 });

    // fill it all in
    var barRect = MakeRect(self.barContentOffset.x - (self.strokeThickness * 1.5),
      self.barContentOffset.y - (self.strokeThickness * 1.5),
      self.barContentSize.width + (self.strokeThickness * 3.0),
      self.barContentSize.height + (self.strokeThickness * 3.0));
    self.drawBarInRectWithLevelColorOffsetContext(barRect, 1.0, self.fillColor, { "width": 0, "height": 0 }, context);

    // fill in the nub
    var nubRect = MakeRect(barRect.x + barRect.width,
      barRect.y + (barRect.height * 0.25),
      barRect.width * 0.1,
      barRect.height * 0.5);
    self.drawBarInRectWithLevelColorOffsetContext(nubRect, 1.0, self.fillColor, { "width": 0, "height": 0 }, context);

    var height = barRect.height * 0.6;
    var width = height * 2.0;
    var iconRect = MakeRect(barRect.x + barRect.width / 2.0 - width / 2.0,
      barRect.y + barRect.height / 2.0 - height / 2.0,
      width,
      height);

    // write the mask image
    var maskCanvas = document.createElement("canvas");
    maskCanvas.width = img.width;
    maskCanvas.height = img.height;
    var maskContext = maskCanvas.getContext("2d");
    maskContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, img.width, img.height);

    var tempCanvas = document.createElement("canvas");
    tempCanvas.width = img.width;
    tempCanvas.height = img.height;
    var tempContext = tempCanvas.getContext("2d");

    // draw the mask
    tempContext.save();
    tempContext.globalCompositeOperation = "copy";
    tempContext.drawImage(maskCanvas, 0, 0);
    tempContext.globalCompositeOperation = "source-in";
    tempContext.fillStyle = self.secondaryFillColor;
    tempContext.fillRect(0, 0, img.width, img.height);
    tempContext.restore();

    // context.drawImage(img, 0, 0, img.width, img.height, iconRect.x, iconRect.y, iconRect.width, iconRect.height);
    context.drawImage(tempCanvas, 0, 0, img.width, img.height, iconRect.x, iconRect.y, iconRect.width, iconRect.height);
  };

  img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAABQCAYAAACeXX40AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABTZJREFUeNrsnW1olWUYx3/TvbQ0owhCyjlNt15IGQwkwrAioSzEDLOioveiVypbtmgGEVHW8iX6UIGEhSL0odJeKLFajIoIY4hgmWlmSZmVVDjb6cN1PWw7O+fktvOc+zzn+f++bIqyc679zv2/7+u5n/upymQyCBGKMSqBkIBCAgohAYUEFEICCgkohAQsT5YDs1QGCRiK04Eu4CmgTuWQgCGoBtqAL4FWlUMChuIsoBt4AqhVOSRgqNGwHfgCaFE5JGAoZgCfAcuAGpVDAoagBuhwEWeoHBIwFC0eye0e0UIClpxaX5x0+2JFSMAgtGLtmjaNhhIwFHVY47oLa2QLCRiEWcBXwIOqvQQMxTHAMz4aTpeAIhTnAFuB+9L8e5CAYakHOoEtwGkSUIRito+GdwNVElCEYBywEtgMTJGAIhRzfDS8PQ2j4XAEPBd4ALgcu845Tq7ExnHAi8B7wORKfqPD6cx/CowFVgNn+9/9BHwDfOtfdw7486/yaNRcBHztH/xXgIo7R6VqBGfDVPtkeRkwocC/O5hDykjUHxNczLeBeQF+7rvALcAPaRcwYiLWUL16BHOVfwrIuRvolYA5+R3rG66RgIMnzasp3o6PI8D3WVIOFPXvFAsYsRG41ZMk9QJGsXyvx/L4mF/z3gJy/pYSAfH3eg+wVgIOjuXngMWB3s+BAtG+r8IEjHjTR8OfJWA/53ssn1lG7/WvAnLu8ehPooDRB+9OYJ0E7KfWY/mxEsTyaOkFduWI9h3Ad75oKmcBI94A7gD2S8B+TgWeBRYldJqS8dZHJOccynvjwH7gLmCDBBzMhR7L2hFcGta7iL+U84ss5bXgD4GZwMPAIfkRO1cCPcACjYBDafBYvkKelITXsJbNAQk4mLnAKqBJjsTOPuA24K20RnAu3sc2NjyCtUlEfEzEeoZrgBM0AuaO5U5su5eIl73YxoZ30j4CDmQ3sBC4GOvDifg4BdgEvAwcrxFwKHXAEo/mevkSK3uAm306JAGzmAysAObLk1jJAC9hN8z/KQGHcomLOE2uxMou4CbsxqjUzQELsQm7D6WD8PsBK5lG4APgBUp0z09VAh/XOhV4HrhMvsTKTuBG4CMJmJtLPZanJuC1Pg30YQ33Zp9KJOERD33Y9fulxNSnrUr4A6vrsXP3Hirz1fJs7DCiiLG+wIqEbPbvm4BJZfj6d/ho2CUBczPNY3leQgQsxLEDZGzCdg9F34fs2fV5jR8t5jy8UgSMmO9FakywgIU4OUvIaPScQulO5t/uo2G3BMwfy0s9lusqTMB81PiHLjvOm7FrwMXmX2w3UweDd4tLwKxYXold2qt0AQsxIU+cNzH6Vss24AbgcwmYnwUeyw0pFbAQk7BTWrMFbfSF0tFwxFf5jwOHJWD+iX07dqmpVgL+L7WeIM055psn5fk/PcB12BnYEjAP07G+1lwJOGJOzJJyYKRXA09iz0fplYD5WYjdQN8gAYvGGK9nE9am+UQCFma8x/L9JYjlNAg4YmvTyiGsXTMTuwAvJGAQtmMHQS6iws7ek4DJYgNwhrcUDqscEjBULLdhj1vdrHJIwFBsw44SuYoKOARSAiaXdVivazlHf3ybkIBFj+UlvlreonJIwJCxfAFwDcU7bVUCqgTDIgO8jl2071QsS8BQ/IFdQWkBPlY5JGAoerATU69VLEvAkLG8FjuQfYViWQKG4iD2FKNWtPFAAgZkK3AecD0JfXaHBKyMWH7VV8urFMv5SfN+QKERUEhAISSgkIBCSECRNv4bAId1XhcE12AOAAAAAElFTkSuQmCC";

};

function roundRect(ctx, x, y, width, height, radius) {
  if (typeof radius === "undefined") {
    radius = 5;
  }
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
}
// Utilities

/*!
* screenfull
* v1.0.2 - 2012-10-15
* https://github.com/sindresorhus/screenfull.js
* (c) Sindre Sorhus; MIT License
*/
(function (e, t) { "use strict"; var n = typeof Element != "undefined" && "ALLOW_KEYBOARD_INPUT" in Element, r = function () { var e, n, r = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "", "webkitfullscreenchange", "webkitfullscreenerror"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"]], i = 0, s = r.length, o = {}; for (; i < s; i++) { e = r[i]; if (e && e[1] in t) { for (i = 0, n = e.length; i < n; i++)o[r[0][i]] = e[i]; return o; } } return !1; }(), i = { request: function (e) { var i = r.requestFullscreen; e = e || t.documentElement, /5\.1[\.\d]* Safari/.test(navigator.userAgent) ? e[i]() : e[i](n && Element.ALLOW_KEYBOARD_INPUT); }, exit: function () { t[r.exitFullscreen](); }, toggle: function (e) { this.isFullscreen ? this.exit() : this.request(e); }, onchange: function () { }, onerror: function () { } }; if (!r) return e.screenfull = !1; Object.defineProperties(i, { isFullscreen: { get: function () { return !!t[r.fullscreenElement]; } }, element: { enumerable: !0, get: function () { return t[r.fullscreenElement]; } }, enabled: { enumerable: !0, get: function () { return t[r.fullscreenEnabled]; } } }), t.addEventListener(r.fullscreenchange, function (e) { i.onchange.call(i, e); }), t.addEventListener(r.fullscreenerror, function (e) { i.onerror.call(i, e); }), e.screenfull = i; })(window, document);

// US States
var usStates = [
  { "name": 'ALABAMA', "abbreviation": 'AL' },
  { "name": 'ALASKA', "abbreviation": 'AK' },
  { "name": 'AMERICAN SAMOA', "abbreviation": 'AS' },
  { "name": 'ARIZONA', "abbreviation": 'AZ' },
  { "name": 'ARKANSAS', "abbreviation": 'AR' },
  { "name": 'CALIFORNIA', "abbreviation": 'CA' },
  { "name": 'COLORADO', "abbreviation": 'CO' },
  { "name": 'CONNECTICUT', "abbreviation": 'CT' },
  { "name": 'DELAWARE', "abbreviation": 'DE' },
  { "name": 'DISTRICT OF COLUMBIA', "abbreviation": 'DC' },
  { "name": 'FEDERATED STATES OF MICRONESIA', "abbreviation": 'FM' },
  { "name": 'FLORIDA', "abbreviation": 'FL' },
  { "name": 'GEORGIA', "abbreviation": 'GA' },
  { "name": 'GUAM', "abbreviation": 'GU' },
  { "name": 'HAWAII', "abbreviation": 'HI' },
  { "name": 'IDAHO', "abbreviation": 'ID' },
  { "name": 'ILLINOIS', "abbreviation": 'IL' },
  { "name": 'INDIANA', "abbreviation": 'IN' },
  { "name": 'IOWA', "abbreviation": 'IA' },
  { "name": 'KANSAS', "abbreviation": 'KS' },
  { "name": 'KENTUCKY', "abbreviation": 'KY' },
  { "name": 'LOUISIANA', "abbreviation": 'LA' },
  { "name": 'MAINE', "abbreviation": 'ME' },
  { "name": 'MARSHALL ISLANDS', "abbreviation": 'MH' },
  { "name": 'MARYLAND', "abbreviation": 'MD' },
  { "name": 'MASSACHUSETTS', "abbreviation": 'MA' },
  { "name": 'MICHIGAN', "abbreviation": 'MI' },
  { "name": 'MINNESOTA', "abbreviation": 'MN' },
  { "name": 'MISSISSIPPI', "abbreviation": 'MS' },
  { "name": 'MISSOURI', "abbreviation": 'MO' },
  { "name": 'MONTANA', "abbreviation": 'MT' },
  { "name": 'NEBRASKA', "abbreviation": 'NE' },
  { "name": 'NEVADA', "abbreviation": 'NV' },
  { "name": 'NEW HAMPSHIRE', "abbreviation": 'NH' },
  { "name": 'NEW JERSEY', "abbreviation": 'NJ' },
  { "name": 'NEW MEXICO', "abbreviation": 'NM' },
  { "name": 'NEW YORK', "abbreviation": 'NY' },
  { "name": 'NORTH CAROLINA', "abbreviation": 'NC' },
  { "name": 'NORTH DAKOTA', "abbreviation": 'ND' },
  { "name": 'NORTHERN MARIANA ISLANDS', "abbreviation": 'MP' },
  { "name": 'OHIO', "abbreviation": 'OH' },
  { "name": 'OKLAHOMA', "abbreviation": 'OK' },
  { "name": 'OREGON', "abbreviation": 'OR' },
  { "name": 'PALAU', "abbreviation": 'PW' },
  { "name": 'PENNSYLVANIA', "abbreviation": 'PA' },
  { "name": 'PUERTO RICO', "abbreviation": 'PR' },
  { "name": 'RHODE ISLAND', "abbreviation": 'RI' },
  { "name": 'SOUTH CAROLINA', "abbreviation": 'SC' },
  { "name": 'SOUTH DAKOTA', "abbreviation": 'SD' },
  { "name": 'TENNESSEE', "abbreviation": 'TN' },
  { "name": 'TEXAS', "abbreviation": 'TX' },
  { "name": 'UTAH', "abbreviation": 'UT' },
  { "name": 'VERMONT', "abbreviation": 'VT' },
  { "name": 'VIRGIN ISLANDS', "abbreviation": 'VI' },
  { "name": 'VIRGINIA', "abbreviation": 'VA' },
  { "name": 'WASHINGTON', "abbreviation": 'WA' },
  { "name": 'WEST VIRGINIA', "abbreviation": 'WV' },
  { "name": 'WISCONSIN', "abbreviation": 'WI' },
  { "name": 'WYOMING', "abbreviation": 'WY' }
];

var countries = [
  { "abbreviation": "USA", "name": "United States of America" },
  { "abbreviation": "USA", "name": "USA" },
  { "abbreviation": "USA", "name": "U S A" },
  { "abbreviation": "AC", "name": "Ascension Island" },
  { "abbreviation": "AD", "name": "ANDORRA" },
  { "abbreviation": "AE", "name": "UNITED ARAB EMIRATES" },
  { "abbreviation": "AF", "name": "AFGHANISTAN" },
  { "abbreviation": "AG", "name": "ANTIGUA AND BARBUDA" },
  { "abbreviation": "AI", "name": "ANGUILLA" },
  { "abbreviation": "AL", "name": "ALBANIA" },
  { "abbreviation": "AM", "name": "ARMENIA" },
  { "abbreviation": "AN", "name": "NETHERLANDS ANTILLES" },
  { "abbreviation": "AO", "name": "ANGOLA" },
  { "abbreviation": "AQ", "name": "ANTARCTICA" },
  { "abbreviation": "AR", "name": "ARGENTINA" },
  { "abbreviation": "AS", "name": "AMERICAN SAMOA" },
  { "abbreviation": "AT", "name": "AUSTRIA" },
  { "abbreviation": "AU", "name": "AUSTRALIA" },
  { "abbreviation": "AW", "name": "ARUBA" },
  { "abbreviation": "AX", "name": "ÅLAND ISLANDS" },
  { "abbreviation": "AZ", "name": "AZERBAIJAN" },
  { "abbreviation": "BA", "name": "BOSNIA AND HERZEGOVINA" },
  { "abbreviation": "BB", "name": "BARBADOS" },
  { "abbreviation": "BD", "name": "BANGLADESH" },
  { "abbreviation": "BE", "name": "BELGIUM" },
  { "abbreviation": "BF", "name": "BURKINA FASO" },
  { "abbreviation": "BG", "name": "BULGARIA" },
  { "abbreviation": "BH", "name": "BAHRAIN" },
  { "abbreviation": "BI", "name": "BURUNDI" },
  { "abbreviation": "BJ", "name": "BENIN" },
  { "abbreviation": "BM", "name": "BERMUDA" },
  { "abbreviation": "BN", "name": "BRUNEI DARUSSALAM" },
  { "abbreviation": "BO", "name": "BOLIVIA" },
  { "abbreviation": "BR", "name": "BRAZIL" },
  { "abbreviation": "BS", "name": "THE BAHAMAS" },
  { "abbreviation": "BT", "name": "BHUTAN" },
  { "abbreviation": "BV", "name": "BOUVET ISLAND" },
  { "abbreviation": "BW", "name": "BOTSWANA" },
  { "abbreviation": "BY", "name": "BELARUS" },
  { "abbreviation": "BZ", "name": "BELIZE" },
  { "abbreviation": "CA", "name": "CANADA" },
  { "abbreviation": "CC", "name": "COCOS (KEELING) ISLANDS" },
  { "abbreviation": "CD", "name": "CONGO, THE DEMOCRATIC REPUBLIC OF THE" },
  { "abbreviation": "CF", "name": "CENTRAL AFRICAN REPUBLIC" },
  { "abbreviation": "CG", "name": "CONGO" },
  { "abbreviation": "CH", "name": "SWITZERLAND" },
  { "abbreviation": "CI", "name": "CÈTE D'IVOIRE" },
  { "abbreviation": "CK", "name": "COOK ISLANDS" },
  { "abbreviation": "CL", "name": "CHILE" },
  { "abbreviation": "CM", "name": "CAMEROON" },
  { "abbreviation": "CN", "name": "CHINA" },
  { "abbreviation": "CO", "name": "COLOMBIA" },
  { "abbreviation": "CR", "name": "COSTA RICA" },
  { "abbreviation": "CS", "name": "SERBIA AND MONTENEGRO" },
  { "abbreviation": "CU", "name": "CUBA" },
  { "abbreviation": "CV", "name": "CAPE VERDE" },
  { "abbreviation": "CX", "name": "CHRISTMAS ISLAND" },
  { "abbreviation": "CY", "name": "CYPRUS" },
  { "abbreviation": "CZ", "name": "CZECH REPUBLIC" },
  { "abbreviation": "DE", "name": "GERMANY" },
  { "abbreviation": "DJ", "name": "DJIBOUTI" },
  { "abbreviation": "DK", "name": "DENMARK" },
  { "abbreviation": "DM", "name": "DOMINICA" },
  { "abbreviation": "DO", "name": "DOMINICAN REPUBLIC" },
  { "abbreviation": "DZ", "name": "ALGERIA" },
  { "abbreviation": "EA", "name": "Ceuta, Melilla" },
  { "abbreviation": "EC", "name": "ECUADOR" },
  { "abbreviation": "EE", "name": "ESTONIA" },
  { "abbreviation": "EG", "name": "EGYPT" },
  { "abbreviation": "EH", "name": "WESTERN SAHARA" },
  { "abbreviation": "ER", "name": "ERITREA" },
  { "abbreviation": "ES", "name": "SPAIN" },
  { "abbreviation": "ET", "name": "ETHIOPIA" },
  { "abbreviation": "FI", "name": "FINLAND" },
  { "abbreviation": "FJ", "name": "FIJI" },
  { "abbreviation": "FK", "name": "FALKLAND ISLANDS (MALVINAS)" },
  { "abbreviation": "FM", "name": "MICRONESIA, FEDERATED STATES OF" },
  { "abbreviation": "FO", "name": "FAROE ISLANDS" },
  { "abbreviation": "FR", "name": "FRANCE" },
  { "abbreviation": "FX", "name": "FRANCE, METROPOLITAN" },
  { "abbreviation": "GA", "name": "GABON" },
  { "abbreviation": "GB", "name": "UNITED KINGDOM" },
  { "abbreviation": "GE", "name": "GEORGIA" },
  { "abbreviation": "GF", "name": "FRENCH GUIANA" },
  { "abbreviation": "GH", "name": "GHANA" },
  { "abbreviation": "GI", "name": "GIBRALTAR" },
  { "abbreviation": "GL", "name": "GREENLAND" },
  { "abbreviation": "GM", "name": "GAMBIA" },
  { "abbreviation": "GN", "name": "GUINEA" },
  { "abbreviation": "GP", "name": "GUADELOUPE" },
  { "abbreviation": "GQ", "name": "EQUATORIAL GUINEA" },
  { "abbreviation": "GR", "name": "GREECE" },
  { "abbreviation": "GS", "name": "S. GEORGIA & S. SANDW. IS." },
  { "abbreviation": "GT", "name": "GUATEMALA" },
  { "abbreviation": "GU", "name": "GUAM" },
  { "abbreviation": "HK", "name": "HONG KONG" },
  { "abbreviation": "HM", "name": "HEARD ISLAND AND MCDONALD ISLANDS" },
  { "abbreviation": "HN", "name": "HONDURAS" },
  { "abbreviation": "HR", "name": "CROATIA" },
  { "abbreviation": "HT", "name": "HAITI" },
  { "abbreviation": "HU", "name": "HUNGARY" },
  { "abbreviation": "IC", "name": "CANARY ISLANDS" },
  { "abbreviation": "ID", "name": "INDONESIA" },
  { "abbreviation": "IE", "name": "IRELAND" },
  { "abbreviation": "IL", "name": "ISRAEL" },
  { "abbreviation": "IM", "name": "ISLE OF MAN" },
  { "abbreviation": "IN", "name": "INDIA" },
  { "abbreviation": "IO", "name": "BRITISH INDIAN OCEAN TERRITORY" },
  { "abbreviation": "IQ", "name": "IRAQ" },
  { "abbreviation": "IR", "name": "IRAN, ISLAMIC REPUBLIC OF" },
  { "abbreviation": "IS", "name": "ICELAND" },
  { "abbreviation": "IT", "name": "ITALY" },
  { "abbreviation": "JE", "name": "JERSEY" },
  { "abbreviation": "JM", "name": "JAMAICA" },
  { "abbreviation": "JO", "name": "JORDAN" },
  { "abbreviation": "JP", "name": "JAPAN" },
  { "abbreviation": "KE", "name": "KENYA" },
  { "abbreviation": "KG", "name": "KYRGYZSTAN" },
  { "abbreviation": "KH", "name": "CAMBODIA" },
  { "abbreviation": "KI", "name": "KIRIBATI" },
  { "abbreviation": "KM", "name": "COMOROS" },
  { "abbreviation": "KN", "name": "SAINT KITTS AND NEVIS" },
  { "abbreviation": "KP", "name": "KOREA, DEMOCRATIC PEOPLE'S REPUBLIC OF" },
  { "abbreviation": "KR", "name": "KOREA, REPUBLIC OF" },
  { "abbreviation": "KW", "name": "KUWAIT" },
  { "abbreviation": "KY", "name": "CAYMAN ISLANDS" },
  { "abbreviation": "KZ", "name": "KAZAKSTAN" },
  { "abbreviation": "LA", "name": "LAO PEOPLE'S DEMOCRATIC REPUBLIC" },
  { "abbreviation": "LB", "name": "LEBANON" },
  { "abbreviation": "LC", "name": "SAINT LUCIA" },
  { "abbreviation": "LI", "name": "LIECHTENSTEIN" },
  { "abbreviation": "LK", "name": "SRI LANKA" },
  { "abbreviation": "LS", "name": "LESOTHO" },
  { "abbreviation": "LT", "name": "LITHUANIA" },
  { "abbreviation": "LU", "name": "LUXEMBOURG" },
  { "abbreviation": "LV", "name": "LATVIA" },
  { "abbreviation": "LY", "name": "LIBYAN ARAB JAMAHIRIYA" },
  { "abbreviation": "MA", "name": "MOROCCO" },
  { "abbreviation": "MC", "name": "MONACO" },
  { "abbreviation": "MD", "name": "MOLDOVA, REPUBLIC OF" },
  { "abbreviation": "ME", "name": "MONTENEGRO" },
  { "abbreviation": "MG", "name": "MADAGASCAR" },
  { "abbreviation": "MH", "name": "MARSHALL ISLANDS" },
  { "abbreviation": "MK", "name": "MACEDONIA, THE FORMER YUGOSLAV REPUBLIC OF" },
  { "abbreviation": "ML", "name": "MALI" },
  { "abbreviation": "MM", "name": "MYANMAR" },
  { "abbreviation": "MN", "name": "MONGOLIA" },
  { "abbreviation": "MO", "name": "MACAU" },
  { "abbreviation": "MP", "name": "NORTHERN MARIANA ISLANDS" },
  { "abbreviation": "MQ", "name": "MARTINIQUE" },
  { "abbreviation": "MR", "name": "MAURITANIA" },
  { "abbreviation": "MS", "name": "MONTSERRAT" },
  { "abbreviation": "MT", "name": "MALTA" },
  { "abbreviation": "MU", "name": "MAURITIUS" },
  { "abbreviation": "MV", "name": "MALDIVES" },
  { "abbreviation": "MW", "name": "MALAWI" },
  { "abbreviation": "MX", "name": "MEXICO" },
  { "abbreviation": "MY", "name": "MALAYSIA" },
  { "abbreviation": "MZ", "name": "MOZAMBIQUE" },
  { "abbreviation": "NA", "name": "NAMIBIA" },
  { "abbreviation": "NC", "name": "NEW CALEDONIA" },
  { "abbreviation": "NE", "name": "NIGER" },
  { "abbreviation": "NF", "name": "NORFOLK ISLAND" },
  { "abbreviation": "NG", "name": "NIGERIA" },
  { "abbreviation": "NI", "name": "NICARAGUA" },
  { "abbreviation": "NL", "name": "THE NETHERLANDS" },
  { "abbreviation": "NO", "name": "NORWAY" },
  { "abbreviation": "NP", "name": "NEPAL" },
  { "abbreviation": "NR", "name": "NAURU" },
  { "abbreviation": "NU", "name": "NIUE" },
  { "abbreviation": "NZ", "name": "NEW ZEALAND" },
  { "abbreviation": "OM", "name": "OMAN" },
  { "abbreviation": "PA", "name": "PANAMA" },
  { "abbreviation": "PE", "name": "PERU" },
  { "abbreviation": "PF", "name": "FRENCH POLYNESIA" },
  { "abbreviation": "PG", "name": "PAPUA NEW GUINEA" },
  { "abbreviation": "PH", "name": "THE PHILIPPINES" },
  { "abbreviation": "PK", "name": "PAKISTAN" },
  { "abbreviation": "PL", "name": "POLAND" },
  { "abbreviation": "PM", "name": "SAINT PIERRE AND MIQUELON" },
  { "abbreviation": "PN", "name": "PITCAIRN" },
  { "abbreviation": "PR", "name": "PUERTO RICO" },
  { "abbreviation": "PS", "name": "PALESTINIAN TERRITORY, OCCUPIED" },
  { "abbreviation": "PT", "name": "PORTUGAL" },
  { "abbreviation": "PW", "name": "PALAU" },
  { "abbreviation": "PY", "name": "PARAGUAY" },
  { "abbreviation": "QA", "name": "QATAR" },
  { "abbreviation": "RE", "name": "R+UNION" },
  { "abbreviation": "RO", "name": "ROMANIA" },
  { "abbreviation": "RS", "name": "SERBIA" },
  { "abbreviation": "RU", "name": "RUSSIAN FEDERATION" },
  { "abbreviation": "RW", "name": "RWANDA" },
  { "abbreviation": "SA", "name": "SAUDI ARABIA" },
  { "abbreviation": "SB", "name": "SOLOMON ISLANDS" },
  { "abbreviation": "SC", "name": "SEYCHELLES" },
  { "abbreviation": "SD", "name": "SUDAN" },
  { "abbreviation": "SE", "name": "SWEDEN" },
  { "abbreviation": "SG", "name": "SINGAPORE" },
  { "abbreviation": "SH", "name": "SAINT HELENA" },
  { "abbreviation": "SI", "name": "SLOVENIA" },
  { "abbreviation": "SJ", "name": "SVALBARD AND JAN MAYEN" },
  { "abbreviation": "SK", "name": "SLOVAKIA" },
  { "abbreviation": "SL", "name": "SIERRA LEONE" },
  { "abbreviation": "SM", "name": "SAN MARINO" },
  { "abbreviation": "SN", "name": "SENEGAL" },
  { "abbreviation": "SO", "name": "SOMALIA" },
  { "abbreviation": "SR", "name": "SURINAME" },
  { "abbreviation": "ST", "name": "SAO TOME AND PRINCIPE" },
  { "abbreviation": "SV", "name": "EL SALVADOR" },
  { "abbreviation": "SY", "name": "SYRIAN ARAB REPUBLIC" },
  { "abbreviation": "SZ", "name": "SWAZILAND" },
  { "abbreviation": "TA", "name": "Tristan da Cunha" },
  { "abbreviation": "TC", "name": "TURKS AND CAICOS ISLANDS" },
  { "abbreviation": "TD", "name": "CHAD" },
  { "abbreviation": "TF", "name": "FRENCH SOUTHERN TERRITRIES" },
  { "abbreviation": "TG", "name": "TOGO" },
  { "abbreviation": "TH", "name": "THAILAND" },
  { "abbreviation": "TJ", "name": "TAJIKISTAN" },
  { "abbreviation": "TK", "name": "TOKELAU" },
  { "abbreviation": "TL", "name": "TIMOR-LESTE" },
  { "abbreviation": "TM", "name": "TURKMENISTAN" },
  { "abbreviation": "TN", "name": "TUNISIA" },
  { "abbreviation": "TO", "name": "TONGA" },
  { "abbreviation": "TP", "name": "EAST TIMOR" },
  { "abbreviation": "TR", "name": "TURKEY" },
  { "abbreviation": "TT", "name": "TRINIDAD AND TOBAGO" },
  { "abbreviation": "TV", "name": "TUVALU" },
  { "abbreviation": "TW", "name": "TAIWAN" },
  { "abbreviation": "TZ", "name": "TANZANIA, UNITED REPUBLIC OF" },
  { "abbreviation": "UA", "name": "UKRAINE" },
  { "abbreviation": "UG", "name": "UGANDA" },
  { "abbreviation": "UY", "name": "URUGUAY" },
  { "abbreviation": "UZ", "name": "UZBEKISTAN" },
  { "abbreviation": "VA", "name": "HOLY SEE (VATICAN)" },
  { "abbreviation": "VC", "name": "SAINT VINCENT AND THE GRENADINES" },
  { "abbreviation": "VE", "name": "VENEZUELA" },
  { "abbreviation": "VG", "name": "VIRGIN ISLANDS, BRITISH" },
  { "abbreviation": "VI", "name": "VIRGIN ISLANDS, U.S." },
  { "abbreviation": "VN", "name": "VIET NAM" },
  { "abbreviation": "VU", "name": "VANUATU" },
  { "abbreviation": "WF", "name": "WALLIS AND FUTUNA" },
  { "abbreviation": "WS", "name": "SAMOA" },
  { "abbreviation": "YE", "name": "YEMEN" },
  { "abbreviation": "YT", "name": "MAYOTTE" },
  { "abbreviation": "YU", "name": "YUGOSLAVIA" },
  { "abbreviation": "ZA", "name": "SOUTH AFRICA" },
  { "abbreviation": "ZW", "name": "ZIMBABWE" }
];

function stateAbbreviationFromName(name) {
  for (var i = 0; i < usStates.length; i++) {
    if (usStates[i].name.toLowerCase() == name.toLowerCase()) {
      return usStates[i].abbreviation;
    }
  }
  return name;
}

function countryAbbreviationFromName(name) {
  for (var i = 0; i < countries.length; i++) {
    if (countries[i].name.toLowerCase() == name.toLowerCase()) {
      return countries[i].abbreviation;
    }
  }
  return name;
}

function roundToPlaces(value, places) {
  return Math.round(value * Math.pow(10, places)) / Math.pow(10, places);
}

function radMod(radians) {
  return radians % (Math.PI * 2);
}

function distanceBetween(a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function angleFromOnePointToAnother(firstPoint, secondPoint) {
  return Math.atan2(firstPoint.y - secondPoint.y, firstPoint.x - secondPoint.x);
}

function radiansToDegrees(radians) {
  return radians * 180 / Math.PI;
}

function degreesToRadians(degrees) {
  return degrees * Math.PI / 180;
}

function degToRad(degrees) {
  return degrees * Math.PI / 180;
}

function radToDeg(radians) {
  return radians * 180 / Math.PI;
}

function geocodeCacheKeyForLatLng(lat, lng) {
  if (isNaN(parseFloat(lat)) || isNaN(parseFloat(lng))) {
    return null;
  }
  return btoa(unescape(encodeURIComponent(parseFloat(lat).toFixed(2) + "," + parseFloat(lng).toFixed(2)))).replace(/=/g, "");
}

function reverseGeocodeLatLng(locationId, lat, lng) {
  // console.log("cache = ", geocoderCache, locationId, lat, lng);

  if (isNaN(parseFloat(lat)) || isNaN(parseFloat(lng))) {
    return;
  }

  if (lat == 0 && lng == 0) {
    window.setTimeout(function () {
      $("." + locationId).html("Location not available");
    }, 10);
  } else {
    var key = geocodeCacheKeyForLatLng(lat, lng);

    document.querySelectorAll("." + locationId).forEach((el) => {
      el.classList.add("geocoder_" + key);
    });

    if (geocoderCache[key]) {
      // console.log("pulled from cache: "+ locationId +" = "+ geocoderCache[key]);
      window.setTimeout(function () {
        document.querySelectorAll("." + locationId).forEach((el) => {
          el.classList.add("geocoder_" + key);
        });
        $(".geocoder_" + key).html(geocoderCache[key]);
      }, 1);
      return;
    }

    if (typeof google !== "undefined" && !geocoder) {
      geocoder = new google.maps.Geocoder();
    } else {
      window.setTimeout(() => {
        reverseGeocodeLatLng(locationId, lat, lng);
      }, 1000);
      return;
    }

    if (geocoderCache[key] != " ") {
      var latlng = new google.maps.LatLng(lat, lng);
      geocoderCache[key] = " ";
      geocoder.geocode({ 'latLng': latlng }, function (results, status) {
        if (status == google.maps.GeocoderStatus.OK) {
          for (var i = 0; i < results.length; i++) {
            if (results[i] && results[i].types && results[i].types.indexOf("locality") >= 0) {
              var string = results[i].formatted_address;
              string = string.replace(", USA", "");
              geocoderCache[key] = string;
              $(".geocoder_" + key).html(geocoderCache[key]);
              // console.log("Got reverse geocode string");
              break;
            }
          }
        } else {
          // console.log("Geocoder failed due to: " + status);
        }
      });
    }
  }
}

// Mouse lock

// The element we'll make fullscreen and pointer locked.
var elem = null;
var turnTimeout;

document.addEventListener("mousemove", function (e) {
  if ((document.mozPointerLockElement === elem || document.webkitPointerLockElement === elem) && (elem)) {
    var movementX = e.movementX ||
      e.mozMovementX ||
      e.webkitMovementX ||
      0,
      movementY = e.movementY ||
        e.mozMovementY ||
        e.webkitMovementY ||
        0;

    // Print the mouse movement delta values
    // console.log("movementX=" + movementX, "movementY=" + movementY);

    if (movementX < 0) {
      leftState = 1;
      rightState = 0;
    } else if (movementX > 0) {
      leftState = 0;
      rightState = 1;
    }

    window.clearTimeout(turnTimeout);
    turnTimeout = window.setTimeout(function () {
      leftState = 0;
      rightState = 0;
    }, 300);

  } else {
    // we're not in pointer lock mode
  }
}, false);

function fullscreenChange() {
  if (document.webkitFullscreenElement === elem ||
    document.mozFullscreenElement === elem ||
    document.mozFullScreenElement === elem) { // Older API upper case 'S'.
    // Element is fullscreen, now we can request pointer lock
    elem.requestPointerLock = elem.requestPointerLock ||
      elem.mozRequestPointerLock ||
      elem.webkitRequestPointerLock;
    elem.requestPointerLock();
  }
}

// document.addEventListener('fullscreenchange', fullscreenChange, false);
// document.addEventListener('mozfullscreenchange', fullscreenChange, false);
// document.addEventListener('webkitfullscreenchange', fullscreenChange, false);

function pointerLockChange() {
  if (document.mozPointerLockElement === elem ||
    document.webkitPointerLockElement === elem) {
    console.log("Pointer Lock was successful.");
  } else {
    console.log("Pointer Lock was lost.");
  }
}

// document.addEventListener('pointerlockchange', pointerLockChange, false);
// document.addEventListener('mozpointerlockchange', pointerLockChange, false);
// document.addEventListener('webkitpointerlockchange', pointerLockChange, false);

function pointerLockError() {
  console.log("Error while locking pointer.");
}

// document.addEventListener('pointerlockerror', pointerLockError, false);
// document.addEventListener('mozpointerlockerror', pointerLockError, false);
// document.addEventListener('webkitpointerlockerror', pointerLockError, false);

function lockPointer() {
  elem = document.getElementById("session");
  // Start by going fullscreen with the element.  Current implementations
  // require the element to be in fullscreen before requesting pointer
  // lock--something that will likely change in the future.
  elem.requestFullscreen = elem.requestFullscreen ||
    elem.mozRequestFullscreen ||
    elem.mozRequestFullScreen || // Older API upper case 'S'.
    elem.webkitRequestFullscreen;
  elem.requestFullscreen();
}

function getBrowserDetails() {
  var nVer = navigator.appVersion;
  var nAgt = navigator.userAgent;
  var browserName = navigator.appName;
  var fullVersion = '' + parseFloat(navigator.appVersion);
  var majorVersion = parseInt(navigator.appVersion, 10);
  var nameOffset, verOffset, ix;

  // In Opera, the true version is after "Opera" or after "Version"
  if ((verOffset = nAgt.indexOf("Opera")) != -1) {
    browserName = "Opera";
    fullVersion = nAgt.substring(verOffset + 6);
    if ((verOffset = nAgt.indexOf("Version")) != -1)
      fullVersion = nAgt.substring(verOffset + 8);
  }
  // In MSIE, the true version is after "MSIE" in userAgent
  else if ((verOffset = nAgt.indexOf("MSIE")) != -1) {
    browserName = "Microsoft Internet Explorer";
    fullVersion = nAgt.substring(verOffset + 5);
  }
  // In Chrome, the true version is after "Chrome"
  else if ((verOffset = nAgt.indexOf("Chrome")) != -1) {
    browserName = "Chrome";
    fullVersion = nAgt.substring(verOffset + 7);
  }
  // In Safari, the true version is after "Safari" or after "Version"
  else if ((verOffset = nAgt.indexOf("Safari")) != -1) {
    browserName = "Safari";
    fullVersion = nAgt.substring(verOffset + 7);
    if ((verOffset = nAgt.indexOf("Version")) != -1)
      fullVersion = nAgt.substring(verOffset + 8);
  }
  // In Firefox, the true version is after "Firefox"
  else if ((verOffset = nAgt.indexOf("Firefox")) != -1) {
    browserName = "Firefox";
    fullVersion = nAgt.substring(verOffset + 8);
  }
  // In most other browsers, "name/version" is at the end of userAgent
  else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) <
    (verOffset = nAgt.lastIndexOf('/'))) {
    browserName = nAgt.substring(nameOffset, verOffset);
    fullVersion = nAgt.substring(verOffset + 1);
    if (browserName.toLowerCase() == browserName.toUpperCase()) {
      browserName = navigator.appName;
    }
  }
  // trim the fullVersion string at semicolon/space if present
  if ((ix = fullVersion.indexOf(";")) != -1)
    fullVersion = fullVersion.substring(0, ix);
  if ((ix = fullVersion.indexOf(" ")) != -1)
    fullVersion = fullVersion.substring(0, ix);

  majorVersion = parseInt('' + fullVersion, 10);
  if (isNaN(majorVersion)) {
    fullVersion = '' + parseFloat(navigator.appVersion);
    majorVersion = parseInt(navigator.appVersion, 10);
  }

  // This script sets OSName variable as follows:
  // "Windows"    for all versions of Windows
  // "MacOS"      for all versions of Macintosh OS
  // "Linux"      for all versions of Linux
  // "UNIX"       for all other UNIX flavors
  // "Unknown OS" indicates failure to detect the OS

  var OSName = "Unknown OS";
  if (navigator.appVersion.indexOf("Win") != -1) OSName = "Windows";
  if (navigator.appVersion.indexOf("Mac") != -1) OSName = "MacOS";
  if (navigator.appVersion.indexOf("X11") != -1) OSName = "UNIX";
  if (navigator.appVersion.indexOf("Linux") != -1) OSName = "Linux";

  var out = {
    browser: browserName,
    fullVersion: fullVersion,
    majorVersion: majorVersion,
    app: navigator.appName,
    userAgent: navigator.userAgent,
    os: OSName
  };
  return out;
}

Date.createFromMysqlUTC = function (mysql_string) {
  if (typeof mysql_string === 'string') {
    var t = mysql_string.split(/[-T:]/);
    return new Date(Date.UTC(t[0], t[1] - 1, t[2], t[3], t[4], t[5]));
  }
  return null;
};
// Robot

function Robot() {
  this.longitude = 0.0;
  this.latitude = 0.0;
  this.dictionary = {};
}

function RobotWithSetup(lon, lat, d) {
  var n = new Robot();
  n.longitude = (lon) ? lon : 0;
  n.latitude = (lat) ? lat : 0;
  n.dictionary = d;
  return n;
}

Robot.prototype.getLocation = function () {
  return {
    "lon": this.longitude,
    "lat": this.latitude
  };
};

Robot.prototype.getPoint = function () {
  return mapboxMap.locationPoint(this.getLocation());
};

Robot.prototype.getMarker = function () {
  return {
    "geometry": { "type": "Point", "coordinates": [this.longitude, this.latitude] },
    "properties": { "image": "images/marker.png" }
  };
};

Robot.prototype.distanceTo = function (other) {
  var a = this.getPoint();
  var b = other.getPoint();
  return distanceBetween(a, b);
};

Robot.prototype.getDictionary = function () {
  var d = this.dictionary;
  d["html"] = this.getHTML();
  return d;
};

Robot.prototype.getHTML = function () {
  var serial = this.dictionary.serial || "Serial Not Found";
  var newHtml = "<li title=\"" + serial + "\">";
  if (this.dictionary.status == kDRRobotStatusInUse) {
    newHtml += "<div class=\"link disabled\">";
  } else {
    newHtml += "<div class=\"link\" onclick=\"connectTo('" + this.dictionary.installationId + "');\">";
  }
  newHtml += "<img src=\"images/";
  var inUseText = "";
  if (this.dictionary.missingRobot) {
    newHtml += "robot-missing-icon@2x.png";
  } else {
    switch (this.dictionary.status) {
      case kDRRobotStatusAvailable:
        newHtml += "robot-available-icon@2x.png";
        break;
      case kDRRobotStatusInUse:
        newHtml += "robot-inuse-icon@2x.png";
        inUseText = $("#stringInUse").html();
        break;
      case kDRRobotStatusAway:
        newHtml += "robot-away-icon@2x.png";
        break;
    }
  }
  newHtml += "\" width=\"48\" height=\"64\" class=\"status\" />";
  newHtml += "<h2>" + this.dictionary.nickname + "</h2>";
  var locationId = "location" + this.dictionary.installationId;
  var lat = roundToPlaces(this.dictionary.latitude, 5);
  var lng = roundToPlaces(this.dictionary.longitude, 5);
  newHtml += "<h3>";

  var eventFound = false;
  for (var i = 0; i < calendarEvents.length; i++) {
    var e = calendarEvents[i];
    if (e.serial && e.serial == this.dictionary.serial) {
      var start = Date.createFromMysqlUTC(e.start);
      var end = Date.createFromMysqlUTC(e.end);
      var now = new Date();
      if (now < start) {
        var amPm = "AM";
        var hours = start.getHours();
        if (hours >= 12) {
          amPm = "PM";
          hours -= 12;
        }
        var minutes = start.getMinutes();
        if (minutes < 10) {
          minutes = "0" + minutes;
        }
        var str = "Reserved " + hours + ":" + minutes + " " + amPm + " (" + e.username + ")";
        newHtml += "<span class=\"badge\">" + str + "</span>";
        eventFound = true;
        break;
      } else if (now < end) {
        var str = "Reserved Now (" + e.username + ")";
        newHtml += "<span class=\"badge\">" + str + "</span>";
        eventFound = true;
        break;
      }
    }
  }

  if (!eventFound && this.dictionary.is_public) {
    newHtml += "<span class=\"badge\">" + $("#stringPublic").html() + "</span>";
  }
  if (!eventFound) {
    newHtml += "<span class=\"location " + locationId + "\">" + inUseText + "</span>";
  }
  newHtml += "</h3>"; // "+ lat +", "+ lng +"
  newHtml += "<div class='battery robotsListBattery" + this.dictionary.installationId + "'></div>";
  newHtml += "<div class='battery light robotsListBatteryLight" + this.dictionary.installationId + "'></div>";
  newHtml += "</div>";
  newHtml += "</li>";

  if (!this.dictionary.missingRobot) {
    var b = BatteryButtonWithParentId("robotsListBattery" + this.dictionary.installationId);
    b.robotBatteryLevel = this.dictionary.robotBatteryPercent;
    if (this.dictionary.hasOwnProperty("iPadBatteryPercent") && this.dictionary.iPadBatteryPercent >= 0) {
      b.iPadBatteryLevel = this.dictionary.iPadBatteryPercent;
      b.supportsiPadMeter = true;
    } else {
      b.iPadBatteryLevel = 0;
      b.supportsiPadMeter = false;
    }
    b.showChargingIcon = this.dictionary.robotIsCharging;
    b.barContentSize = { "width": 28.0, "height": 10.0 };
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      // dark mode
      b.fillColor = "rgba(180, 180, 180, 1.0)";
    } else {
      b.fillColor = "rgba(40, 40, 40, 1.0)";
    }
    if (this.dictionary.robotIsCharging) {
      if (this.dictionary.robotIsFullyCharged == 1) {
        b.fillColor = kDRGreenColor;
      } else {
        b.fillColor = kDROrangeColor;
      }
    }
    b.redraw();

    b = BatteryButtonWithParentId("robotsListBatteryLight" + this.dictionary.installationId);
    b.robotBatteryLevel = this.dictionary.robotBatteryPercent;
    b.iPadBatteryLevel = this.dictionary.iPadBatteryPercent;
    if (this.dictionary.hasOwnProperty("iPadBatteryPercent") && this.dictionary.iPadBatteryPercent >= 0) {
      b.iPadBatteryLevel = this.dictionary.iPadBatteryPercent;
      b.supportsiPadMeter = true;
    } else {
      b.iPadBatteryLevel = 0;
      b.supportsiPadMeter = false;
    }
    b.showChargingIcon = this.dictionary.robotIsCharging;
    b.barContentSize = { "width": 28.0, "height": 10.0 };
    b.fillColor = "white";
    b.secondaryFillColor = "#1A9CFC";
    b.redraw();
  }

  if (this.dictionary.status != kDRRobotStatusInUse) {
    if (this.dictionary.locationLabel) {
      window.setTimeout(() => {
        document.querySelectorAll("." + locationId).forEach((el) => {
          el.innerText = this.dictionary.locationLabel;
        });
      }, 100);
    } else {
      reverseGeocodeLatLng(locationId, lat, lng);
    }
  }

  return newHtml;
};// Marker

var kDRMaxObstacleDistance = 600.0;

var kDRDirectionNone = 0;
var kDRDirectionTopLeft = 1;
var kDRDirectionTopRight = 2;
var kDRDirectionBottomRight = 3;
var kDRDirectionBottomLeft = 4;
var kDRDirectionTop = 5;
var kDRDirectionRight = 6;
var kDRDirectionBottom = 7;
var kDRDirectionLeft = 8;

function Marker() {
  this.isCluster = false;
  this.robots = [];
  this.longitude = 0.0;
  this.latitude = 0.0;
  this.isOpen = false;
  this.direction = kDRDirectionNone;
  this.closedWidth = 40.0;
  this.closedHeight = 40.0;
  this.openWidth = 360.0 + 90.0;
  this.openHeight = 0.0;
}

function MarkerWithSetup(isCluster) {
  var n = new Marker();
  n.isCluster = isCluster;
  return n;
}

function MarkerWithRobot(robot) {
  var n = new Marker();
  n.isCluster = false;
  n.longitude = robot.longitude;
  n.latitude = robot.latitude;
  n.addRobot(robot);
  return n;
}

function MarkerWithCluster(cluster) {
  var n = new Marker();
  n.isCluster = true;
  n.longitude = cluster.longitude;
  n.latitude = cluster.latitude;
  for (var i = 0; i < cluster.getRobots().length; i++) {
    n.addRobot(cluster.getRobots()[i]);
  }
  return n;
}

Marker.prototype.getLocation = function () {
  return {
    "lon": this.longitude,
    "lat": this.latitude
  };
};

Marker.prototype.getPoint = function () {
  return mapboxMap.locationPoint(this.getLocation());
};

Marker.prototype.addRobot = function (r) {
  this.robots.push(r);
};

Marker.prototype.setIsCluster = function (tf) {
  this.isCluster = tf;
};

Marker.prototype.getOpenHeight = function () {
  return this.getOpenCSSHeight() + 10;
};

Marker.prototype.getOpenCSSHeight = function () {
  return this.robots.length * 74;
};

Marker.prototype.closeBubble = function () {
  this.isOpen = false;
  this.direction = kDRDirectionNone;
};

Marker.prototype.isOnScreen = function () {
  var mapRect = MakeRect(0, 0, $("#map").outerWidth(), $("#map").outerHeight());
  return mapRect.containsPoint(this.getPoint());
};

Marker.prototype.getMarkerDictionary = function () {
  return {
    "geometry": { "type": "Point", "coordinates": [this.longitude, this.latitude] },
    "properties": {
      "image": (this.isOpen) ? "images/marker-stem.png" : "images/marker.png",
      "isOpen": this.isOpen,
      "direction": this.directionClass(),
      "numberOfRobots": this.robots.length,
      "robots": this.getRobotDictionaries()
    }
  };
};

Marker.prototype.getRobotDictionaries = function () {
  var out = [];
  for (var i = 0; i < this.robots.length; i++) {
    var r = this.robots[i];
    out.push(r.getDictionary());
  }
  return out;
};

Marker.prototype.getObstacleRect = function () {
  return this.getObstacleRectForDirection(this.direction);
};

Marker.prototype.getObstacleRectForDirection = function (dir) {
  var rect;
  if (this.isOpen == false && dir == this.direction) {
    rect = MakeRect(
      this.getPoint().x - this.closedWidth / 2,
      this.getPoint().y - this.closedHeight / 2,
      this.closedWidth,
      this.closedHeight
    );
  } else {
    var h = this.getOpenHeight();
    switch (dir) {
      case kDRDirectionTopLeft:
        rect = MakeRect(
          this.getPoint().x - this.openWidth + this.closedWidth / 2,
          this.getPoint().y - h + this.closedHeight / 2,
          this.openWidth,
          h
        );
        break;
      case kDRDirectionTopRight:
        rect = MakeRect(
          this.getPoint().x - this.closedWidth / 2,
          this.getPoint().y - h + this.closedHeight / 2,
          this.openWidth,
          h
        );
        break;
      case kDRDirectionBottomRight:
        rect = MakeRect(
          this.getPoint().x - this.closedWidth / 2,
          this.getPoint().y - this.closedHeight / 2,
          this.openWidth,
          h
        );
        break;
      case kDRDirectionBottomLeft:
        rect = MakeRect(
          this.getPoint().x - this.openWidth + this.closedWidth / 2,
          this.getPoint().y - this.closedWidth / 2,
          this.openWidth,
          h
        );
        break;
    }
  }
  return rect;
};

Marker.prototype.getBubbleObstacleRectForDirection = function (dir) {
  var rect;
  var horOffset = 68.0;
  var verOffset = 40.0;
  var w = 360.0;
  var h = this.getOpenCSSHeight();
  var x = this.getPoint().x;
  var y = this.getPoint().y;
  switch (dir) {
    case kDRDirectionTopLeft:
      rect = MakeRect(
        x - horOffset - w,
        y - verOffset - h,
        w,
        h
      );
      break;
    case kDRDirectionTopRight:
      rect = MakeRect(
        x + horOffset,
        y - verOffset - h,
        w,
        h
      );
      break;
    case kDRDirectionBottomRight:
      rect = MakeRect(
        x + horOffset,
        y + verOffset,
        w,
        h
      );
      break;
    case kDRDirectionBottomLeft:
      rect = MakeRect(
        x - horOffset - w,
        y + verOffset,
        w,
        h
      );
      break;
  }
  return rect;
};

Marker.prototype.directionClass = function () {
  var classes = [
    "noBubble",
    "topLeft",
    "topRight",
    "bottomRight",
    "bottomLeft",
    "top",
    "right",
    "bottom",
    "left"
  ];
  return classes[this.direction];
};

Marker.prototype.getQuadrants = function () {
  var point = this.getPoint();
  var x = point.x;
  var y = point.y;
  var w = $("#map").outerWidth();
  var h = $("#map").outerHeight();
  var quadrants = [];
  quadrants[kDRDirectionNone] = MakeRect(0, 0, 0, 0);
  quadrants[kDRDirectionTopLeft] = MakeRect(0, 0, x, y);
  quadrants[kDRDirectionTopRight] = MakeRect(x, 0, w - x, y);
  quadrants[kDRDirectionBottomRight] = MakeRect(x, y, w - x, h - y);
  quadrants[kDRDirectionBottomLeft] = MakeRect(0, y, x, h - y);
  quadrants[kDRDirectionTop] = MakeRect(0, 0, w, y);
  quadrants[kDRDirectionRight] = MakeRect(x, 0, w - x, h);
  quadrants[kDRDirectionBottom] = MakeRect(0, y, w, h - y);
  quadrants[kDRDirectionLeft] = MakeRect(0, 0, x, h);
  return quadrants;
};

Marker.prototype.getQuadrantsBySize = function () {
  // get quadrants sorted by size, biggest first
  var quads = this.getQuadrants();
  var quadsBySize = [];
  for (var i = kDRDirectionTopLeft; i <= kDRDirectionBottomLeft; i++) {
    var n = new Object();
    n.direction = i;
    n.rect = quads[i];
    quadsBySize.push(n);
  }
  quadsBySize.sort(function (a, b) {
    if (this.direction == a || a.rect.getArea() > b.rect.getArea()) {
      return -1;
    }
    if (this.direction == b || a.rect.getArea() < b.rect.getArea()) {
      return 1;
    }
    return 0;
  });
  return quads;
};

Marker.prototype.getQuadrantsByFarFromObstacles = function (obstacles) {
  var angleTotal = 0;
  var weightTotal = 0;
  var mapRect = MakeRect(0, 0, $("#map").outerWidth(), $("#map").outerHeight());
  for (var i = 0; i < obstacles.length; i++) {
    if (obstacles[i] != this && !(obstacles[i] instanceof Rect) && mapRect.containsPoint(obstacles[i].getPoint())) {
      // the obstacle isn't me and it's on screen
      var v = VectorBetweenPoints(this.getPoint(), obstacles[i].getPoint());
      if (v.distance < kDRMaxObstacleDistance) {
        angleTotal += v.getRadians() * (kDRMaxObstacleDistance - v.distance);
        weightTotal += kDRMaxObstacleDistance - v.distance;
      }
    }
  }
  var averageRadians = angleTotal / weightTotal;
  var averageDegrees = radiansToDegrees(averageRadians);
  // var oppositeDegrees = (averageDegrees - 180) % 360;
  var oppositeDegrees = averageDegrees % 360;
  if (oppositeDegrees < 0) {
    oppositeDegrees = 360 + oppositeDegrees;
  }

  var out = [];
  var quads = this.getQuadrants();
  var tr = MakeQuadrant(kDRDirectionTopRight, quads[kDRDirectionTopRight]);
  var br = MakeQuadrant(kDRDirectionBottomRight, quads[kDRDirectionBottomRight]);
  var tl = MakeQuadrant(kDRDirectionTopLeft, quads[kDRDirectionTopLeft]);
  var bl = MakeQuadrant(kDRDirectionBottomLeft, quads[kDRDirectionBottomLeft]);
  if (oppositeDegrees <= 90) {
    out.push(tr);
    out.push(br);
    out.push(tl);
    out.push(bl);
  } else if (oppositeDegrees <= 180) {
    out.push(br);
    out.push(tr);
    out.push(bl);
    out.push(tl);
  } else if (oppositeDegrees <= 270) {
    out.push(bl);
    out.push(tl);
    out.push(br);
    out.push(tr);
  } else {
    out.push(tl);
    out.push(bl);
    out.push(tr);
    out.push(br);
  }

  return out;
};

Marker.prototype.calculateBubbleWithObstacles = function (obstacles) {
  // check if center of marker is on screen
  var mapRect = MakeRect(0, 0, $("#map").outerWidth(), $("#map").outerHeight());
  // if (!mapRect.containsPoint(this.getPoint())) {
  // 	this.direction = kDRDirectionNone;
  // 	this.isOpen = false;
  // 	return false;
  // }

  // var quads = this.getQuadrantsBySize();
  var quads = this.getQuadrantsByFarFromObstacles(obstacles);

  // check obstacles
  for (var i = 0; i < quads.length; i++) {
    var rect = this.getBubbleObstacleRectForDirection(quads[i].direction);
    var intersects = false;
    for (var k = 0; k < obstacles.length; k++) {
      var obstacle = obstacles[k];
      if (obstacle != this) {
        if (rect.intersectsRect(obstacle.getObstacleRect())) {
          intersects = true;
          break;
        }
      }
    }

    // check to make sure the whole bubble is on screen
    if (!mapRect.containsRect(rect)) {
      intersects = true;
    }

    if (!intersects) {
      this.direction = quads[i].direction;
      this.isOpen = true;
      return false;
    }
  }

  // this.isOpen = false;
  // this.direction = kDRDirectionNone;
  this.isOpen = true;
  this.direction = quads[0].direction;
  return true;
};
// Rect

function Rect() {
  this.x = 0;
  this.y = 0;
  this.width = 0;
  this.height = 0;
}

function MakeRect(x, y, w, h) {
  var n = new Rect();
  n.x = x;
  n.y = y;
  n.width = w;
  n.height = h;
  return n;
}

Rect.prototype.reset = function () {
  this.x = 0;
  this.y = 0;
  this.width = 0;
  this.height = 0;
};

Rect.prototype.getArea = function () {
  return this.width * this.height;
};

Rect.prototype.intersectsRect = function (rect) {
  var thisRight = this.x + this.width;
  var thisBottom = this.y + this.height;
  var rectRight = rect.x + rect.width;
  var rectBottom = rect.y + rect.height;
  return (this.x <= rectRight &&
    rect.x <= thisRight &&
    this.y <= rectBottom &&
    rect.y <= thisBottom);
};

Rect.prototype.containsPoint = function (point) {
  return (point.x >= this.x
    && point.x <= this.x + this.width
    && point.y >= this.y
    && point.y <= this.y + this.height);
};

Rect.prototype.containsRect = function (rect) {
  return (rect.x >= this.x
    && rect.y >= this.y
    && rect.x + rect.width <= this.x + this.width
    && rect.y + rect.height <= this.y + this.height);
};

Rect.prototype.getObstacleRect = function () {
  return this;
};

Rect.prototype.getPoint = function () {
  return { "x": this.x + this.width / 2, "y": this.y + this.height / 2 };
};// Cluster

function Cluster() {
  this.robots = [];
  this.longitude = 0.0;
  this.latitude = 0.0;
  this.noLocation = false;
}

function ClusterWithSetup(a, b) {
  var n = new Cluster();
  n.addRobot(a);
  n.addRobot(b);
  return n;
}

Cluster.prototype.addRobot = function (r) {
  if (this.robots.indexOf(r) < 0) {
    this.robots.push(r);
  }
  this.recalculateLocation();
};

Cluster.prototype.getLocation = function () {
  return {
    "lon": this.longitude,
    "lat": this.latitude
  };
};

Cluster.prototype.getPoint = function () {
  return mapboxMap.locationPoint(this.getLocation());
};

Cluster.prototype.recalculateLocation = function () {
  var lon = 0.0;
  var lat = 0.0;
  for (var i = 0; i < this.robots.length; i++) {
    lon += this.robots[i].longitude;
    lat += this.robots[i].latitude;
  }
  this.longitude = lon / this.robots.length;
  this.latitude = lat / this.robots.length;
};

Cluster.prototype.getMarker = function () {
  return {
    "geometry": { "type": "Point", "coordinates": [this.longitude, this.latitude] },
    "properties": { "image": "images/marker.png" }
  };
};

Cluster.prototype.getRobots = function () {
  return this.robots;
};// Quadrant

function Quadrant() {
  this.direction = 0;
  this.frame = MakeRect(0, 0, 0, 0);
}

function MakeQuadrant(direction, frame) {
  var n = new Quadrant();
  n.direction = direction;
  n.frame = frame;
  return n;
}

// Vector

function Vector() {
  this.angle = 0;
  this.distance = 0;
}

function MakeVector(angle, distance) {
  var n = new Object();
  n.angle = angle;
  n.distance = distance;
  return n;
}

function VectorBetweenPoints(a, b) {
  var n = new Vector();
  n.angle = radiansToDegrees(angleFromOnePointToAnother(a, b)) + 90.0; // make 0 point vertical
  n.distance = distanceBetween(a, b);
  return n;
}

Vector.prototype.getRadians = function () {
  return degreesToRadians(this.angle);
};// Video

// opentok
var opentokScreenSharingPublisher = null;
var opentokHardwareSetupComponent = null;
var opentokExceptionListenerAdded = false;

var smoothedMicLevel = 0;
var micSmoothingFactor = 0.8;

function videoIsSupported() {
  if (typeof OT === "undefined") {
    return "RTCPeerConnection" in window;
  }
  return OT.checkSystemRequirements();
}

function opentokConnect() {
  if (typeof OT === "undefined") {
    endSession();
    return;
  }
  OT.setLogLevel(OT.WARN);
  if (!opentokExceptionListenerAdded) {
    OT.addEventListener("exception", exceptionHandler);
    opentokExceptionListenerAdded = true;
  }
  opentokSession = OT.initSession(opentokSessionId);	// Initialize session

  // Add event listeners to the session
  opentokSession.on('sessionConnected', sessionConnectedHandler);
  opentokSession.on('sessionDisconnected', sessionDisconnectedHandler);
  opentokSession.on('connectionCreated', connectionCreatedHandler);
  opentokSession.on('connectionDestroyed', connectionDestroyedHandler);
  opentokSession.on('streamCreated', streamCreatedHandler);
  opentokSession.on('streamDestroyed', streamDestroyedHandler);
  opentokSession.on('streamPropertyChanged', streamPropertyChangedHandler);

  opentokSession.connect(opentokAPIKey, opentokSessionToken);
}

function opentokDisconnect() {
  opentokStopPublishing();
  opentokStopScreenSharing();
  if (opentokSession) {
    opentokSession.disconnect();
  }
  sessionIsMultipartyHost = false;
  sessionIsViewer = false;
  opentokSubscriber = undefined;
  opentokPublisher = undefined;
  opentokScreenSharingPublisher = undefined;
  opentokViewSubscribers = [];
  opentokSession = undefined;
}

function percentForCoordinates(x, y) {
  var videoWidth = $("#videoOverlay").height() * 0.75;
  var videoOriginX = ($("#videoOverlay").width() / 2.0) - videoWidth / 2.0;
  if (cameraKitEnabled) {
    videoOriginX = 0.0;
    videoWidth = $("#videoOverlay").height();
  }
  var xPercent = Math.min(1.0, Math.max(0.0, (x - videoOriginX) / videoWidth));
  var yPercent = Math.min(1.0, Math.max(0.0, y / window.innerHeight));
  return [xPercent, yPercent];
}

function sendZoom() {
  if (zoomLevel && nextZoomCenter) {
    // Camera Kit
    nextZoomCenter[0] = Math.min(1.0, Math.max(0.0, nextZoomCenter[0]));
    nextZoomCenter[1] = Math.min(1.0, Math.max(0.0, nextZoomCenter[1]));
    var x = nextZoomCenter[0];
    var y = nextZoomCenter[1];
    if (!isUsingCameraKit()) {
      // iPad camera
      x = Math.min(1.0, Math.max(0.0, 1.0 - nextZoomCenter[1]));
      y = Math.min(1.0, Math.max(0.0, nextZoomCenter[0]));
    }
    sendCommandWithData(kDRCommandZoom, { "zoom": zoomLevel, "center": [x.toFixed(4), y.toFixed(4)] });
  }

  if (zoomLevel == 1.0) {
    $("#resetZoomButton").fadeOut();
  } else {
    $("#resetZoomButton").fadeIn();
  }

  zoomCenter = nextZoomCenter;
  nextZoomCenter = null;
}

// Called when user wants to start publishing to the session
function opentokStartPublishing(audioOnly) {
  // check if cookie devices still exist
  navigator.mediaDevices.enumerateDevices().then(function (devices) {
    var foundVideo = false;
    var foundAudio = false;
    for (var i = 0; i < devices.length; i++) {
      var d = devices[i];
      if (d.deviceId == opentokVideoSourceDeviceId) {
        foundVideo = true;
        opentokVideoSourceDeviceName = d.label;
      }
      if (d.deviceId == opentokAudioSourceDeviceId) {
        foundAudio = true;
        opentokAudioSourceDeviceName = d.label;
      }
    }
    if (!foundVideo) {
      console.log("Saved video device not found, so reverting to default.");
      opentokVideoSourceDeviceId = null;
      for (var i = 0; i < devices.length; i++) {
        var d = devices[i];
        if (d.kind == "videoinput" && d.deviceId != "default") {
          opentokVideoSourceDeviceId = d.deviceId;
          opentokVideoSourceDeviceName = d.label;
          break;
        }
      }
    }
    if (!foundAudio) {
      console.log("Saved audio device not found, so reverting to default.");
      opentokAudioSourceDeviceId = null;
      for (var i = 0; i < devices.length; i++) {
        var d = devices[i];
        if (d.kind == "audioinput" && d.deviceId != "default") {
          opentokAudioSourceDeviceId = d.deviceId;
          opentokAudioSourceDeviceName = d.label;
          break;
        }
      }
    }
    saveSettings();
    opentokStartPublishingFinish(audioOnly);
  });
}

function opentokStartPublishingFinish(audioOnly) {
  if (!opentokPublisher) {
    zoomLevel = 1.0;
    nextZoomCenter = [0.5, 0.5];
    var parentDiv = document.getElementById("myCamera");
    var publisherDiv = document.createElement('div'); // Create a div for the publisher to replace
    var publisherProperties = {
      publishAudio: true,
      publishVideo: true,
      fitMode: "contain",
      resolution: "640x480",
      frameRate: 15,
      style: {
        showMicButton: false,
        showSettingsButton: false,
        showCameraToggleButton: false,
        showOpentokButton: false,
        nameDisplayMode: "off",
        buttonDisplayMode: "off",
        audioLevelDisplayMode: "off"
      },
      name: "webdriver",
      fitMode: "cover",
      data: "driver"// ,
      // 			constraints: {
      // 				video: true,
      // 				audio: {
      // 					optional: [
      // 						{googAutoGainControl: false},
      // 						{googAutoGainControl2: false},
      // 						{googEchoCancellation: false},
      // 						{googEchoCancellation2: false},
      // 						{googNoiseSuppression: false},
      // 						{googNoiseSuppression2: false},
      // 						{googHighpassFilter: false},
      // 						{googTypingNoiseDetection: false},
      // 						{googAudioMirroring: false}
      // 					]
      // 				}
      // },
    };
    if (opentokAudioSourceDeviceId) {
      publisherProperties.audioSource = opentokAudioSourceDeviceId;
    }
    if (opentokVideoSourceDeviceId) {
      publisherProperties.videoSource = opentokVideoSourceDeviceId;
    }
    if (IS_ROBOT_MODE) {
      publisherProperties.resolution = "1280x720";
      publisherProperties.width = 1280;
      publisherProperties.height = 720;
    }
    if (audioOnly) {
      publisherProperties.publishAudio = true;
      publisherProperties.publishVideo = false;
      publisherProperties.name = "multipartyAudio";
    }
    if (sessionIsViewer) {
      publisherDiv.setAttribute('id', 'opentok_publisher_viewer');
      parentDiv = document.getElementById("myCameraViewer");
    } else {
      publisherDiv.setAttribute('id', 'opentok_publisher');
    }
    parentDiv.appendChild(publisherDiv);
    opentokPublisher = OT.initPublisher(publisherDiv.id, publisherProperties, function (err) {
      if (err && err.name === 'OT_CHROME_MICROPHONE_ACQUISITION_ERROR') {
        nonModalAlert("Microphone Failed", "Failed to acquire microphone. Please completely quit and restart your browser.");
      }
    });
    if (isMuted) {
      opentokPublisher.publishAudio(false);
    }
    opentokSession.publish(opentokPublisher);
    opentokPublisher.addEventListener("streamCreated", publisherStreamCreated);
    opentokPublisher.addEventListener("accessDialogOpened", publisherAccessDialogOpened);
    opentokPublisher.addEventListener("accessAllowed", publisherAccessAllowed);
    opentokPublisher.addEventListener("accessDenied", publisherAccessDenied);
    opentokPublisher.addEventListener("accessDialogClosed", publisherAccessAllowed);

    if (audioOnly) {

    } else {
      opentokPublisher.on('audioLevelUpdated', function (event) {
        if (opentokPublisher && opentokPublisher.stream && opentokPublisher.stream.hasAudio) {
          smoothedMicLevel = Math.max(event.audioLevel, smoothedMicLevel * micSmoothingFactor + event.audioLevel * (1.0 - micSmoothingFactor));
          lastMicPeak = Math.max(smoothedMicLevel, lastMicPeak);
          $("#localVideo .audioLevel").fadeIn(100);
          $("#localVideo .audioLevel .bar").width(Math.round(smoothedMicLevel * 100) + "%");
        } else {
          lastMicPeak = 0;
          $("#localVideo .audioLevel .bar").width("0%");
          $("#localVideo .audioLevel").fadeOut(100);
        }
      });

      $("#videoOverlay").dblclick(function (e) {
        // check for toolbar
        if (e.pageY < 70 || !remoteRobotSupports("zoom")) {
          return;
        }

        // check for over video
        var w = $(window).width();
        var h = $(window).height();
        var videoWidth = h * 0.75;
        var videoMinX = Math.round(w / 2 - videoWidth / 2);
        var videoMaxX = Math.round(w / 2 + videoWidth / 2);
        if (cameraKitEnabled) {

        } else {
          if (e.pageX < videoMinX || e.pageX >= videoMaxX) {
            return;
          }
        }

        if (zoomLevel >= 2.0) {
          // reset
          zoomLevel = 1.0;
          nextZoomCenter = [0.5, 0.5];
        } else {
          zoomLevel += 1.0;
          var newPoint = percentForCoordinates(e.pageX, e.pageY);
          var deltaX = (newPoint[0] - 0.5) / (zoomLevel - 1);
          var deltaY = (newPoint[1] - 0.5) / (zoomLevel - 1);
          nextZoomCenter = [zoomCenter[0] + deltaX, zoomCenter[1] + deltaY];
        }
        sendZoom();
      });

      $("#videoOverlay").mousedown(function (e) {
        var mouseDownPoint = percentForCoordinates(e.pageX, e.pageY);
        var centerPointWhenMouseDown = zoomCenter;

        // long press
        if (zoomLevel == 1) {
          longPressTimeout = window.setTimeout(function () {
            if (remoteRobotSupports("exposurePoint") || (remoteRobotSupports("cameraKitIsConnected") && !cameraKitEnabled)) {
              sendCommandWithData(kDRCommandFocusOnPoint, { "point": { "x": mouseDownPoint[1], "y": mouseDownPoint[0] } });
              $("#resetExposureButton").fadeIn();
            }
          }, 1000);
        }

        $(window).mousemove(function (e) {
          window.clearTimeout(longPressTimeout);
          if (zoomLevel > 1.0) {
            var newPoint = percentForCoordinates(e.pageX, e.pageY);
            var deltaX = (newPoint[0] - mouseDownPoint[0]) / (zoomLevel - 1);
            var deltaY = (newPoint[1] - mouseDownPoint[1]) / (zoomLevel - 1);
            nextZoomCenter = [centerPointWhenMouseDown[0] - deltaX, centerPointWhenMouseDown[1] - deltaY];
          }
        });
      })
        .mouseup(function () {
          window.clearTimeout(longPressTimeout);
          $(window).unbind("mousemove");
        });
    }
  }
}

function resetZoom() {
  zoomLevel = 1.0;
  nextZoomCenter = [0.5, 0.5];
  sendZoom();
}

function resetExposure() {
  if (remoteRobotSupports("exposurePoint") || (remoteRobotSupports("cameraKitIsConnected") && !cameraKitEnabled)) {
    sendCommandWithData(kDRCommandFocusOnPoint, { "point": { "x": 0.5, "y": 0.5 } });
    $("#resetExposureButton").fadeOut();
  }
}

function screenSharingIsActive() {
  return (opentokScreenSharingPublisher != null);
}

function opentokStartScreenSharing() {
  OT.checkScreenSharingCapability(function (response) {
    if (!response.supported || response.extensionRegistered === false) {
      nonModalAlert("Not Available", "Screen sharing is not available on this device.");
    } else {
      opentokFinishStartingScreenSharing();
    }
  });
}

function opentokFinishStartingScreenSharing() {
  hideWebPage();

  // publish screen sharing
  var screenSharingPublisherProperties = {
    videoSource: 'screen',
    publishAudio: false,
    publishVideo: true,
    fitMode: "contain",
    insertMode: "append",
    name: "screen"
  };
  $("#screenSharingContainer").show();
  opentokScreenSharingPublisher = opentokSession.publish("opentok_screenSharing_publisher", screenSharingPublisherProperties);

  $("#myCamera").removeClass("myCameraStandard");
  $("#myCamera").addClass("myCameraWhileScreenSharing");

  updateUserInterface();
  repeatCenterRemoteVideo();
}

function opentokStopScreenSharing() {
  $("#screenSharingContainer").hide();
  if (opentokScreenSharingPublisher) {
    opentokSession.unpublish(opentokScreenSharingPublisher);
  }
  opentokScreenSharingPublisher = null;

  $("#myCamera").removeClass("myCameraWhileScreenSharing");
  $("#myCamera").addClass("myCameraStandard");

  updateUserInterface();
}

function opentokToggleScreenSharing() {
  if (opentokScreenSharingPublisher) {
    opentokStopScreenSharing();
  } else {
    opentokStartScreenSharing();
  }
}

function opentokStopPublishing() {
  $(window).unbind("mousemove");
  $("#videoOverlay").unbind("mousedown");
  $("#videoOverlay").unbind("mouseup");
  $("#videoOverlay").unbind("dblclick");

  opentokStopScreenSharing();
  if (opentokPublisher) {
    opentokPublisher.off('audioLevelUpdated');
    opentokSession.unpublish(opentokPublisher);
  }
  opentokPublisher = null;
}

//--------------------------------------
//  OPENTOK EVENT HANDLERS
//--------------------------------------

function sessionConnectedHandler(event) {
  // Subscribe to all streams currently in the Session
  if (event && event.streams) {
    for (var i = 0; i < event.streams.length; i++) {
      addStream(event.streams[i]);
    }
  }

  opentokStartPublishing(sessionIsViewer);
}

function streamCreatedHandler(event) {
  // Subscribe to the newly created streams
  for (var i = 0; i < event.streams.length; i++) {
    OT.log("streamCreated - connectionId: " + event.streams[i].connection.connectionId);
    OT.log("streamCreated - connectionData: " + event.streams[i].connection.data);
    addStream(event.streams[i]);
    hideHoverMessage();

    if (opentokSubscriber && opentokSubscriber.stream && event.streams[i].streamId == opentokSubscriber.stream.streamId) {
      window.setTimeout(function () {
        $("#remoteVideoOverlay").fadeIn();
      }, 2000);
    } else {
      // probably a viewer
      console.log("streamCreatedHandler viewer published audio: ", event.stream);
    }
  }
}

function streamDestroyedHandler(event) {
  // This signals that a stream was destroyed. Any Subscribers will automatically be removed.
  // This default behaviour can be prevented using event.preventDefault()
  if (event.reason === "mediaStopped"
    && opentokScreenSharingPublisher && opentokScreenSharingPublisher.stream
    && opentokScreenSharingPublisher.stream == event.stream) {
    opentokStopScreenSharing();
  } else if (opentokSubscriber && event.stream == opentokSubscriber.stream) {
    opentokSubscriber = undefined;
  } else {
    // probably a viewer
    console.log("streamDestroyedHandler viewer left: ", event.stream);
    removeViewerByStreamId(event.stream.streamId);
  }
}

function sessionDisconnectedHandler(event) {
  // This signals that the user was disconnected from the Session. Any subscribers and publishers
  // will automatically be removed. This default behaviour can be prevented using event.preventDefault()
  if (opentokPublisher) {
    opentokPublisher.off('audioLevelUpdated');
    opentokPublisher = null;
  }
}

function connectionDestroyedHandler(event) {
  // This signals that connections were destroyed
}

function connectionCreatedHandler(event) {
  // This signals new connections have been created.
}

function streamPropertyChangedHandler(event) {
  if (event.changedProperty == "videoDimensions") {
    repeatCenterRemoteVideo();
  }
}

function publisherStreamCreated(event) {
  if (sessionIsViewer) {
    sendCommandWithData(kDRCommandViewerDidPublishAudio, { viewerId: multipartyViewerId, streamId: event.stream.streamId });

    if (opentokPublisher && opentokPublisher.stream) {
      // addViewer(multipartyViewerId, multipartyViewerName);
      // attachAudioToViewer(multipartyViewerId, opentokPublisher.stream.streamId);

      opentokPublisher.on('audioLevelUpdated', function (event) {
        if (opentokPublisher && opentokPublisher.stream) {
          if (opentokPublisher.stream.hasAudio) {
            smoothedMicLevel = Math.max(event.audioLevel, smoothedMicLevel * micSmoothingFactor + event.audioLevel * (1.0 - micSmoothingFactor));
            lastMicPeak = Math.max(smoothedMicLevel, lastMicPeak);
            $("#stream_" + opentokPublisher.stream.streamId + " .bar").width(Math.round(smoothedMicLevel * 100) + "%");
          } else {
            lastMicPeak = 0;
            $("#stream_" + opentokPublisher.stream.streamId + " .bar").width("0%");
          }
        }
      });
    }
  }
}

function publisherAccessDialogOpened(event) {
  // $("#allowHint").show();
  // $("#localVideo").css("top", "74px");
}

function publisherAccessAllowed(event) {
  // $("#allowHint").hide();
  // $("#localVideo").animate({ top: "10px" });
  window.setTimeout(function () {
    repeatCenterRemoteVideo();
    if (!sessionIsViewer) {
      $("#localVideo .audioLevel").fadeIn();
    }
  }, 1000);
}

function publisherAccessDenied(event) {
  if (remoteRobotSupports("requireDriverToPublishVideo")) {
    nonModalAlert("Camera Required", "Camera permission is required to connect a call. Please restart the call and click \"Allow\" when prompted.");
  }
}

/*
If you un-comment the call to OT.addEventListener("exception", exceptionHandler) above, OpenTok calls the
exceptionHandler() method when exception events occur. You can modify this method to further process exception events.
If you un-comment the call to OT.setLogLevel(), above, OpenTok automatically displays exception event messages.
*/
function exceptionHandler(event) {
  sendCommand(kDRCommandLogSessionError, { "error": { "code": event.code, "message": event.message } });
  if (event.code == 1013) {
    nonModalAlert("Exception " + event.code, event.message + " You may need to choose another webcam or restart your browser.");
    opentokAudioSourceDeviceId = "";
    opentokVideoSourceDeviceId = "";
    opentokAudioSourceDeviceName = "";
    opentokVideoSourceDeviceName = "";
    saveSettings();

    // } else if (event.code != 1500) {
    // 	// code 1500 is denied video, so don't bother resetting in that case
    // 	resetVideoLink();
  }
  console.log("Exception: " + event.code + "::" + event.message);
}

//--------------------------------------
//  HELPER METHODS
//--------------------------------------

function addStream(stream) {
  if (IS_ROBOT_MODE) { return; }

  // Check if this is the stream that I am publishing, and if so do not subscribe.
  if (stream.connection.connectionId == opentokSession.connection.connectionId) {
    return;
  }

  if (stream.hasVideo) {
    var subscriberDiv = document.createElement('div');
    subscriberDiv.setAttribute('id', stream.streamId);
    subscriberDiv.setAttribute('class', 'remoteVideo');

    var fitMode = "cover";
    if (stream && stream.name == "webdriver") {
      subscriberDiv.setAttribute('id', 'opentok_publisher');
      subscriberDiv.setAttribute('class', '');
      document.getElementById("myCamera").appendChild(subscriberDiv);
      fitMode = "cover";
    } else {
      document.getElementById("subscribers").appendChild(subscriberDiv);
      fitMode = "contain";
    }

    var options = {
      fitMode: "contain",
      width: "100%",
      height: "100%",
      fitMode: fitMode,
      style: {
        showMicButton: false,
        showSettingsButton: false,
        showCameraToggleButton: false,
        showOpentokButton: false,
        nameDisplayMode: "off",
        buttonDisplayMode: "off",
        audioLevelDisplayMode: "off"
      }
    };
    if (sessionIsViewer && getURLParameter("viewerAudioOnly")) {
      options.subscribeToVideo = false;
    }
    var subscriber = opentokSession.subscribe(stream, subscriberDiv.id, options);
    subscriber.setAudioVolume(100);
    if (speakerIsMuted) {
      subscriber.subscribeToAudio(false);
    }
    if (sessionIsViewer) {
      // we're a viewer
      if (stream.name == "webdriver") {
        console.log("added driver video stream");
      } else {
        opentokViewSubscribers.push(subscriber);
      }
    } else if (!opentokSubscriber) {
      // we're the driver
      opentokSubscriber = subscriber;
    }

    var subscriberRemoveCounter = 0;
    var subscriberRemoveInterval = window.setInterval(function () {
      centerRemoteVideo();
      subscriberRemoveCounter++;
      if (subscriberRemoveCounter > 100) {
        window.clearInterval(subscriberRemoveInterval);
      }
    }, 50);

    sendCommand(kDRCommandRequestRobotiPadOrientation);
  } else {
    var subscriber = opentokSession.subscribe(stream);
    opentokViewSubscribers.push(subscriber);

    subscriber.on('audioLevelUpdated', function (event) {
      if (subscriber && subscriber.stream) {
        if (subscriber.stream.hasAudio) {
          smoothedMicLevel = Math.max(event.audioLevel, smoothedMicLevel * micSmoothingFactor + event.audioLevel * (1.0 - micSmoothingFactor));
          lastMicPeak = Math.max(smoothedMicLevel, lastMicPeak);
          $("#stream_" + subscriber.stream.streamId + " .bar").width(Math.round(smoothedMicLevel * 100) + "%");
        } else {
          lastMicPeak = 0;
          $("#stream_" + subscriber.stream.streamId + " .bar").width("0%");
        }
      }
    });
  }

  window.setTimeout(function () {
    $("#connecting").fadeOut();
  }, 3000);
}

function opentokHardwareSetupShow(element) {
  $(element).empty();

  var options = {
    insertMode: 'append' // Or use another insertMode setting.
  };

  opentokHardwareSetupComponent = createOpentokHardwareSetupComponent(element, options, function (error) {
    if (error) {
      console.error('Error: ', error);
      element.innerHTML = '<strong>Error getting devices</strong>: ' + error.message;
      return;
    }
  });
}

function opentokHardwareSetupHide(apply) {
  if (opentokHardwareSetupComponent) {
    var changed = (opentokAudioSourceDeviceId != opentokHardwareSetupComponent.audioSource().deviceId || opentokVideoSourceDeviceId != opentokHardwareSetupComponent.videoSource().deviceId);
    if (apply) {
      opentokAudioSourceDeviceId = opentokHardwareSetupComponent.audioSource().deviceId;
      opentokVideoSourceDeviceId = opentokHardwareSetupComponent.videoSource().deviceId;
      opentokAudioSourceDeviceName = opentokHardwareSetupComponent.audioSource().label;
      opentokVideoSourceDeviceName = opentokHardwareSetupComponent.videoSource().label;
      saveSettings();
      opentokHardwareSetupComponent.destroy();
      opentokHardwareSetupComponent = null;
      opentokStopPublishing();
      window.setTimeout(opentokStartPublishing, 500);
    } else {
      opentokHardwareSetupComponent.destroy();
      opentokHardwareSetupComponent = null;
    }
  }
}
// DRTURNFinder

Object.defineProperty(Array.prototype, "shuffle", {
  value: function () {
    for (let i = this.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this[i], this[j]] = [this[j], this[i]];
    }
    return this;
  }
});

function DRTURNFinder(iceConfigs, callback) {

  this.bestIceConfigTime = 99999;
  this.bestIceConfig = null;

  this.gotResponse = function (iceConfig, ms) {
    if (ms < bestIceConfigTime) {
      bestIceConfigTime = ms;
      bestIceConfig = iceConfig;
      // console.log(bestIceConfig);
      if (callback) {
        callback(bestIceConfig, ms);
      }
    }
  };

  this.checkServer = function (iceConfig) {
    var pc = new RTCPeerConnection(iceConfig);
    var timer = Date.now();
    if (pc) {
      pc.onicecandidate = (event) => {
        if (event.candidate && event.candidate.type == "relay") {
          var ms = Date.now() - timer;
          // console.log(ms + "ms", iceConfig.iceServers[0].urls[0]);
          this.gotResponse(iceConfig, ms);
          pc.onicecandidate = null;
          pc.close();
          pc = null;
        }
      };
      pc.createOffer((result) => {
        // success
        pc.setLocalDescription(result);
      }, (result) => {
        // fail
        console.log("Fail", iceConfig);
      }, {
        offerToReceiveVideo: true,
        offerToReceiveAudio: true
      });
    }
  };

  if (Array.isArray(iceConfigs)) {
    iceConfigs.shuffle().forEach((iceConfig) => {
      this.checkServer(iceConfig);
    });
  } else {
    if (callback) {
      callback(iceConfigs);
    }
  }

}
// DRDriverWebRTC

function DRDriverWebRTC(iceConfig) {

  this.init = () => {
    this.pc = null; // PeerConnection
    this.iceConfig = iceConfig;
    this.iceConfigDomain = null;
    this.began = false;
    this.answered = false;
    this.hasRemoteSdp = false;
    this.acquiredCamera = false;
    this.remoteVideo = null;
    this.localVideo = null;
    this.localVideoMediaStream = null;
    this.localVideoCameraId = null;
    this.localVideoMicId = null;
    this.useCamera = true;
    this.canvasCropInterval = null;
    this.micAudioContext = null;
    this.micMediaStream = null;
    this.micActivityRelease = 0;

    this.queue = [];

    this.statsRunning = false;
    this.statsIntervalTime = 1000;
    this.stats = { recv: {} };

    this.checkH264Support();
  };

  this.domainFromIceConfig = (config) => {
    if (Array.isArray(config.iceServers) && config.iceServers.length > 0
      && Array.isArray(config.iceServers[0].urls) && config.iceServers[0].urls.length > 0) {
      var url = config.iceServers[0].urls[0];
      if (url.startsWith("turn:")) {
        url = url.substring(5);
      } else if (url.startsWith("turns:")) {
        url = url.substring(6);
      }
      try {
        url = new URL("https://" + url);
        return url.hostname;
      } catch (e) { }
    }
    return null;
  };

  this.setIceConfig = (config, source = null, ms = 0) => {
    if (config && config.sdpSemantics == "unified-plan" && "iceTransportPolicy" in config) {
      this.iceConfig = config;
      var message = "setIceConfig";
      if (source) {
        message += " from " + source;
      }
      if (ms) {
        message += " (" + ms + " ms)";
      }
      message += " " + this.domainFromIceConfig(config);
      this.log(message, config);
    }
  };

  this.checkH264Support = () => {
    if ("supportsH264" in window) { return; }
    window.supportsH264 = true;

    var testPeerConnection = new RTCPeerConnection();
    if (testPeerConnection) {
      testPeerConnection.createOffer((result) => {
        // success
        window.supportsH264 = !!(JSON.stringify(result).toLowerCase().indexOf("h264") >= 0);
        window.setTimeout(() => {
          if (!window.supportsH264) {
            nonModalAlert("Not Supported", "This browser or device does not support h264 video encoding, so you cannot drive Double. Please try another browser or device.");
          }
        }, 2000);
      }, (result) => {
        // fail
      }, {
        offerToReceiveVideo: true
      });
    }
  };

  this.isActive = () => {
    return this.began;
  };

  this.begin = () => {
    this.began = true;
    this.log("begin");

    $("#subscribers").html("<video id=\"webrtcRemoteVideo\" autoplay playsinline></video></div>");
    this.remoteVideo = document.getElementById("webrtcRemoteVideo");
    this.remoteVideo.onresize = this.didResizeRemoteVideo;

    if (this.useCamera) {
      $("#myCamera").html("<video id=\"webrtcLocalVideo\" autoplay playsinline></video></div>");
      this.localVideo = document.querySelector("#webrtcLocalVideo");
      this.localVideo.muted = true;
      this.localVideo.autoplay = true;
      this.localVideo.onloadedmetadata = (e) => {
        this.localVideo.play();
        $("#localVideo").show();
      };
    } else {
      $("#localVideo").hide();
    }
    this.startCamera();
  };

  this.end = () => {
    this.stopMicMeter();
    this.endStats();

    if (this.pc) {
      this.pc.onicecandidate = null;
      // this.pc.oniceconnectionstatechange = null;
      this.pc.onicegatheringstatechange = null;
      this.pc.onsignalingstatechange = null;
      try {
        this.pc.getSenders().forEach(track => { this.pc.removeTrack(track); });
      } catch (e) { }
      this.pc.close();
      this.pc = null;
    }

    if (this.localVideo && this.localVideo.srcObject) {
      this.localVideo.srcObject.getTracks().forEach(function (track) { track.stop(); });
    }

    this.answered = false;
    this.acquiredCamera = false;
    this.hasRemoteSdp = false;
    this.began = false;
    this.remoteVideo = null;
    this.localVideo = null;
    this.localVideoMediaStream = null;
    this.queue = [];

    $("#subscribers").empty();
    $("#myCamera").empty();

    this.log("end");

    if (this.canvasCropInterval) {
      window.clearInterval(this.canvasCropInterval);
      this.canvasCropInterval = null;
    }
  };

  this.startCamera = async () => {
    if (!this.localVideoMediaStream && this.useCamera) {
      var constraints = { audio: true, video: { width: 360, height: 480, frameRate: 25 } };
      if (this.localVideoMicId) {
        constraints.audio.deviceId = this.localVideoMicId;
      }
      if (this.localVideoCameraId == "None") {
        constraints.video = false;
      } else if (this.localVideoCameraId) {
        constraints.video.deviceId = this.localVideoCameraId;
      }
      this.localVideoMediaStream = await navigator.mediaDevices.getUserMedia(constraints).catch(e => {
        this.log("getUserMediaError", { name: e.name, message: e.message }, true);
        disconnect();
        window.setTimeout(() => {
          nonModalAlert("Camera Required", "A camera is required to start a call. Please allow a camera by clicking on the camera icon in your browser's toolbar, then refresh the page and try again.");
        }, 2000);
      });
    }
    if (this.localVideoMediaStream || !this.useCamera) {
      this.acquiredCamera = true;

      if (this.localVideoMediaStream) {
        this.log("getUserMediaFoundMediaStream");
        this.localVideo.srcObject = this.localVideoMediaStream;
      }

      this.createPeerConnection();

      if (this.localVideoMediaStream) {
        if (window.useCanvasCrop) {
          var canvas = document.createElement("canvas");
          canvas.width = 360;
          canvas.height = 480;
          document.body.appendChild(canvas);
          var ctx = canvas.getContext("2d");
          this.canvasCropInterval = window.setInterval(() => {
            var scale = this.localVideo.videoHeight / canvas.height;
            var sourceX = (this.localVideo.videoWidth - canvas.width * scale) / 2;
            ctx.drawImage(this.localVideo,
              sourceX, 0, this.localVideo.videoWidth - sourceX * 2, this.localVideo.videoHeight,
              0, 0, canvas.width, canvas.height);
          }, 40);
          this.canvasStream = canvas.captureStream(25);
          this.canvasStream.getTracks().forEach(async (track) => {
            this.pc.addTrack(track, this.canvasStream);
          });
          this.localVideoMediaStream.getAudioTracks().forEach(async (track) => {
            this.pc.addTrack(track, this.localVideoMediaStream);
          });
        } else {
          this.localVideoMediaStream.getTracks().forEach(async (track) => {
            this.localSender = this.pc.addTrack(track, this.localVideoMediaStream);
            // window.setTimeout(async () => {
            // 	var params = this.localSender.getParameters();
            // 	if (params.encodings.length > 0) {
            // 		params.encodings[0].maxBitrate = 2500000;
            // 		await this.localSender.setParameters(params);
            // 	}
            // 	this.localVideoMediaStream.getVideoTracks()[0].applyConstraints({ frameRate: { max: 20 } });
            // }, 1000);
          });
        }
        this.log("addingTracksToRTCPeerConnection");
      }

      this.drainQueue();

    } else {
      this.log("getUserMediaMissingMediaStream");
      endSession();
    }
  };

  this.setHalfDuplex = (flag) => {
    if (this.micAudioContext && !flag) {
      this.stopMicMeter();
    } else if (!this.micAudioContext && flag) {
      this.startMicMeter();
    }
  };

  this.stopMicMeter = () => {
    if (this.micAudioContext) {
      this.micAudioContext.close();
      this.micAudioContext = null;
    }
    if (this.micMediaStream) {
      this.micMediaStream.getTracks().forEach(function (track) { track.stop(); });
      this.micMediaStream = null;
    }
  };

  this.startMicMeter = async () => {
    console.log("startMicMeter");
    this.stopMicMeter();

    if (!this.localVideoMediaStream) {
      return;
    }
    var micTrackConstraints = null;
    this.micMediaStream = null;
    if (this.localVideoMediaStream.getAudioTracks().length > 0) {
      micTrackConstraints = this.localVideoMediaStream.getAudioTracks()[0].getConstraints();
    }
    if (micTrackConstraints) {
      micTrackConstraints = { audio: micTrackConstraints };
      this.micMediaStream = await navigator.mediaDevices.getUserMedia(micTrackConstraints).catch(e => {
        this.log("getUserMediaErrorForMicLevel", { name: e.name, message: e.message }, true);
      });
    } else {
      return;
    }

    this.micAudioContext = new (window.AudioContext || window.webkitAudioContext);
    var analyser = this.micAudioContext.createAnalyser();
    var microphone = this.micAudioContext.createMediaStreamSource(this.micMediaStream);
    var javascriptNode = this.micAudioContext.createScriptProcessor(256, 1, 1);

    analyser.smoothingTimeConstant = 0.1;
    analyser.fftSize = 1024;

    microphone.connect(analyser);
    analyser.connect(javascriptNode);
    javascriptNode.connect(this.micAudioContext.destination);
    javascriptNode.onaudioprocess = () => {
      var array = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(array);
      var values = 0;
      var length = array.length;
      for (var i = 0; i < length; i++) {
        values += (array[i]);
      }
      var average = values / length;
      var percent = average / 130;

      if (isMuted) {
        return;
      }
      // mute local speaker while driver is talking
      if (percent >= 0.25) {
        this.micActivityRelease = Math.min(1.0, this.micActivityRelease + 0.24);
        if (this.micActivityRelease >= 1.0) {
          if (!this.remoteIsMuted()) {
            this.muteRemote();
            this.unmutePublisher(); // unmute local mic
          }
        }
      } else if (this.micActivityRelease <= 0) {
        if (this.remoteIsMuted()) {
          this.unmuteRemote();
          this.mutePublisher(); // mute local mic
        }
      } else {
        this.micActivityRelease = Math.max(0, this.micActivityRelease - 0.008);
      }
    };
  };

  this.createPeerConnection = () => {
    try {
      if (this.pc) {
        this.pc.close();
      }

      this.iceConfigDomain = this.domainFromIceConfig(this.iceConfig);

      this.pc = new window.RTCPeerConnection(this.iceConfig);
      this.pc.onicecandidate = this.onIceCandidate;
      this.pc.oniceconnectionstatechange = this.onICEConnectionStateChangeEvent;
      this.pc.onicegatheringstatechange = this.onICEGatheringStateChangeEvent;
      this.pc.onsignalingstatechange = this.onSignalingStateChangeEvent;
      this.pc.onnegotiationneeded = this.onNegotiationNeededEvent;
      this.pc.onidentityresult = this.onIdentityResultEvent;
      this.pc.ontrack = this.ontrack;

      this.log("createPeerConnection", this.iceConfig);

    } catch (e) {
      this.log("failedToCreatePeerConnection", { message: e.message });
    }
  };

  this.onIceCandidate = (event) => {
    this.log("onIceCandidate"); //, event.candidate
    if (event.candidate) {
      sendCommandWithData(kDRCommandWebRTCSignal, {
        type: "candidate", // Don't send this, so we can be backwards compatible with version prior to 1.0.18
        sdpMLineIndex: event.candidate.sdpMLineIndex,
        sdpMid: event.candidate.sdpMid,
        candidate: event.candidate.candidate
      });
    } else {
      this.log("endOfCandidates");
    }
  };

  this.onICEConnectionStateChangeEvent = (event) => {
    this.log("oniceconnectionstatechange", { iceConnectionState: this.pc.iceConnectionState });
    switch (this.pc.iceConnectionState) {
      case "closed":
      case "failed":
        this.end();
        break;
      case "disconnected":
        // Ignore this state
        // this.end();
        break;
    }
  };

  this.onICEGatheringStateChangeEvent = (event) => {
    this.log("onicegatheringstatechange", {
      iceGatheringState: this.pc.iceGatheringState
    });
  };

  this.onSignalingStateChangeEvent = (event) => {
    if (event && event.target && event.target.signalingState) {
      this.log("onsignalingstatechange", { signalingState: event.target.signalingState });
      switch (event.target.signalingState) {
        case "closed":
          this.end();
          break;
      }
    }
  };

  this.onNegotiationNeededEvent = (event) => {
    this.log("onnegotiationneeded", { assertion: event.assertion });
  };

  this.onIdentityResultEvent = (event) => {
    this.log("onidentityresult", { assertion: event.assertion });
  };

  this.ontrack = (event) => {
    if (this.remoteVideo.srcObject) {
      this.log("ontrack", "blocking");
      return;
    }
    this.log("ontrack");
    if (!this.useCamera) {
      this.remoteVideo.muted = true;
    }
    this.remoteVideo.srcObject = event.streams[0];
    $("#connecting").hide();
    this.didResizeRemoteVideo();
    this.beginStats(this.pc);
  };

  this.mutePublisher = () => {
    if (this.localVideoMediaStream) {
      var tracks = this.localVideoMediaStream.getAudioTracks();
      for (var i = 0; i < tracks.length; i++) {
        tracks[i].enabled = false;
      }
    }
  };

  this.unmutePublisher = () => {
    if (this.localVideoMediaStream) {
      var tracks = this.localVideoMediaStream.getAudioTracks();
      for (var i = 0; i < tracks.length; i++) {
        tracks[i].enabled = true;
      }
    }
  };

  this.publisherIsMuted = () => {
    if (this.localVideoMediaStream) {
      var anyOn = false;
      var tracks = this.localVideoMediaStream.getAudioTracks();
      for (var i = 0; i < tracks.length; i++) {
        if (tracks[i].enabled) {
          anyOn = true;
        }
      }
      return !anyOn;
    }
    return false;
  };

  this.muteRemote = () => {
    if (this.remoteVideo) {
      this.remoteVideo.muted = true;
    }
  };

  this.unmuteRemote = () => {
    if (this.remoteVideo) {
      this.remoteVideo.muted = false;
    }
  };

  this.remoteIsMuted = () => {
    return (this.remoteVideo && this.remoteVideo.muted);
  };

  this.answer = () => {
    this.log("sendAnswerToPeer");
    this.pc.createAnswer()
      .then((sessionDescription) => {
        this.log("setLocalDescription", sessionDescription);
        this.pc.setLocalDescription(sessionDescription);
        sendCommandWithData(kDRCommandWebRTCSignal, sessionDescription);
      })
      .catch((e) => {
        this.log("createAnswerFailed", { name: e.name, message: e.message });
      });
    this.answered = true;
  };

  // This note is from: https://github.com/webrtc/apprtc/blob/master/src/web_app/js/peerconnectionclient.js
  // When we receive messages from GAE registration and from the WSS connection,
  // we add them to a queue and drain it if conditions are right.
  //
  // It's possible that we finish registering and receiving messages from WSS
  // before our peer connection is created or started. We need to wait for the
  // peer connection to be created and started before processing messages.
  //
  // Also, the order of messages is in general not the same as the POST order
  // from the other client because the POSTs are async and the server may handle
  // some requests faster than others. We need to process offer before
  // candidates so we wait for the offer to arrive first if we're answering.
  // Offers are added to the front of the queue.
  this.receiveSignal = (signal) => {
    if (signal.type == "offer") {
      // Always process offer before candidates.
      this.queue.unshift(signal);
      this.hasRemoteSdp = true;
    } else {
      this.queue.push(signal);
    }
    this.drainQueue();
  };

  this.drainQueue = () => {
    if (!this.pc || !this.began || !this.hasRemoteSdp || !this.acquiredCamera) {
      return;
    }
    this.log("drainingQueue", { count: this.queue.length });
    for (var i = 0, len = this.queue.length; i < len; i++) {
      this.processSignal(this.queue[i]);
    }
    this.queue = [];
  };

  this.processSignal = (signal) => {
    if (signal && signal.candidate) {
      signal.type = "candidate";
    }
    if (!signal || !signal.type) {
      this.log("processSignalError", signal);
      return;
    } else {
      this.log("processSignal", signal);
    }

    if (signal.type == "offer") {
      this.log("receivedOffer");
      this.pc.setRemoteDescription(new RTCSessionDescription(signal))
        .then(() => { this.log("setRemoteDescriptionFromOfferSuccess"); })
        .catch((e) => { this.log("setRemoteDescriptionFromOfferFailed", { message: e.message, signal: signal }); });
      this.answer();

    } else if (signal.type == "candidate" && this.answered) {
      this.pc.addIceCandidate(new RTCIceCandidate(signal)).catch(e => {
        this.log("processSignalAddIceCandidateFailed", { message: e.message, signal: signal });
      });
      try {
        this.pc.addIceCandidate(candidate);
      } catch (e) {
      }
    }
  };

  this.didResizeRemoteVideo = () => {
    if (centerRemoteVideo) {
      centerRemoteVideo();
    }
  };

  // Quality Stats

  this.resetStats = () => {
    $("#webrtcVideo").text("");
    $("#webrtcNetwork").text("");
    $("#webrtcTransport").text("");
  };

  this.beginStats = (peerConnection) => {
    if (this.statsRunning) {
      return;
    }
    this.statsRunning = true;
    this.stats = {
      recv: {
        bytes: -1,
        bitrate: -1,
        fps: -1,
        latency: -1,
        codec: "",
        frameWidth: -1,
        frameHeight: -1
      },
      send: {
        bytes: -1,
        bitrate: -1,
        fps: -1,
        latency: -1,
        codec: "",
        frameWidth: -1,
        frameHeight: -1
      },
      localConnection: {
        candidateType: "",
        ipAddress: "",
        networkType: "",
        transport: ""
      },
      remoteConnection: {
        candidateType: "",
        ipAddress: "",
        networkType: "",
        transport: ""
      },
      systemIpAddress: "",
      systemNetworkType: "",
      encryption: "",
      transport: ""
    };

    if (navigator.userAgent.includes("Chrome")) {
      getStats(peerConnection, (result) => {
        if (!this.statsRunning) {
          result.nomore();
          return;
        }

        if (this.stats.recv) {
          this.stats.recv.bitrate = (result.video.bytesReceived - this.stats.recv.bytes) / (this.statsIntervalTime / 1000) * 8;
          this.stats.recv.bytes = result.video.bytesReceived;
        }
        if (this.stats.send) {
          this.stats.send.bitrate = (result.video.bytesSent - this.stats.send.bytes) / (this.statsIntervalTime / 1000) * 8;
          this.stats.send.bytes = result.video.bytesSent;
        }
        var transport = "";
        if (result.connectionType.remote) {
          transport = result.connectionType.remote.candidateType[0];
          transport += "<br>";
          transport += result.connectionType.transport;
          transport += "://";
          transport += (result.connectionType.remote.ipAddress) ? result.connectionType.remote.ipAddress[0] : "";
        }

        result.results.forEach((item) => {
          if (item.googContentType === 'realtime') {

            // Receive
            if ("googFrameRateReceived" in item) {
              this.stats.recv.fps = parseInt(item.googFrameRateReceived);
              if ("googCurrentDelayMs" in item) {
                this.stats.recv.latency = parseInt(item.googCurrentDelayMs);
              }
              if ("googCodecName" in item) {
                this.stats.recv.codec = item.googCodecName;
              }
            }

            // Send
            if ("googFrameRateSent" in item) {
              this.stats.send.fps = parseInt(item.googFrameRateSent);
              if ("googCurrentDelayMs" in item) {
                this.stats.send.latency = parseInt(item.googCurrentDelayMs);
              }
              if ("googCodecName" in item) {
                this.stats.send.codec = item.googCodecName;
              }
            }
          }
        });

        var size = (result.resolutions && result.resolutions.recv) ? result.resolutions.recv.width + "x" + result.resolutions.recv.height : "";
        var mbps = (this.stats.recv.bitrate / 1000000).toFixed(2);

        $("#webrtcVideo").text(this.stats.recv.fps + " FPS, " + size + ", " + this.stats.recv.codec);
        $("#webrtcNetwork").text(mbps + " Mbps, " + this.stats.recv.latency + " ms");
        $("#webrtcTransport").html(transport + "<br>Encryption: " + result.encryption);
        $("#webrtcIceDomain").text(this.iceConfigDomain || "---");

        if (result.resolutions) {
          if (result.resolutions.recv) {
            this.stats.recv.frameWidth = result.resolutions.recv.width;
            this.stats.recv.frameHeight = result.resolutions.recv.height;
          }
          if (result.resolutions.send) {
            this.stats.send.frameWidth = result.resolutions.send.width;
            this.stats.send.frameHeight = result.resolutions.send.height;
          }
        }

        if (result.connectionType.local) {
          this.stats.localConnection.candidateType = result.connectionType.local.candidateType.join(",")
            .replace("serverreflexive", "srflx")
            .replace("peerreflexive", "prflx")
            .replace("relayed", "relay");
          this.stats.localConnection.ipAddress = result.connectionType.local.ipAddress.join(",");
          this.stats.localConnection.networkType = result.connectionType.local.networkType.join(",");
          this.stats.localConnection.transport = result.connectionType.local.transport.join(",");
        }

        if (result.connectionType.remote) {
          this.stats.remoteConnection.candidateType = result.connectionType.remote.candidateType.join(",")
            .replace("serverreflexive", "srflx")
            .replace("peerreflexive", "prflx")
            .replace("relayed", "relay");
          this.stats.remoteConnection.ipAddress = result.connectionType.remote.ipAddress.join(",");
          this.stats.remoteConnection.networkType = result.connectionType.remote.networkType.join(",");
          this.stats.remoteConnection.transport = result.connectionType.remote.transport.join(",");
        }

        if (result.connectionType.systemIpAddress) {
          this.stats.systemIpAddress = result.connectionType.systemIpAddress;
          this.stats.systemNetworkType = result.connectionType.systemNetworkType;
          this.stats.transport = result.connectionType.udp;
        }
        if (result.encryption) {
          this.stats.encryption = result.encryption;
        }

        this.log("stats", this.stats);

      }, this.statsIntervalTime);
    }
  };

  this.endStats = () => {
    this.statsRunning = false;
    this.resetStats();
  };

  this.log = (event, data, forceConsole) => {
    forceConsole = forceConsole || IS_DEV_MODE;
    var out = {
      event: event
    };
    if (data) {
      out.data = data;
      if (forceConsole) {
        console.log(event, data);
      }
    } else if (forceConsole) {
      console.log(event);
    }
    sendCommandWithData(kDRCommandWebRTCLog, out);
  };

  this.init();
}
function DRDriverWebRTCScreenSharing(iceConfig) {

  this.init = () => {
    this.pc = null; // RTCPeerConnection
    this.localVideo = null;
    this.began = false;
    this.hasRemoteSdp = false;
    this.queue = [];
  };

  this.isActive = () => {
    return !!this.began;
  };

  this.begin = async () => {
    this.began = true;

    // Get video source
    var src = await navigator.mediaDevices.getDisplayMedia({ audio: false, video: true }).catch(e => {
      this.log("screenSharingPermissionDenied");
      this.end();
    });
    if (!src) {
      return;
    }

    if (!document.querySelector("#webrtcScreenSharingLocalVideo")) {
      $("#screenSharingPublisher").append("<video style=\"\" id=\"webrtcScreenSharingLocalVideo\" autoplay playsinline></video></div>");
    }
    this.localVideo = document.querySelector("#webrtcScreenSharingLocalVideo");
    this.localVideo.muted = true;
    this.localVideo.autoplay = true;
    this.localVideo.onloadedmetadata = (e) => {
      this.localVideo.play();
    };
    this.localVideo.srcObject = src;

    // Local UI setup
    $("#screenSharingContainer").show();
    $("#myCamera").removeClass("myCameraStandard");
    $("#myCamera").addClass("myCameraWhileScreenSharing");
    updateUserInterface();
    repeatCenterRemoteVideo();

    // Tell the robot to open the screen sharing window
    this.sendToServer({ type: "open" });

    window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 300);
    window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 1000);

    src.getVideoTracks()[0].addEventListener("ended", () => {
      this.end();
    });
  };

  this.startCall = (iceConfig) => {
    this.queue = [];
    this.pc = new RTCPeerConnection(iceConfig);
    var handler = (event, state) => {
      this.log(event.type, state);
      switch (state) {
        case "closed":
        case "failed":
        case "disconnected":
          this.end();
          break;
      }
    };
    this.pc.oniceconnectionstatechange = (event) => handler(event, this.pc.iceConnectionState);
    this.pc.onicegatheringstatechange = (event) => handler(event, this.pc.iceGatheringState);
    this.pc.onsignalingstatechange = (event) => handler(event, this.pc.signalingState);
    this.pc.onicecandidate = (event) => {
      if (event.candidate) {
        this.log(event.type, event.candidate.candidate);
        this.sendToServer({
          type: "candidate",
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid,
          candidate: event.candidate.candidate
        });
      }
    };

    this.sendToServer({
      type: "startCall",
      iceConfig: iceConfig
    });
  };

  this.handleVideoOffer = async (msg) => {
    // Add local video source
    this.localVideo.srcObject.getTracks().forEach(track => this.pc.addTrack(track, this.localVideo.srcObject));

    // Send SDP
    this.hasRemoteSdp = true;
    await this.pc.setRemoteDescription(new RTCSessionDescription(msg));
    await this.pc.setLocalDescription(await this.pc.createAnswer());
    this.sendToServer(this.pc.localDescription); // type: answer
  };

  this.end = () => {
    this.sendToServer({ type: "close" });

    if (this.pc) {
      this.pc.onicecandidate = null;
      this.pc.oniceconnectionstatechange = null;
      this.pc.onicegatheringstatechange = null;
      this.pc.onsignalingstatechange = null;
      this.pc.getSenders().forEach(track => { this.pc.removeTrack(track); });
      this.pc.close();
      this.pc = null;
    }

    if (this.localVideo && this.localVideo.srcObject) {
      this.localVideo.srcObject.getTracks().forEach(function (track) { track.stop(); });
    }

    this.localVideo = null;
    this.hasRemoteSdp = false;
    this.began = false;

    // Local UI cleanup
    $("#screenSharingPublisher").empty();
    $("#screenSharingContainer").hide();
    $("#myCamera").removeClass("myCameraWhileScreenSharing");
    $("#myCamera").addClass("myCameraStandard");
    updateUserInterface();

    window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 300);
    window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 1000);
  };

  this.processSignal = (signal) => {
    if (signal && signal.candidate) {
      signal.type = "candidate";
    }
    this.log("processSignal", signal);
    switch (signal.type) {
      case "didOpen":
        this.startCall(iceConfig);
        break;
      case "offer":
        this.handleVideoOffer(signal);
        break;
      case "candidate":
        this.queue.push(signal);
        break;
    }
    this.drainQueue();
  };

  this.drainQueue = () => {
    if (!this.pc || !this.began || !this.hasRemoteSdp || !this.localVideo || !this.localVideo.srcObject) {
      return;
    }
    this.log("drainingQueue", { count: this.queue.length });
    for (var i = 0; i < this.queue.length; i++) {
      var signal = this.queue[i];
      this.pc.addIceCandidate(new RTCIceCandidate(signal)).catch(e => {
        this.log("processSignalAddIceCandidateFailed", { message: e.message, signal: signal });
      });
    }
    this.queue = [];
  };

  this.sendToServer = (data) => {
    this.log("screenSharingSignal", data);
    sendCommandWithData(kDRCommandWebRTCScreenSharingSignal, data);
  };

  this.log = (event, data) => {
    var out = { event: "DRDriverWebRTCScreenSharing." + event };
    if (data) { out.data = data; }
    sendCommandWithData(kDRCommandWebRTCLog, out);
    // console.log(out);
  };

  this.init();
}
/*!
 * Socket.IO v2.1.1
 * (c) 2014-2018 Guillermo Rauch
 * Released under the MIT License.
 */
!function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.io = e() : t.io = e(); }(this, function () {
  return function (t) { function e(r) { if (n[r]) return n[r].exports; var o = n[r] = { exports: {}, id: r, loaded: !1 }; return t[r].call(o.exports, o, o.exports, e), o.loaded = !0, o.exports; } var n = {}; return e.m = t, e.c = n, e.p = "", e(0); }([function (t, e, n) { "use strict"; function r(t, e) { "object" === ("undefined" == typeof t ? "undefined" : o(t)) && (e = t, t = void 0), e = e || {}; var n, r = i(t), s = r.source, p = r.id, h = r.path, f = u[p] && h in u[p].nsps, l = e.forceNew || e["force new connection"] || !1 === e.multiplex || f; return l ? (c("ignoring socket cache for %s", s), n = a(s, e)) : (u[p] || (c("new io instance for %s", s), u[p] = a(s, e)), n = u[p]), r.query && !e.query && (e.query = r.query), n.socket(r.path, e); } var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t; } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }, i = n(1), s = n(7), a = n(12), c = n(3)("socket.io-client"); t.exports = e = r; var u = e.managers = {}; e.protocol = s.protocol, e.connect = r, e.Manager = n(12), e.Socket = n(37); }, function (t, e, n) { (function (e) { "use strict"; function r(t, n) { var r = t; n = n || e.location, null == t && (t = n.protocol + "//" + n.host), "string" == typeof t && ("/" === t.charAt(0) && (t = "/" === t.charAt(1) ? n.protocol + t : n.host + t), /^(https?|wss?):\/\//.test(t) || (i("protocol-less url %s", t), t = "undefined" != typeof n ? n.protocol + "//" + t : "https://" + t), i("parse %s", t), r = o(t)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/"; var s = r.host.indexOf(":") !== -1, a = s ? "[" + r.host + "]" : r.host; return r.id = r.protocol + "://" + a + ":" + r.port, r.href = r.protocol + "://" + a + (n && n.port === r.port ? "" : ":" + r.port), r; } var o = n(2), i = n(3)("socket.io-client:url"); t.exports = r; }).call(e, function () { return this; }()); }, function (t, e) { var n = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, r = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"]; t.exports = function (t) { var e = t, o = t.indexOf("["), i = t.indexOf("]"); o != -1 && i != -1 && (t = t.substring(0, o) + t.substring(o, i).replace(/:/g, ";") + t.substring(i, t.length)); for (var s = n.exec(t || ""), a = {}, c = 14; c--;)a[r[c]] = s[c] || ""; return o != -1 && i != -1 && (a.source = e, a.host = a.host.substring(1, a.host.length - 1).replace(/;/g, ":"), a.authority = a.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), a.ipv6uri = !0), a; }; }, function (t, e, n) { (function (r) { function o() { return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)); } function i(t) { var n = this.useColors; if (t[0] = (n ? "%c" : "") + this.namespace + (n ? " %c" : " ") + t[0] + (n ? "%c " : " ") + "+" + e.humanize(this.diff), n) { var r = "color: " + this.color; t.splice(1, 0, r, "color: inherit"); var o = 0, i = 0; t[0].replace(/%[a-zA-Z%]/g, function (t) { "%%" !== t && (o++, "%c" === t && (i = o)); }), t.splice(i, 0, r); } } function s() { return "object" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments); } function a(t) { try { null == t ? e.storage.removeItem("debug") : e.storage.debug = t; } catch (n) { } } function c() { var t; try { t = e.storage.debug; } catch (n) { } return !t && "undefined" != typeof r && "env" in r && (t = r.env.DEBUG), t; } function u() { try { return window.localStorage; } catch (t) { } } e = t.exports = n(5), e.log = s, e.formatArgs = i, e.save = a, e.load = c, e.useColors = o, e.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : u(), e.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], e.formatters.j = function (t) { try { return JSON.stringify(t); } catch (e) { return "[UnexpectedJSONParseError]: " + e.message; } }, e.enable(c()); }).call(e, n(4)); }, function (t, e) { function n() { throw new Error("setTimeout has not been defined"); } function r() { throw new Error("clearTimeout has not been defined"); } function o(t) { if (p === setTimeout) return setTimeout(t, 0); if ((p === n || !p) && setTimeout) return p = setTimeout, setTimeout(t, 0); try { return p(t, 0); } catch (e) { try { return p.call(null, t, 0); } catch (e) { return p.call(this, t, 0); } } } function i(t) { if (h === clearTimeout) return clearTimeout(t); if ((h === r || !h) && clearTimeout) return h = clearTimeout, clearTimeout(t); try { return h(t); } catch (e) { try { return h.call(null, t); } catch (e) { return h.call(this, t); } } } function s() { y && l && (y = !1, l.length ? d = l.concat(d) : m = -1, d.length && a()); } function a() { if (!y) { var t = o(s); y = !0; for (var e = d.length; e;) { for (l = d, d = []; ++m < e;)l && l[m].run(); m = -1, e = d.length; } l = null, y = !1, i(t); } } function c(t, e) { this.fun = t, this.array = e; } function u() { } var p, h, f = t.exports = {}; !function () { try { p = "function" == typeof setTimeout ? setTimeout : n; } catch (t) { p = n; } try { h = "function" == typeof clearTimeout ? clearTimeout : r; } catch (t) { h = r; } }(); var l, d = [], y = !1, m = -1; f.nextTick = function (t) { var e = new Array(arguments.length - 1); if (arguments.length > 1) for (var n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; d.push(new c(t, e)), 1 !== d.length || y || o(a); }, c.prototype.run = function () { this.fun.apply(null, this.array); }, f.title = "browser", f.browser = !0, f.env = {}, f.argv = [], f.version = "", f.versions = {}, f.on = u, f.addListener = u, f.once = u, f.off = u, f.removeListener = u, f.removeAllListeners = u, f.emit = u, f.prependListener = u, f.prependOnceListener = u, f.listeners = function (t) { return []; }, f.binding = function (t) { throw new Error("process.binding is not supported"); }, f.cwd = function () { return "/"; }, f.chdir = function (t) { throw new Error("process.chdir is not supported"); }, f.umask = function () { return 0; }; }, function (t, e, n) { function r(t) { var n, r = 0; for (n in t) r = (r << 5) - r + t.charCodeAt(n), r |= 0; return e.colors[Math.abs(r) % e.colors.length]; } function o(t) { function n() { if (n.enabled) { var t = n, r = +new Date, i = r - (o || r); t.diff = i, t.prev = o, t.curr = r, o = r; for (var s = new Array(arguments.length), a = 0; a < s.length; a++)s[a] = arguments[a]; s[0] = e.coerce(s[0]), "string" != typeof s[0] && s.unshift("%O"); var c = 0; s[0] = s[0].replace(/%([a-zA-Z%])/g, function (n, r) { if ("%%" === n) return n; c++; var o = e.formatters[r]; if ("function" == typeof o) { var i = s[c]; n = o.call(t, i), s.splice(c, 1), c--; } return n; }), e.formatArgs.call(t, s); var u = n.log || e.log || console.log.bind(console); u.apply(t, s); } } var o; return n.namespace = t, n.enabled = e.enabled(t), n.useColors = e.useColors(), n.color = r(t), n.destroy = i, "function" == typeof e.init && e.init(n), e.instances.push(n), n; } function i() { var t = e.instances.indexOf(this); return t !== -1 && (e.instances.splice(t, 1), !0); } function s(t) { e.save(t), e.names = [], e.skips = []; var n, r = ("string" == typeof t ? t : "").split(/[\s,]+/), o = r.length; for (n = 0; n < o; n++)r[n] && (t = r[n].replace(/\*/g, ".*?"), "-" === t[0] ? e.skips.push(new RegExp("^" + t.substr(1) + "$")) : e.names.push(new RegExp("^" + t + "$"))); for (n = 0; n < e.instances.length; n++) { var i = e.instances[n]; i.enabled = e.enabled(i.namespace); } } function a() { e.enable(""); } function c(t) { if ("*" === t[t.length - 1]) return !0; var n, r; for (n = 0, r = e.skips.length; n < r; n++)if (e.skips[n].test(t)) return !1; for (n = 0, r = e.names.length; n < r; n++)if (e.names[n].test(t)) return !0; return !1; } function u(t) { return t instanceof Error ? t.stack || t.message : t; } e = t.exports = o.debug = o["default"] = o, e.coerce = u, e.disable = a, e.enable = s, e.enabled = c, e.humanize = n(6), e.instances = [], e.names = [], e.skips = [], e.formatters = {}; }, function (t, e) { function n(t) { if (t = String(t), !(t.length > 100)) { var e = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t); if (e) { var n = parseFloat(e[1]), r = (e[2] || "ms").toLowerCase(); switch (r) { case "years": case "year": case "yrs": case "yr": case "y": return n * p; case "days": case "day": case "d": return n * u; case "hours": case "hour": case "hrs": case "hr": case "h": return n * c; case "minutes": case "minute": case "mins": case "min": case "m": return n * a; case "seconds": case "second": case "secs": case "sec": case "s": return n * s; case "milliseconds": case "millisecond": case "msecs": case "msec": case "ms": return n; default: return; } } } } function r(t) { return t >= u ? Math.round(t / u) + "d" : t >= c ? Math.round(t / c) + "h" : t >= a ? Math.round(t / a) + "m" : t >= s ? Math.round(t / s) + "s" : t + "ms"; } function o(t) { return i(t, u, "day") || i(t, c, "hour") || i(t, a, "minute") || i(t, s, "second") || t + " ms"; } function i(t, e, n) { if (!(t < e)) return t < 1.5 * e ? Math.floor(t / e) + " " + n : Math.ceil(t / e) + " " + n + "s"; } var s = 1e3, a = 60 * s, c = 60 * a, u = 24 * c, p = 365.25 * u; t.exports = function (t, e) { e = e || {}; var i = typeof t; if ("string" === i && t.length > 0) return n(t); if ("number" === i && isNaN(t) === !1) return e["long"] ? o(t) : r(t); throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t)); }; }, function (t, e, n) { function r() { } function o(t) { var n = "" + t.type; if (e.BINARY_EVENT !== t.type && e.BINARY_ACK !== t.type || (n += t.attachments + "-"), t.nsp && "/" !== t.nsp && (n += t.nsp + ","), null != t.id && (n += t.id), null != t.data) { var r = i(t.data); if (r === !1) return g; n += r; } return f("encoded %j as %s", t, n), n; } function i(t) { try { return JSON.stringify(t); } catch (e) { return !1; } } function s(t, e) { function n(t) { var n = d.deconstructPacket(t), r = o(n.packet), i = n.buffers; i.unshift(r), e(i); } d.removeBlobs(t, n); } function a() { this.reconstructor = null; } function c(t) { var n = 0, r = { type: Number(t.charAt(0)) }; if (null == e.types[r.type]) return h("unknown packet type " + r.type); if (e.BINARY_EVENT === r.type || e.BINARY_ACK === r.type) { for (var o = ""; "-" !== t.charAt(++n) && (o += t.charAt(n), n != t.length);); if (o != Number(o) || "-" !== t.charAt(n)) throw new Error("Illegal attachments"); r.attachments = Number(o); } if ("/" === t.charAt(n + 1)) for (r.nsp = ""; ++n;) { var i = t.charAt(n); if ("," === i) break; if (r.nsp += i, n === t.length) break; } else r.nsp = "/"; var s = t.charAt(n + 1); if ("" !== s && Number(s) == s) { for (r.id = ""; ++n;) { var i = t.charAt(n); if (null == i || Number(i) != i) { --n; break; } if (r.id += t.charAt(n), n === t.length) break; } r.id = Number(r.id); } if (t.charAt(++n)) { var a = u(t.substr(n)), c = a !== !1 && (r.type === e.ERROR || y(a)); if (!c) return h("invalid payload"); r.data = a; } return f("decoded %s as %j", t, r), r; } function u(t) { try { return JSON.parse(t); } catch (e) { return !1; } } function p(t) { this.reconPack = t, this.buffers = []; } function h(t) { return { type: e.ERROR, data: "parser error: " + t }; } var f = n(3)("socket.io-parser"), l = n(8), d = n(9), y = n(10), m = n(11); e.protocol = 4, e.types = ["CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK"], e.CONNECT = 0, e.DISCONNECT = 1, e.EVENT = 2, e.ACK = 3, e.ERROR = 4, e.BINARY_EVENT = 5, e.BINARY_ACK = 6, e.Encoder = r, e.Decoder = a; var g = e.ERROR + '"encode error"'; r.prototype.encode = function (t, n) { if (f("encoding packet %j", t), e.BINARY_EVENT === t.type || e.BINARY_ACK === t.type) s(t, n); else { var r = o(t); n([r]); } }, l(a.prototype), a.prototype.add = function (t) { var n; if ("string" == typeof t) n = c(t), e.BINARY_EVENT === n.type || e.BINARY_ACK === n.type ? (this.reconstructor = new p(n), 0 === this.reconstructor.reconPack.attachments && this.emit("decoded", n)) : this.emit("decoded", n); else { if (!m(t) && !t.base64) throw new Error("Unknown type: " + t); if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet"); n = this.reconstructor.takeBinaryData(t), n && (this.reconstructor = null, this.emit("decoded", n)); } }, a.prototype.destroy = function () { this.reconstructor && this.reconstructor.finishedReconstruction(); }, p.prototype.takeBinaryData = function (t) { if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) { var e = d.reconstructPacket(this.reconPack, this.buffers); return this.finishedReconstruction(), e; } return null; }, p.prototype.finishedReconstruction = function () { this.reconPack = null, this.buffers = []; }; }, function (t, e, n) { function r(t) { if (t) return o(t); } function o(t) { for (var e in r.prototype) t[e] = r.prototype[e]; return t; } t.exports = r, r.prototype.on = r.prototype.addEventListener = function (t, e) { return this._callbacks = this._callbacks || {}, (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e), this; }, r.prototype.once = function (t, e) { function n() { this.off(t, n), e.apply(this, arguments); } return n.fn = e, this.on(t, n), this; }, r.prototype.off = r.prototype.removeListener = r.prototype.removeAllListeners = r.prototype.removeEventListener = function (t, e) { if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this; var n = this._callbacks["$" + t]; if (!n) return this; if (1 == arguments.length) return delete this._callbacks["$" + t], this; for (var r, o = 0; o < n.length; o++)if (r = n[o], r === e || r.fn === e) { n.splice(o, 1); break; } return this; }, r.prototype.emit = function (t) { this._callbacks = this._callbacks || {}; var e = [].slice.call(arguments, 1), n = this._callbacks["$" + t]; if (n) { n = n.slice(0); for (var r = 0, o = n.length; r < o; ++r)n[r].apply(this, e); } return this; }, r.prototype.listeners = function (t) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + t] || []; }, r.prototype.hasListeners = function (t) { return !!this.listeners(t).length; }; }, function (t, e, n) { (function (t) { function r(t, e) { if (!t) return t; if (s(t)) { var n = { _placeholder: !0, num: e.length }; return e.push(t), n; } if (i(t)) { for (var o = new Array(t.length), a = 0; a < t.length; a++)o[a] = r(t[a], e); return o; } if ("object" == typeof t && !(t instanceof Date)) { var o = {}; for (var c in t) o[c] = r(t[c], e); return o; } return t; } function o(t, e) { if (!t) return t; if (t && t._placeholder) return e[t.num]; if (i(t)) for (var n = 0; n < t.length; n++)t[n] = o(t[n], e); else if ("object" == typeof t) for (var r in t) t[r] = o(t[r], e); return t; } var i = n(10), s = n(11), a = Object.prototype.toString, c = "function" == typeof t.Blob || "[object BlobConstructor]" === a.call(t.Blob), u = "function" == typeof t.File || "[object FileConstructor]" === a.call(t.File); e.deconstructPacket = function (t) { var e = [], n = t.data, o = t; return o.data = r(n, e), o.attachments = e.length, { packet: o, buffers: e }; }, e.reconstructPacket = function (t, e) { return t.data = o(t.data, e), t.attachments = void 0, t; }, e.removeBlobs = function (t, e) { function n(t, a, p) { if (!t) return t; if (c && t instanceof Blob || u && t instanceof File) { r++; var h = new FileReader; h.onload = function () { p ? p[a] = this.result : o = this.result, --r || e(o); }, h.readAsArrayBuffer(t); } else if (i(t)) for (var f = 0; f < t.length; f++)n(t[f], f, t); else if ("object" == typeof t && !s(t)) for (var l in t) n(t[l], l, t); } var r = 0, o = t; n(o), r || e(o); }; }).call(e, function () { return this; }()); }, function (t, e) { var n = {}.toString; t.exports = Array.isArray || function (t) { return "[object Array]" == n.call(t); }; }, function (t, e) { (function (e) { function n(t) { return r && e.Buffer.isBuffer(t) || o && (t instanceof e.ArrayBuffer || i(t)); } t.exports = n; var r = "function" == typeof e.Buffer && "function" == typeof e.Buffer.isBuffer, o = "function" == typeof e.ArrayBuffer, i = function () { return o && "function" == typeof e.ArrayBuffer.isView ? e.ArrayBuffer.isView : function (t) { return t.buffer instanceof e.ArrayBuffer; }; }(); }).call(e, function () { return this; }()); }, function (t, e, n) { "use strict"; function r(t, e) { if (!(this instanceof r)) return new r(t, e); t && "object" === ("undefined" == typeof t ? "undefined" : o(t)) && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.nsps = {}, this.subs = [], this.opts = e, this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor(e.randomizationFactor || .5), this.backoff = new l({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(null == e.timeout ? 2e4 : e.timeout), this.readyState = "closed", this.uri = t, this.connecting = [], this.lastPing = null, this.encoding = !1, this.packetBuffer = []; var n = e.parser || c; this.encoder = new n.Encoder, this.decoder = new n.Decoder, this.autoConnect = e.autoConnect !== !1, this.autoConnect && this.open(); } var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t; } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }, i = n(13), s = n(37), a = n(8), c = n(7), u = n(39), p = n(40), h = n(3)("socket.io-client:manager"), f = n(36), l = n(41), d = Object.prototype.hasOwnProperty; t.exports = r, r.prototype.emitAll = function () { this.emit.apply(this, arguments); for (var t in this.nsps) d.call(this.nsps, t) && this.nsps[t].emit.apply(this.nsps[t], arguments); }, r.prototype.updateSocketIds = function () { for (var t in this.nsps) d.call(this.nsps, t) && (this.nsps[t].id = this.generateId(t)); }, r.prototype.generateId = function (t) { return ("/" === t ? "" : t + "#") + this.engine.id; }, a(r.prototype), r.prototype.reconnection = function (t) { return arguments.length ? (this._reconnection = !!t, this) : this._reconnection; }, r.prototype.reconnectionAttempts = function (t) { return arguments.length ? (this._reconnectionAttempts = t, this) : this._reconnectionAttempts; }, r.prototype.reconnectionDelay = function (t) { return arguments.length ? (this._reconnectionDelay = t, this.backoff && this.backoff.setMin(t), this) : this._reconnectionDelay; }, r.prototype.randomizationFactor = function (t) { return arguments.length ? (this._randomizationFactor = t, this.backoff && this.backoff.setJitter(t), this) : this._randomizationFactor; }, r.prototype.reconnectionDelayMax = function (t) { return arguments.length ? (this._reconnectionDelayMax = t, this.backoff && this.backoff.setMax(t), this) : this._reconnectionDelayMax; }, r.prototype.timeout = function (t) { return arguments.length ? (this._timeout = t, this) : this._timeout; }, r.prototype.maybeReconnectOnOpen = function () { !this.reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect(); }, r.prototype.open = r.prototype.connect = function (t, e) { if (h("readyState %s", this.readyState), ~this.readyState.indexOf("open")) return this; h("opening %s", this.uri), this.engine = i(this.uri, this.opts); var n = this.engine, r = this; this.readyState = "opening", this.skipReconnect = !1; var o = u(n, "open", function () { r.onopen(), t && t(); }), s = u(n, "error", function (e) { if (h("connect_error"), r.cleanup(), r.readyState = "closed", r.emitAll("connect_error", e), t) { var n = new Error("Connection error"); n.data = e, t(n); } else r.maybeReconnectOnOpen(); }); if (!1 !== this._timeout) { var a = this._timeout; h("connect attempt will timeout after %d", a); var c = setTimeout(function () { h("connect attempt timed out after %d", a), o.destroy(), n.close(), n.emit("error", "timeout"), r.emitAll("connect_timeout", a); }, a); this.subs.push({ destroy: function () { clearTimeout(c); } }); } return this.subs.push(o), this.subs.push(s), this; }, r.prototype.onopen = function () { h("open"), this.cleanup(), this.readyState = "open", this.emit("open"); var t = this.engine; this.subs.push(u(t, "data", p(this, "ondata"))), this.subs.push(u(t, "ping", p(this, "onping"))), this.subs.push(u(t, "pong", p(this, "onpong"))), this.subs.push(u(t, "error", p(this, "onerror"))), this.subs.push(u(t, "close", p(this, "onclose"))), this.subs.push(u(this.decoder, "decoded", p(this, "ondecoded"))); }, r.prototype.onping = function () { this.lastPing = new Date, this.emitAll("ping"); }, r.prototype.onpong = function () { this.emitAll("pong", new Date - this.lastPing); }, r.prototype.ondata = function (t) { this.decoder.add(t); }, r.prototype.ondecoded = function (t) { this.emit("packet", t); }, r.prototype.onerror = function (t) { h("error", t), this.emitAll("error", t); }, r.prototype.socket = function (t, e) { function n() { ~f(o.connecting, r) || o.connecting.push(r); } var r = this.nsps[t]; if (!r) { r = new s(this, t, e), this.nsps[t] = r; var o = this; r.on("connecting", n), r.on("connect", function () { r.id = o.generateId(t); }), this.autoConnect && n(); } return r; }, r.prototype.destroy = function (t) { var e = f(this.connecting, t); ~e && this.connecting.splice(e, 1), this.connecting.length || this.close(); }, r.prototype.packet = function (t) { h("writing packet %j", t); var e = this; t.query && 0 === t.type && (t.nsp += "?" + t.query), e.encoding ? e.packetBuffer.push(t) : (e.encoding = !0, this.encoder.encode(t, function (n) { for (var r = 0; r < n.length; r++)e.engine.write(n[r], t.options); e.encoding = !1, e.processPacketQueue(); })); }, r.prototype.processPacketQueue = function () { if (this.packetBuffer.length > 0 && !this.encoding) { var t = this.packetBuffer.shift(); this.packet(t); } }, r.prototype.cleanup = function () { h("cleanup"); for (var t = this.subs.length, e = 0; e < t; e++) { var n = this.subs.shift(); n.destroy(); } this.packetBuffer = [], this.encoding = !1, this.lastPing = null, this.decoder.destroy(); }, r.prototype.close = r.prototype.disconnect = function () { h("disconnect"), this.skipReconnect = !0, this.reconnecting = !1, "opening" === this.readyState && this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.engine && this.engine.close(); }, r.prototype.onclose = function (t) { h("onclose"), this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.emit("close", t), this._reconnection && !this.skipReconnect && this.reconnect(); }, r.prototype.reconnect = function () { if (this.reconnecting || this.skipReconnect) return this; var t = this; if (this.backoff.attempts >= this._reconnectionAttempts) h("reconnect failed"), this.backoff.reset(), this.emitAll("reconnect_failed"), this.reconnecting = !1; else { var e = this.backoff.duration(); h("will wait %dms before reconnect attempt", e), this.reconnecting = !0; var n = setTimeout(function () { t.skipReconnect || (h("attempting reconnect"), t.emitAll("reconnect_attempt", t.backoff.attempts), t.emitAll("reconnecting", t.backoff.attempts), t.skipReconnect || t.open(function (e) { e ? (h("reconnect attempt error"), t.reconnecting = !1, t.reconnect(), t.emitAll("reconnect_error", e.data)) : (h("reconnect success"), t.onreconnect()); })); }, e); this.subs.push({ destroy: function () { clearTimeout(n); } }); } }, r.prototype.onreconnect = function () { var t = this.backoff.attempts; this.reconnecting = !1, this.backoff.reset(), this.updateSocketIds(), this.emitAll("reconnect", t); }; }, function (t, e, n) { t.exports = n(14), t.exports.parser = n(21); }, function (t, e, n) { (function (e) { function r(t, n) { if (!(this instanceof r)) return new r(t, n); n = n || {}, t && "object" == typeof t && (n = t, t = null), t ? (t = p(t), n.hostname = t.host, n.secure = "https" === t.protocol || "wss" === t.protocol, n.port = t.port, t.query && (n.query = t.query)) : n.host && (n.hostname = p(n.host).host), this.secure = null != n.secure ? n.secure : e.location && "https:" === location.protocol, n.hostname && !n.port && (n.port = this.secure ? "443" : "80"), this.agent = n.agent || !1, this.hostname = n.hostname || (e.location ? location.hostname : "localhost"), this.port = n.port || (e.location && location.port ? location.port : this.secure ? 443 : 80), this.query = n.query || {}, "string" == typeof this.query && (this.query = h.decode(this.query)), this.upgrade = !1 !== n.upgrade, this.path = (n.path || "/engine.io").replace(/\/$/, "") + "/", this.forceJSONP = !!n.forceJSONP, this.jsonp = !1 !== n.jsonp, this.forceBase64 = !!n.forceBase64, this.enablesXDR = !!n.enablesXDR, this.timestampParam = n.timestampParam || "t", this.timestampRequests = n.timestampRequests, this.transports = n.transports || ["polling", "websocket"], this.transportOptions = n.transportOptions || {}, this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.policyPort = n.policyPort || 843, this.rememberUpgrade = n.rememberUpgrade || !1, this.binaryType = null, this.onlyBinaryUpgrades = n.onlyBinaryUpgrades, this.perMessageDeflate = !1 !== n.perMessageDeflate && (n.perMessageDeflate || {}), !0 === this.perMessageDeflate && (this.perMessageDeflate = {}), this.perMessageDeflate && null == this.perMessageDeflate.threshold && (this.perMessageDeflate.threshold = 1024), this.pfx = n.pfx || null, this.key = n.key || null, this.passphrase = n.passphrase || null, this.cert = n.cert || null, this.ca = n.ca || null, this.ciphers = n.ciphers || null, this.rejectUnauthorized = void 0 === n.rejectUnauthorized || n.rejectUnauthorized, this.forceNode = !!n.forceNode; var o = "object" == typeof e && e; o.global === o && (n.extraHeaders && Object.keys(n.extraHeaders).length > 0 && (this.extraHeaders = n.extraHeaders), n.localAddress && (this.localAddress = n.localAddress)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingIntervalTimer = null, this.pingTimeoutTimer = null, this.open(); } function o(t) { var e = {}; for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]); return e; } var i = n(15), s = n(8), a = n(3)("engine.io-client:socket"), c = n(36), u = n(21), p = n(2), h = n(30); t.exports = r, r.priorWebsocketSuccess = !1, s(r.prototype), r.protocol = u.protocol, r.Socket = r, r.Transport = n(20), r.transports = n(15), r.parser = n(21), r.prototype.createTransport = function (t) { a('creating transport "%s"', t); var e = o(this.query); e.EIO = u.protocol, e.transport = t; var n = this.transportOptions[t] || {}; this.id && (e.sid = this.id); var r = new i[t]({ query: e, socket: this, agent: n.agent || this.agent, hostname: n.hostname || this.hostname, port: n.port || this.port, secure: n.secure || this.secure, path: n.path || this.path, forceJSONP: n.forceJSONP || this.forceJSONP, jsonp: n.jsonp || this.jsonp, forceBase64: n.forceBase64 || this.forceBase64, enablesXDR: n.enablesXDR || this.enablesXDR, timestampRequests: n.timestampRequests || this.timestampRequests, timestampParam: n.timestampParam || this.timestampParam, policyPort: n.policyPort || this.policyPort, pfx: n.pfx || this.pfx, key: n.key || this.key, passphrase: n.passphrase || this.passphrase, cert: n.cert || this.cert, ca: n.ca || this.ca, ciphers: n.ciphers || this.ciphers, rejectUnauthorized: n.rejectUnauthorized || this.rejectUnauthorized, perMessageDeflate: n.perMessageDeflate || this.perMessageDeflate, extraHeaders: n.extraHeaders || this.extraHeaders, forceNode: n.forceNode || this.forceNode, localAddress: n.localAddress || this.localAddress, requestTimeout: n.requestTimeout || this.requestTimeout, protocols: n.protocols || void 0 }); return r; }, r.prototype.open = function () { var t; if (this.rememberUpgrade && r.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) t = "websocket"; else { if (0 === this.transports.length) { var e = this; return void setTimeout(function () { e.emit("error", "No transports available"); }, 0); } t = this.transports[0]; } this.readyState = "opening"; try { t = this.createTransport(t); } catch (n) { return this.transports.shift(), void this.open(); } t.open(), this.setTransport(t); }, r.prototype.setTransport = function (t) { a("setting transport %s", t.name); var e = this; this.transport && (a("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = t, t.on("drain", function () { e.onDrain(); }).on("packet", function (t) { e.onPacket(t); }).on("error", function (t) { e.onError(t); }).on("close", function () { e.onClose("transport close"); }); }, r.prototype.probe = function (t) { function e() { if (f.onlyBinaryUpgrades) { var e = !this.supportsBinary && f.transport.supportsBinary; h = h || e; } h || (a('probe transport "%s" opened', t), p.send([{ type: "ping", data: "probe" }]), p.once("packet", function (e) { if (!h) if ("pong" === e.type && "probe" === e.data) { if (a('probe transport "%s" pong', t), f.upgrading = !0, f.emit("upgrading", p), !p) return; r.priorWebsocketSuccess = "websocket" === p.name, a('pausing current transport "%s"', f.transport.name), f.transport.pause(function () { h || "closed" !== f.readyState && (a("changing transport and sending upgrade packet"), u(), f.setTransport(p), p.send([{ type: "upgrade" }]), f.emit("upgrade", p), p = null, f.upgrading = !1, f.flush()); }); } else { a('probe transport "%s" failed', t); var n = new Error("probe error"); n.transport = p.name, f.emit("upgradeError", n); } })); } function n() { h || (h = !0, u(), p.close(), p = null); } function o(e) { var r = new Error("probe error: " + e); r.transport = p.name, n(), a('probe transport "%s" failed because of error: %s', t, e), f.emit("upgradeError", r); } function i() { o("transport closed"); } function s() { o("socket closed"); } function c(t) { p && t.name !== p.name && (a('"%s" works - aborting "%s"', t.name, p.name), n()); } function u() { p.removeListener("open", e), p.removeListener("error", o), p.removeListener("close", i), f.removeListener("close", s), f.removeListener("upgrading", c); } a('probing transport "%s"', t); var p = this.createTransport(t, { probe: 1 }), h = !1, f = this; r.priorWebsocketSuccess = !1, p.once("open", e), p.once("error", o), p.once("close", i), this.once("close", s), this.once("upgrading", c), p.open(); }, r.prototype.onOpen = function () { if (a("socket open"), this.readyState = "open", r.priorWebsocketSuccess = "websocket" === this.transport.name, this.emit("open"), this.flush(), "open" === this.readyState && this.upgrade && this.transport.pause) { a("starting upgrade probes"); for (var t = 0, e = this.upgrades.length; t < e; t++)this.probe(this.upgrades[t]); } }, r.prototype.onPacket = function (t) { if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) switch (a('socket receive: type "%s", data "%s"', t.type, t.data), this.emit("packet", t), this.emit("heartbeat"), t.type) { case "open": this.onHandshake(JSON.parse(t.data)); break; case "pong": this.setPing(), this.emit("pong"); break; case "error": var e = new Error("server error"); e.code = t.data, this.onError(e); break; case "message": this.emit("data", t.data), this.emit("message", t.data); } else a('packet received with socket readyState "%s"', this.readyState); }, r.prototype.onHandshake = function (t) { this.emit("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.onOpen(), "closed" !== this.readyState && (this.setPing(), this.removeListener("heartbeat", this.onHeartbeat), this.on("heartbeat", this.onHeartbeat)); }, r.prototype.onHeartbeat = function (t) { clearTimeout(this.pingTimeoutTimer); var e = this; e.pingTimeoutTimer = setTimeout(function () { "closed" !== e.readyState && e.onClose("ping timeout"); }, t || e.pingInterval + e.pingTimeout); }, r.prototype.setPing = function () { var t = this; clearTimeout(t.pingIntervalTimer), t.pingIntervalTimer = setTimeout(function () { a("writing ping packet - expecting pong within %sms", t.pingTimeout), t.ping(), t.onHeartbeat(t.pingTimeout); }, t.pingInterval); }, r.prototype.ping = function () { var t = this; this.sendPacket("ping", function () { t.emit("ping"); }); }, r.prototype.onDrain = function () { this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emit("drain") : this.flush(); }, r.prototype.flush = function () { "closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && (a("flushing %d packets in socket", this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit("flush")); }, r.prototype.write = r.prototype.send = function (t, e, n) { return this.sendPacket("message", t, e, n), this; }, r.prototype.sendPacket = function (t, e, n, r) { if ("function" == typeof e && (r = e, e = void 0), "function" == typeof n && (r = n, n = null), "closing" !== this.readyState && "closed" !== this.readyState) { n = n || {}, n.compress = !1 !== n.compress; var o = { type: t, data: e, options: n }; this.emit("packetCreate", o), this.writeBuffer.push(o), r && this.once("flush", r), this.flush(); } }, r.prototype.close = function () { function t() { r.onClose("forced close"), a("socket closing - telling transport to close"), r.transport.close(); } function e() { r.removeListener("upgrade", e), r.removeListener("upgradeError", e), t(); } function n() { r.once("upgrade", e), r.once("upgradeError", e); } if ("opening" === this.readyState || "open" === this.readyState) { this.readyState = "closing"; var r = this; this.writeBuffer.length ? this.once("drain", function () { this.upgrading ? n() : t(); }) : this.upgrading ? n() : t(); } return this; }, r.prototype.onError = function (t) { a("socket error %j", t), r.priorWebsocketSuccess = !1, this.emit("error", t), this.onClose("transport error", t); }, r.prototype.onClose = function (t, e) { if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) { a('socket close with reason: "%s"', t); var n = this; clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", this.id = null, this.emit("close", t, e), n.writeBuffer = [], n.prevBufferLen = 0; } }, r.prototype.filterUpgrades = function (t) { for (var e = [], n = 0, r = t.length; n < r; n++)~c(this.transports, t[n]) && e.push(t[n]); return e; }; }).call(e, function () { return this; }()); }, function (t, e, n) {
    (function (t) {
      function r(e) {
        var n, r = !1, a = !1, c = !1 !== e.jsonp; if (t.location) {
          var u = "https:" === location.protocol, p = location.port;
          p || (p = u ? 443 : 80), r = e.hostname !== location.hostname || p !== e.port, a = e.secure !== u;
        } if (e.xdomain = r, e.xscheme = a, n = new o(e), "open" in n && !e.forceJSONP) return new i(e); if (!c) throw new Error("JSONP disabled"); return new s(e);
      } var o = n(16), i = n(18), s = n(33), a = n(34); e.polling = r, e.websocket = a;
    }).call(e, function () { return this; }());
  }, function (t, e, n) { (function (e) { var r = n(17); t.exports = function (t) { var n = t.xdomain, o = t.xscheme, i = t.enablesXDR; try { if ("undefined" != typeof XMLHttpRequest && (!n || r)) return new XMLHttpRequest; } catch (s) { } try { if ("undefined" != typeof XDomainRequest && !o && i) return new XDomainRequest; } catch (s) { } if (!n) try { return new (e[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP"); } catch (s) { } }; }).call(e, function () { return this; }()); }, function (t, e) { try { t.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest; } catch (n) { t.exports = !1; } }, function (t, e, n) { (function (e) { function r() { } function o(t) { if (c.call(this, t), this.requestTimeout = t.requestTimeout, this.extraHeaders = t.extraHeaders, e.location) { var n = "https:" === location.protocol, r = location.port; r || (r = n ? 443 : 80), this.xd = t.hostname !== e.location.hostname || r !== t.port, this.xs = t.secure !== n; } } function i(t) { this.method = t.method || "GET", this.uri = t.uri, this.xd = !!t.xd, this.xs = !!t.xs, this.async = !1 !== t.async, this.data = void 0 !== t.data ? t.data : null, this.agent = t.agent, this.isBinary = t.isBinary, this.supportsBinary = t.supportsBinary, this.enablesXDR = t.enablesXDR, this.requestTimeout = t.requestTimeout, this.pfx = t.pfx, this.key = t.key, this.passphrase = t.passphrase, this.cert = t.cert, this.ca = t.ca, this.ciphers = t.ciphers, this.rejectUnauthorized = t.rejectUnauthorized, this.extraHeaders = t.extraHeaders, this.create(); } function s() { for (var t in i.requests) i.requests.hasOwnProperty(t) && i.requests[t].abort(); } var a = n(16), c = n(19), u = n(8), p = n(31), h = n(3)("engine.io-client:polling-xhr"); t.exports = o, t.exports.Request = i, p(o, c), o.prototype.supportsBinary = !0, o.prototype.request = function (t) { return t = t || {}, t.uri = this.uri(), t.xd = this.xd, t.xs = this.xs, t.agent = this.agent || !1, t.supportsBinary = this.supportsBinary, t.enablesXDR = this.enablesXDR, t.pfx = this.pfx, t.key = this.key, t.passphrase = this.passphrase, t.cert = this.cert, t.ca = this.ca, t.ciphers = this.ciphers, t.rejectUnauthorized = this.rejectUnauthorized, t.requestTimeout = this.requestTimeout, t.extraHeaders = this.extraHeaders, new i(t); }, o.prototype.doWrite = function (t, e) { var n = "string" != typeof t && void 0 !== t, r = this.request({ method: "POST", data: t, isBinary: n }), o = this; r.on("success", e), r.on("error", function (t) { o.onError("xhr post error", t); }), this.sendXhr = r; }, o.prototype.doPoll = function () { h("xhr poll"); var t = this.request(), e = this; t.on("data", function (t) { e.onData(t); }), t.on("error", function (t) { e.onError("xhr poll error", t); }), this.pollXhr = t; }, u(i.prototype), i.prototype.create = function () { var t = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR }; t.pfx = this.pfx, t.key = this.key, t.passphrase = this.passphrase, t.cert = this.cert, t.ca = this.ca, t.ciphers = this.ciphers, t.rejectUnauthorized = this.rejectUnauthorized; var n = this.xhr = new a(t), r = this; try { h("xhr open %s: %s", this.method, this.uri), n.open(this.method, this.uri, this.async); try { if (this.extraHeaders) { n.setDisableHeaderCheck && n.setDisableHeaderCheck(!0); for (var o in this.extraHeaders) this.extraHeaders.hasOwnProperty(o) && n.setRequestHeader(o, this.extraHeaders[o]); } } catch (s) { } if ("POST" === this.method) try { this.isBinary ? n.setRequestHeader("Content-type", "application/octet-stream") : n.setRequestHeader("Content-type", "text/plain;charset=UTF-8"); } catch (s) { } try { n.setRequestHeader("Accept", "*/*"); } catch (s) { } "withCredentials" in n && (n.withCredentials = !0), this.requestTimeout && (n.timeout = this.requestTimeout), this.hasXDR() ? (n.onload = function () { r.onLoad(); }, n.onerror = function () { r.onError(n.responseText); }) : n.onreadystatechange = function () { if (2 === n.readyState) try { var t = n.getResponseHeader("Content-Type"); r.supportsBinary && "application/octet-stream" === t && (n.responseType = "arraybuffer"); } catch (e) { } 4 === n.readyState && (200 === n.status || 1223 === n.status ? r.onLoad() : setTimeout(function () { r.onError(n.status); }, 0)); }, h("xhr data %s", this.data), n.send(this.data); } catch (s) { return void setTimeout(function () { r.onError(s); }, 0); } e.document && (this.index = i.requestsCount++, i.requests[this.index] = this); }, i.prototype.onSuccess = function () { this.emit("success"), this.cleanup(); }, i.prototype.onData = function (t) { this.emit("data", t), this.onSuccess(); }, i.prototype.onError = function (t) { this.emit("error", t), this.cleanup(!0); }, i.prototype.cleanup = function (t) { if ("undefined" != typeof this.xhr && null !== this.xhr) { if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = r : this.xhr.onreadystatechange = r, t) try { this.xhr.abort(); } catch (n) { } e.document && delete i.requests[this.index], this.xhr = null; } }, i.prototype.onLoad = function () { var t; try { var e; try { e = this.xhr.getResponseHeader("Content-Type"); } catch (n) { } t = "application/octet-stream" === e ? this.xhr.response || this.xhr.responseText : this.xhr.responseText; } catch (n) { this.onError(n); } null != t && this.onData(t); }, i.prototype.hasXDR = function () { return "undefined" != typeof e.XDomainRequest && !this.xs && this.enablesXDR; }, i.prototype.abort = function () { this.cleanup(); }, i.requestsCount = 0, i.requests = {}, e.document && (e.attachEvent ? e.attachEvent("onunload", s) : e.addEventListener && e.addEventListener("beforeunload", s, !1)); }).call(e, function () { return this; }()); }, function (t, e, n) { function r(t) { var e = t && t.forceBase64; p && !e || (this.supportsBinary = !1), o.call(this, t); } var o = n(20), i = n(30), s = n(21), a = n(31), c = n(32), u = n(3)("engine.io-client:polling"); t.exports = r; var p = function () { var t = n(16), e = new t({ xdomain: !1 }); return null != e.responseType; }(); a(r, o), r.prototype.name = "polling", r.prototype.doOpen = function () { this.poll(); }, r.prototype.pause = function (t) { function e() { u("paused"), n.readyState = "paused", t(); } var n = this; if (this.readyState = "pausing", this.polling || !this.writable) { var r = 0; this.polling && (u("we are currently polling - waiting to pause"), r++, this.once("pollComplete", function () { u("pre-pause polling complete"), --r || e(); })), this.writable || (u("we are currently writing - waiting to pause"), r++, this.once("drain", function () { u("pre-pause writing complete"), --r || e(); })); } else e(); }, r.prototype.poll = function () { u("polling"), this.polling = !0, this.doPoll(), this.emit("poll"); }, r.prototype.onData = function (t) { var e = this; u("polling got data %s", t); var n = function (t, n, r) { return "opening" === e.readyState && e.onOpen(), "close" === t.type ? (e.onClose(), !1) : void e.onPacket(t); }; s.decodePayload(t, this.socket.binaryType, n), "closed" !== this.readyState && (this.polling = !1, this.emit("pollComplete"), "open" === this.readyState ? this.poll() : u('ignoring poll - transport state "%s"', this.readyState)); }, r.prototype.doClose = function () { function t() { u("writing close packet"), e.write([{ type: "close" }]); } var e = this; "open" === this.readyState ? (u("transport open - closing"), t()) : (u("transport not open - deferring close"), this.once("open", t)); }, r.prototype.write = function (t) { var e = this; this.writable = !1; var n = function () { e.writable = !0, e.emit("drain"); }; s.encodePayload(t, this.supportsBinary, function (t) { e.doWrite(t, n); }); }, r.prototype.uri = function () { var t = this.query || {}, e = this.secure ? "https" : "http", n = ""; !1 !== this.timestampRequests && (t[this.timestampParam] = c()), this.supportsBinary || t.sid || (t.b64 = 1), t = i.encode(t), this.port && ("https" === e && 443 !== Number(this.port) || "http" === e && 80 !== Number(this.port)) && (n = ":" + this.port), t.length && (t = "?" + t); var r = this.hostname.indexOf(":") !== -1; return e + "://" + (r ? "[" + this.hostname + "]" : this.hostname) + n + this.path + t; }; }, function (t, e, n) { function r(t) { this.path = t.path, this.hostname = t.hostname, this.port = t.port, this.secure = t.secure, this.query = t.query, this.timestampParam = t.timestampParam, this.timestampRequests = t.timestampRequests, this.readyState = "", this.agent = t.agent || !1, this.socket = t.socket, this.enablesXDR = t.enablesXDR, this.pfx = t.pfx, this.key = t.key, this.passphrase = t.passphrase, this.cert = t.cert, this.ca = t.ca, this.ciphers = t.ciphers, this.rejectUnauthorized = t.rejectUnauthorized, this.forceNode = t.forceNode, this.extraHeaders = t.extraHeaders, this.localAddress = t.localAddress; } var o = n(21), i = n(8); t.exports = r, i(r.prototype), r.prototype.onError = function (t, e) { var n = new Error(t); return n.type = "TransportError", n.description = e, this.emit("error", n), this; }, r.prototype.open = function () { return "closed" !== this.readyState && "" !== this.readyState || (this.readyState = "opening", this.doOpen()), this; }, r.prototype.close = function () { return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), this.onClose()), this; }, r.prototype.send = function (t) { if ("open" !== this.readyState) throw new Error("Transport not open"); this.write(t); }, r.prototype.onOpen = function () { this.readyState = "open", this.writable = !0, this.emit("open"); }, r.prototype.onData = function (t) { var e = o.decodePacket(t, this.socket.binaryType); this.onPacket(e); }, r.prototype.onPacket = function (t) { this.emit("packet", t); }, r.prototype.onClose = function () { this.readyState = "closed", this.emit("close"); }; }, function (t, e, n) { (function (t) { function r(t, n) { var r = "b" + e.packets[t.type] + t.data.data; return n(r); } function o(t, n, r) { if (!n) return e.encodeBase64Packet(t, r); var o = t.data, i = new Uint8Array(o), s = new Uint8Array(1 + o.byteLength); s[0] = v[t.type]; for (var a = 0; a < i.length; a++)s[a + 1] = i[a]; return r(s.buffer); } function i(t, n, r) { if (!n) return e.encodeBase64Packet(t, r); var o = new FileReader; return o.onload = function () { t.data = o.result, e.encodePacket(t, n, !0, r); }, o.readAsArrayBuffer(t.data); } function s(t, n, r) { if (!n) return e.encodeBase64Packet(t, r); if (g) return i(t, n, r); var o = new Uint8Array(1); o[0] = v[t.type]; var s = new k([o.buffer, t.data]); return r(s); } function a(t) { try { t = d.decode(t, { strict: !1 }); } catch (e) { return !1; } return t; } function c(t, e, n) { for (var r = new Array(t.length), o = l(t.length, n), i = function (t, n, o) { e(n, function (e, n) { r[t] = n, o(e, r); }); }, s = 0; s < t.length; s++)i(s, t[s], o); } var u, p = n(22), h = n(23), f = n(24), l = n(25), d = n(26); t && t.ArrayBuffer && (u = n(28)); var y = "undefined" != typeof navigator && /Android/i.test(navigator.userAgent), m = "undefined" != typeof navigator && /PhantomJS/i.test(navigator.userAgent), g = y || m; e.protocol = 3; var v = e.packets = { open: 0, close: 1, ping: 2, pong: 3, message: 4, upgrade: 5, noop: 6 }, b = p(v), w = { type: "error", data: "parser error" }, k = n(29); e.encodePacket = function (e, n, i, a) { "function" == typeof n && (a = n, n = !1), "function" == typeof i && (a = i, i = null); var c = void 0 === e.data ? void 0 : e.data.buffer || e.data; if (t.ArrayBuffer && c instanceof ArrayBuffer) return o(e, n, a); if (k && c instanceof t.Blob) return s(e, n, a); if (c && c.base64) return r(e, a); var u = v[e.type]; return void 0 !== e.data && (u += i ? d.encode(String(e.data), { strict: !1 }) : String(e.data)), a("" + u); }, e.encodeBase64Packet = function (n, r) { var o = "b" + e.packets[n.type]; if (k && n.data instanceof t.Blob) { var i = new FileReader; return i.onload = function () { var t = i.result.split(",")[1]; r(o + t); }, i.readAsDataURL(n.data); } var s; try { s = String.fromCharCode.apply(null, new Uint8Array(n.data)); } catch (a) { for (var c = new Uint8Array(n.data), u = new Array(c.length), p = 0; p < c.length; p++)u[p] = c[p]; s = String.fromCharCode.apply(null, u); } return o += t.btoa(s), r(o); }, e.decodePacket = function (t, n, r) { if (void 0 === t) return w; if ("string" == typeof t) { if ("b" === t.charAt(0)) return e.decodeBase64Packet(t.substr(1), n); if (r && (t = a(t), t === !1)) return w; var o = t.charAt(0); return Number(o) == o && b[o] ? t.length > 1 ? { type: b[o], data: t.substring(1) } : { type: b[o] } : w; } var i = new Uint8Array(t), o = i[0], s = f(t, 1); return k && "blob" === n && (s = new k([s])), { type: b[o], data: s }; }, e.decodeBase64Packet = function (t, e) { var n = b[t.charAt(0)]; if (!u) return { type: n, data: { base64: !0, data: t.substr(1) } }; var r = u.decode(t.substr(1)); return "blob" === e && k && (r = new k([r])), { type: n, data: r }; }, e.encodePayload = function (t, n, r) { function o(t) { return t.length + ":" + t; } function i(t, r) { e.encodePacket(t, !!s && n, !1, function (t) { r(null, o(t)); }); } "function" == typeof n && (r = n, n = null); var s = h(t); return n && s ? k && !g ? e.encodePayloadAsBlob(t, r) : e.encodePayloadAsArrayBuffer(t, r) : t.length ? void c(t, i, function (t, e) { return r(e.join("")); }) : r("0:"); }, e.decodePayload = function (t, n, r) { if ("string" != typeof t) return e.decodePayloadAsBinary(t, n, r); "function" == typeof n && (r = n, n = null); var o; if ("" === t) return r(w, 0, 1); for (var i, s, a = "", c = 0, u = t.length; c < u; c++) { var p = t.charAt(c); if (":" === p) { if ("" === a || a != (i = Number(a))) return r(w, 0, 1); if (s = t.substr(c + 1, i), a != s.length) return r(w, 0, 1); if (s.length) { if (o = e.decodePacket(s, n, !1), w.type === o.type && w.data === o.data) return r(w, 0, 1); var h = r(o, c + i, u); if (!1 === h) return; } c += i, a = ""; } else a += p; } return "" !== a ? r(w, 0, 1) : void 0; }, e.encodePayloadAsArrayBuffer = function (t, n) { function r(t, n) { e.encodePacket(t, !0, !0, function (t) { return n(null, t); }); } return t.length ? void c(t, r, function (t, e) { var r = e.reduce(function (t, e) { var n; return n = "string" == typeof e ? e.length : e.byteLength, t + n.toString().length + n + 2; }, 0), o = new Uint8Array(r), i = 0; return e.forEach(function (t) { var e = "string" == typeof t, n = t; if (e) { for (var r = new Uint8Array(t.length), s = 0; s < t.length; s++)r[s] = t.charCodeAt(s); n = r.buffer; } e ? o[i++] = 0 : o[i++] = 1; for (var a = n.byteLength.toString(), s = 0; s < a.length; s++)o[i++] = parseInt(a[s]); o[i++] = 255; for (var r = new Uint8Array(n), s = 0; s < r.length; s++)o[i++] = r[s]; }), n(o.buffer); }) : n(new ArrayBuffer(0)); }, e.encodePayloadAsBlob = function (t, n) { function r(t, n) { e.encodePacket(t, !0, !0, function (t) { var e = new Uint8Array(1); if (e[0] = 1, "string" == typeof t) { for (var r = new Uint8Array(t.length), o = 0; o < t.length; o++)r[o] = t.charCodeAt(o); t = r.buffer, e[0] = 0; } for (var i = t instanceof ArrayBuffer ? t.byteLength : t.size, s = i.toString(), a = new Uint8Array(s.length + 1), o = 0; o < s.length; o++)a[o] = parseInt(s[o]); if (a[s.length] = 255, k) { var c = new k([e.buffer, a.buffer, t]); n(null, c); } }); } c(t, r, function (t, e) { return n(new k(e)); }); }, e.decodePayloadAsBinary = function (t, n, r) { "function" == typeof n && (r = n, n = null); for (var o = t, i = []; o.byteLength > 0;) { for (var s = new Uint8Array(o), a = 0 === s[0], c = "", u = 1; 255 !== s[u]; u++) { if (c.length > 310) return r(w, 0, 1); c += s[u]; } o = f(o, 2 + c.length), c = parseInt(c); var p = f(o, 0, c); if (a) try { p = String.fromCharCode.apply(null, new Uint8Array(p)); } catch (h) { var l = new Uint8Array(p); p = ""; for (var u = 0; u < l.length; u++)p += String.fromCharCode(l[u]); } i.push(p), o = f(o, c); } var d = i.length; i.forEach(function (t, o) { r(e.decodePacket(t, n, !0), o, d); }); }; }).call(e, function () { return this; }()); }, function (t, e) { t.exports = Object.keys || function (t) { var e = [], n = Object.prototype.hasOwnProperty; for (var r in t) n.call(t, r) && e.push(r); return e; }; }, function (t, e, n) { (function (e) { function r(t) { if (!t || "object" != typeof t) return !1; if (o(t)) { for (var n = 0, i = t.length; n < i; n++)if (r(t[n])) return !0; return !1; } if ("function" == typeof e.Buffer && e.Buffer.isBuffer && e.Buffer.isBuffer(t) || "function" == typeof e.ArrayBuffer && t instanceof ArrayBuffer || s && t instanceof Blob || a && t instanceof File) return !0; if (t.toJSON && "function" == typeof t.toJSON && 1 === arguments.length) return r(t.toJSON(), !0); for (var c in t) if (Object.prototype.hasOwnProperty.call(t, c) && r(t[c])) return !0; return !1; } var o = n(10), i = Object.prototype.toString, s = "function" == typeof e.Blob || "[object BlobConstructor]" === i.call(e.Blob), a = "function" == typeof e.File || "[object FileConstructor]" === i.call(e.File); t.exports = r; }).call(e, function () { return this; }()); }, function (t, e) { t.exports = function (t, e, n) { var r = t.byteLength; if (e = e || 0, n = n || r, t.slice) return t.slice(e, n); if (e < 0 && (e += r), n < 0 && (n += r), n > r && (n = r), e >= r || e >= n || 0 === r) return new ArrayBuffer(0); for (var o = new Uint8Array(t), i = new Uint8Array(n - e), s = e, a = 0; s < n; s++, a++)i[a] = o[s]; return i.buffer; }; }, function (t, e) { function n(t, e, n) { function o(t, r) { if (o.count <= 0) throw new Error("after called too many times"); --o.count, t ? (i = !0, e(t), e = n) : 0 !== o.count || i || e(null, r); } var i = !1; return n = n || r, o.count = t, 0 === t ? e() : o; } function r() { } t.exports = n; }, function (t, e, n) { var r; (function (t, o) { !function (i) { function s(t) { for (var e, n, r = [], o = 0, i = t.length; o < i;)e = t.charCodeAt(o++), e >= 55296 && e <= 56319 && o < i ? (n = t.charCodeAt(o++), 56320 == (64512 & n) ? r.push(((1023 & e) << 10) + (1023 & n) + 65536) : (r.push(e), o--)) : r.push(e); return r; } function a(t) { for (var e, n = t.length, r = -1, o = ""; ++r < n;)e = t[r], e > 65535 && (e -= 65536, o += w(e >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), o += w(e); return o; } function c(t, e) { if (t >= 55296 && t <= 57343) { if (e) throw Error("Lone surrogate U+" + t.toString(16).toUpperCase() + " is not a scalar value"); return !1; } return !0; } function u(t, e) { return w(t >> e & 63 | 128); } function p(t, e) { if (0 == (4294967168 & t)) return w(t); var n = ""; return 0 == (4294965248 & t) ? n = w(t >> 6 & 31 | 192) : 0 == (4294901760 & t) ? (c(t, e) || (t = 65533), n = w(t >> 12 & 15 | 224), n += u(t, 6)) : 0 == (4292870144 & t) && (n = w(t >> 18 & 7 | 240), n += u(t, 12), n += u(t, 6)), n += w(63 & t | 128); } function h(t, e) { e = e || {}; for (var n, r = !1 !== e.strict, o = s(t), i = o.length, a = -1, c = ""; ++a < i;)n = o[a], c += p(n, r); return c; } function f() { if (b >= v) throw Error("Invalid byte index"); var t = 255 & g[b]; if (b++, 128 == (192 & t)) return 63 & t; throw Error("Invalid continuation byte"); } function l(t) { var e, n, r, o, i; if (b > v) throw Error("Invalid byte index"); if (b == v) return !1; if (e = 255 & g[b], b++, 0 == (128 & e)) return e; if (192 == (224 & e)) { if (n = f(), i = (31 & e) << 6 | n, i >= 128) return i; throw Error("Invalid continuation byte"); } if (224 == (240 & e)) { if (n = f(), r = f(), i = (15 & e) << 12 | n << 6 | r, i >= 2048) return c(i, t) ? i : 65533; throw Error("Invalid continuation byte"); } if (240 == (248 & e) && (n = f(), r = f(), o = f(), i = (7 & e) << 18 | n << 12 | r << 6 | o, i >= 65536 && i <= 1114111)) return i; throw Error("Invalid UTF-8 detected"); } function d(t, e) { e = e || {}; var n = !1 !== e.strict; g = s(t), v = g.length, b = 0; for (var r, o = []; (r = l(n)) !== !1;)o.push(r); return a(o); } var y = "object" == typeof e && e, m = ("object" == typeof t && t && t.exports == y && t, "object" == typeof o && o); m.global !== m && m.window !== m || (i = m); var g, v, b, w = String.fromCharCode, k = { version: "2.1.2", encode: h, decode: d }; r = function () { return k; }.call(e, n, e, t), !(void 0 !== r && (t.exports = r)); }(this); }).call(e, n(27)(t), function () { return this; }()); }, function (t, e) { t.exports = function (t) { return t.webpackPolyfill || (t.deprecate = function () { }, t.paths = [], t.children = [], t.webpackPolyfill = 1), t; }; }, function (t, e) { !function () { "use strict"; for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = new Uint8Array(256), r = 0; r < t.length; r++)n[t.charCodeAt(r)] = r; e.encode = function (e) { var n, r = new Uint8Array(e), o = r.length, i = ""; for (n = 0; n < o; n += 3)i += t[r[n] >> 2], i += t[(3 & r[n]) << 4 | r[n + 1] >> 4], i += t[(15 & r[n + 1]) << 2 | r[n + 2] >> 6], i += t[63 & r[n + 2]]; return o % 3 === 2 ? i = i.substring(0, i.length - 1) + "=" : o % 3 === 1 && (i = i.substring(0, i.length - 2) + "=="), i; }, e.decode = function (t) { var e, r, o, i, s, a = .75 * t.length, c = t.length, u = 0; "=" === t[t.length - 1] && (a--, "=" === t[t.length - 2] && a--); var p = new ArrayBuffer(a), h = new Uint8Array(p); for (e = 0; e < c; e += 4)r = n[t.charCodeAt(e)], o = n[t.charCodeAt(e + 1)], i = n[t.charCodeAt(e + 2)], s = n[t.charCodeAt(e + 3)], h[u++] = r << 2 | o >> 4, h[u++] = (15 & o) << 4 | i >> 2, h[u++] = (3 & i) << 6 | 63 & s; return p; }; }(); }, function (t, e) { (function (e) { function n(t) { for (var e = 0; e < t.length; e++) { var n = t[e]; if (n.buffer instanceof ArrayBuffer) { var r = n.buffer; if (n.byteLength !== r.byteLength) { var o = new Uint8Array(n.byteLength); o.set(new Uint8Array(r, n.byteOffset, n.byteLength)), r = o.buffer; } t[e] = r; } } } function r(t, e) { e = e || {}; var r = new i; n(t); for (var o = 0; o < t.length; o++)r.append(t[o]); return e.type ? r.getBlob(e.type) : r.getBlob(); } function o(t, e) { return n(t), new Blob(t, e || {}); } var i = e.BlobBuilder || e.WebKitBlobBuilder || e.MSBlobBuilder || e.MozBlobBuilder, s = function () { try { var t = new Blob(["hi"]); return 2 === t.size; } catch (e) { return !1; } }(), a = s && function () { try { var t = new Blob([new Uint8Array([1, 2])]); return 2 === t.size; } catch (e) { return !1; } }(), c = i && i.prototype.append && i.prototype.getBlob; t.exports = function () { return s ? a ? e.Blob : o : c ? r : void 0; }(); }).call(e, function () { return this; }()); }, function (t, e) { e.encode = function (t) { var e = ""; for (var n in t) t.hasOwnProperty(n) && (e.length && (e += "&"), e += encodeURIComponent(n) + "=" + encodeURIComponent(t[n])); return e; }, e.decode = function (t) { for (var e = {}, n = t.split("&"), r = 0, o = n.length; r < o; r++) { var i = n[r].split("="); e[decodeURIComponent(i[0])] = decodeURIComponent(i[1]); } return e; }; }, function (t, e) { t.exports = function (t, e) { var n = function () { }; n.prototype = e.prototype, t.prototype = new n, t.prototype.constructor = t; }; }, function (t, e) { "use strict"; function n(t) { var e = ""; do e = s[t % a] + e, t = Math.floor(t / a); while (t > 0); return e; } function r(t) { var e = 0; for (p = 0; p < t.length; p++)e = e * a + c[t.charAt(p)]; return e; } function o() { var t = n(+new Date); return t !== i ? (u = 0, i = t) : t + "." + n(u++); } for (var i, s = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), a = 64, c = {}, u = 0, p = 0; p < a; p++)c[s[p]] = p; o.encode = n, o.decode = r, t.exports = o; }, function (t, e, n) { (function (e) { function r() { } function o(t) { i.call(this, t), this.query = this.query || {}, a || (e.___eio || (e.___eio = []), a = e.___eio), this.index = a.length; var n = this; a.push(function (t) { n.onData(t); }), this.query.j = this.index, e.document && e.addEventListener && e.addEventListener("beforeunload", function () { n.script && (n.script.onerror = r); }, !1); } var i = n(19), s = n(31); t.exports = o; var a, c = /\n/g, u = /\\n/g; s(o, i), o.prototype.supportsBinary = !1, o.prototype.doClose = function () { this.script && (this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), i.prototype.doClose.call(this); }, o.prototype.doPoll = function () { var t = this, e = document.createElement("script"); this.script && (this.script.parentNode.removeChild(this.script), this.script = null), e.async = !0, e.src = this.uri(), e.onerror = function (e) { t.onError("jsonp poll error", e); }; var n = document.getElementsByTagName("script")[0]; n ? n.parentNode.insertBefore(e, n) : (document.head || document.body).appendChild(e), this.script = e; var r = "undefined" != typeof navigator && /gecko/i.test(navigator.userAgent); r && setTimeout(function () { var t = document.createElement("iframe"); document.body.appendChild(t), document.body.removeChild(t); }, 100); }, o.prototype.doWrite = function (t, e) { function n() { r(), e(); } function r() { if (o.iframe) try { o.form.removeChild(o.iframe); } catch (t) { o.onError("jsonp polling iframe removal error", t); } try { var e = '<iframe src="javascript:0" name="' + o.iframeId + '">'; i = document.createElement(e); } catch (t) { i = document.createElement("iframe"), i.name = o.iframeId, i.src = "javascript:0"; } i.id = o.iframeId, o.form.appendChild(i), o.iframe = i; } var o = this; if (!this.form) { var i, s = document.createElement("form"), a = document.createElement("textarea"), p = this.iframeId = "eio_iframe_" + this.index; s.className = "socketio", s.style.position = "absolute", s.style.top = "-1000px", s.style.left = "-1000px", s.target = p, s.method = "POST", s.setAttribute("accept-charset", "utf-8"), a.name = "d", s.appendChild(a), document.body.appendChild(s), this.form = s, this.area = a; } this.form.action = this.uri(), r(), t = t.replace(u, "\\\n"), this.area.value = t.replace(c, "\\n"); try { this.form.submit(); } catch (h) { } this.iframe.attachEvent ? this.iframe.onreadystatechange = function () { "complete" === o.iframe.readyState && n(); } : this.iframe.onload = n; }; }).call(e, function () { return this; }()); }, function (t, e, n) { (function (e) { function r(t) { var e = t && t.forceBase64; e && (this.supportsBinary = !1), this.perMessageDeflate = t.perMessageDeflate, this.usingBrowserWebSocket = h && !t.forceNode, this.protocols = t.protocols, this.usingBrowserWebSocket || (l = o), i.call(this, t); } var o, i = n(20), s = n(21), a = n(30), c = n(31), u = n(32), p = n(3)("engine.io-client:websocket"), h = e.WebSocket || e.MozWebSocket; if ("undefined" == typeof window) try { o = n(35); } catch (f) { } var l = h; l || "undefined" != typeof window || (l = o), t.exports = r, c(r, i), r.prototype.name = "websocket", r.prototype.supportsBinary = !0, r.prototype.doOpen = function () { if (this.check()) { var t = this.uri(), e = this.protocols, n = { agent: this.agent, perMessageDeflate: this.perMessageDeflate }; n.pfx = this.pfx, n.key = this.key, n.passphrase = this.passphrase, n.cert = this.cert, n.ca = this.ca, n.ciphers = this.ciphers, n.rejectUnauthorized = this.rejectUnauthorized, this.extraHeaders && (n.headers = this.extraHeaders), this.localAddress && (n.localAddress = this.localAddress); try { this.ws = this.usingBrowserWebSocket ? e ? new l(t, e) : new l(t) : new l(t, e, n); } catch (r) { return this.emit("error", r); } void 0 === this.ws.binaryType && (this.supportsBinary = !1), this.ws.supports && this.ws.supports.binary ? (this.supportsBinary = !0, this.ws.binaryType = "nodebuffer") : this.ws.binaryType = "arraybuffer", this.addEventListeners(); } }, r.prototype.addEventListeners = function () { var t = this; this.ws.onopen = function () { t.onOpen(); }, this.ws.onclose = function () { t.onClose(); }, this.ws.onmessage = function (e) { t.onData(e.data); }, this.ws.onerror = function (e) { t.onError("websocket error", e); }; }, r.prototype.write = function (t) { function n() { r.emit("flush"), setTimeout(function () { r.writable = !0, r.emit("drain"); }, 0); } var r = this; this.writable = !1; for (var o = t.length, i = 0, a = o; i < a; i++)!function (t) { s.encodePacket(t, r.supportsBinary, function (i) { if (!r.usingBrowserWebSocket) { var s = {}; if (t.options && (s.compress = t.options.compress), r.perMessageDeflate) { var a = "string" == typeof i ? e.Buffer.byteLength(i) : i.length; a < r.perMessageDeflate.threshold && (s.compress = !1); } } try { r.usingBrowserWebSocket ? r.ws.send(i) : r.ws.send(i, s); } catch (c) { p("websocket closed before onclose event"); } --o || n(); }); }(t[i]); }, r.prototype.onClose = function () { i.prototype.onClose.call(this); }, r.prototype.doClose = function () { "undefined" != typeof this.ws && this.ws.close(); }, r.prototype.uri = function () { var t = this.query || {}, e = this.secure ? "wss" : "ws", n = ""; this.port && ("wss" === e && 443 !== Number(this.port) || "ws" === e && 80 !== Number(this.port)) && (n = ":" + this.port), this.timestampRequests && (t[this.timestampParam] = u()), this.supportsBinary || (t.b64 = 1), t = a.encode(t), t.length && (t = "?" + t); var r = this.hostname.indexOf(":") !== -1; return e + "://" + (r ? "[" + this.hostname + "]" : this.hostname) + n + this.path + t; }, r.prototype.check = function () { return !(!l || "__initialize" in l && this.name === r.prototype.name); }; }).call(e, function () { return this; }()); }, function (t, e) { }, function (t, e) { var n = [].indexOf; t.exports = function (t, e) { if (n) return t.indexOf(e); for (var r = 0; r < t.length; ++r)if (t[r] === e) return r; return -1; }; }, function (t, e, n) { "use strict"; function r(t, e, n) { this.io = t, this.nsp = e, this.json = this, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected = !1, this.disconnected = !0, this.flags = {}, n && n.query && (this.query = n.query), this.io.autoConnect && this.open(); } var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t; } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t; }, i = n(7), s = n(8), a = n(38), c = n(39), u = n(40), p = n(3)("socket.io-client:socket"), h = n(30), f = n(23); t.exports = e = r; var l = { connect: 1, connect_error: 1, connect_timeout: 1, connecting: 1, disconnect: 1, error: 1, reconnect: 1, reconnect_attempt: 1, reconnect_failed: 1, reconnect_error: 1, reconnecting: 1, ping: 1, pong: 1 }, d = s.prototype.emit; s(r.prototype), r.prototype.subEvents = function () { if (!this.subs) { var t = this.io; this.subs = [c(t, "open", u(this, "onopen")), c(t, "packet", u(this, "onpacket")), c(t, "close", u(this, "onclose"))]; } }, r.prototype.open = r.prototype.connect = function () { return this.connected ? this : (this.subEvents(), this.io.open(), "open" === this.io.readyState && this.onopen(), this.emit("connecting"), this); }, r.prototype.send = function () { var t = a(arguments); return t.unshift("message"), this.emit.apply(this, t), this; }, r.prototype.emit = function (t) { if (l.hasOwnProperty(t)) return d.apply(this, arguments), this; var e = a(arguments), n = { type: (void 0 !== this.flags.binary ? this.flags.binary : f(e)) ? i.BINARY_EVENT : i.EVENT, data: e }; return n.options = {}, n.options.compress = !this.flags || !1 !== this.flags.compress, "function" == typeof e[e.length - 1] && (p("emitting packet with ack id %d", this.ids), this.acks[this.ids] = e.pop(), n.id = this.ids++), this.connected ? this.packet(n) : this.sendBuffer.push(n), this.flags = {}, this; }, r.prototype.packet = function (t) { t.nsp = this.nsp, this.io.packet(t); }, r.prototype.onopen = function () { if (p("transport is open - connecting"), "/" !== this.nsp) if (this.query) { var t = "object" === o(this.query) ? h.encode(this.query) : this.query; p("sending connect packet with query %s", t), this.packet({ type: i.CONNECT, query: t }); } else this.packet({ type: i.CONNECT }); }, r.prototype.onclose = function (t) { p("close (%s)", t), this.connected = !1, this.disconnected = !0, delete this.id, this.emit("disconnect", t); }, r.prototype.onpacket = function (t) { var e = t.nsp === this.nsp, n = t.type === i.ERROR && "/" === t.nsp; if (e || n) switch (t.type) { case i.CONNECT: this.onconnect(); break; case i.EVENT: this.onevent(t); break; case i.BINARY_EVENT: this.onevent(t); break; case i.ACK: this.onack(t); break; case i.BINARY_ACK: this.onack(t); break; case i.DISCONNECT: this.ondisconnect(); break; case i.ERROR: this.emit("error", t.data); } }, r.prototype.onevent = function (t) { var e = t.data || []; p("emitting event %j", e), null != t.id && (p("attaching ack callback to event"), e.push(this.ack(t.id))), this.connected ? d.apply(this, e) : this.receiveBuffer.push(e); }, r.prototype.ack = function (t) { var e = this, n = !1; return function () { if (!n) { n = !0; var r = a(arguments); p("sending ack %j", r), e.packet({ type: f(r) ? i.BINARY_ACK : i.ACK, id: t, data: r }); } }; }, r.prototype.onack = function (t) { var e = this.acks[t.id]; "function" == typeof e ? (p("calling ack %s with %j", t.id, t.data), e.apply(this, t.data), delete this.acks[t.id]) : p("bad ack %s", t.id); }, r.prototype.onconnect = function () { this.connected = !0, this.disconnected = !1, this.emit("connect"), this.emitBuffered(); }, r.prototype.emitBuffered = function () { var t; for (t = 0; t < this.receiveBuffer.length; t++)d.apply(this, this.receiveBuffer[t]); for (this.receiveBuffer = [], t = 0; t < this.sendBuffer.length; t++)this.packet(this.sendBuffer[t]); this.sendBuffer = []; }, r.prototype.ondisconnect = function () { p("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect"); }, r.prototype.destroy = function () { if (this.subs) { for (var t = 0; t < this.subs.length; t++)this.subs[t].destroy(); this.subs = null; } this.io.destroy(this); }, r.prototype.close = r.prototype.disconnect = function () { return this.connected && (p("performing disconnect (%s)", this.nsp), this.packet({ type: i.DISCONNECT })), this.destroy(), this.connected && this.onclose("io client disconnect"), this; }, r.prototype.compress = function (t) { return this.flags.compress = t, this; }, r.prototype.binary = function (t) { return this.flags.binary = t, this; }; }, function (t, e) { function n(t, e) { var n = []; e = e || 0; for (var r = e || 0; r < t.length; r++)n[r - e] = t[r]; return n; } t.exports = n; }, function (t, e) { "use strict"; function n(t, e, n) { return t.on(e, n), { destroy: function () { t.removeListener(e, n); } }; } t.exports = n; }, function (t, e) { var n = [].slice; t.exports = function (t, e) { if ("string" == typeof e && (e = t[e]), "function" != typeof e) throw new Error("bind() requires a function"); var r = n.call(arguments, 2); return function () { return e.apply(t, r.concat(n.call(arguments))); }; }; }, function (t, e) { function n(t) { t = t || {}, this.ms = t.min || 100, this.max = t.max || 1e4, this.factor = t.factor || 2, this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0, this.attempts = 0; } t.exports = n, n.prototype.duration = function () { var t = this.ms * Math.pow(this.factor, this.attempts++); if (this.jitter) { var e = Math.random(), n = Math.floor(e * this.jitter * t); t = 0 == (1 & Math.floor(10 * e)) ? t - n : t + n; } return 0 | Math.min(t, this.max); }, n.prototype.reset = function () { this.attempts = 0; }, n.prototype.setMin = function (t) { this.ms = t; }, n.prototype.setMax = function (t) { this.max = t; }, n.prototype.setJitter = function (t) { this.jitter = t; }; }]);
});/*!
 * jQuery Cookie Plugin v1.3.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as anonymous module.
    define(['jquery'], factory);
  } else {
    // Browser globals.
    factory(jQuery);
  }
}(function ($) {

  var pluses = /\+/g;

  function raw(s) {
    return s;
  }

  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  function converted(s) {
    if (s.indexOf('"') === 0) {
      // This is a quoted cookie as according to RFC2068, unescape
      s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
    }
    try {
      return config.json ? JSON.parse(s) : s;
    } catch (er) { }
  }

  var config = $.cookie = function (key, value, options) {

    // write
    if (value !== undefined) {
      options = $.extend({}, config.defaults, options);

      if (typeof options.expires === 'number') {
        var days = options.expires, t = options.expires = new Date();
        t.setDate(t.getDate() + days);
      }

      value = config.json ? JSON.stringify(value) : String(value);

      return (document.cookie = [
        config.raw ? key : encodeURIComponent(key),
        '=',
        config.raw ? value : encodeURIComponent(value),
        options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
        options.path ? '; path=' + options.path : '',
        options.domain ? '; domain=' + options.domain : '',
        options.secure ? '; secure' : '',
        options.sameSite ? '; SameSite=' + options.sameSite : '',
      ].join(''));
    }

    // read
    var decode = config.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    var result = key ? undefined : {};
    for (var i = 0, l = cookies.length; i < l; i++) {
      var parts = cookies[i].split('=');
      var name = decode(parts.shift());
      var cookie = decode(parts.join('='));

      if (key && key === name) {
        result = converted(cookie);
        break;
      }

      if (!key) {
        result[name] = converted(cookie);
      }
    }

    return result;
  };

  config.defaults = {};

  $.removeCookie = function (key, options) {
    if ($.cookie(key) !== undefined) {
      $.cookie(key, '', $.extend(options, { expires: -1 }));
      return true;
    }
    return false;
  };

}));// DBLGamepad

function DBLGamepadManager() {
  var self = this;
  this.controllers = [];
  this.haveEvents = 'GamepadEvent' in window;
  this.haveWebkitEvents = 'WebKitGamepadEvent' in window;
  this.deadzone = 0.1;

  this.init = function () {
    if (this.haveEvents) {
      window.addEventListener("gamepadconnected", this.didConnect);
      window.addEventListener("gamepaddisconnected", this.didDisconnect);
    } else if (this.haveWebkitEvents) {
      window.addEventListener("webkitgamepadconnected", this.didConnect);
      window.addEventListener("webkitgamepaddisconnected", this.didDisconnect);
    } else {
      setInterval(this.scanGamepads, 500);
    }
  };

  this.clearState = function () {
    poleDownState = 0;
    poleUpState = 0;
    powerDriveOn = false;
    throttleSpeed = 0;
    turnSpeed = 0;
    forwardState = 0;
    backwardState = 0;
    leftState = 0;
    rightState = 0;
  };

  this.updateLabel = function (gamepad) {
    if (gamepad && gamepad.connected) {
      $("#gamepadStatus").text("Connected");
    } else {
      $("#gamepadStatus").text("Not Connected");
    }
  };

  this.didConnect = function (e) {
    console.log("gamepad didConnect: ", e.gamepad);
    this.clearState();
    this.addGamepad(e.gamepad);
    this.updateLabel(e.gamepad);
  };

  this.didDisconnect = function (e) {
    console.log("gamepad didDisonnect: ", e.gamepad);
    this.clearState();
    this.removeGamepad(e.gamepad);
    this.updateLabel(e.gamepad);
  };

  this.addGamepad = function (gamepad) {
    this.controllers[gamepad.index] = new DBLGamepad(gamepad);
    requestAnimationFrame(this.update);
  };

  this.removeGamepad = function (gamepad) {
    this.controllers[gamepad.index].didDisconnect();
    delete this.controllers[gamepad.index];
  };

  this.update = function () {
    self.scanGamepads();
    var i = 0;
    var j;
    for (j in self.controllers) {
      var controller = controllers[j];
      for (i = 0; i < controller.gamepad.buttons.length; i++) {
        var val = controller.gamepad.buttons[i];
        var pressed = val == 1.0;
        if (typeof (val) == "object") {
          pressed = val.pressed;
          val = val.value;
        }

        var lastVal = controller.lastButtons[i];
        if (val != lastVal) {
          controller.buttonChanged(i, val);
        }
      }

      for (i = 0; i < controller.gamepad.axes.length; i++) {
        var a = controller.gamepad.axes[i];
        var val = controller.gamepad.axes[i].toFixed(3);
        if ((val > 0 && val <= self.deadzone) || (val < 0 && val >= -1 * self.deadzone)) {
          val = 0;
        }
        var lastVal = controller.lastAxes[i];
        if (val != lastVal) {
          controller.axisChanged(i, val);
        }
      }
    }

    requestAnimationFrame(self.update);
  };

  this.scanGamepads = function () {
    var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);
    for (var i = 0; i < gamepads.length; i++) {
      if (gamepads[i]) {
        if (!(gamepads[i].index in controllers)) {
          self.addGamepad(gamepads[i]);
        } else {
          self.controllers[gamepads[i].index].gamepad = gamepads[i];
        }
      }
    }
  };

  this.init();
}

function DBLGamepad(gamepad) {
  if (!gamepad) {
    return null;
  }
  this.index = gamepad.index;
  this.gamepad = gamepad;
  this.lastButtons = [];
  this.lastAxes = [];
  this.lastAxes[5] = 0;
  this.lastAxes[1] = 0;
  this.lastAxes[2] = 0;
  this.lastAxes[0] = 0;
  this.lastAxes[9] = 8;
  this.buttonMap = [];
  this.axisMap = [];

  this.buttonChanged = function (index, val) {
    val = parseFloat(val);
    if (this.lastButtons[index] != undefined) {
      if (this.lastButtons[index] != val) {
        if (val >= 1.0) {
          this.buttonDown(index);
        } else {
          this.buttonUp(index);
        }
      }
    }
    this.lastButtons[index] = val;
    // console.log("button "+ index +" = "+ val);
  };

  this.axisChanged = function (index, val) {
    index = this.mappedAxis(index);
    if (index == -1) { return; }

    this.lastAxes[index] = val;
    // console.log(this.index +" axis"+ index +" = "+ val +" "+ parseFloat(val));
    if (!$("#session").is(":visible")) {
      return;
    }
    switch (index) {
      case 1: // left stick, forward (-1), back (+1)
      case 5: // right stick, forward (-1), back (+1)
        if (val < 0 && kickstandState == kDRKickstand_stateDeployed) {
          parkAction();
        }
        throttleSpeed = Math.min(1, Math.max(-1, val));
        break;
      case 0: // left stick, left (-1), right (+1)
      case 2: // right stick, left (-1), right (+1)
        turnSpeed = Math.min(1, Math.max(-1, val));
        break;
      case 9:
        if (parseFloat(val) == 0) {
          throttleSpeed = 0;
          turnSpeed = 0;
        } else {
          var rounded = Math.round((parseFloat(val) + 1.0) * 3.5); // clockwise positions 0-7, 8=off
          // console.log("rounded = "+ rounded +", "+ val);
          switch (rounded) {
            case 0:
              throttleSpeed = -1;
              turnSpeed = 0;
              break;
            case 1:
              throttleSpeed = -0.5;
              turnSpeed = 0.5;
              break;
            case 2:
              throttleSpeed = 0;
              turnSpeed = 1;
              break;
            case 3:
              throttleSpeed = 0.5;
              turnSpeed = 0.5;
              break;
            case 4:
              throttleSpeed = 1;
              turnSpeed = 0;
              break;
            case 5:
              throttleSpeed = 0.5;
              turnSpeed = -0.5;
              break;
            case 6:
              throttleSpeed = 0;
              turnSpeed = -1;
              break;
            case 7:
              throttleSpeed = -0.5;
              turnSpeed = -0.5;
              break;
            case 8:
              throttleSpeed = 0;
              turnSpeed = 0;
              break;
          }
        }
        break;
    }
  };

  this.didDisconnect = function () {
    this.lastButtons = [];
    this.lastAxes = [];
  };

  this.buttonDown = function (index) {
    index = this.mappedButton(index);
    if (index == -1) { return; }

    // console.log(this.index +" "+ index +" down");
    if (!$("#session").is(":visible")) {
      return;
    }
    switch (index) {
      case 0:
        flipAction();
        break;
      case 1:
        poleDownState = 1;
        break;
      case 2:
        parkAction();
        break;
      case 3:
        poleUpState = 1;
        break;
      case 5:
        powerDriveOn = true;
        break;
      case 12:
        forwardState = 1;
        break;
      case 13:
        backwardState = 1;
        break;
      case 14:
        leftState = 1;
        break;
      case 15:
        rightState = 1;
        break;
    }
  };

  this.buttonUp = function (index) {
    index = this.mappedButton(index);
    if (index == -1) { return; }

    // console.log(this.index +" "+ index +" up");
    if (!$("#session").is(":visible")) {
      return;
    }
    switch (index) {
      case 0:
        // floor camera flip, none on up
        break;
      case 1:
        poleDownState = 0;
        break;
      case 2:
        // park action, none on up
        break;
      case 3:
        poleUpState = 0;
        break;
      case 5:
        powerDriveOn = false;
        break;
      case 12:
        forwardState = 0;
        break;
      case 13:
        backwardState = 0;
        break;
      case 14:
        leftState = 0;
        break;
      case 15:
        rightState = 0;
        break;
    }
  };

  this.determineMaps = function () {
    if (this.gamepad.mapping == "standard") {
      this.buttonMap = [];
      this.buttonMap[0] = 1;
      this.buttonMap[1] = 2;
      this.buttonMap[2] = 0;
      this.buttonMap[3] = 3;
      this.buttonMap[4] = 4;
      this.buttonMap[5] = 5;
      this.buttonMap[6] = 6;
      this.buttonMap[7] = 7;
      this.buttonMap[8] = 8;
      this.buttonMap[9] = 9;
      this.buttonMap[10] = 10;
      this.buttonMap[11] = 11;
      this.buttonMap[12] = 12;
      this.buttonMap[13] = 13;
      this.buttonMap[14] = 14;
      this.buttonMap[15] = 15;
      this.buttonMap[16] = 12;
      this.axisMap = [];
      this.axisMap[0] = 0;
      this.axisMap[1] = 1;
      this.axisMap[2] = 2;
      this.axisMap[3] = 5;
    } else {
      this.buttonMap = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
      this.axisMap = [0, 1, 2, 3, -1, 5, -1, -1, -1, 9];
    }
  };

  this.mappedButton = function (input) {
    if (input >= this.buttonMap.length) {
      return -1;
    }
    return this.buttonMap[input];
  };

  this.mappedAxis = function (input) {
    if (input >= this.axisMap.length) {
      return -1;
    }
    return this.axisMap[input];
  };

  this.determineMaps();
}
// threejs.org/license
(function (k, ta) { "object" === typeof exports && "undefined" !== typeof module ? ta(exports) : "function" === typeof define && define.amd ? define(["exports"], ta) : (k = k || self, ta(k.THREE = {})); })(this, function (k) {
  function ta() { } function C(a, b) { this.x = a || 0; this.y = b || 0; } function ma(a, b, c, d) { this._x = a || 0; this._y = b || 0; this._z = c || 0; this._w = void 0 !== d ? d : 1; } function n(a, b, c) { this.x = a || 0; this.y = b || 0; this.z = c || 0; } function na() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]; 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."); }
  function Y(a, b, c, d, e, f, g, h, l, m) {
    Object.defineProperty(this, "id", { value: Yf++ }); this.uuid = O.generateUUID(); this.name = ""; this.image = void 0 !== a ? a : Y.DEFAULT_IMAGE; this.mipmaps = []; this.mapping = void 0 !== b ? b : Y.DEFAULT_MAPPING; this.wrapS = void 0 !== c ? c : 1001; this.wrapT = void 0 !== d ? d : 1001; this.magFilter = void 0 !== e ? e : 1006; this.minFilter = void 0 !== f ? f : 1008; this.anisotropy = void 0 !== l ? l : 1; this.format = void 0 !== g ? g : 1023; this.type = void 0 !== h ? h : 1009; this.offset = new C(0, 0); this.repeat = new C(1, 1); this.center = new C(0, 0); this.rotation =
      0; this.matrixAutoUpdate = !0; this.matrix = new na; this.generateMipmaps = !0; this.premultiplyAlpha = !1; this.flipY = !0; this.unpackAlignment = 4; this.encoding = void 0 !== m ? m : 3E3; this.version = 0; this.onUpdate = null;
  } function W(a, b, c, d) { this.x = a || 0; this.y = b || 0; this.z = c || 0; this.w = void 0 !== d ? d : 1; } function Sa(a, b, c) {
    this.width = a; this.height = b; this.scissor = new W(0, 0, a, b); this.scissorTest = !1; this.viewport = new W(0, 0, a, b); c = c || {}; this.texture = new Y(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy,
      c.encoding); this.texture.generateMipmaps = void 0 !== c.generateMipmaps ? c.generateMipmaps : !1; this.texture.minFilter = void 0 !== c.minFilter ? c.minFilter : 1006; this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0; this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0; this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null;
  } function ce(a, b, c) { Sa.call(this, a, b, c); this.samples = 4; } function rb(a, b, c) { Sa.call(this, a, b, c); } function sb(a, b, c, d, e, f, g, h, l, m, q, p) {
    Y.call(this, null, f, g, h, l, m, d, e, q, p); this.image =
      { data: a, width: b, height: c }; this.magFilter = void 0 !== l ? l : 1003; this.minFilter = void 0 !== m ? m : 1003; this.flipY = this.generateMipmaps = !1; this.unpackAlignment = 1;
  } function Ga(a, b) { this.min = void 0 !== a ? a : new n(Infinity, Infinity, Infinity); this.max = void 0 !== b ? b : new n(-Infinity, -Infinity, -Infinity); } function Ta(a, b) { this.center = void 0 !== a ? a : new n; this.radius = void 0 !== b ? b : 0; } function Ua(a, b) { this.normal = void 0 !== a ? a : new n(1, 0, 0); this.constant = void 0 !== b ? b : 0; } function yd(a, b, c, d, e, f) {
    this.planes = [void 0 !== a ? a : new Ua, void 0 !==
      b ? b : new Ua, void 0 !== c ? c : new Ua, void 0 !== d ? d : new Ua, void 0 !== e ? e : new Ua, void 0 !== f ? f : new Ua];
  } function P() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."); } function Rb(a) {
    var b = {}, c; for (c in a) {
      b[c] = {}; for (var d in a[c]) {
        var e = a[c][d]; e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? b[c][d] = e.clone() : Array.isArray(e) ? b[c][d] = e.slice() : b[c][d] =
          e;
      }
    } return b;
  } function ya(a) { for (var b = {}, c = 0; c < a.length; c++) { var d = Rb(a[c]), e; for (e in d) b[e] = d[e]; } return b; } function A(a, b, c) { return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c); } function de() { function a(e, f) { !1 !== c && (d(e, f), b.requestAnimationFrame(a)); } var b = null, c = !1, d = null; return { start: function () { !0 !== c && null !== d && (b.requestAnimationFrame(a), c = !0); }, stop: function () { c = !1; }, setAnimationLoop: function (a) { d = a; }, setContext: function (a) { b = a; } }; } function Zf(a) {
    function b(b, c) {
      var d = b.array, e = b.dynamic ?
        35048 : 35044, h = a.createBuffer(); a.bindBuffer(c, h); a.bufferData(c, d, e); b.onUploadCallback(); c = 5126; d instanceof Float32Array ? c = 5126 : d instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : d instanceof Uint16Array ? c = 5123 : d instanceof Int16Array ? c = 5122 : d instanceof Uint32Array ? c = 5125 : d instanceof Int32Array ? c = 5124 : d instanceof Int8Array ? c = 5120 : d instanceof Uint8Array && (c = 5121); return { buffer: h, type: c, bytesPerElement: d.BYTES_PER_ELEMENT, version: b.version };
    }
    var c = new WeakMap; return {
      get: function (a) { a.isInterleavedBufferAttribute && (a = a.data); return c.get(a); }, remove: function (b) { b.isInterleavedBufferAttribute && (b = b.data); var d = c.get(b); d && (a.deleteBuffer(d.buffer), c.delete(b)); }, update: function (d, e) {
        d.isInterleavedBufferAttribute && (d = d.data); var f = c.get(d); if (void 0 === f) c.set(d, b(d, e)); else if (f.version < d.version) {
          var g = d, h = g.array, l = g.updateRange; a.bindBuffer(e, f.buffer); !1 === g.dynamic ? a.bufferData(e, h, 35044) : -1 === l.count ? a.bufferSubData(e, 0, h) : 0 === l.count ?
            console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(e, l.offset * h.BYTES_PER_ELEMENT, h.subarray(l.offset, l.offset + l.count)), l.count = -1); f.version = d.version;
        }
      }
    };
  } function Sb(a, b, c, d, e, f) {
    this.a = a; this.b = b; this.c = c; this.normal = d && d.isVector3 ? d : new n; this.vertexNormals = Array.isArray(d) ? d : []; this.color = e && e.isColor ? e : new A; this.vertexColors = Array.isArray(e) ?
      e : []; this.materialIndex = void 0 !== f ? f : 0;
  } function tb(a, b, c, d) { this._x = a || 0; this._y = b || 0; this._z = c || 0; this._order = d || tb.DefaultOrder; } function ee() { this.mask = 1; } function D() {
    Object.defineProperty(this, "id", { value: $f++ }); this.uuid = O.generateUUID(); this.name = ""; this.type = "Object3D"; this.parent = null; this.children = []; this.up = D.DefaultUp.clone(); var a = new n, b = new tb, c = new ma, d = new n(1, 1, 1); b.onChange(function () { c.setFromEuler(b, !1); }); c.onChange(function () { b.setFromQuaternion(c, void 0, !1); }); Object.defineProperties(this,
      { position: { configurable: !0, enumerable: !0, value: a }, rotation: { configurable: !0, enumerable: !0, value: b }, quaternion: { configurable: !0, enumerable: !0, value: c }, scale: { configurable: !0, enumerable: !0, value: d }, modelViewMatrix: { value: new P }, normalMatrix: { value: new na } }); this.matrix = new P; this.matrixWorld = new P; this.matrixAutoUpdate = D.DefaultMatrixAutoUpdate; this.matrixWorldNeedsUpdate = !1; this.layers = new ee; this.visible = !0; this.receiveShadow = this.castShadow = !1; this.frustumCulled = !0; this.renderOrder = 0; this.userData =
        {};
  } function K() {
    Object.defineProperty(this, "id", { value: ag += 2 }); this.uuid = O.generateUUID(); this.name = ""; this.type = "Geometry"; this.vertices = []; this.colors = []; this.faces = []; this.faceVertexUvs = [[]]; this.morphTargets = []; this.morphNormals = []; this.skinWeights = []; this.skinIndices = []; this.lineDistances = []; this.boundingSphere = this.boundingBox = null; this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate =
      !1;
  } function H(a, b, c) { if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = ""; this.array = a; this.itemSize = b; this.count = void 0 !== a ? a.length / b : 0; this.normalized = !0 === c; this.dynamic = !1; this.updateRange = { offset: 0, count: -1 }; this.version = 0; } function Ac(a, b, c) { H.call(this, new Int8Array(a), b, c); } function Bc(a, b, c) { H.call(this, new Uint8Array(a), b, c); } function Cc(a, b, c) { H.call(this, new Uint8ClampedArray(a), b, c); } function Dc(a, b, c) {
    H.call(this, new Int16Array(a),
      b, c);
  } function ub(a, b, c) { H.call(this, new Uint16Array(a), b, c); } function Ec(a, b, c) { H.call(this, new Int32Array(a), b, c); } function vb(a, b, c) { H.call(this, new Uint32Array(a), b, c); } function E(a, b, c) { H.call(this, new Float32Array(a), b, c); } function Fc(a, b, c) { H.call(this, new Float64Array(a), b, c); } function Ve() {
    this.vertices = []; this.normals = []; this.colors = []; this.uvs = []; this.uvs2 = []; this.groups = []; this.morphTargets = {}; this.skinWeights = []; this.skinIndices = []; this.boundingSphere = this.boundingBox = null; this.groupsNeedUpdate =
      this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1;
  } function We(a) { if (0 === a.length) return -Infinity; for (var b = a[0], c = 1, d = a.length; c < d; ++c)a[c] > b && (b = a[c]); return b; } function B() { Object.defineProperty(this, "id", { value: bg += 2 }); this.uuid = O.generateUUID(); this.name = ""; this.type = "BufferGeometry"; this.index = null; this.attributes = {}; this.morphAttributes = {}; this.groups = []; this.boundingSphere = this.boundingBox = null; this.drawRange = { start: 0, count: Infinity }; this.userData = {}; }
  function Tb(a, b, c, d, e, f) { K.call(this); this.type = "BoxGeometry"; this.parameters = { width: a, height: b, depth: c, widthSegments: d, heightSegments: e, depthSegments: f }; this.fromBufferGeometry(new wb(a, b, c, d, e, f)); this.mergeVertices(); } function wb(a, b, c, d, e, f) {
    function g(a, b, c, d, e, f, g, k, ua, pa, I) {
      var r = f / ua, u = g / pa, w = f / 2, y = g / 2, z = k / 2; g = ua + 1; var G = pa + 1, ha = f = 0, S, x, F = new n; for (x = 0; x < G; x++) {
        var C = x * u - y; for (S = 0; S < g; S++)F[a] = (S * r - w) * d, F[b] = C * e, F[c] = z, m.push(F.x, F.y, F.z), F[a] = 0, F[b] = 0, F[c] = 0 < k ? 1 : -1, q.push(F.x, F.y, F.z), p.push(S /
          ua), p.push(1 - x / pa), f += 1;
      } for (x = 0; x < pa; x++)for (S = 0; S < ua; S++)a = v + S + g * (x + 1), b = v + (S + 1) + g * (x + 1), c = v + (S + 1) + g * x, l.push(v + S + g * x, a, c), l.push(a, b, c), ha += 6; h.addGroup(t, ha, I); t += ha; v += f;
    } B.call(this); this.type = "BoxBufferGeometry"; this.parameters = { width: a, height: b, depth: c, widthSegments: d, heightSegments: e, depthSegments: f }; var h = this; a = a || 1; b = b || 1; c = c || 1; d = Math.floor(d) || 1; e = Math.floor(e) || 1; f = Math.floor(f) || 1; var l = [], m = [], q = [], p = [], v = 0, t = 0; g("z", "y", "x", -1, -1, c, b, a, f, e, 0); g("z", "y", "x", 1, -1, c, b, -a, f, e, 1); g("x",
      "z", "y", 1, 1, a, c, b, d, f, 2); g("x", "z", "y", 1, -1, a, c, -b, d, f, 3); g("x", "y", "z", 1, -1, a, b, c, d, e, 4); g("x", "y", "z", -1, -1, a, b, -c, d, e, 5); this.setIndex(l); this.addAttribute("position", new E(m, 3)); this.addAttribute("normal", new E(q, 3)); this.addAttribute("uv", new E(p, 2));
  } function Gc(a, b, c, d) { K.call(this); this.type = "PlaneGeometry"; this.parameters = { width: a, height: b, widthSegments: c, heightSegments: d }; this.fromBufferGeometry(new yb(a, b, c, d)); this.mergeVertices(); } function yb(a, b, c, d) {
    B.call(this); this.type = "PlaneBufferGeometry";
    this.parameters = { width: a, height: b, widthSegments: c, heightSegments: d }; a = a || 1; b = b || 1; var e = a / 2, f = b / 2; c = Math.floor(c) || 1; d = Math.floor(d) || 1; var g = c + 1, h = d + 1, l = a / c, m = b / d, q = [], p = [], v = [], t = []; for (a = 0; a < h; a++) { var k = a * m - f; for (b = 0; b < g; b++)p.push(b * l - e, -k, 0), v.push(0, 0, 1), t.push(b / c), t.push(1 - a / d); } for (a = 0; a < d; a++)for (b = 0; b < c; b++)e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, q.push(b + g * a, e, h), q.push(e, f, h); this.setIndex(q); this.addAttribute("position", new E(p, 3)); this.addAttribute("normal", new E(v, 3)); this.addAttribute("uv",
      new E(t, 2));
  } function Q() {
    Object.defineProperty(this, "id", { value: cg++ }); this.uuid = O.generateUUID(); this.name = ""; this.type = "Material"; this.lights = this.fog = !0; this.blending = 1; this.side = 0; this.vertexTangents = this.flatShading = !1; this.vertexColors = 0; this.opacity = 1; this.transparent = !1; this.blendSrc = 204; this.blendDst = 205; this.blendEquation = 100; this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null; this.depthFunc = 3; this.depthWrite = this.depthTest = !0; this.clippingPlanes = null; this.clipShadows = this.clipIntersection =
      !1; this.shadowSide = null; this.colorWrite = !0; this.precision = null; this.polygonOffset = !1; this.polygonOffsetUnits = this.polygonOffsetFactor = 0; this.dithering = !1; this.alphaTest = 0; this.premultipliedAlpha = !1; this.visible = !0; this.userData = {}; this.needsUpdate = !0;
  } function ea(a) {
    Q.call(this); this.type = "ShaderMaterial"; this.defines = {}; this.uniforms = {}; this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"; this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    this.linewidth = 1; this.wireframe = !1; this.wireframeLinewidth = 1; this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1; this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }; this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }; this.index0AttributeName = void 0; this.uniformsNeedUpdate = !1; void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a));
  }
  function zb(a, b) { this.origin = void 0 !== a ? a : new n; this.direction = void 0 !== b ? b : new n; } function ra(a, b, c) { this.a = void 0 !== a ? a : new n; this.b = void 0 !== b ? b : new n; this.c = void 0 !== c ? c : new n; } function Ca(a) {
    Q.call(this); this.type = "MeshBasicMaterial"; this.color = new A(16777215); this.lightMap = this.map = null; this.lightMapIntensity = 1; this.aoMap = null; this.aoMapIntensity = 1; this.envMap = this.alphaMap = this.specularMap = null; this.combine = 0; this.reflectivity = 1; this.refractionRatio = .98; this.wireframe = !1; this.wireframeLinewidth =
      1; this.wireframeLinejoin = this.wireframeLinecap = "round"; this.lights = this.morphTargets = this.skinning = !1; this.setValues(a);
  } function qa(a, b) { D.call(this); this.type = "Mesh"; this.geometry = void 0 !== a ? a : new B; this.material = void 0 !== b ? b : new Ca({ color: 16777215 * Math.random() }); this.drawMode = 0; this.updateMorphTargets(); } function dg(a, b, c, d) {
    function e(a, c) { b.buffers.color.setClear(a.r, a.g, a.b, c, d); } var f = new A(0), g = 0, h, l, m = null, q = 0; return {
      getClearColor: function () { return f; }, setClearColor: function (a, b) {
        f.set(a); g =
          void 0 !== b ? b : 1; e(f, g);
      }, getClearAlpha: function () { return g; }, setClearAlpha: function (a) { g = a; e(f, g); }, render: function (b, d, t, k) {
        d = d.background; t = a.vr; (t = t.getSession && t.getSession()) && "additive" === t.environmentBlendMode && (d = null); null === d ? (e(f, g), m = null, q = 0) : d && d.isColor && (e(d, 1), k = !0, m = null, q = 0); (a.autoClear || k) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil); if (d && (d.isCubeTexture || d.isWebGLRenderTargetCube)) {
          void 0 === l && (l = new qa(new wb(1, 1, 1), new ea({
            type: "BackgroundCubeMaterial", uniforms: Rb(Va.cube.uniforms),
            vertexShader: Va.cube.vertexShader, fragmentShader: Va.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1
          })), l.geometry.removeAttribute("normal"), l.geometry.removeAttribute("uv"), l.onBeforeRender = function (a, b, c) { this.matrixWorld.copyPosition(c.matrixWorld); }, Object.defineProperty(l.material, "map", { get: function () { return this.uniforms.tCube.value; } }), c.update(l)); k = d.isWebGLRenderTargetCube ? d.texture : d; l.material.uniforms.tCube.value = k; l.material.uniforms.tFlip.value = d.isWebGLRenderTargetCube ?
            1 : -1; if (m !== d || q !== k.version) l.material.needsUpdate = !0, m = d, q = k.version; b.unshift(l, l.geometry, l.material, 0, 0, null);
        } else if (d && d.isTexture) {
          void 0 === h && (h = new qa(new yb(2, 2), new ea({ type: "BackgroundMaterial", uniforms: Rb(Va.background.uniforms), vertexShader: Va.background.vertexShader, fragmentShader: Va.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 })), h.geometry.removeAttribute("normal"), Object.defineProperty(h.material, "map", { get: function () { return this.uniforms.t2D.value; } }), c.update(h));
          h.material.uniforms.t2D.value = d; !0 === d.matrixAutoUpdate && d.updateMatrix(); h.material.uniforms.uvTransform.value.copy(d.matrix); if (m !== d || q !== d.version) h.material.needsUpdate = !0, m = d, q = d.version; b.unshift(h, h.geometry, h.material, 0, 0, null);
        }
      }
    };
  } function eg(a, b, c, d) {
    var e; this.setMode = function (a) { e = a; }; this.render = function (b, d) { a.drawArrays(e, b, d); c.update(d, e); }; this.renderInstances = function (f, g, h) {
      if (d.isWebGL2) var l = a; else if (l = b.get("ANGLE_instanced_arrays"), null === l) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      } l[d.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](e, g, h, f.maxInstancedCount); c.update(h, e, f.maxInstancedCount);
    };
  } function fg(a, b, c) {
    function d(b) { if ("highp" === b) { if (0 < a.getShaderPrecisionFormat(35633, 36338).precision && 0 < a.getShaderPrecisionFormat(35632, 36338).precision) return "highp"; b = "mediump"; } return "mediump" === b && 0 < a.getShaderPrecisionFormat(35633, 36337).precision && 0 < a.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"; } var e, f = "undefined" !== typeof WebGL2RenderingContext &&
      a instanceof WebGL2RenderingContext, g = void 0 !== c.precision ? c.precision : "highp", h = d(g); h !== g && (console.warn("THREE.WebGLRenderer:", g, "not supported, using", h, "instead."), g = h); c = !0 === c.logarithmicDepthBuffer; h = a.getParameter(34930); var l = a.getParameter(35660), m = a.getParameter(3379), q = a.getParameter(34076), p = a.getParameter(34921), v = a.getParameter(36347), t = a.getParameter(36348), k = a.getParameter(36349), u = 0 < l, w = f || !!b.get("OES_texture_float"), n = u && w, x = f ? a.getParameter(36183) : 0; return {
        isWebGL2: f, getMaxAnisotropy: function () {
          if (void 0 !==
            e) return e; var c = b.get("EXT_texture_filter_anisotropic"); return e = null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
        }, getMaxPrecision: d, precision: g, logarithmicDepthBuffer: c, maxTextures: h, maxVertexTextures: l, maxTextureSize: m, maxCubemapSize: q, maxAttributes: p, maxVertexUniforms: v, maxVaryings: t, maxFragmentUniforms: k, vertexTextures: u, floatFragmentTextures: w, floatVertexTextures: n, maxSamples: x
      };
  } function gg() {
    function a() {
      m.value !== d && (m.value = d, m.needsUpdate = 0 < e); c.numPlanes = e; c.numIntersection =
        0;
    } function b(a, b, d, e) { var f = null !== a ? a.length : 0, g = null; if (0 !== f) { g = m.value; if (!0 !== e || null === g) { e = d + 4 * f; b = b.matrixWorldInverse; l.getNormalMatrix(b); if (null === g || g.length < e) g = new Float32Array(e); for (e = 0; e !== f; ++e, d += 4)h.copy(a[e]).applyMatrix4(b, l), h.normal.toArray(g, d), g[d + 3] = h.constant; } m.value = g; m.needsUpdate = !0; } c.numPlanes = f; return g; } var c = this, d = null, e = 0, f = !1, g = !1, h = new Ua, l = new na, m = { value: null, needsUpdate: !1 }; this.uniform = m; this.numIntersection = this.numPlanes = 0; this.init = function (a, c, g) {
      var h =
        0 !== a.length || c || 0 !== e || f; f = c; d = b(a, g, 0); e = a.length; return h;
    }; this.beginShadows = function () { g = !0; b(null); }; this.endShadows = function () { g = !1; a(); }; this.setState = function (c, h, l, k, r, u) { if (!f || null === c || 0 === c.length || g && !l) g ? b(null) : a(); else { l = g ? 0 : e; var q = 4 * l, p = r.clippingState || null; m.value = p; p = b(c, k, q, u); for (c = 0; c !== q; ++c)p[c] = d[c]; r.clippingState = p; this.numIntersection = h ? this.numPlanes : 0; this.numPlanes += l; } };
  } function hg(a) {
    var b = {}; return {
      get: function (c) {
        if (void 0 !== b[c]) return b[c]; switch (c) {
          case "WEBGL_depth_texture": var d =
            a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break; case "WEBGL_compressed_texture_pvrtc": d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: d = a.getExtension(c);
        }null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported."); return b[c] = d;
      }
    };
  } function ig(a, b, c) {
    function d(a) {
      var g = a.target; a = e[g.id]; null !== a.index && b.remove(a.index); for (var l in a.attributes) b.remove(a.attributes[l]); g.removeEventListener("dispose", d); delete e[g.id]; if (l = f[a.id]) b.remove(l), delete f[a.id];
      c.memory.geometries--;
    } var e = {}, f = {}; return {
      get: function (a, b) { var f = e[b.id]; if (f) return f; b.addEventListener("dispose", d); b.isBufferGeometry ? f = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new B).setFromObject(a)), f = b._bufferGeometry); e[b.id] = f; c.memory.geometries++; return f; }, update: function (a) { var c = a.index, d = a.attributes; null !== c && b.update(c, 34963); for (var e in d) b.update(d[e], 34962); a = a.morphAttributes; for (e in a) { c = a[e]; d = 0; for (var f = c.length; d < f; d++)b.update(c[d], 34962); } }, getWireframeAttribute: function (a) {
        var c =
          f[a.id]; if (c) return c; c = []; var d = a.index, e = a.attributes; if (null !== d) { d = d.array; e = 0; for (var g = d.length; e < g; e += 3) { var p = d[e + 0], v = d[e + 1], k = d[e + 2]; c.push(p, v, v, k, k, p); } } else for (d = e.position.array, e = 0, g = d.length / 3 - 1; e < g; e += 3)p = e + 0, v = e + 1, k = e + 2, c.push(p, v, v, k, k, p); c = new (65535 < We(c) ? vb : ub)(c, 1); b.update(c, 34963); return f[a.id] = c;
      }
    };
  } function jg(a, b, c, d) {
    var e, f, g; this.setMode = function (a) { e = a; }; this.setIndex = function (a) { f = a.type; g = a.bytesPerElement; }; this.render = function (b, d) {
      a.drawElements(e, d, f, b * g); c.update(d,
        e);
    }; this.renderInstances = function (h, l, m) { if (d.isWebGL2) var q = a; else if (q = b.get("ANGLE_instanced_arrays"), null === q) { console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return; } q[d.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](e, m, f, l * g, h.maxInstancedCount); c.update(m, e, h.maxInstancedCount); };
  } function kg(a) {
    var b = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return {
      memory: {
        geometries: 0,
        textures: 0
      }, render: b, programs: null, autoReset: !0, reset: function () { b.frame++; b.calls = 0; b.triangles = 0; b.points = 0; b.lines = 0; }, update: function (a, d, e) { e = e || 1; b.calls++; switch (d) { case 4: b.triangles += a / 3 * e; break; case 5: case 6: b.triangles += e * (a - 2); break; case 1: b.lines += a / 2 * e; break; case 3: b.lines += e * (a - 1); break; case 2: b.lines += e * a; break; case 0: b.points += e * a; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", d); } }
    };
  } function lg(a, b) { return Math.abs(b[1]) - Math.abs(a[1]); } function mg(a) {
    var b = {}, c =
      new Float32Array(8); return {
        update: function (d, e, f, g) {
          var h = d.morphTargetInfluences, l = h.length; d = b[e.id]; if (void 0 === d) { d = []; for (var m = 0; m < l; m++)d[m] = [m, 0]; b[e.id] = d; } var q = f.morphTargets && e.morphAttributes.position; f = f.morphNormals && e.morphAttributes.normal; for (m = 0; m < l; m++) { var p = d[m]; 0 !== p[1] && (q && e.removeAttribute("morphTarget" + m), f && e.removeAttribute("morphNormal" + m)); } for (m = 0; m < l; m++)p = d[m], p[0] = m, p[1] = h[m]; d.sort(lg); for (m = 0; 8 > m; m++) {
            if (p = d[m]) if (h = p[0], l = p[1]) {
              q && e.addAttribute("morphTarget" + m,
                q[h]); f && e.addAttribute("morphNormal" + m, f[h]); c[m] = l; continue;
            } c[m] = 0;
          } g.getUniforms().setValue(a, "morphTargetInfluences", c);
        }
      };
  } function ng(a, b) { var c = {}; return { update: function (d) { var e = b.render.frame, f = d.geometry, g = a.get(d, f); c[g.id] !== e && (f.isGeometry && g.updateFromObject(d), a.update(g), c[g.id] = e); return g; }, dispose: function () { c = {}; } }; } function cb(a, b, c, d, e, f, g, h, l, m) { a = void 0 !== a ? a : []; Y.call(this, a, void 0 !== b ? b : 301, c, d, e, f, void 0 !== g ? g : 1022, h, l, m); this.flipY = !1; } function Ub(a, b, c, d) {
    Y.call(this, null);
    this.image = { data: a, width: b, height: c, depth: d }; this.minFilter = this.magFilter = 1003; this.wrapR = 1001; this.flipY = this.generateMipmaps = !1;
  } function Vb(a, b, c, d) { Y.call(this, null); this.image = { data: a, width: b, height: c, depth: d }; this.minFilter = this.magFilter = 1003; this.wrapR = 1001; this.flipY = this.generateMipmaps = !1; } function Wb(a, b, c) { var d = a[0]; if (0 >= d || 0 < d) return a; var e = b * c, f = Xe[e]; void 0 === f && (f = new Float32Array(e), Xe[e] = f); if (0 !== b) for (d.toArray(f, 0), d = 1, e = 0; d !== b; ++d)e += c, a[d].toArray(f, e); return f; } function X(a,
    b) { if (a.length !== b.length) return !1; for (var c = 0, d = a.length; c < d; c++)if (a[c] !== b[c]) return !1; return !0; } function sa(a, b) { for (var c = 0, d = b.length; c < d; c++)a[c] = b[c]; } function Ye(a, b) { var c = Ze[b]; void 0 === c && (c = new Int32Array(b), Ze[b] = c); for (var d = 0; d !== b; ++d)c[d] = a.allocateTextureUnit(); return c; } function og(a, b) { var c = this.cache; c[0] !== b && (a.uniform1f(this.addr, b), c[0] = b); } function pg(a, b) { var c = this.cache; c[0] !== b && (a.uniform1i(this.addr, b), c[0] = b); } function qg(a, b) {
      var c = this.cache; if (void 0 !== b.x) {
        if (c[0] !==
          b.x || c[1] !== b.y) a.uniform2f(this.addr, b.x, b.y), c[0] = b.x, c[1] = b.y;
      } else X(c, b) || (a.uniform2fv(this.addr, b), sa(c, b));
    } function rg(a, b) { var c = this.cache; if (void 0 !== b.x) { if (c[0] !== b.x || c[1] !== b.y || c[2] !== b.z) a.uniform3f(this.addr, b.x, b.y, b.z), c[0] = b.x, c[1] = b.y, c[2] = b.z; } else if (void 0 !== b.r) { if (c[0] !== b.r || c[1] !== b.g || c[2] !== b.b) a.uniform3f(this.addr, b.r, b.g, b.b), c[0] = b.r, c[1] = b.g, c[2] = b.b; } else X(c, b) || (a.uniform3fv(this.addr, b), sa(c, b)); } function sg(a, b) {
      var c = this.cache; if (void 0 !== b.x) {
        if (c[0] !== b.x ||
          c[1] !== b.y || c[2] !== b.z || c[3] !== b.w) a.uniform4f(this.addr, b.x, b.y, b.z, b.w), c[0] = b.x, c[1] = b.y, c[2] = b.z, c[3] = b.w;
      } else X(c, b) || (a.uniform4fv(this.addr, b), sa(c, b));
    } function tg(a, b) { var c = this.cache, d = b.elements; void 0 === d ? X(c, b) || (a.uniformMatrix2fv(this.addr, !1, b), sa(c, b)) : X(c, d) || ($e.set(d), a.uniformMatrix2fv(this.addr, !1, $e), sa(c, d)); } function ug(a, b) {
      var c = this.cache, d = b.elements; void 0 === d ? X(c, b) || (a.uniformMatrix3fv(this.addr, !1, b), sa(c, b)) : X(c, d) || (af.set(d), a.uniformMatrix3fv(this.addr, !1, af), sa(c,
        d));
    } function vg(a, b) { var c = this.cache, d = b.elements; void 0 === d ? X(c, b) || (a.uniformMatrix4fv(this.addr, !1, b), sa(c, b)) : X(c, d) || (bf.set(d), a.uniformMatrix4fv(this.addr, !1, bf), sa(c, d)); } function wg(a, b, c) { var d = this.cache, e = c.allocateTextureUnit(); d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e); c.safeSetTexture2D(b || cf, e); } function xg(a, b, c) { var d = this.cache, e = c.allocateTextureUnit(); d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e); c.setTexture2DArray(b || yg, e); } function zg(a, b, c) {
      var d = this.cache, e = c.allocateTextureUnit();
      d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e); c.setTexture3D(b || Ag, e);
    } function Bg(a, b, c) { var d = this.cache, e = c.allocateTextureUnit(); d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e); c.safeSetTextureCube(b || df, e); } function ef(a, b) { var c = this.cache; X(c, b) || (a.uniform2iv(this.addr, b), sa(c, b)); } function ff(a, b) { var c = this.cache; X(c, b) || (a.uniform3iv(this.addr, b), sa(c, b)); } function gf(a, b) { var c = this.cache; X(c, b) || (a.uniform4iv(this.addr, b), sa(c, b)); } function Cg(a) {
      switch (a) {
        case 5126: return og; case 35664: return qg;
        case 35665: return rg; case 35666: return sg; case 35674: return tg; case 35675: return ug; case 35676: return vg; case 35678: case 36198: return wg; case 35679: return zg; case 35680: return Bg; case 36289: return xg; case 5124: case 35670: return pg; case 35667: case 35671: return ef; case 35668: case 35672: return ff; case 35669: case 35673: return gf;
      }
    } function Dg(a, b) { var c = this.cache; X(c, b) || (a.uniform1fv(this.addr, b), sa(c, b)); } function Eg(a, b) { var c = this.cache; X(c, b) || (a.uniform1iv(this.addr, b), sa(c, b)); } function Fg(a, b) {
      var c =
        this.cache; b = Wb(b, this.size, 2); X(c, b) || (a.uniform2fv(this.addr, b), this.updateCache(b));
    } function Gg(a, b) { var c = this.cache; b = Wb(b, this.size, 3); X(c, b) || (a.uniform3fv(this.addr, b), this.updateCache(b)); } function Hg(a, b) { var c = this.cache; b = Wb(b, this.size, 4); X(c, b) || (a.uniform4fv(this.addr, b), this.updateCache(b)); } function Ig(a, b) { var c = this.cache; b = Wb(b, this.size, 4); X(c, b) || (a.uniformMatrix2fv(this.addr, !1, b), this.updateCache(b)); } function Jg(a, b) {
      var c = this.cache; b = Wb(b, this.size, 9); X(c, b) || (a.uniformMatrix3fv(this.addr,
        !1, b), this.updateCache(b));
    } function Kg(a, b) { var c = this.cache; b = Wb(b, this.size, 16); X(c, b) || (a.uniformMatrix4fv(this.addr, !1, b), this.updateCache(b)); } function Lg(a, b, c) { var d = this.cache, e = b.length, f = Ye(c, e); !1 === X(d, f) && (a.uniform1iv(this.addr, f), sa(d, f)); for (a = 0; a !== e; ++a)c.safeSetTexture2D(b[a] || cf, f[a]); } function Mg(a, b, c) { var d = this.cache, e = b.length, f = Ye(c, e); !1 === X(d, f) && (a.uniform1iv(this.addr, f), sa(d, f)); for (a = 0; a !== e; ++a)c.safeSetTextureCube(b[a] || df, f[a]); } function Ng(a) {
      switch (a) {
        case 5126: return Dg;
        case 35664: return Fg; case 35665: return Gg; case 35666: return Hg; case 35674: return Ig; case 35675: return Jg; case 35676: return Kg; case 35678: return Lg; case 35680: return Mg; case 5124: case 35670: return Eg; case 35667: case 35671: return ef; case 35668: case 35672: return ff; case 35669: case 35673: return gf;
      }
    } function Og(a, b, c) { this.id = a; this.addr = c; this.cache = []; this.setValue = Cg(b.type); } function hf(a, b, c) { this.id = a; this.addr = c; this.cache = []; this.size = b.size; this.setValue = Ng(b.type); } function jf(a) {
      this.id = a; this.seq =
        []; this.map = {};
    } function ib(a, b) { this.seq = []; this.map = {}; for (var c = a.getProgramParameter(b, 35718), d = 0; d < c; ++d) { var e = a.getActiveUniform(b, d), f = a.getUniformLocation(b, e.name), g = this, h = e.name, l = h.length; for (he.lastIndex = 0; ;) { var m = he.exec(h), q = he.lastIndex, p = m[1], v = m[3]; "]" === m[2] && (p |= 0); if (void 0 === v || "[" === v && q + 2 === l) { h = g; e = void 0 === v ? new Og(p, e, f) : new hf(p, e, f); h.seq.push(e); h.map[e.id] = e; break; } else v = g.map[p], void 0 === v && (v = new jf(p), p = g, g = v, p.seq.push(g), p.map[g.id] = g), g = v; } } } function Pg(a) {
      a = a.split("\n");
      for (var b = 0; b < a.length; b++)a[b] = b + 1 + ": " + a[b]; return a.join("\n");
    } function kf(a, b, c, d) { var e = a.createShader(b); a.shaderSource(e, c); a.compileShader(e); !0 === d && (!1 === a.getShaderParameter(e, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== a.getShaderInfoLog(e) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === b ? "vertex" : "fragment", a.getShaderInfoLog(e), Pg(c))); return e; } function lf(a) {
      switch (a) {
        case 3E3: return ["Linear", "( value )"]; case 3001: return ["sRGB", "( value )"];
        case 3002: return ["RGBE", "( value )"]; case 3004: return ["RGBM", "( value, 7.0 )"]; case 3005: return ["RGBM", "( value, 16.0 )"]; case 3006: return ["RGBD", "( value, 256.0 )"]; case 3007: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; default: throw Error("unsupported encoding: " + a);
      }
    } function zd(a, b) { b = lf(b); return "vec4 " + a + "( vec4 value ) { return " + b[0] + "ToLinear" + b[1] + "; }"; } function Qg(a, b) { b = lf(b); return "vec4 " + a + "( vec4 value ) { return LinearTo" + b[0] + b[1] + "; }"; } function Rg(a, b) {
      switch (b) {
        case 1: b = "Linear";
          break; case 2: b = "Reinhard"; break; case 3: b = "Uncharted2"; break; case 4: b = "OptimizedCineon"; break; case 5: b = "ACESFilmic"; break; default: throw Error("unsupported toneMapping: " + b);
      }return "vec3 " + a + "( vec3 color ) { return " + b + "ToneMapping( color ); }";
    } function Sg(a, b, c) {
      a = a || {}; return [a.derivatives || b.envMapCubeUV || b.bumpMap || b.normalMap && !b.objectSpaceNormalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" :
        "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Hc).join("\n");
    } function Tg(a) { var b = [], c; for (c in a) { var d = a[c]; !1 !== d && b.push("#define " + c + " " + d); } return b.join("\n"); } function Hc(a) { return "" !== a; } function mf(a, b) {
      return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,
        b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights);
    } function nf(a, b) { return a.replace(/NUM_CLIPPING_PLANES/g, b.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, b.numClippingPlanes - b.numClipIntersection); } function ie(a) { return a.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function (a, c) { a = R[c]; if (void 0 === a) throw Error("Can not resolve #include <" + c + ">"); return ie(a); }); } function of(a) {
      return a.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        function (a, c, d, e) { a = ""; for (c = parseInt(c); c < parseInt(d); c++)a += e.replace(/\[ i \]/g, "[ " + c + " ]"); return a; });
    } function Ug(a, b, c, d, e, f, g, h) {
      var l = a.context, m = d.defines, q = e.vertexShader, p = e.fragmentShader, v = "SHADOWMAP_TYPE_BASIC"; 1 === f.shadowMapType ? v = "SHADOWMAP_TYPE_PCF" : 2 === f.shadowMapType && (v = "SHADOWMAP_TYPE_PCF_SOFT"); var k = "ENVMAP_TYPE_CUBE", r = "ENVMAP_MODE_REFLECTION", u = "ENVMAP_BLENDING_MULTIPLY"; if (f.envMap) {
        switch (d.envMap.mapping) {
          case 301: case 302: k = "ENVMAP_TYPE_CUBE"; break; case 306: case 307: k =
            "ENVMAP_TYPE_CUBE_UV"; break; case 303: case 304: k = "ENVMAP_TYPE_EQUIREC"; break; case 305: k = "ENVMAP_TYPE_SPHERE";
        }switch (d.envMap.mapping) { case 302: case 304: r = "ENVMAP_MODE_REFRACTION"; }switch (d.combine) { case 0: u = "ENVMAP_BLENDING_MULTIPLY"; break; case 1: u = "ENVMAP_BLENDING_MIX"; break; case 2: u = "ENVMAP_BLENDING_ADD"; }
      } var w = 0 < a.gammaFactor ? a.gammaFactor : 1, n = g.isWebGL2 ? "" : Sg(d.extensions, f, b), x = Tg(m), y = l.createProgram(); d.isRawShaderMaterial ? (m = [x].filter(Hc).join("\n"), 0 < m.length && (m += "\n"), b = [n, x].filter(Hc).join("\n"),
        0 < b.length && (b += "\n")) : (m = ["precision " + f.precision + " float;", "precision " + f.precision + " int;", "#define SHADER_NAME " + e.name, x, f.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + w, "#define MAX_BONES " + f.maxBones, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.envMap ? "#define " + r : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ? "#define USE_EMISSIVEMAP" :
          "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.normalMap && f.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", f.displacementMap && f.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexTangents ? "#define USE_TANGENT" : "", f.vertexColors ? "#define USE_COLOR" : "", f.flatShading ? "#define FLAT_SHADED" :
          "", f.skinning ? "#define USE_SKINNING" : "", f.useVertexTexture ? "#define BONE_TEXTURE" : "", f.morphTargets ? "#define USE_MORPHTARGETS" : "", f.morphNormals && !1 === f.flatShading ? "#define USE_MORPHNORMALS" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " + v : "", f.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && (g.isWebGL2 || b.get("EXT_frag_depth")) ?
          "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;",
          "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Hc).join("\n"), b = [n, "precision " +
            f.precision + " float;", "precision " + f.precision + " int;", "#define SHADER_NAME " + e.name, x, f.alphaTest ? "#define ALPHATEST " + f.alphaTest + (f.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + w, f.useFog && f.fog ? "#define USE_FOG" : "", f.useFog && f.fogExp ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.matcap ? "#define USE_MATCAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.envMap ? "#define " + k : "", f.envMap ? "#define " + r : "", f.envMap ? "#define " + u : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.aoMap ? "#define USE_AOMAP" : "", f.emissiveMap ?
              "#define USE_EMISSIVEMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.normalMap && f.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", f.metalnessMap ? "#define USE_METALNESSMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexTangents ? "#define USE_TANGENT" : "", f.vertexColors ? "#define USE_COLOR" : "", f.gradientMap ? "#define USE_GRADIENTMAP" : "", f.flatShading ? "#define FLAT_SHADED" :
              "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " + v : "", f.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", f.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", f.logarithmicDepthBuffer && (g.isWebGL2 || b.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", f.envMap && (g.isWebGL2 || b.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" :
              "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== f.toneMapping ? "#define TONE_MAPPING" : "", 0 !== f.toneMapping ? R.tonemapping_pars_fragment : "", 0 !== f.toneMapping ? Rg("toneMapping", f.toneMapping) : "", f.dithering ? "#define DITHERING" : "", f.outputEncoding || f.mapEncoding || f.matcapEncoding || f.envMapEncoding || f.emissiveMapEncoding ? R.encodings_pars_fragment : "", f.mapEncoding ? zd("mapTexelToLinear", f.mapEncoding) : "", f.matcapEncoding ? zd("matcapTexelToLinear", f.matcapEncoding) : "", f.envMapEncoding ? zd("envMapTexelToLinear",
                f.envMapEncoding) : "", f.emissiveMapEncoding ? zd("emissiveMapTexelToLinear", f.emissiveMapEncoding) : "", f.outputEncoding ? Qg("linearToOutputTexel", f.outputEncoding) : "", f.depthPacking ? "#define DEPTH_PACKING " + d.depthPacking : "", "\n"].filter(Hc).join("\n")); q = ie(q); q = mf(q, f); q = nf(q, f); p = ie(p); p = mf(p, f); p = nf(p, f); q = of(q); p = of(p); g.isWebGL2 && !d.isRawShaderMaterial && (g = !1, v = /^\s*#version\s+300\s+es\s*\n/, d.isShaderMaterial && null !== q.match(v) && null !== p.match(v) && (g = !0, q = q.replace(v, ""), p = p.replace(v, "")), m = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" +
                  m, b = ["#version 300 es\n\n#define varying in", g ? "" : "out highp vec4 pc_fragColor;", g ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") +
                  "\n" + b); p = b + p; q = kf(l, 35633, m + q, a.debug.checkShaderErrors); p = kf(l, 35632, p, a.debug.checkShaderErrors); l.attachShader(y, q); l.attachShader(y, p); void 0 !== d.index0AttributeName ? l.bindAttribLocation(y, 0, d.index0AttributeName) : !0 === f.morphTargets && l.bindAttribLocation(y, 0, "position"); l.linkProgram(y); if (a.debug.checkShaderErrors) {
                    a = l.getProgramInfoLog(y).trim(); f = l.getShaderInfoLog(q).trim(); g = l.getShaderInfoLog(p).trim(); k = v = !0; if (!1 === l.getProgramParameter(y, 35714)) v = !1, console.error("THREE.WebGLProgram: shader error: ",
                      l.getError(), "35715", l.getProgramParameter(y, 35715), "gl.getProgramInfoLog", a, f, g); else if ("" !== a) console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", a); else if ("" === f || "" === g) k = !1; k && (this.diagnostics = { runnable: v, material: d, programLog: a, vertexShader: { log: f, prefix: m }, fragmentShader: { log: g, prefix: b } });
                  } l.deleteShader(q); l.deleteShader(p); var F; this.getUniforms = function () { void 0 === F && (F = new ib(l, y, h)); return F; }; var G; this.getAttributes = function () {
                    if (void 0 === G) {
                      for (var a = {}, b = l.getProgramParameter(y,
                        35721), c = 0; c < b; c++) { var d = l.getActiveAttrib(y, c).name; a[d] = l.getAttribLocation(y, d); } G = a;
                    } return G;
                  }; this.destroy = function () { l.deleteProgram(y); this.program = void 0; }; Object.defineProperties(this, { uniforms: { get: function () { console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."); return this.getUniforms(); } }, attributes: { get: function () { console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."); return this.getAttributes(); } } }); this.name = e.name; this.id = Vg++; this.code = c; this.usedTimes =
                    1; this.program = y; this.vertexShader = q; this.fragmentShader = p; return this;
    } function Wg(a, b, c, d) {
      function e(a, b) { if (a) a.isTexture ? c = a.encoding : a.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), c = a.texture.encoding); else var c = 3E3; 3E3 === c && b && (c = 3007); return c; } var f = [], g = {
        MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong", MeshToonMaterial: "phong", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite"
      }, h = "precision supportsVertexTextures map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
      this.getParameters = function (b, d, f, h, v, k, r) {
        var l = g[b.type]; if (r.isSkinnedMesh) { var m = r.skeleton.bones; if (c.floatVertexTextures) m = 1024; else { var q = Math.min(Math.floor((c.maxVertexUniforms - 20) / 4), m.length); q < m.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + m.length + " bones. This GPU supports " + q + "."), m = 0) : m = q; } } else m = 0; q = c.precision; null !== b.precision && (q = c.getMaxPrecision(b.precision), q !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", q, "instead."));
        var p = a.getRenderTarget(); return {
          shaderID: l, precision: q, supportsVertexTextures: c.vertexTextures, outputEncoding: e(p ? p.texture : null, a.gammaOutput), map: !!b.map, mapEncoding: e(b.map, a.gammaInput), matcap: !!b.matcap, matcapEncoding: e(b.matcap, a.gammaInput), envMap: !!b.envMap, envMapMode: b.envMap && b.envMap.mapping, envMapEncoding: e(b.envMap, a.gammaInput), envMapCubeUV: !!b.envMap && (306 === b.envMap.mapping || 307 === b.envMap.mapping), lightMap: !!b.lightMap, aoMap: !!b.aoMap, emissiveMap: !!b.emissiveMap, emissiveMapEncoding: e(b.emissiveMap,
            a.gammaInput), bumpMap: !!b.bumpMap, normalMap: !!b.normalMap, objectSpaceNormalMap: 1 === b.normalMapType, displacementMap: !!b.displacementMap, roughnessMap: !!b.roughnessMap, metalnessMap: !!b.metalnessMap, specularMap: !!b.specularMap, alphaMap: !!b.alphaMap, gradientMap: !!b.gradientMap, combine: b.combine, vertexTangents: b.normalMap && b.vertexTangents, vertexColors: b.vertexColors, fog: !!h, useFog: b.fog, fogExp: h && h.isFogExp2, flatShading: b.flatShading, sizeAttenuation: b.sizeAttenuation, logarithmicDepthBuffer: c.logarithmicDepthBuffer,
          skinning: b.skinning && 0 < m, maxBones: m, useVertexTexture: c.floatVertexTextures, morphTargets: b.morphTargets, morphNormals: b.morphNormals, maxMorphTargets: a.maxMorphTargets, maxMorphNormals: a.maxMorphNormals, numDirLights: d.directional.length, numPointLights: d.point.length, numSpotLights: d.spot.length, numRectAreaLights: d.rectArea.length, numHemiLights: d.hemi.length, numClippingPlanes: v, numClipIntersection: k, dithering: b.dithering, shadowMapEnabled: a.shadowMap.enabled && r.receiveShadow && 0 < f.length, shadowMapType: a.shadowMap.type,
          toneMapping: a.toneMapping, physicallyCorrectLights: a.physicallyCorrectLights, premultipliedAlpha: b.premultipliedAlpha, alphaTest: b.alphaTest, doubleSided: 2 === b.side, flipSided: 1 === b.side, depthPacking: void 0 !== b.depthPacking ? b.depthPacking : !1
        };
      }; this.getProgramCode = function (b, c) {
        var d = []; c.shaderID ? d.push(c.shaderID) : (d.push(b.fragmentShader), d.push(b.vertexShader)); if (void 0 !== b.defines) for (var e in b.defines) d.push(e), d.push(b.defines[e]); for (e = 0; e < h.length; e++)d.push(c[h[e]]); d.push(b.onBeforeCompile.toString());
        d.push(a.gammaOutput); d.push(a.gammaFactor); return d.join();
      }; this.acquireProgram = function (e, g, h, p) { for (var l, m = 0, q = f.length; m < q; m++) { var k = f[m]; if (k.code === p) { l = k; ++l.usedTimes; break; } } void 0 === l && (l = new Ug(a, b, p, e, g, h, c, d), f.push(l)); return l; }; this.releaseProgram = function (a) { if (0 === --a.usedTimes) { var b = f.indexOf(a); f[b] = f[f.length - 1]; f.pop(); a.destroy(); } }; this.programs = f;
    } function Xg() {
      var a = new WeakMap; return {
        get: function (b) { var c = a.get(b); void 0 === c && (c = {}, a.set(b, c)); return c; }, remove: function (b) { a.delete(b); },
        update: function (b, c, d) { a.get(b)[c] = d; }, dispose: function () { a = new WeakMap; }
      };
    } function Yg(a, b) { return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id; } function Zg(a, b) {
      return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id -
        b.id;
    } function pf() {
      function a(a, d, e, m, q, p) { var g = b[c]; void 0 === g ? (g = { id: a.id, object: a, geometry: d, material: e, program: e.program || f, groupOrder: m, renderOrder: a.renderOrder, z: q, group: p }, b[c] = g) : (g.id = a.id, g.object = a, g.geometry = d, g.material = e, g.program = e.program || f, g.groupOrder = m, g.renderOrder = a.renderOrder, g.z = q, g.group = p); c++; return g; } var b = [], c = 0, d = [], e = [], f = { id: -1 }; return {
        opaque: d, transparent: e, init: function () { c = 0; d.length = 0; e.length = 0; }, push: function (b, c, f, m, q, p) {
          b = a(b, c, f, m, q, p); (!0 === f.transparent ?
            e : d).push(b);
        }, unshift: function (b, c, f, m, q, p) { b = a(b, c, f, m, q, p); (!0 === f.transparent ? e : d).unshift(b); }, sort: function () { 1 < d.length && d.sort(Yg); 1 < e.length && e.sort(Zg); }
      };
    } function $g() { function a(c) { c = c.target; c.removeEventListener("dispose", a); delete b[c.id]; } var b = {}; return { get: function (c, d) { var e = b[c.id]; if (void 0 === e) { var f = new pf; b[c.id] = {}; b[c.id][d.id] = f; c.addEventListener("dispose", a); } else f = e[d.id], void 0 === f && (f = new pf, e[d.id] = f); return f; }, dispose: function () { b = {}; } }; } function ah() {
      var a = {}; return {
        get: function (b) {
          if (void 0 !==
            a[b.id]) return a[b.id]; switch (b.type) {
              case "DirectionalLight": var c = { direction: new n, color: new A, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new C }; break; case "SpotLight": c = { position: new n, direction: new n, color: new A, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new C }; break; case "PointLight": c = { position: new n, color: new A, distance: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new C, shadowCameraNear: 1, shadowCameraFar: 1E3 }; break;
              case "HemisphereLight": c = { direction: new n, skyColor: new A, groundColor: new A }; break; case "RectAreaLight": c = { color: new A, position: new n, halfWidth: new n, halfHeight: new n };
            }return a[b.id] = c;
        }
      };
    } function bh() {
      for (var a = new ah, b = {
        id: ch++, hash: { stateID: -1, directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, shadowsLength: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [],
        pointShadowMap: [], pointShadowMatrix: [], hemi: []
      }, c = 0; 9 > c; c++)b.probe.push(new n); var d = new n, e = new P, f = new P; return {
        setup: function (c, h, l) {
          for (var g = 0, q = 0, p = 0, v = 0; 9 > v; v++)b.probe[v].set(0, 0, 0); var k = 0, r = 0, u = 0, n = 0, z = 0; l = l.matrixWorldInverse; v = 0; for (var x = c.length; v < x; v++) {
            var y = c[v], F = y.color, G = y.intensity, ua = y.distance, pa = y.shadow && y.shadow.map ? y.shadow.map.texture : null; if (y.isAmbientLight) g += F.r * G, q += F.g * G, p += F.b * G; else if (y.isLightProbe) for (pa = 0; 9 > pa; pa++)b.probe[pa].addScaledVector(y.sh.coefficients[pa],
              G); else if (y.isDirectionalLight) { var I = a.get(y); I.color.copy(y.color).multiplyScalar(y.intensity); I.direction.setFromMatrixPosition(y.matrixWorld); d.setFromMatrixPosition(y.target.matrixWorld); I.direction.sub(d); I.direction.transformDirection(l); if (I.shadow = y.castShadow) G = y.shadow, I.shadowBias = G.bias, I.shadowRadius = G.radius, I.shadowMapSize = G.mapSize; b.directionalShadowMap[k] = pa; b.directionalShadowMatrix[k] = y.shadow.matrix; b.directional[k] = I; k++; } else if (y.isSpotLight) {
                I = a.get(y); I.position.setFromMatrixPosition(y.matrixWorld);
                I.position.applyMatrix4(l); I.color.copy(F).multiplyScalar(G); I.distance = ua; I.direction.setFromMatrixPosition(y.matrixWorld); d.setFromMatrixPosition(y.target.matrixWorld); I.direction.sub(d); I.direction.transformDirection(l); I.coneCos = Math.cos(y.angle); I.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)); I.decay = y.decay; if (I.shadow = y.castShadow) G = y.shadow, I.shadowBias = G.bias, I.shadowRadius = G.radius, I.shadowMapSize = G.mapSize; b.spotShadowMap[u] = pa; b.spotShadowMatrix[u] = y.shadow.matrix; b.spot[u] = I; u++;
              } else if (y.isRectAreaLight) I =
                a.get(y), I.color.copy(F).multiplyScalar(G), I.position.setFromMatrixPosition(y.matrixWorld), I.position.applyMatrix4(l), f.identity(), e.copy(y.matrixWorld), e.premultiply(l), f.extractRotation(e), I.halfWidth.set(.5 * y.width, 0, 0), I.halfHeight.set(0, .5 * y.height, 0), I.halfWidth.applyMatrix4(f), I.halfHeight.applyMatrix4(f), b.rectArea[n] = I, n++; else if (y.isPointLight) {
                  I = a.get(y); I.position.setFromMatrixPosition(y.matrixWorld); I.position.applyMatrix4(l); I.color.copy(y.color).multiplyScalar(y.intensity); I.distance =
                    y.distance; I.decay = y.decay; if (I.shadow = y.castShadow) G = y.shadow, I.shadowBias = G.bias, I.shadowRadius = G.radius, I.shadowMapSize = G.mapSize, I.shadowCameraNear = G.camera.near, I.shadowCameraFar = G.camera.far; b.pointShadowMap[r] = pa; b.pointShadowMatrix[r] = y.shadow.matrix; b.point[r] = I; r++;
                } else y.isHemisphereLight && (I = a.get(y), I.direction.setFromMatrixPosition(y.matrixWorld), I.direction.transformDirection(l), I.direction.normalize(), I.skyColor.copy(y.color).multiplyScalar(G), I.groundColor.copy(y.groundColor).multiplyScalar(G),
                  b.hemi[z] = I, z++);
          } b.ambient[0] = g; b.ambient[1] = q; b.ambient[2] = p; b.directional.length = k; b.spot.length = u; b.rectArea.length = n; b.point.length = r; b.hemi.length = z; b.hash.stateID = b.id; b.hash.directionalLength = k; b.hash.pointLength = r; b.hash.spotLength = u; b.hash.rectAreaLength = n; b.hash.hemiLength = z; b.hash.shadowsLength = h.length;
        }, state: b
      };
    } function qf() {
      var a = new bh, b = [], c = []; return {
        init: function () { b.length = 0; c.length = 0; }, state: { lightsArray: b, shadowsArray: c, lights: a }, setupLights: function (d) { a.setup(b, c, d); }, pushLight: function (a) { b.push(a); },
        pushShadow: function (a) { c.push(a); }
      };
    } function dh() { function a(c) { c = c.target; c.removeEventListener("dispose", a); delete b[c.id]; } var b = {}; return { get: function (c, d) { if (void 0 === b[c.id]) { var e = new qf; b[c.id] = {}; b[c.id][d.id] = e; c.addEventListener("dispose", a); } else void 0 === b[c.id][d.id] ? (e = new qf, b[c.id][d.id] = e) : e = b[c.id][d.id]; return e; }, dispose: function () { b = {}; } }; } function jb(a) {
      Q.call(this); this.type = "MeshDepthMaterial"; this.depthPacking = 3200; this.morphTargets = this.skinning = !1; this.displacementMap = this.alphaMap =
        this.map = null; this.displacementScale = 1; this.displacementBias = 0; this.wireframe = !1; this.wireframeLinewidth = 1; this.lights = this.fog = !1; this.setValues(a);
    } function kb(a) { Q.call(this); this.type = "MeshDistanceMaterial"; this.referencePosition = new n; this.nearDistance = 1; this.farDistance = 1E3; this.morphTargets = this.skinning = !1; this.displacementMap = this.alphaMap = this.map = null; this.displacementScale = 1; this.displacementBias = 0; this.lights = this.fog = !1; this.setValues(a); } function rf(a, b, c) {
      function d(b, c, d, e, f, g) {
        var h =
          b.geometry; var l = p; var m = b.customDepthMaterial; d && (l = v, m = b.customDistanceMaterial); m ? l = m : (m = !1, c.morphTargets && (h && h.isBufferGeometry ? m = h.morphAttributes && h.morphAttributes.position && 0 < h.morphAttributes.position.length : h && h.isGeometry && (m = h.morphTargets && 0 < h.morphTargets.length)), b.isSkinnedMesh && !1 === c.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", b), b = b.isSkinnedMesh && c.skinning, h = 0, m && (h |= 1), b && (h |= 2), l = l[h]); a.localClippingEnabled && !0 ===
            c.clipShadows && 0 !== c.clippingPlanes.length && (h = l.uuid, m = c.uuid, b = k[h], void 0 === b && (b = {}, k[h] = b), h = b[m], void 0 === h && (h = l.clone(), b[m] = h), l = h); l.visible = c.visible; l.wireframe = c.wireframe; l.side = null != c.shadowSide ? c.shadowSide : r[c.side]; l.clipShadows = c.clipShadows; l.clippingPlanes = c.clippingPlanes; l.clipIntersection = c.clipIntersection; l.wireframeLinewidth = c.wireframeLinewidth; l.linewidth = c.linewidth; d && l.isMeshDistanceMaterial && (l.referencePosition.copy(e), l.nearDistance = f, l.farDistance = g); return l;
      }
      function e(c, g, h, l) {
        if (!1 !== c.visible) {
          if (c.layers.test(g.layers) && (c.isMesh || c.isLine || c.isPoints) && c.castShadow && (!c.frustumCulled || f.intersectsObject(c))) {
            c.modelViewMatrix.multiplyMatrices(h.matrixWorldInverse, c.matrixWorld); var m = b.update(c), p = c.material; if (Array.isArray(p)) for (var v = m.groups, k = 0, t = v.length; k < t; k++) { var r = v[k], u = p[r.materialIndex]; u && u.visible && (u = d(c, u, l, q, h.near, h.far), a.renderBufferDirect(h, null, m, u, c, r)); } else p.visible && (u = d(c, p, l, q, h.near, h.far), a.renderBufferDirect(h, null,
              m, u, c, null));
          } c = c.children; m = 0; for (p = c.length; m < p; m++)e(c[m], g, h, l);
        }
      } var f = new yd, g = new P, h = new C, l = new C(c, c), m = new n, q = new n, p = Array(4), v = Array(4), k = {}, r = { 0: 1, 1: 0, 2: 2 }, u = [new n(1, 0, 0), new n(-1, 0, 0), new n(0, 0, 1), new n(0, 0, -1), new n(0, 1, 0), new n(0, -1, 0)], w = [new n(0, 1, 0), new n(0, 1, 0), new n(0, 1, 0), new n(0, 1, 0), new n(0, 0, 1), new n(0, 0, -1)], z = [new W, new W, new W, new W, new W, new W]; for (c = 0; 4 !== c; ++c) {
        var x = 0 !== (c & 1), y = 0 !== (c & 2), F = new jb({ depthPacking: 3201, morphTargets: x, skinning: y }); p[c] = F; x = new kb({
          morphTargets: x,
          skinning: y
        }); v[c] = x;
      } var G = this; this.enabled = !1; this.autoUpdate = !0; this.needsUpdate = !1; this.type = 1; this.render = function (b, c, d) {
        if (!1 !== G.enabled && (!1 !== G.autoUpdate || !1 !== G.needsUpdate) && 0 !== b.length) {
          var p = a.getRenderTarget(), v = a.state; v.setBlending(0); v.buffers.color.setClear(1, 1, 1, 1); v.buffers.depth.setTest(!0); v.setScissorTest(!1); for (var k, t = 0, r = b.length; t < r; t++) {
            var n = b[t]; k = n.shadow; var ha = n && n.isPointLight; if (void 0 === k) console.warn("THREE.WebGLShadowMap:", n, "has no shadow."); else {
              var S = k.camera;
              h.copy(k.mapSize); h.min(l); if (ha) { var y = h.x, x = h.y; z[0].set(2 * y, x, y, x); z[1].set(0, x, y, x); z[2].set(3 * y, x, y, x); z[3].set(y, x, y, x); z[4].set(3 * y, 0, y, x); z[5].set(y, 0, y, x); h.x *= 4; h.y *= 2; } null === k.map && (k.map = new Sa(h.x, h.y, { minFilter: 1003, magFilter: 1003, format: 1023 }), k.map.texture.name = n.name + ".shadowMap", S.updateProjectionMatrix()); k.isSpotLightShadow && k.update(n); y = k.map; x = k.matrix; q.setFromMatrixPosition(n.matrixWorld); S.position.copy(q); ha ? (k = 6, x.makeTranslation(-q.x, -q.y, -q.z)) : (k = 1, m.setFromMatrixPosition(n.target.matrixWorld),
                S.lookAt(m), S.updateMatrixWorld(), x.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), x.multiply(S.projectionMatrix), x.multiply(S.matrixWorldInverse)); a.setRenderTarget(y); a.clear(); for (n = 0; n < k; n++)ha && (m.copy(S.position), m.add(u[n]), S.up.copy(w[n]), S.lookAt(m), S.updateMatrixWorld(), v.viewport(z[n])), g.multiplyMatrices(S.projectionMatrix, S.matrixWorldInverse), f.setFromMatrix(g), e(c, d, S, ha);
            }
          } G.needsUpdate = !1; a.setRenderTarget(p);
        }
      };
    } function eh(a, b, c, d) {
      function e(b, c, d) {
        var e = new Uint8Array(4), f = a.createTexture();
        a.bindTexture(b, f); a.texParameteri(b, 10241, 9728); a.texParameteri(b, 10240, 9728); for (b = 0; b < d; b++)a.texImage2D(c + b, 0, 6408, 1, 1, 0, 6408, 5121, e); return f;
      } function f(c, e) { z[c] = 1; 0 === x[c] && (a.enableVertexAttribArray(c), x[c] = 1); y[c] !== e && ((d.isWebGL2 ? a : b.get("ANGLE_instanced_arrays"))[d.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](c, e), y[c] = e); } function g(b) { !0 !== F[b] && (a.enable(b), F[b] = !0); } function h(b) { !1 !== F[b] && (a.disable(b), F[b] = !1); } function l(b, d, e, f, l, m, q, p) {
        if (0 === b) pa && (h(3042), pa = !1);
        else if (pa || (g(3042), pa = !0), 5 !== b) {
          if (b !== I || p !== ha) {
            if (100 !== C || 100 !== D) a.blendEquation(32774), D = C = 100; if (p) switch (b) { case 1: a.blendFuncSeparate(1, 771, 1, 771); break; case 2: a.blendFunc(1, 1); break; case 3: a.blendFuncSeparate(0, 0, 769, 771); break; case 4: a.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", b); } else switch (b) {
              case 1: a.blendFuncSeparate(770, 771, 1, 771); break; case 2: a.blendFunc(770, 1); break; case 3: a.blendFunc(0, 769); break; case 4: a.blendFunc(0, 768);
                break; default: console.error("THREE.WebGLState: Invalid blending: ", b);
            }J = B = fe = E = null; I = b; ha = p;
          }
        } else { l = l || d; m = m || e; q = q || f; if (d !== C || l !== D) a.blendEquationSeparate(c.convert(d), c.convert(l)), C = d, D = l; if (e !== E || f !== fe || m !== B || q !== J) a.blendFuncSeparate(c.convert(e), c.convert(f), c.convert(m), c.convert(q)), E = e, fe = f, B = m, J = q; I = b; ha = null; }
      } function m(b) { S !== b && (b ? a.frontFace(2304) : a.frontFace(2305), S = b); } function q(b) {
        0 !== b ? (g(2884), b !== ge && (1 === b ? a.cullFace(1029) : 2 === b ? a.cullFace(1028) : a.cullFace(1032))) : h(2884);
        ge = b;
      } function p(b, c, d) { if (b) { if (g(32823), bb !== c || sf !== d) a.polygonOffset(c, d), bb = c, sf = d; } else h(32823); } function v(b) { void 0 === b && (b = 33984 + A - 1); P !== b && (a.activeTexture(b), P = b); } var k = new function () { var b = !1, c = new W, d = null, e = new W(0, 0, 0, 0); return { setMask: function (c) { d === c || b || (a.colorMask(c, c, c, c), d = c); }, setLocked: function (a) { b = a; }, setClear: function (b, d, f, g, h) { !0 === h && (b *= g, d *= g, f *= g); c.set(b, d, f, g); !1 === e.equals(c) && (a.clearColor(b, d, f, g), e.copy(c)); }, reset: function () { b = !1; d = null; e.set(-1, 0, 0, 0); } }; }, r = new function () {
        var b =
          !1, c = null, d = null, e = null; return {
            setTest: function (a) { a ? g(2929) : h(2929); }, setMask: function (d) { c === d || b || (a.depthMask(d), c = d); }, setFunc: function (b) { if (d !== b) { if (b) switch (b) { case 0: a.depthFunc(512); break; case 1: a.depthFunc(519); break; case 2: a.depthFunc(513); break; case 3: a.depthFunc(515); break; case 4: a.depthFunc(514); break; case 5: a.depthFunc(518); break; case 6: a.depthFunc(516); break; case 7: a.depthFunc(517); break; default: a.depthFunc(515); } else a.depthFunc(515); d = b; } }, setLocked: function (a) { b = a; }, setClear: function (b) {
              e !==
              b && (a.clearDepth(b), e = b);
            }, reset: function () { b = !1; e = d = c = null; }
          };
      }, u = new function () {
        var b = !1, c = null, d = null, e = null, f = null, l = null, m = null, q = null, p = null; return {
          setTest: function (a) { a ? g(2960) : h(2960); }, setMask: function (d) { c === d || b || (a.stencilMask(d), c = d); }, setFunc: function (b, c, g) { if (d !== b || e !== c || f !== g) a.stencilFunc(b, c, g), d = b, e = c, f = g; }, setOp: function (b, c, d) { if (l !== b || m !== c || q !== d) a.stencilOp(b, c, d), l = b, m = c, q = d; }, setLocked: function (a) { b = a; }, setClear: function (b) { p !== b && (a.clearStencil(b), p = b); }, reset: function () {
            b =
            !1; p = q = m = l = f = e = d = c = null;
          }
        };
      }, n = a.getParameter(34921), z = new Uint8Array(n), x = new Uint8Array(n), y = new Uint8Array(n), F = {}, G = null, ua = null, pa = null, I = null, C = null, E = null, fe = null, D = null, B = null, J = null, ha = !1, S = null, ge = null, xb = null, bb = null, sf = null, A = a.getParameter(35661), M = !1; n = 0; n = a.getParameter(7938); -1 !== n.indexOf("WebGL") ? (n = parseFloat(/^WebGL ([0-9])/.exec(n)[1]), M = 1 <= n) : -1 !== n.indexOf("OpenGL ES") && (n = parseFloat(/^OpenGL ES ([0-9])/.exec(n)[1]), M = 2 <= n); var P = null, K = {}, O = new W, Q = new W, L = {}; L[3553] = e(3553,
        3553, 1); L[34067] = e(34067, 34069, 6); k.setClear(0, 0, 0, 1); r.setClear(1); u.setClear(0); g(2929); r.setFunc(3); m(!1); q(1); g(2884); l(0); return {
          buffers: { color: k, depth: r, stencil: u }, initAttributes: function () { for (var a = 0, b = z.length; a < b; a++)z[a] = 0; }, enableAttribute: function (a) { f(a, 0); }, enableAttributeAndDivisor: f, disableUnusedAttributes: function () { for (var b = 0, c = x.length; b !== c; ++b)x[b] !== z[b] && (a.disableVertexAttribArray(b), x[b] = 0); }, enable: g, disable: h, getCompressedTextureFormats: function () {
            if (null === G && (G = [], b.get("WEBGL_compressed_texture_pvrtc") ||
              b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1") || b.get("WEBGL_compressed_texture_astc"))) for (var c = a.getParameter(34467), d = 0; d < c.length; d++)G.push(c[d]); return G;
          }, useProgram: function (b) { return ua !== b ? (a.useProgram(b), ua = b, !0) : !1; }, setBlending: l, setMaterial: function (a, b) {
            2 === a.side ? h(2884) : g(2884); var c = 1 === a.side; b && (c = !c); m(c); 1 === a.blending && !1 === a.transparent ? l(0) : l(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha, a.blendSrcAlpha, a.blendDstAlpha,
              a.premultipliedAlpha); r.setFunc(a.depthFunc); r.setTest(a.depthTest); r.setMask(a.depthWrite); k.setMask(a.colorWrite); p(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits);
          }, setFlipSided: m, setCullFace: q, setLineWidth: function (b) { b !== xb && (M && a.lineWidth(b), xb = b); }, setPolygonOffset: p, setScissorTest: function (a) { a ? g(3089) : h(3089); }, activeTexture: v, bindTexture: function (b, c) {
            null === P && v(); var d = K[P]; void 0 === d && (d = { type: void 0, texture: void 0 }, K[P] = d); if (d.type !== b || d.texture !== c) a.bindTexture(b, c || L[b]),
              d.type = b, d.texture = c;
          }, compressedTexImage2D: function () { try { a.compressedTexImage2D.apply(a, arguments); } catch (Z) { console.error("THREE.WebGLState:", Z); } }, texImage2D: function () { try { a.texImage2D.apply(a, arguments); } catch (Z) { console.error("THREE.WebGLState:", Z); } }, texImage3D: function () { try { a.texImage3D.apply(a, arguments); } catch (Z) { console.error("THREE.WebGLState:", Z); } }, scissor: function (b) { !1 === O.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), O.copy(b)); }, viewport: function (b) {
            !1 === Q.equals(b) && (a.viewport(b.x, b.y, b.z,
              b.w), Q.copy(b));
          }, reset: function () { for (var b = 0; b < x.length; b++)1 === x[b] && (a.disableVertexAttribArray(b), x[b] = 0); F = {}; P = G = null; K = {}; ge = S = I = ua = null; k.reset(); r.reset(); u.reset(); }
        };
    } function fh(a, b, c, d, e, f, g) {
      function h(a, b) { return D ? new OffscreenCanvas(a, b) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); } function l(a, b, c, d) {
        var e = 1; if (a.width > d || a.height > d) e = d / Math.max(a.width, a.height); if (1 > e || !0 === b) {
          if ("undefined" !== typeof HTMLImageElement && a instanceof HTMLImageElement || "undefined" !==
            typeof HTMLCanvasElement && a instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && a instanceof ImageBitmap) return d = b ? O.floorPowerOfTwo : Math.floor, b = d(e * a.width), e = d(e * a.height), void 0 === E && (E = h(b, e)), c = c ? h(b, e) : E, c.width = b, c.height = e, c.getContext("2d").drawImage(a, 0, 0, b, e), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + a.width + "x" + a.height + ") to (" + b + "x" + e + ")."), c; "data" in a && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + a.width + "x" + a.height +
              ").");
        } return a;
      } function m(a) { return O.isPowerOfTwo(a.width) && O.isPowerOfTwo(a.height); } function q(a, b) { return a.generateMipmaps && b && 1003 !== a.minFilter && 1006 !== a.minFilter; } function p(b, c, e, f) { a.generateMipmap(b); d.get(c).__maxMipLevel = Math.log(Math.max(e, f)) * Math.LOG2E; } function v(a, c) {
        if (!e.isWebGL2) return a; var d = a; 6403 === a && (5126 === c && (d = 33326), 5131 === c && (d = 33325), 5121 === c && (d = 33321)); 6407 === a && (5126 === c && (d = 34837), 5131 === c && (d = 34843), 5121 === c && (d = 32849)); 6408 === a && (5126 === c && (d = 34836), 5131 === c &&
          (d = 34842), 5121 === c && (d = 32856)); 33325 === d || 33326 === d || 34842 === d || 34836 === d ? b.get("EXT_color_buffer_float") : (34843 === d || 34837 === d) && console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."); return d;
      } function k(a) { return 1003 === a || 1004 === a || 1005 === a ? 9728 : 9729; } function r(b) { b = b.target; b.removeEventListener("dispose", r); var c = d.get(b); void 0 !== c.__webglInit && (a.deleteTexture(c.__webglTexture), d.remove(b)); b.isVideoTexture && delete C[b.id]; g.memory.textures--; }
      function u(b) { b = b.target; b.removeEventListener("dispose", u); var c = d.get(b), e = d.get(b.texture); if (b) { void 0 !== e.__webglTexture && a.deleteTexture(e.__webglTexture); b.depthTexture && b.depthTexture.dispose(); if (b.isWebGLRenderTargetCube) for (e = 0; 6 > e; e++)a.deleteFramebuffer(c.__webglFramebuffer[e]), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer[e]); else a.deleteFramebuffer(c.__webglFramebuffer), c.__webglDepthbuffer && a.deleteRenderbuffer(c.__webglDepthbuffer); d.remove(b.texture); d.remove(b); } g.memory.textures--; }
      function n(a, b) { var e = d.get(a); if (a.isVideoTexture) { var f = a.id, h = g.render.frame; C[f] !== h && (C[f] = h, a.update()); } if (0 < a.version && e.__version !== a.version) if (f = a.image, void 0 === f) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else if (!1 === f.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete"); else { G(e, a, b); return; } c.activeTexture(33984 + b); c.bindTexture(3553, e.__webglTexture); } function z(b, g) {
        var h = d.get(b); if (6 === b.image.length) if (0 <
          b.version && h.__version !== b.version) {
            F(h, b); c.activeTexture(33984 + g); c.bindTexture(34067, h.__webglTexture); a.pixelStorei(37440, b.flipY); g = b && b.isCompressedTexture; for (var k = b.image[0] && b.image[0].isDataTexture, t = [], r = 0; 6 > r; r++)t[r] = g || k ? k ? b.image[r].image : b.image[r] : l(b.image[r], !1, !0, e.maxCubemapSize); var u = t[0], n = m(u) || e.isWebGL2, w = f.convert(b.format), x = f.convert(b.type), G = v(w, x); y(34067, b, n); for (r = 0; 6 > r; r++)if (g) for (var S, ha = t[r].mipmaps, z = 0, ua = ha.length; z < ua; z++)S = ha[z], 1023 !== b.format && 1022 !==
              b.format ? -1 < c.getCompressedTextureFormats().indexOf(w) ? c.compressedTexImage2D(34069 + r, z, G, S.width, S.height, 0, S.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : c.texImage2D(34069 + r, z, G, S.width, S.height, 0, w, x, S.data); else k ? c.texImage2D(34069 + r, 0, G, t[r].width, t[r].height, 0, w, x, t[r].data) : c.texImage2D(34069 + r, 0, G, w, x, t[r]); h.__maxMipLevel = g ? ha.length - 1 : 0; q(b, n) && p(34067, b, u.width, u.height); h.__version = b.version; if (b.onUpdate) b.onUpdate(b);
        } else c.activeTexture(33984 +
          g), c.bindTexture(34067, h.__webglTexture);
      } function x(a, b) { c.activeTexture(33984 + b); c.bindTexture(34067, d.get(a).__webglTexture); } function y(c, g, h) {
        h ? (a.texParameteri(c, 10242, f.convert(g.wrapS)), a.texParameteri(c, 10243, f.convert(g.wrapT)), 32879 !== c && 35866 !== c || a.texParameteri(c, 32882, f.convert(g.wrapR)), a.texParameteri(c, 10240, f.convert(g.magFilter)), a.texParameteri(c, 10241, f.convert(g.minFilter))) : (a.texParameteri(c, 10242, 33071), a.texParameteri(c, 10243, 33071), 32879 !== c && 35866 !== c || a.texParameteri(c,
          32882, 33071), 1001 === g.wrapS && 1001 === g.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), a.texParameteri(c, 10240, k(g.magFilter)), a.texParameteri(c, 10241, k(g.minFilter)), 1003 !== g.minFilter && 1006 !== g.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")); !(h = b.get("EXT_texture_filter_anisotropic")) || 1015 ===
            g.type && null === b.get("OES_texture_float_linear") || 1016 === g.type && null === (e.isWebGL2 || b.get("OES_texture_half_float_linear")) || !(1 < g.anisotropy || d.get(g).__currentAnisotropy) || (a.texParameterf(c, h.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(g.anisotropy, e.getMaxAnisotropy())), d.get(g).__currentAnisotropy = g.anisotropy);
      } function F(b, c) { void 0 === b.__webglInit && (b.__webglInit = !0, c.addEventListener("dispose", r), b.__webglTexture = a.createTexture(), g.memory.textures++); } function G(b, d, g) {
        var h = 3553; d.isDataTexture2DArray &&
          (h = 35866); d.isDataTexture3D && (h = 32879); F(b, d); c.activeTexture(33984 + g); c.bindTexture(h, b.__webglTexture); a.pixelStorei(37440, d.flipY); a.pixelStorei(37441, d.premultiplyAlpha); a.pixelStorei(3317, d.unpackAlignment); g = e.isWebGL2 ? !1 : 1001 !== d.wrapS || 1001 !== d.wrapT || 1003 !== d.minFilter && 1006 !== d.minFilter; g = g && !1 === m(d.image); g = l(d.image, g, !1, e.maxTextureSize); var k = m(g) || e.isWebGL2, r = f.convert(d.format), t = f.convert(d.type), u = v(r, t); y(h, d, k); var n = d.mipmaps; if (d.isDepthTexture) {
            u = 6402; if (1015 === d.type) {
              if (!e.isWebGL2) throw Error("Float Depth Texture only supported in WebGL2.0");
              u = 36012;
            } else e.isWebGL2 && (u = 33189); 1026 === d.format && 6402 === u && 1012 !== d.type && 1014 !== d.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), d.type = 1012, t = f.convert(d.type)); 1027 === d.format && (u = 34041, 1020 !== d.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), d.type = 1020, t = f.convert(d.type))); c.texImage2D(3553, 0, u, g.width, g.height, 0, r, t, null);
          } else if (d.isDataTexture) if (0 < n.length && k) {
            for (var w =
              0, x = n.length; w < x; w++)h = n[w], c.texImage2D(3553, w, u, h.width, h.height, 0, r, t, h.data); d.generateMipmaps = !1; b.__maxMipLevel = n.length - 1;
          } else c.texImage2D(3553, 0, u, g.width, g.height, 0, r, t, g.data), b.__maxMipLevel = 0; else if (d.isCompressedTexture) {
            w = 0; for (x = n.length; w < x; w++)h = n[w], 1023 !== d.format && 1022 !== d.format ? -1 < c.getCompressedTextureFormats().indexOf(r) ? c.compressedTexImage2D(3553, w, u, h.width, h.height, 0, h.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") :
              c.texImage2D(3553, w, u, h.width, h.height, 0, r, t, h.data); b.__maxMipLevel = n.length - 1;
          } else if (d.isDataTexture2DArray) c.texImage3D(35866, 0, u, g.width, g.height, g.depth, 0, r, t, g.data), b.__maxMipLevel = 0; else if (d.isDataTexture3D) c.texImage3D(32879, 0, u, g.width, g.height, g.depth, 0, r, t, g.data), b.__maxMipLevel = 0; else if (0 < n.length && k) { w = 0; for (x = n.length; w < x; w++)h = n[w], c.texImage2D(3553, w, u, r, t, h); d.generateMipmaps = !1; b.__maxMipLevel = n.length - 1; } else c.texImage2D(3553, 0, u, r, t, g), b.__maxMipLevel = 0; q(d, k) && p(3553, d, g.width,
            g.height); b.__version = d.version; if (d.onUpdate) d.onUpdate(d);
      } function ua(b, e, g, h) { var l = f.convert(e.texture.format), m = f.convert(e.texture.type), q = v(l, m); c.texImage2D(h, 0, q, e.width, e.height, 0, l, m, null); a.bindFramebuffer(36160, b); a.framebufferTexture2D(36160, g, h, d.get(e.texture).__webglTexture, 0); a.bindFramebuffer(36160, null); } function pa(b, c, d) {
        a.bindRenderbuffer(36161, b); if (c.depthBuffer && !c.stencilBuffer) d ? (d = I(c), a.renderbufferStorageMultisample(36161, d, 33189, c.width, c.height)) : a.renderbufferStorage(36161,
          33189, c.width, c.height), a.framebufferRenderbuffer(36160, 36096, 36161, b); else if (c.depthBuffer && c.stencilBuffer) d ? (d = I(c), a.renderbufferStorageMultisample(36161, d, 34041, c.width, c.height)) : a.renderbufferStorage(36161, 34041, c.width, c.height), a.framebufferRenderbuffer(36160, 33306, 36161, b); else { b = f.convert(c.texture.format); var e = f.convert(c.texture.type); b = v(b, e); d ? (d = I(c), a.renderbufferStorageMultisample(36161, d, b, c.width, c.height)) : a.renderbufferStorage(36161, b, c.width, c.height); } a.bindRenderbuffer(36161,
            null);
      } function I(a) { return e.isWebGL2 && a.isWebGLMultisampleRenderTarget ? Math.min(e.maxSamples, a.samples) : 0; } var C = {}, E, D = "undefined" !== typeof OffscreenCanvas, B = 0, J = !1, A = !1; this.allocateTextureUnit = function () { var a = B; a >= e.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + a + " texture units while this GPU supports only " + e.maxTextures); B += 1; return a; }; this.resetTextureUnits = function () { B = 0; }; this.setTexture2D = n; this.setTexture2DArray = function (a, b) {
        var e = d.get(a); 0 < a.version && e.__version !==
          a.version ? G(e, a, b) : (c.activeTexture(33984 + b), c.bindTexture(35866, e.__webglTexture));
      }; this.setTexture3D = function (a, b) { var e = d.get(a); 0 < a.version && e.__version !== a.version ? G(e, a, b) : (c.activeTexture(33984 + b), c.bindTexture(32879, e.__webglTexture)); }; this.setTextureCube = z; this.setTextureCubeDynamic = x; this.setupRenderTarget = function (b) {
        var h = d.get(b), l = d.get(b.texture); b.addEventListener("dispose", u); l.__webglTexture = a.createTexture(); g.memory.textures++; var k = !0 === b.isWebGLRenderTargetCube, r = !0 === b.isWebGLMultisampleRenderTarget,
          t = m(b) || e.isWebGL2; if (k) for (h.__webglFramebuffer = [], r = 0; 6 > r; r++)h.__webglFramebuffer[r] = a.createFramebuffer(); else if (h.__webglFramebuffer = a.createFramebuffer(), r) if (e.isWebGL2) {
            h.__webglMultisampledFramebuffer = a.createFramebuffer(); h.__webglColorRenderbuffer = a.createRenderbuffer(); a.bindRenderbuffer(36161, h.__webglColorRenderbuffer); r = f.convert(b.texture.format); var w = f.convert(b.texture.type); r = v(r, w); w = I(b); a.renderbufferStorageMultisample(36161, w, r, b.width, b.height); a.bindFramebuffer(36160, h.__webglMultisampledFramebuffer);
            a.framebufferRenderbuffer(36160, 36064, 36161, h.__webglColorRenderbuffer); a.bindRenderbuffer(36161, null); b.depthBuffer && (h.__webglDepthRenderbuffer = a.createRenderbuffer(), pa(h.__webglDepthRenderbuffer, b, !0)); a.bindFramebuffer(36160, null);
          } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (k) {
            c.bindTexture(34067, l.__webglTexture); y(34067, b.texture, t); for (r = 0; 6 > r; r++)ua(h.__webglFramebuffer[r], b, 36064, 34069 + r); q(b.texture, t) && p(34067, b.texture, b.width,
              b.height); c.bindTexture(34067, null);
          } else c.bindTexture(3553, l.__webglTexture), y(3553, b.texture, t), ua(h.__webglFramebuffer, b, 36064, 3553), q(b.texture, t) && p(3553, b.texture, b.width, b.height), c.bindTexture(3553, null); if (b.depthBuffer) {
            h = d.get(b); l = !0 === b.isWebGLRenderTargetCube; if (b.depthTexture) {
              if (l) throw Error("target.depthTexture not supported in Cube render targets"); if (b && b.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported"); a.bindFramebuffer(36160, h.__webglFramebuffer);
              if (!b.depthTexture || !b.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); d.get(b.depthTexture).__webglTexture && b.depthTexture.image.width === b.width && b.depthTexture.image.height === b.height || (b.depthTexture.image.width = b.width, b.depthTexture.image.height = b.height, b.depthTexture.needsUpdate = !0); n(b.depthTexture, 0); h = d.get(b.depthTexture).__webglTexture; if (1026 === b.depthTexture.format) a.framebufferTexture2D(36160, 36096, 3553, h, 0); else if (1027 ===
                b.depthTexture.format) a.framebufferTexture2D(36160, 33306, 3553, h, 0); else throw Error("Unknown depthTexture format");
            } else if (l) for (h.__webglDepthbuffer = [], l = 0; 6 > l; l++)a.bindFramebuffer(36160, h.__webglFramebuffer[l]), h.__webglDepthbuffer[l] = a.createRenderbuffer(), pa(h.__webglDepthbuffer[l], b); else a.bindFramebuffer(36160, h.__webglFramebuffer), h.__webglDepthbuffer = a.createRenderbuffer(), pa(h.__webglDepthbuffer, b); a.bindFramebuffer(36160, null);
          }
      }; this.updateRenderTargetMipmap = function (a) {
        var b = a.texture,
        f = m(a) || e.isWebGL2; if (q(b, f)) { f = a.isWebGLRenderTargetCube ? 34067 : 3553; var g = d.get(b).__webglTexture; c.bindTexture(f, g); p(f, b, a.width, a.height); c.bindTexture(f, null); }
      }; this.updateMultisampleRenderTarget = function (b) {
        if (b.isWebGLMultisampleRenderTarget) if (e.isWebGL2) {
          var c = d.get(b); a.bindFramebuffer(36008, c.__webglMultisampledFramebuffer); a.bindFramebuffer(36009, c.__webglFramebuffer); c = b.width; var f = b.height, g = 16384; b.depthBuffer && (g |= 256); b.stencilBuffer && (g |= 1024); a.blitFramebuffer(0, 0, c, f, 0, 0, c, f,
            g, 9728);
        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }; this.safeSetTexture2D = function (a, b) { a && a.isWebGLRenderTarget && (!1 === J && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), J = !0), a = a.texture); n(a, b); }; this.safeSetTextureCube = function (a, b) {
        a && a.isWebGLRenderTargetCube && (!1 === A && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
          A = !0), a = a.texture); a && a.isCubeTexture || Array.isArray(a.image) && 6 === a.image.length ? z(a, b) : x(a, b);
      };
    } function tf(a, b, c) {
      return {
        convert: function (a) {
          if (1E3 === a) return 10497; if (1001 === a) return 33071; if (1002 === a) return 33648; if (1003 === a) return 9728; if (1004 === a) return 9984; if (1005 === a) return 9986; if (1006 === a) return 9729; if (1007 === a) return 9985; if (1008 === a) return 9987; if (1009 === a) return 5121; if (1017 === a) return 32819; if (1018 === a) return 32820; if (1019 === a) return 33635; if (1010 === a) return 5120; if (1011 === a) return 5122;
          if (1012 === a) return 5123; if (1013 === a) return 5124; if (1014 === a) return 5125; if (1015 === a) return 5126; if (1016 === a) { if (c.isWebGL2) return 5131; var d = b.get("OES_texture_half_float"); if (null !== d) return d.HALF_FLOAT_OES; } if (1021 === a) return 6406; if (1022 === a) return 6407; if (1023 === a) return 6408; if (1024 === a) return 6409; if (1025 === a) return 6410; if (1026 === a) return 6402; if (1027 === a) return 34041; if (1028 === a) return 6403; if (100 === a) return 32774; if (101 === a) return 32778; if (102 === a) return 32779; if (200 === a) return 0; if (201 ===
            a) return 1; if (202 === a) return 768; if (203 === a) return 769; if (204 === a) return 770; if (205 === a) return 771; if (206 === a) return 772; if (207 === a) return 773; if (208 === a) return 774; if (209 === a) return 775; if (210 === a) return 776; if (33776 === a || 33777 === a || 33778 === a || 33779 === a) if (d = b.get("WEBGL_compressed_texture_s3tc"), null !== d) { if (33776 === a) return d.COMPRESSED_RGB_S3TC_DXT1_EXT; if (33777 === a) return d.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (33778 === a) return d.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (33779 === a) return d.COMPRESSED_RGBA_S3TC_DXT5_EXT; } if (35840 ===
              a || 35841 === a || 35842 === a || 35843 === a) if (d = b.get("WEBGL_compressed_texture_pvrtc"), null !== d) { if (35840 === a) return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (35841 === a) return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (35842 === a) return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (35843 === a) return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG; } if (36196 === a && (d = b.get("WEBGL_compressed_texture_etc1"), null !== d)) return d.COMPRESSED_RGB_ETC1_WEBGL; if (37808 === a || 37809 === a || 37810 === a || 37811 === a || 37812 === a || 37813 === a || 37814 === a || 37815 === a || 37816 ===
                a || 37817 === a || 37818 === a || 37819 === a || 37820 === a || 37821 === a) if (d = b.get("WEBGL_compressed_texture_astc"), null !== d) return a; if (103 === a || 104 === a) { if (c.isWebGL2) { if (103 === a) return 32775; if (104 === a) return 32776; } d = b.get("EXT_blend_minmax"); if (null !== d) { if (103 === a) return d.MIN_EXT; if (104 === a) return d.MAX_EXT; } } if (1020 === a) { if (c.isWebGL2) return 34042; d = b.get("WEBGL_depth_texture"); if (null !== d) return d.UNSIGNED_INT_24_8_WEBGL; } return 0;
        }
      };
    } function Xb() { D.call(this); this.type = "Group"; } function Xa() {
      D.call(this); this.type =
        "Camera"; this.matrixWorldInverse = new P; this.projectionMatrix = new P; this.projectionMatrixInverse = new P;
    } function ca(a, b, c, d) { Xa.call(this); this.type = "PerspectiveCamera"; this.fov = void 0 !== a ? a : 50; this.zoom = 1; this.near = void 0 !== c ? c : .1; this.far = void 0 !== d ? d : 2E3; this.focus = 10; this.aspect = void 0 !== b ? b : 1; this.view = null; this.filmGauge = 35; this.filmOffset = 0; this.updateProjectionMatrix(); } function Jc(a) { ca.call(this); this.cameras = a || []; } function uf(a, b, c) {
      vf.setFromMatrixPosition(b.matrixWorld); wf.setFromMatrixPosition(c.matrixWorld);
      var d = vf.distanceTo(wf), e = b.projectionMatrix.elements, f = c.projectionMatrix.elements, g = e[14] / (e[10] - 1); c = e[14] / (e[10] + 1); var h = (e[9] + 1) / e[5], l = (e[9] - 1) / e[5], m = (e[8] - 1) / e[0], q = (f[8] + 1) / f[0]; e = g * m; f = g * q; q = d / (-m + q); m = q * -m; b.matrixWorld.decompose(a.position, a.quaternion, a.scale); a.translateX(m); a.translateZ(q); a.matrixWorld.compose(a.position, a.quaternion, a.scale); a.matrixWorldInverse.getInverse(a.matrixWorld); b = g + q; g = c + q; a.projectionMatrix.makePerspective(e - m, f + (d - m), h * c / g * b, l * c / g * b, b, g);
    } function xf(a) {
      function b() {
        return null !==
          e && !0 === e.isPresenting;
      } function c() { if (b()) { var c = e.getEyeParameters("left"), f = c.renderWidth * q; c = c.renderHeight * q; y = a.getPixelRatio(); a.getSize(x); a.setDrawingBufferSize(2 * f, c, 1); G.start(); } else d.enabled && a.setDrawingBufferSize(x.width, x.height, y), G.stop(); } var d = this, e = null, f = null, g = null, h = [], l = new P, m = new P, q = 1, p = "stage"; "undefined" !== typeof window && "VRFrameData" in window && (f = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", c, !1)); var k = new P, t = new ma, r = new n, u = new ca; u.bounds =
        new W(0, 0, .5, 1); u.layers.enable(1); var w = new ca; w.bounds = new W(.5, 0, .5, 1); w.layers.enable(2); var z = new Jc([u, w]); z.layers.enable(1); z.layers.enable(2); var x = new C, y, F = []; this.enabled = !1; this.getController = function (a) { var b = h[a]; void 0 === b && (b = new Xb, b.matrixAutoUpdate = !1, b.visible = !1, h[a] = b); return b; }; this.getDevice = function () { return e; }; this.setDevice = function (a) { void 0 !== a && (e = a); G.setContext(a); }; this.setFramebufferScaleFactor = function (a) { q = a; }; this.setFrameOfReferenceType = function (a) { p = a; }; this.setPoseTarget =
          function (a) { void 0 !== a && (g = a); }; this.getCamera = function (a) {
            var c = "stage" === p ? 1.6 : 0; if (!1 === b()) return a.position.set(0, c, 0), a.rotation.set(0, 0, 0), a; e.depthNear = a.near; e.depthFar = a.far; e.getFrameData(f); if ("stage" === p) { var d = e.stageParameters; d ? l.fromArray(d.sittingToStandingTransform) : l.makeTranslation(0, c, 0); } c = f.pose; d = null !== g ? g : a; d.matrix.copy(l); d.matrix.decompose(d.position, d.quaternion, d.scale); null !== c.orientation && (t.fromArray(c.orientation), d.quaternion.multiply(t)); null !== c.position && (t.setFromRotationMatrix(l),
              r.fromArray(c.position), r.applyQuaternion(t), d.position.add(r)); d.updateMatrixWorld(); u.near = a.near; w.near = a.near; u.far = a.far; w.far = a.far; u.matrixWorldInverse.fromArray(f.leftViewMatrix); w.matrixWorldInverse.fromArray(f.rightViewMatrix); m.getInverse(l); "stage" === p && (u.matrixWorldInverse.multiply(m), w.matrixWorldInverse.multiply(m)); a = d.parent; null !== a && (k.getInverse(a.matrixWorld), u.matrixWorldInverse.multiply(k), w.matrixWorldInverse.multiply(k)); u.matrixWorld.getInverse(u.matrixWorldInverse); w.matrixWorld.getInverse(w.matrixWorldInverse);
            u.projectionMatrix.fromArray(f.leftProjectionMatrix); w.projectionMatrix.fromArray(f.rightProjectionMatrix); uf(z, u, w); a = e.getLayers(); a.length && (a = a[0], null !== a.leftBounds && 4 === a.leftBounds.length && u.bounds.fromArray(a.leftBounds), null !== a.rightBounds && 4 === a.rightBounds.length && w.bounds.fromArray(a.rightBounds)); a: for (a = 0; a < h.length; a++) {
              c = h[a]; b: {
                d = a; for (var q = navigator.getGamepads && navigator.getGamepads(), v = 0, n = 0, y = q.length; v < y; v++) {
                  var x = q[v]; if (x && ("Daydream Controller" === x.id || "Gear VR Controller" ===
                    x.id || "Oculus Go Controller" === x.id || "OpenVR Gamepad" === x.id || x.id.startsWith("Oculus Touch") || x.id.startsWith("Spatial Controller"))) { if (n === d) { d = x; break b; } n++; }
                } d = void 0;
              } if (void 0 !== d && void 0 !== d.pose) {
                if (null === d.pose) break a; q = d.pose; !1 === q.hasPosition && c.position.set(.2, -.6, -.05); null !== q.position && c.position.fromArray(q.position); null !== q.orientation && c.quaternion.fromArray(q.orientation); c.matrix.compose(c.position, c.quaternion, c.scale); c.matrix.premultiply(l); c.matrix.decompose(c.position,
                  c.quaternion, c.scale); c.matrixWorldNeedsUpdate = !0; c.visible = !0; q = "Daydream Controller" === d.id ? 0 : 1; F[a] !== d.buttons[q].pressed && (F[a] = d.buttons[q].pressed, !0 === F[a] ? c.dispatchEvent({ type: "selectstart" }) : (c.dispatchEvent({ type: "selectend" }), c.dispatchEvent({ type: "select" })));
              } else c.visible = !1;
            } return z;
          }; this.getStandingMatrix = function () { return l; }; this.isPresenting = b; var G = new de; this.setAnimationLoop = function (a) { G.setAnimationLoop(a); b() && G.start(); }; this.submitFrame = function () { b() && e.submitFrame(); };
      this.dispose = function () { "undefined" !== typeof window && window.removeEventListener("vrdisplaypresentchange", c); };
    } function gh(a) {
      function b() { return null !== h && null !== m; } function c(a) { var b = k[t.indexOf(a.inputSource)]; b && b.dispatchEvent({ type: a.type }); } function d() { a.setFramebuffer(null); a.setRenderTarget(a.getRenderTarget()); x.stop(); } function e(a, b) { null === b ? a.matrixWorld.copy(a.matrix) : a.matrixWorld.multiplyMatrices(b.matrixWorld, a.matrix); a.matrixWorldInverse.getInverse(a.matrixWorld); } var f = a.context,
        g = null, h = null, l = 1, m = null, q = "stage", p = null, k = [], t = [], r = new ca; r.layers.enable(1); r.viewport = new W; var u = new ca; u.layers.enable(2); u.viewport = new W; var n = new Jc([r, u]); n.layers.enable(1); n.layers.enable(2); this.enabled = !1; this.getController = function (a) { var b = k[a]; void 0 === b && (b = new Xb, b.matrixAutoUpdate = !1, b.visible = !1, k[a] = b); return b; }; this.getDevice = function () { return g; }; this.setDevice = function (a) { void 0 !== a && (g = a); a instanceof XRDevice && f.setCompatibleXRDevice(a); }; this.setFramebufferScaleFactor = function (a) {
          l =
          a;
        }; this.setFrameOfReferenceType = function (a) { q = a; }; this.setSession = function (b) {
          h = b; null !== h && (h.addEventListener("select", c), h.addEventListener("selectstart", c), h.addEventListener("selectend", c), h.addEventListener("end", d), h.baseLayer = new XRWebGLLayer(h, f, { framebufferScaleFactor: l }), h.requestFrameOfReference(q).then(function (b) { m = b; a.setFramebuffer(h.baseLayer.framebuffer); x.setContext(h); x.start(); }), t = h.getInputSources(), h.addEventListener("inputsourceschange", function () {
            t = h.getInputSources(); console.log(t);
            for (var a = 0; a < k.length; a++)k[a].userData.inputSource = t[a];
          }));
        }; this.getCamera = function (a) { if (b()) { var c = a.parent, d = n.cameras; e(n, c); for (var f = 0; f < d.length; f++)e(d[f], c); a.matrixWorld.copy(n.matrixWorld); a = a.children; f = 0; for (c = a.length; f < c; f++)a[f].updateMatrixWorld(!0); uf(n, r, u); return n; } return a; }; this.isPresenting = b; var z = null, x = new de; x.setAnimationLoop(function (a, b) {
          p = b.getDevicePose(m); if (null !== p) for (var c = h.baseLayer, d = b.views, e = 0; e < d.length; e++) {
            var f = d[e], g = c.getViewport(f), l = p.getViewMatrix(f),
            q = n.cameras[e]; q.matrix.fromArray(l).getInverse(q.matrix); q.projectionMatrix.fromArray(f.projectionMatrix); q.viewport.set(g.x, g.y, g.width, g.height); 0 === e && n.matrix.copy(q.matrix);
          } for (e = 0; e < k.length; e++) { c = k[e]; if (d = t[e]) if (d = b.getInputPose(d, m), null !== d) { "targetRay" in d ? c.matrix.elements = d.targetRay.transformMatrix : "pointerMatrix" in d && (c.matrix.elements = d.pointerMatrix); c.matrix.decompose(c.position, c.rotation, c.scale); c.visible = !0; continue; } c.visible = !1; } z && z(a);
        }); this.setAnimationLoop = function (a) {
          z =
          a;
        }; this.dispose = function () { }; this.getStandingMatrix = function () { console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."); return new P; }; this.submitFrame = function () { };
    } function je(a) {
      var b; function c() {
        ja = new hg(N); Aa = new fg(N, ja, a); Aa.isWebGL2 || (ja.get("WEBGL_depth_texture"), ja.get("OES_texture_float"), ja.get("OES_texture_half_float"), ja.get("OES_texture_half_float_linear"), ja.get("OES_standard_derivatives"), ja.get("OES_element_index_uint"), ja.get("ANGLE_instanced_arrays")); ja.get("OES_texture_float_linear");
        ea = new tf(N, ja, Aa); aa = new eh(N, ja, ea, Aa); aa.scissor(Y.copy(Z).multiplyScalar(X)); aa.viewport(U.copy(L).multiplyScalar(X)); mb = new kg(N); Ba = new Xg; ba = new fh(N, ja, aa, Ba, Aa, ea, mb); qa = new Zf(N); sa = new ig(N, qa, mb); ka = new ng(sa, mb); va = new mg(N); da = new Wg(A, ja, Aa, ba); ra = new $g; oa = new dh; ia = new dg(A, aa, ka, ua); xa = new eg(N, ja, mb, Aa); ya = new jg(N, ja, mb, Aa); mb.programs = da.programs; A.context = N; A.capabilities = Aa; A.extensions = ja; A.properties = Ba; A.renderLists = ra; A.state = aa; A.info = mb;
      } function d(a) {
        a.preventDefault();
        console.log("THREE.WebGLRenderer: Context Lost."); M = !0;
      } function e() { console.log("THREE.WebGLRenderer: Context Restored."); M = !1; c(); } function f(a) { a = a.target; a.removeEventListener("dispose", f); g(a); Ba.remove(a); } function g(a) { var b = Ba.get(a).program; a.program = void 0; void 0 !== b && da.releaseProgram(b); } function h(a, b) { a.render(function (a) { A.renderBufferImmediate(a, b); }); } function l(a, b, c, d) {
        if (!1 !== a.visible) {
          if (a.layers.test(b.layers)) if (a.isGroup) c = a.renderOrder; else if (a.isLight) B.pushLight(a), a.castShadow &&
            B.pushShadow(a); else if (a.isSprite) { if (!a.frustumCulled || ma.intersectsSprite(a)) { d && lb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Ic); var e = ka.update(a), f = a.material; f.visible && D.push(a, e, f, c, lb.z, null); } } else if (a.isImmediateRenderObject) d && lb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Ic), D.push(a, null, a.material, c, lb.z, null); else if (a.isMesh || a.isLine || a.isPoints) if (a.isSkinnedMesh && a.skeleton.update(), !a.frustumCulled || ma.intersectsObject(a)) if (d && lb.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Ic),
              e = ka.update(a), f = a.material, Array.isArray(f)) for (var g = e.groups, h = 0, m = g.length; h < m; h++) { var q = g[h], p = f[q.materialIndex]; p && p.visible && D.push(a, e, p, c, lb.z, q); } else f.visible && D.push(a, e, f, c, lb.z, null); a = a.children; h = 0; for (m = a.length; h < m; h++)l(a[h], b, c, d);
        }
      } function m(a, b, c, d) {
        for (var e = 0, f = a.length; e < f; e++) {
          var g = a[e], h = g.object, l = g.geometry, m = void 0 === d ? g.material : d; g = g.group; if (c.isArrayCamera) {
            R = c; for (var p = c.cameras, k = 0, v = p.length; k < v; k++) {
              var r = p[k]; if (h.layers.test(r.layers)) {
                if ("viewport" in r) aa.viewport(U.copy(r.viewport));
                else { var t = r.bounds; aa.viewport(U.set(t.x * T, t.y * Wa, t.z * T, t.w * Wa).multiplyScalar(X)); } B.setupLights(r); q(h, b, r, l, m, g);
              }
            }
          } else R = null, q(h, b, c, l, m, g);
        }
      } function q(a, c, d, e, f, g) {
        a.onBeforeRender(A, c, d, e, f, g); B = oa.get(c, R || d); a.modelViewMatrix.multiplyMatrices(d.matrixWorldInverse, a.matrixWorld); a.normalMatrix.getNormalMatrix(a.modelViewMatrix); if (a.isImmediateRenderObject) { aa.setMaterial(f); var l = k(d, c.fog, f, a); H = b = null; xb = !1; h(a, l); } else A.renderBufferDirect(d, c.fog, e, f, a, g); a.onAfterRender(A, c, d, e, f, g);
        B = oa.get(c, R || d);
      } function p(a, b, c) {
        var d = Ba.get(a), e = B.state.lights, h = d.lightsHash, l = e.state.hash; c = da.getParameters(a, e.state, B.state.shadowsArray, b, Ha.numPlanes, Ha.numIntersection, c); var m = da.getProgramCode(a, c), q = d.program, p = !0; if (void 0 === q) a.addEventListener("dispose", f); else if (q.code !== m) g(a); else {
          if (h.stateID !== l.stateID || h.directionalLength !== l.directionalLength || h.pointLength !== l.pointLength || h.spotLength !== l.spotLength || h.rectAreaLength !== l.rectAreaLength || h.hemiLength !== l.hemiLength ||
            h.shadowsLength !== l.shadowsLength) h.stateID = l.stateID, h.directionalLength = l.directionalLength, h.pointLength = l.pointLength, h.spotLength = l.spotLength, h.rectAreaLength = l.rectAreaLength, h.hemiLength = l.hemiLength, h.shadowsLength = l.shadowsLength; else if (void 0 !== c.shaderID) return; p = !1;
        } p && (c.shaderID ? (m = Va[c.shaderID], d.shader = { name: a.type, uniforms: Rb(m.uniforms), vertexShader: m.vertexShader, fragmentShader: m.fragmentShader }) : d.shader = { name: a.type, uniforms: a.uniforms, vertexShader: a.vertexShader, fragmentShader: a.fragmentShader },
          a.onBeforeCompile(d.shader, A), m = da.getProgramCode(a, c), q = da.acquireProgram(a, d.shader, c, m), d.program = q, a.program = q); c = q.getAttributes(); if (a.morphTargets) for (m = a.numSupportedMorphTargets = 0; m < A.maxMorphTargets; m++)0 <= c["morphTarget" + m] && a.numSupportedMorphTargets++; if (a.morphNormals) for (m = a.numSupportedMorphNormals = 0; m < A.maxMorphNormals; m++)0 <= c["morphNormal" + m] && a.numSupportedMorphNormals++; c = d.shader.uniforms; if (!a.isShaderMaterial && !a.isRawShaderMaterial || !0 === a.clipping) d.numClippingPlanes = Ha.numPlanes,
            d.numIntersection = Ha.numIntersection, c.clippingPlanes = Ha.uniform; d.fog = b; void 0 === h && (d.lightsHash = h = {}); h.stateID = l.stateID; h.directionalLength = l.directionalLength; h.pointLength = l.pointLength; h.spotLength = l.spotLength; h.rectAreaLength = l.rectAreaLength; h.hemiLength = l.hemiLength; h.shadowsLength = l.shadowsLength; a.lights && (c.ambientLightColor.value = e.state.ambient, c.lightProbe.value = e.state.probe, c.directionalLights.value = e.state.directional, c.spotLights.value = e.state.spot, c.rectAreaLights.value = e.state.rectArea,
              c.pointLights.value = e.state.point, c.hemisphereLights.value = e.state.hemi, c.directionalShadowMap.value = e.state.directionalShadowMap, c.directionalShadowMatrix.value = e.state.directionalShadowMatrix, c.spotShadowMap.value = e.state.spotShadowMap, c.spotShadowMatrix.value = e.state.spotShadowMatrix, c.pointShadowMap.value = e.state.pointShadowMap, c.pointShadowMatrix.value = e.state.pointShadowMatrix); a = d.program.getUniforms(); a = ib.seqWithValue(a.seq, c); d.uniformsList = a;
      } function k(a, b, c, d) {
        ba.resetTextureUnits(); var e =
          Ba.get(c), f = e.lightsHash, g = B.state.lights.state.hash; na && (fa || a !== bb) && Ha.setState(c.clippingPlanes, c.clipIntersection, c.clipShadows, a, e, a === bb && c.id === S); !1 === c.needsUpdate && (void 0 === e.program ? c.needsUpdate = !0 : c.fog && e.fog !== b ? c.needsUpdate = !0 : !c.lights || f.stateID === g.stateID && f.directionalLength === g.directionalLength && f.pointLength === g.pointLength && f.spotLength === g.spotLength && f.rectAreaLength === g.rectAreaLength && f.hemiLength === g.hemiLength && f.shadowsLength === g.shadowsLength ? void 0 === e.numClippingPlanes ||
            e.numClippingPlanes === Ha.numPlanes && e.numIntersection === Ha.numIntersection || (c.needsUpdate = !0) : c.needsUpdate = !0); c.needsUpdate && (p(c, b, d), c.needsUpdate = !1); var h = !1, l = !1, m = !1; f = e.program; g = f.getUniforms(); var q = e.shader.uniforms; aa.useProgram(f.program) && (m = l = h = !0); c.id !== S && (S = c.id, l = !0); if (h || bb !== a) {
              g.setValue(N, "projectionMatrix", a.projectionMatrix); Aa.logarithmicDepthBuffer && g.setValue(N, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2)); bb !== a && (bb = a, m = l = !0); if (c.isShaderMaterial || c.isMeshPhongMaterial ||
                c.isMeshStandardMaterial || c.envMap) h = g.map.cameraPosition, void 0 !== h && h.setValue(N, lb.setFromMatrixPosition(a.matrixWorld)); (c.isMeshPhongMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial || c.isMeshStandardMaterial || c.isShaderMaterial || c.skinning) && g.setValue(N, "viewMatrix", a.matrixWorldInverse);
            } if (c.skinning && (g.setOptional(N, d, "bindMatrix"), g.setOptional(N, d, "bindMatrixInverse"), a = d.skeleton)) if (h = a.bones, Aa.floatVertexTextures) {
              if (void 0 === a.boneTexture) {
                h = Math.sqrt(4 * h.length); h = O.ceilPowerOfTwo(h);
                h = Math.max(h, 4); var k = new Float32Array(h * h * 4); k.set(a.boneMatrices); var v = new sb(k, h, h, 1023, 1015); v.needsUpdate = !0; a.boneMatrices = k; a.boneTexture = v; a.boneTextureSize = h;
              } g.setValue(N, "boneTexture", a.boneTexture, ba); g.setValue(N, "boneTextureSize", a.boneTextureSize);
            } else g.setOptional(N, a, "boneMatrices"); l && (g.setValue(N, "toneMappingExposure", A.toneMappingExposure), g.setValue(N, "toneMappingWhitePoint", A.toneMappingWhitePoint), c.lights && (l = m, q.ambientLightColor.needsUpdate = l, q.lightProbe.needsUpdate = l,
              q.directionalLights.needsUpdate = l, q.pointLights.needsUpdate = l, q.spotLights.needsUpdate = l, q.rectAreaLights.needsUpdate = l, q.hemisphereLights.needsUpdate = l), b && c.fog && (q.fogColor.value.copy(b.color), b.isFog ? (q.fogNear.value = b.near, q.fogFar.value = b.far) : b.isFogExp2 && (q.fogDensity.value = b.density)), c.isMeshBasicMaterial ? t(q, c) : c.isMeshLambertMaterial ? (t(q, c), c.emissiveMap && (q.emissiveMap.value = c.emissiveMap)) : c.isMeshPhongMaterial ? (t(q, c), c.isMeshToonMaterial ? (r(q, c), c.gradientMap && (q.gradientMap.value =
                c.gradientMap)) : r(q, c)) : c.isMeshStandardMaterial ? (t(q, c), c.isMeshPhysicalMaterial ? (u(q, c), q.reflectivity.value = c.reflectivity, q.clearCoat.value = c.clearCoat, q.clearCoatRoughness.value = c.clearCoatRoughness) : u(q, c)) : c.isMeshMatcapMaterial ? (t(q, c), c.matcap && (q.matcap.value = c.matcap), c.bumpMap && (q.bumpMap.value = c.bumpMap, q.bumpScale.value = c.bumpScale, 1 === c.side && (q.bumpScale.value *= -1)), c.normalMap && (q.normalMap.value = c.normalMap, q.normalScale.value.copy(c.normalScale), 1 === c.side && q.normalScale.value.negate()),
                  c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value = c.displacementScale, q.displacementBias.value = c.displacementBias)) : c.isMeshDepthMaterial ? (t(q, c), c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value = c.displacementScale, q.displacementBias.value = c.displacementBias)) : c.isMeshDistanceMaterial ? (t(q, c), c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value = c.displacementScale, q.displacementBias.value =
                    c.displacementBias), q.referencePosition.value.copy(c.referencePosition), q.nearDistance.value = c.nearDistance, q.farDistance.value = c.farDistance) : c.isMeshNormalMaterial ? (t(q, c), c.bumpMap && (q.bumpMap.value = c.bumpMap, q.bumpScale.value = c.bumpScale, 1 === c.side && (q.bumpScale.value *= -1)), c.normalMap && (q.normalMap.value = c.normalMap, q.normalScale.value.copy(c.normalScale), 1 === c.side && q.normalScale.value.negate()), c.displacementMap && (q.displacementMap.value = c.displacementMap, q.displacementScale.value = c.displacementScale,
                      q.displacementBias.value = c.displacementBias)) : c.isLineBasicMaterial ? (q.diffuse.value.copy(c.color), q.opacity.value = c.opacity, c.isLineDashedMaterial && (q.dashSize.value = c.dashSize, q.totalSize.value = c.dashSize + c.gapSize, q.scale.value = c.scale)) : c.isPointsMaterial ? (q.diffuse.value.copy(c.color), q.opacity.value = c.opacity, q.size.value = c.size * X, q.scale.value = .5 * Wa, q.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(), q.uvTransform.value.copy(c.map.matrix))) : c.isSpriteMaterial ?
                        (q.diffuse.value.copy(c.color), q.opacity.value = c.opacity, q.rotation.value = c.rotation, q.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(), q.uvTransform.value.copy(c.map.matrix))) : c.isShadowMaterial && (q.color.value.copy(c.color), q.opacity.value = c.opacity), void 0 !== q.ltc_1 && (q.ltc_1.value = J.LTC_1), void 0 !== q.ltc_2 && (q.ltc_2.value = J.LTC_2), ib.upload(N, e.uniformsList, q, ba)); c.isShaderMaterial && !0 === c.uniformsNeedUpdate && (ib.upload(N, e.uniformsList, q, ba), c.uniformsNeedUpdate =
                          !1); c.isSpriteMaterial && g.setValue(N, "center", d.center); g.setValue(N, "modelViewMatrix", d.modelViewMatrix); g.setValue(N, "normalMatrix", d.normalMatrix); g.setValue(N, "modelMatrix", d.matrixWorld); return f;
      } function t(a, b) {
        a.opacity.value = b.opacity; b.color && a.diffuse.value.copy(b.color); b.emissive && a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity); b.map && (a.map.value = b.map); b.alphaMap && (a.alphaMap.value = b.alphaMap); b.specularMap && (a.specularMap.value = b.specularMap); b.envMap && (a.envMap.value =
          b.envMap, a.flipEnvMap.value = b.envMap.isCubeTexture ? -1 : 1, a.reflectivity.value = b.reflectivity, a.refractionRatio.value = b.refractionRatio, a.maxMipLevel.value = Ba.get(b.envMap).__maxMipLevel); b.lightMap && (a.lightMap.value = b.lightMap, a.lightMapIntensity.value = b.lightMapIntensity); b.aoMap && (a.aoMap.value = b.aoMap, a.aoMapIntensity.value = b.aoMapIntensity); if (b.map) var c = b.map; else b.specularMap ? c = b.specularMap : b.displacementMap ? c = b.displacementMap : b.normalMap ? c = b.normalMap : b.bumpMap ? c = b.bumpMap : b.roughnessMap ?
            c = b.roughnessMap : b.metalnessMap ? c = b.metalnessMap : b.alphaMap ? c = b.alphaMap : b.emissiveMap && (c = b.emissiveMap); void 0 !== c && (c.isWebGLRenderTarget && (c = c.texture), !0 === c.matrixAutoUpdate && c.updateMatrix(), a.uvTransform.value.copy(c.matrix));
      } function r(a, b) {
        a.specular.value.copy(b.specular); a.shininess.value = Math.max(b.shininess, 1E-4); b.emissiveMap && (a.emissiveMap.value = b.emissiveMap); b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale, 1 === b.side && (a.bumpScale.value *= -1)); b.normalMap && (a.normalMap.value =
          b.normalMap, a.normalScale.value.copy(b.normalScale), 1 === b.side && a.normalScale.value.negate()); b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias);
      } function u(a, b) {
        a.roughness.value = b.roughness; a.metalness.value = b.metalness; b.roughnessMap && (a.roughnessMap.value = b.roughnessMap); b.metalnessMap && (a.metalnessMap.value = b.metalnessMap); b.emissiveMap && (a.emissiveMap.value = b.emissiveMap); b.bumpMap && (a.bumpMap.value =
          b.bumpMap, a.bumpScale.value = b.bumpScale, 1 === b.side && (a.bumpScale.value *= -1)); b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale), 1 === b.side && a.normalScale.value.negate()); b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias); b.envMap && (a.envMapIntensity.value = b.envMapIntensity);
      } console.log("THREE.WebGLRenderer", "104"); a = a || {}; var w = void 0 !== a.canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml",
        "canvas"), z = void 0 !== a.context ? a.context : null, x = void 0 !== a.alpha ? a.alpha : !1, y = void 0 !== a.depth ? a.depth : !0, F = void 0 !== a.stencil ? a.stencil : !0, G = void 0 !== a.antialias ? a.antialias : !1, ua = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0, E = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1, I = void 0 !== a.powerPreference ? a.powerPreference : "default", D = null, B = null; this.domElement = w; this.context = null; this.debug = { checkShaderErrors: !1 }; this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor =
          this.autoClear = !0; this.clippingPlanes = []; this.localClippingEnabled = !1; this.gammaFactor = 2; this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1; this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1; this.maxMorphTargets = 8; this.maxMorphNormals = 4; var A = this, M = !1, K = null, Q = null, ha = null, S = -1; var H = b = null; var xb = !1; var bb = null, R = null, U = new W, Y = new W, V = null, T = w.width, Wa = w.height, X = 1, L = new W(0, 0, T, Wa), Z = new W(0, 0, T, Wa), ca = !1, ma = new yd, Ha = new gg, na = !1, fa = !1, Ic = new P, lb = new n; try {
            x =
            { alpha: x, depth: y, stencil: F, antialias: G, premultipliedAlpha: ua, preserveDrawingBuffer: E, powerPreference: I }; w.addEventListener("webglcontextlost", d, !1); w.addEventListener("webglcontextrestored", e, !1); var N = z || w.getContext("webgl", x) || w.getContext("experimental-webgl", x); if (null === N) { if (null !== w.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes."); throw Error("Error creating WebGL context."); } void 0 === N.getShaderPrecisionFormat && (N.getShaderPrecisionFormat = function () {
              return {
                rangeMin: 1,
                rangeMax: 1, precision: 1
              };
            });
          } catch (yf) { throw console.error("THREE.WebGLRenderer: " + yf.message), yf; } var ja, Aa, aa, mb, Ba, ba, qa, sa, ka, da, ra, oa, ia, va, xa, ya, ea; c(); var la = "undefined" !== typeof navigator && "xr" in navigator ? new gh(A) : new xf(A); this.vr = la; var za = new rf(A, ka, Aa.maxTextureSize); this.shadowMap = za; this.getContext = function () { return N; }; this.getContextAttributes = function () { return N.getContextAttributes(); }; this.forceContextLoss = function () { var a = ja.get("WEBGL_lose_context"); a && a.loseContext(); }; this.forceContextRestore =
            function () { var a = ja.get("WEBGL_lose_context"); a && a.restoreContext(); }; this.getPixelRatio = function () { return X; }; this.setPixelRatio = function (a) { void 0 !== a && (X = a, this.setSize(T, Wa, !1)); }; this.getSize = function (a) { void 0 === a && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), a = new C); return a.set(T, Wa); }; this.setSize = function (a, b, c) {
              la.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = a, Wa = b, w.width = a * X, w.height = b * X, !1 !==
                c && (w.style.width = a + "px", w.style.height = b + "px"), this.setViewport(0, 0, a, b));
            }; this.getDrawingBufferSize = function (a) { void 0 === a && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), a = new C); return a.set(T * X, Wa * X); }; this.setDrawingBufferSize = function (a, b, c) { T = a; Wa = b; X = c; w.width = a * c; w.height = b * c; this.setViewport(0, 0, a, b); }; this.getCurrentViewport = function (a) {
              void 0 === a && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), a =
                new W); return a.copy(U);
            }; this.getViewport = function (a) { return a.copy(L); }; this.setViewport = function (a, b, c, d) { a.isVector4 ? L.set(a.x, a.y, a.z, a.w) : L.set(a, b, c, d); aa.viewport(U.copy(L).multiplyScalar(X)); }; this.getScissor = function (a) { return a.copy(Z); }; this.setScissor = function (a, b, c, d) { a.isVector4 ? Z.set(a.x, a.y, a.z, a.w) : Z.set(a, b, c, d); aa.scissor(Y.copy(Z).multiplyScalar(X)); }; this.getScissorTest = function () { return ca; }; this.setScissorTest = function (a) { aa.setScissorTest(ca = a); }; this.getClearColor = function () { return ia.getClearColor(); };
      this.setClearColor = function () { ia.setClearColor.apply(ia, arguments); }; this.getClearAlpha = function () { return ia.getClearAlpha(); }; this.setClearAlpha = function () { ia.setClearAlpha.apply(ia, arguments); }; this.clear = function (a, b, c) { var d = 0; if (void 0 === a || a) d |= 16384; if (void 0 === b || b) d |= 256; if (void 0 === c || c) d |= 1024; N.clear(d); }; this.clearColor = function () { this.clear(!0, !1, !1); }; this.clearDepth = function () { this.clear(!1, !0, !1); }; this.clearStencil = function () { this.clear(!1, !1, !0); }; this.dispose = function () {
        w.removeEventListener("webglcontextlost",
          d, !1); w.removeEventListener("webglcontextrestored", e, !1); ra.dispose(); oa.dispose(); Ba.dispose(); ka.dispose(); la.dispose(); ta.stop();
      }; this.renderBufferImmediate = function (a, b) {
        aa.initAttributes(); var c = Ba.get(a); a.hasPositions && !c.position && (c.position = N.createBuffer()); a.hasNormals && !c.normal && (c.normal = N.createBuffer()); a.hasUvs && !c.uv && (c.uv = N.createBuffer()); a.hasColors && !c.color && (c.color = N.createBuffer()); b = b.getAttributes(); a.hasPositions && (N.bindBuffer(34962, c.position), N.bufferData(34962, a.positionArray,
          35048), aa.enableAttribute(b.position), N.vertexAttribPointer(b.position, 3, 5126, !1, 0, 0)); a.hasNormals && (N.bindBuffer(34962, c.normal), N.bufferData(34962, a.normalArray, 35048), aa.enableAttribute(b.normal), N.vertexAttribPointer(b.normal, 3, 5126, !1, 0, 0)); a.hasUvs && (N.bindBuffer(34962, c.uv), N.bufferData(34962, a.uvArray, 35048), aa.enableAttribute(b.uv), N.vertexAttribPointer(b.uv, 2, 5126, !1, 0, 0)); a.hasColors && (N.bindBuffer(34962, c.color), N.bufferData(34962, a.colorArray, 35048), aa.enableAttribute(b.color), N.vertexAttribPointer(b.color,
            3, 5126, !1, 0, 0)); aa.disableUnusedAttributes(); N.drawArrays(4, 0, a.count); a.count = 0;
      }; this.renderBufferDirect = function (a, c, d, e, f, g) {
        var h = f.isMesh && 0 > f.matrixWorld.determinant(); aa.setMaterial(e, h); var l = k(a, c, e, f), m = !1; if (b !== d.id || H !== l.id || xb !== (!0 === e.wireframe)) b = d.id, H = l.id, xb = !0 === e.wireframe, m = !0; f.morphTargetInfluences && (va.update(f, d, e, l), m = !0); h = d.index; var q = d.attributes.position; c = 1; !0 === e.wireframe && (h = sa.getWireframeAttribute(d), c = 2); a = xa; if (null !== h) { var p = qa.get(h); a = ya; a.setIndex(p); } if (m) {
          if (d &&
            d.isInstancedBufferGeometry && !Aa.isWebGL2 && null === ja.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); else {
              aa.initAttributes(); m = d.attributes; l = l.getAttributes(); var v = e.defaultAttributeValues; for (F in l) {
                var r = l[F]; if (0 <= r) {
                  var t = m[F]; if (void 0 !== t) {
                    var n = t.normalized, u = t.itemSize, w = qa.get(t); if (void 0 !== w) {
                      var x = w.buffer, y = w.type; w = w.bytesPerElement; if (t.isInterleavedBufferAttribute) {
                        var z =
                          t.data, G = z.stride; t = t.offset; z && z.isInstancedInterleavedBuffer ? (aa.enableAttributeAndDivisor(r, z.meshPerAttribute), void 0 === d.maxInstancedCount && (d.maxInstancedCount = z.meshPerAttribute * z.count)) : aa.enableAttribute(r); N.bindBuffer(34962, x); N.vertexAttribPointer(r, u, y, n, G * w, t * w);
                      } else t.isInstancedBufferAttribute ? (aa.enableAttributeAndDivisor(r, t.meshPerAttribute), void 0 === d.maxInstancedCount && (d.maxInstancedCount = t.meshPerAttribute * t.count)) : aa.enableAttribute(r), N.bindBuffer(34962, x), N.vertexAttribPointer(r,
                        u, y, n, 0, 0);
                    }
                  } else if (void 0 !== v && (n = v[F], void 0 !== n)) switch (n.length) { case 2: N.vertexAttrib2fv(r, n); break; case 3: N.vertexAttrib3fv(r, n); break; case 4: N.vertexAttrib4fv(r, n); break; default: N.vertexAttrib1fv(r, n); }
                }
              } aa.disableUnusedAttributes();
          } null !== h && N.bindBuffer(34963, p.buffer);
        } p = Infinity; null !== h ? p = h.count : void 0 !== q && (p = q.count); h = d.drawRange.start * c; q = null !== g ? g.start * c : 0; var F = Math.max(h, q); g = Math.max(0, Math.min(p, h + d.drawRange.count * c, q + (null !== g ? g.count * c : Infinity)) - 1 - F + 1); if (0 !== g) {
          if (f.isMesh) if (!0 ===
            e.wireframe) aa.setLineWidth(e.wireframeLinewidth * (null === Q ? X : 1)), a.setMode(1); else switch (f.drawMode) { case 0: a.setMode(4); break; case 1: a.setMode(5); break; case 2: a.setMode(6); } else f.isLine ? (e = e.linewidth, void 0 === e && (e = 1), aa.setLineWidth(e * (null === Q ? X : 1)), f.isLineSegments ? a.setMode(1) : f.isLineLoop ? a.setMode(2) : a.setMode(3)) : f.isPoints ? a.setMode(0) : f.isSprite && a.setMode(4); d && d.isInstancedBufferGeometry ? 0 < d.maxInstancedCount && a.renderInstances(d, F, g) : a.render(F, g);
        }
      }; this.compile = function (a, b) {
        B = oa.get(a,
          b); B.init(); a.traverse(function (a) { a.isLight && (B.pushLight(a), a.castShadow && B.pushShadow(a)); }); B.setupLights(b); a.traverse(function (b) { if (b.material) if (Array.isArray(b.material)) for (var c = 0; c < b.material.length; c++)p(b.material[c], a.fog, b); else p(b.material, a.fog, b); });
      }; var wa = null, ta = new de; ta.setAnimationLoop(function (a) { la.isPresenting() || wa && wa(a); }); "undefined" !== typeof window && ta.setContext(window); this.setAnimationLoop = function (a) { wa = a; la.setAnimationLoop(a); ta.start(); }; this.render = function (a,
        c, d, e) {
          if (void 0 !== d) { console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."); var f = d; } if (void 0 !== e) { console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."); var g = e; } c && c.isCamera ? M || (H = b = null, xb = !1, S = -1, bb = null, !0 === a.autoUpdate && a.updateMatrixWorld(), null === c.parent && c.updateMatrixWorld(), la.enabled && (c = la.getCamera(c)), B = oa.get(a, c), B.init(), a.onBeforeRender(A, a, c, f || Q), Ic.multiplyMatrices(c.projectionMatrix,
            c.matrixWorldInverse), ma.setFromMatrix(Ic), fa = this.localClippingEnabled, na = Ha.init(this.clippingPlanes, fa, c), D = ra.get(a, c), D.init(), l(a, c, 0, A.sortObjects), !0 === A.sortObjects && D.sort(), na && Ha.beginShadows(), za.render(B.state.shadowsArray, a, c), B.setupLights(c), na && Ha.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== f && this.setRenderTarget(f), ia.render(D, a, c, g), d = D.opaque, e = D.transparent, a.overrideMaterial ? (f = a.overrideMaterial, d.length && m(d, a, c, f), e.length && m(e, a, c, f)) : (d.length && m(d, a,
              c), e.length && m(e, a, c)), a.onAfterRender(A, a, c), null !== Q && (ba.updateRenderTargetMipmap(Q), ba.updateMultisampleRenderTarget(Q)), aa.buffers.depth.setTest(!0), aa.buffers.depth.setMask(!0), aa.buffers.color.setMask(!0), aa.setPolygonOffset(!1), la.enabled && la.submitFrame(), B = D = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      }; this.setFramebuffer = function (a) { K = a; }; this.getRenderTarget = function () { return Q; }; this.setRenderTarget = function (a, b, c) {
        (Q = a) && void 0 === Ba.get(a).__webglFramebuffer &&
        ba.setupRenderTarget(a); var d = K, e = !1; a ? (d = Ba.get(a).__webglFramebuffer, a.isWebGLRenderTargetCube ? (d = d[b || 0], e = !0) : d = a.isWebGLMultisampleRenderTarget ? Ba.get(a).__webglMultisampledFramebuffer : d, U.copy(a.viewport), Y.copy(a.scissor), V = a.scissorTest) : (U.copy(L).multiplyScalar(X), Y.copy(Z).multiplyScalar(X), V = ca); ha !== d && (N.bindFramebuffer(36160, d), ha = d); aa.viewport(U); aa.scissor(Y); aa.setScissorTest(V); e && (a = Ba.get(a.texture), N.framebufferTexture2D(36160, 36064, 34069 + (b || 0), a.__webglTexture, c || 0));
      }; this.readRenderTargetPixels =
        function (a, b, c, d, e, f) {
          if (a && a.isWebGLRenderTarget) {
            var g = Ba.get(a).__webglFramebuffer; if (g) {
              var h = !1; g !== ha && (N.bindFramebuffer(36160, g), h = !0); try {
                var l = a.texture, m = l.format, q = l.type; 1023 !== m && ea.convert(m) !== N.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === q || ea.convert(q) === N.getParameter(35738) || 1015 === q && (Aa.isWebGL2 || ja.get("OES_texture_float") || ja.get("WEBGL_color_buffer_float")) || 1016 === q &&
                  (Aa.isWebGL2 ? ja.get("EXT_color_buffer_float") : ja.get("EXT_color_buffer_half_float")) ? 36053 === N.checkFramebufferStatus(36160) ? 0 <= b && b <= a.width - d && 0 <= c && c <= a.height - e && N.readPixels(b, c, d, e, ea.convert(m), ea.convert(q), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
              } finally {
                h && N.bindFramebuffer(36160,
                  ha);
                }
            }
          } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        }; this.copyFramebufferToTexture = function (a, b, c) { var d = b.image.width, e = b.image.height, f = ea.convert(b.format); ba.setTexture2D(b, 0); N.copyTexImage2D(3553, c || 0, f, a.x, a.y, d, e, 0); }; this.copyTextureToTexture = function (a, b, c, d) {
          var e = b.image.width, f = b.image.height, g = ea.convert(c.format), h = ea.convert(c.type); ba.setTexture2D(c, 0); b.isDataTexture ? N.texSubImage2D(3553, d || 0, a.x, a.y, e, f, g, h, b.image.data) :
            N.texSubImage2D(3553, d || 0, a.x, a.y, g, h, b.image);
        };
    } function Ad(a, b) { this.name = ""; this.color = new A(a); this.density = void 0 !== b ? b : 2.5E-4; } function Bd(a, b, c) { this.name = ""; this.color = new A(a); this.near = void 0 !== b ? b : 1; this.far = void 0 !== c ? c : 1E3; } function Cd() { D.call(this); this.type = "Scene"; this.overrideMaterial = this.fog = this.background = null; this.autoUpdate = !0; } function Ab(a, b) { this.array = a; this.stride = b; this.count = void 0 !== a ? a.length / b : 0; this.dynamic = !1; this.updateRange = { offset: 0, count: -1 }; this.version = 0; } function Kc(a,
      b, c, d) { this.data = a; this.itemSize = b; this.offset = c; this.normalized = !0 === d; } function nb(a) { Q.call(this); this.type = "SpriteMaterial"; this.color = new A(16777215); this.map = null; this.rotation = 0; this.sizeAttenuation = !0; this.lights = !1; this.transparent = !0; this.setValues(a); } function Lc(a) {
        D.call(this); this.type = "Sprite"; if (void 0 === Yb) {
          Yb = new B; var b = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]); b = new Ab(b, 5); Yb.setIndex([0, 1, 2, 0, 2, 3]); Yb.addAttribute("position", new Kc(b, 3, 0, !1)); Yb.addAttribute("uv",
            new Kc(b, 2, 3, !1));
        } this.geometry = Yb; this.material = void 0 !== a ? a : new nb; this.center = new C(.5, .5);
      } function Mc() { D.call(this); this.type = "LOD"; Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }); } function Nc(a, b) { a && a.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); qa.call(this, a, b); this.type = "SkinnedMesh"; this.bindMode = "attached"; this.bindMatrix = new P; this.bindMatrixInverse = new P; } function Dd(a, b) {
        a = a || []; this.bones = a.slice(0);
        this.boneMatrices = new Float32Array(16 * this.bones.length); if (void 0 === b) this.calculateInverses(); else if (this.bones.length === b.length) this.boneInverses = b.slice(0); else for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], a = 0, b = this.bones.length; a < b; a++)this.boneInverses.push(new P);
      } function ke() { D.call(this); this.type = "Bone"; } function U(a) {
        Q.call(this); this.type = "LineBasicMaterial"; this.color = new A(16777215); this.linewidth = 1; this.linejoin = this.linecap = "round"; this.lights =
          !1; this.setValues(a);
      } function ka(a, b, c) { 1 === c && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."); D.call(this); this.type = "Line"; this.geometry = void 0 !== a ? a : new B; this.material = void 0 !== b ? b : new U({ color: 16777215 * Math.random() }); } function V(a, b) { ka.call(this, a, b); this.type = "LineSegments"; } function Ed(a, b) { ka.call(this, a, b); this.type = "LineLoop"; } function Ia(a) {
        Q.call(this); this.type = "PointsMaterial"; this.color = new A(16777215); this.map = null; this.size =
          1; this.sizeAttenuation = !0; this.lights = this.morphTargets = !1; this.setValues(a);
      } function Zb(a, b) { D.call(this); this.type = "Points"; this.geometry = void 0 !== a ? a : new B; this.material = void 0 !== b ? b : new Ia({ color: 16777215 * Math.random() }); } function le(a, b, c, d, e, f, g, h, l) { Y.call(this, a, b, c, d, e, f, g, h, l); this.format = void 0 !== g ? g : 1022; this.minFilter = void 0 !== f ? f : 1006; this.magFilter = void 0 !== e ? e : 1006; this.generateMipmaps = !1; } function $b(a, b, c, d, e, f, g, h, l, m, q, p) {
        Y.call(this, null, f, g, h, l, m, d, e, q, p); this.image = { width: b, height: c };
        this.mipmaps = a; this.generateMipmaps = this.flipY = !1;
      } function Oc(a, b, c, d, e, f, g, h, l) { Y.call(this, a, b, c, d, e, f, g, h, l); this.needsUpdate = !0; } function Pc(a, b, c, d, e, f, g, h, l, m) {
        m = void 0 !== m ? m : 1026; if (1026 !== m && 1027 !== m) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === c && 1026 === m && (c = 1012); void 0 === c && 1027 === m && (c = 1020); Y.call(this, null, d, e, f, g, h, m, c, l); this.image = { width: a, height: b }; this.magFilter = void 0 !== g ? g : 1003; this.minFilter = void 0 !== h ? h : 1003; this.generateMipmaps =
          this.flipY = !1;
      } function ac(a) {
        B.call(this); this.type = "WireframeGeometry"; var b = [], c, d, e, f = [0, 0], g = {}, h = ["a", "b", "c"]; if (a && a.isGeometry) { var l = a.faces; var m = 0; for (d = l.length; m < d; m++) { var q = l[m]; for (c = 0; 3 > c; c++) { var p = q[h[c]]; var k = q[h[(c + 1) % 3]]; f[0] = Math.min(p, k); f[1] = Math.max(p, k); p = f[0] + "," + f[1]; void 0 === g[p] && (g[p] = { index1: f[0], index2: f[1] }); } } for (p in g) m = g[p], h = a.vertices[m.index1], b.push(h.x, h.y, h.z), h = a.vertices[m.index2], b.push(h.x, h.y, h.z); } else if (a && a.isBufferGeometry) if (h = new n, null !== a.index) {
          l =
          a.attributes.position; q = a.index; var t = a.groups; 0 === t.length && (t = [{ start: 0, count: q.count, materialIndex: 0 }]); a = 0; for (e = t.length; a < e; ++a)for (m = t[a], c = m.start, d = m.count, m = c, d = c + d; m < d; m += 3)for (c = 0; 3 > c; c++)p = q.getX(m + c), k = q.getX(m + (c + 1) % 3), f[0] = Math.min(p, k), f[1] = Math.max(p, k), p = f[0] + "," + f[1], void 0 === g[p] && (g[p] = { index1: f[0], index2: f[1] }); for (p in g) m = g[p], h.fromBufferAttribute(l, m.index1), b.push(h.x, h.y, h.z), h.fromBufferAttribute(l, m.index2), b.push(h.x, h.y, h.z);
        } else for (l = a.attributes.position, m = 0, d =
          l.count / 3; m < d; m++)for (c = 0; 3 > c; c++)g = 3 * m + c, h.fromBufferAttribute(l, g), b.push(h.x, h.y, h.z), g = 3 * m + (c + 1) % 3, h.fromBufferAttribute(l, g), b.push(h.x, h.y, h.z); this.addAttribute("position", new E(b, 3));
      } function Qc(a, b, c) { K.call(this); this.type = "ParametricGeometry"; this.parameters = { func: a, slices: b, stacks: c }; this.fromBufferGeometry(new bc(a, b, c)); this.mergeVertices(); } function bc(a, b, c) {
        B.call(this); this.type = "ParametricBufferGeometry"; this.parameters = { func: a, slices: b, stacks: c }; var d = [], e = [], f = [], g = [], h = new n,
          l = new n, m = new n, q = new n, p = new n, k, t; 3 > a.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."); var r = b + 1; for (k = 0; k <= c; k++) { var u = k / c; for (t = 0; t <= b; t++) { var w = t / b; a(w, u, l); e.push(l.x, l.y, l.z); 0 <= w - 1E-5 ? (a(w - 1E-5, u, m), q.subVectors(l, m)) : (a(w + 1E-5, u, m), q.subVectors(m, l)); 0 <= u - 1E-5 ? (a(w, u - 1E-5, m), p.subVectors(l, m)) : (a(w, u + 1E-5, m), p.subVectors(m, l)); h.crossVectors(q, p).normalize(); f.push(h.x, h.y, h.z); g.push(w, u); } } for (k = 0; k < c; k++)for (t = 0; t < b; t++)a = k * r + t +
            1, h = (k + 1) * r + t + 1, l = (k + 1) * r + t, d.push(k * r + t, a, l), d.push(a, h, l); this.setIndex(d); this.addAttribute("position", new E(e, 3)); this.addAttribute("normal", new E(f, 3)); this.addAttribute("uv", new E(g, 2));
      } function Rc(a, b, c, d) { K.call(this); this.type = "PolyhedronGeometry"; this.parameters = { vertices: a, indices: b, radius: c, detail: d }; this.fromBufferGeometry(new la(a, b, c, d)); this.mergeVertices(); } function la(a, b, c, d) {
        function e(a) { h.push(a.x, a.y, a.z); } function f(b, c) { b *= 3; c.x = a[b + 0]; c.y = a[b + 1]; c.z = a[b + 2]; } function g(a, b, c,
          d) { 0 > d && 1 === a.x && (l[b] = a.x - 1); 0 === c.x && 0 === c.z && (l[b] = d / 2 / Math.PI + .5); } B.call(this); this.type = "PolyhedronBufferGeometry"; this.parameters = { vertices: a, indices: b, radius: c, detail: d }; c = c || 1; d = d || 0; var h = [], l = []; (function (a) {
            for (var c = new n, d = new n, g = new n, h = 0; h < b.length; h += 3) {
              f(b[h + 0], c); f(b[h + 1], d); f(b[h + 2], g); var l, m, k = c, z = d, x = g, y = Math.pow(2, a), F = []; for (m = 0; m <= y; m++) { F[m] = []; var G = k.clone().lerp(x, m / y), C = z.clone().lerp(x, m / y), B = y - m; for (l = 0; l <= B; l++)F[m][l] = 0 === l && m === y ? G : G.clone().lerp(C, l / B); } for (m = 0; m <
                y; m++)for (l = 0; l < 2 * (y - m) - 1; l++)k = Math.floor(l / 2), 0 === l % 2 ? (e(F[m][k + 1]), e(F[m + 1][k]), e(F[m][k])) : (e(F[m][k + 1]), e(F[m + 1][k + 1]), e(F[m + 1][k]));
            }
          })(d); (function (a) { for (var b = new n, c = 0; c < h.length; c += 3)b.x = h[c + 0], b.y = h[c + 1], b.z = h[c + 2], b.normalize().multiplyScalar(a), h[c + 0] = b.x, h[c + 1] = b.y, h[c + 2] = b.z; })(c); (function () {
            for (var a = new n, b = 0; b < h.length; b += 3)a.x = h[b + 0], a.y = h[b + 1], a.z = h[b + 2], l.push(Math.atan2(a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5)); a = new n; b = new n; for (var c =
              new n, d = new n, e = new C, f = new C, k = new C, w = 0, z = 0; w < h.length; w += 9, z += 6) { a.set(h[w + 0], h[w + 1], h[w + 2]); b.set(h[w + 3], h[w + 4], h[w + 5]); c.set(h[w + 6], h[w + 7], h[w + 8]); e.set(l[z + 0], l[z + 1]); f.set(l[z + 2], l[z + 3]); k.set(l[z + 4], l[z + 5]); d.copy(a).add(b).add(c).divideScalar(3); var x = Math.atan2(d.z, -d.x); g(e, z + 0, a, x); g(f, z + 2, b, x); g(k, z + 4, c, x); } for (a = 0; a < l.length; a += 6)b = l[a + 0], c = l[a + 2], d = l[a + 4], e = Math.min(b, c, d), .9 < Math.max(b, c, d) && .1 > e && (.2 > b && (l[a + 0] += 1), .2 > c && (l[a + 2] += 1), .2 > d && (l[a + 4] += 1));
          })(); this.addAttribute("position",
            new E(h, 3)); this.addAttribute("normal", new E(h.slice(), 3)); this.addAttribute("uv", new E(l, 2)); 0 === d ? this.computeVertexNormals() : this.normalizeNormals();
      } function Sc(a, b) { K.call(this); this.type = "TetrahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new cc(a, b)); this.mergeVertices(); } function cc(a, b) { la.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b); this.type = "TetrahedronBufferGeometry"; this.parameters = { radius: a, detail: b }; } function Tc(a, b) {
        K.call(this);
        this.type = "OctahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new Bb(a, b)); this.mergeVertices();
      } function Bb(a, b) { la.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b); this.type = "OctahedronBufferGeometry"; this.parameters = { radius: a, detail: b }; } function Uc(a, b) { K.call(this); this.type = "IcosahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new dc(a, b)); this.mergeVertices(); } function dc(a, b) {
        var c =
          (1 + Math.sqrt(5)) / 2; la.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b); this.type = "IcosahedronBufferGeometry"; this.parameters = { radius: a, detail: b };
      } function Vc(a, b) { K.call(this); this.type = "DodecahedronGeometry"; this.parameters = { radius: a, detail: b }; this.fromBufferGeometry(new ec(a, b)); this.mergeVertices(); } function ec(a, b) {
        var c =
          (1 + Math.sqrt(5)) / 2, d = 1 / c; la.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b); this.type = "DodecahedronBufferGeometry"; this.parameters =
            { radius: a, detail: b };
      } function Wc(a, b, c, d, e, f) { K.call(this); this.type = "TubeGeometry"; this.parameters = { path: a, tubularSegments: b, radius: c, radialSegments: d, closed: e }; void 0 !== f && console.warn("THREE.TubeGeometry: taper has been removed."); a = new Cb(a, b, c, d, e); this.tangents = a.tangents; this.normals = a.normals; this.binormals = a.binormals; this.fromBufferGeometry(a); this.mergeVertices(); } function Cb(a, b, c, d, e) {
        function f(e) {
          q = a.getPointAt(e / b, q); var f = g.normals[e]; e = g.binormals[e]; for (k = 0; k <= d; k++) {
            var m = k / d * Math.PI *
              2, p = Math.sin(m); m = -Math.cos(m); l.x = m * f.x + p * e.x; l.y = m * f.y + p * e.y; l.z = m * f.z + p * e.z; l.normalize(); r.push(l.x, l.y, l.z); h.x = q.x + c * l.x; h.y = q.y + c * l.y; h.z = q.z + c * l.z; t.push(h.x, h.y, h.z);
          }
        } B.call(this); this.type = "TubeBufferGeometry"; this.parameters = { path: a, tubularSegments: b, radius: c, radialSegments: d, closed: e }; b = b || 64; c = c || 1; d = d || 8; e = e || !1; var g = a.computeFrenetFrames(b, e); this.tangents = g.tangents; this.normals = g.normals; this.binormals = g.binormals; var h = new n, l = new n, m = new C, q = new n, p, k, t = [], r = [], u = [], w = []; for (p =
          0; p < b; p++)f(p); f(!1 === e ? b : 0); for (p = 0; p <= b; p++)for (k = 0; k <= d; k++)m.x = p / b, m.y = k / d, u.push(m.x, m.y); (function () { for (k = 1; k <= b; k++)for (p = 1; p <= d; p++) { var a = (d + 1) * k + (p - 1), c = (d + 1) * k + p, e = (d + 1) * (k - 1) + p; w.push((d + 1) * (k - 1) + (p - 1), a, e); w.push(a, c, e); } })(); this.setIndex(w); this.addAttribute("position", new E(t, 3)); this.addAttribute("normal", new E(r, 3)); this.addAttribute("uv", new E(u, 2));
      } function Xc(a, b, c, d, e, f, g) {
        K.call(this); this.type = "TorusKnotGeometry"; this.parameters = {
          radius: a, tube: b, tubularSegments: c, radialSegments: d,
          p: e, q: f
        }; void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."); this.fromBufferGeometry(new fc(a, b, c, d, e, f)); this.mergeVertices();
      } function fc(a, b, c, d, e, f) {
        function g(a, b, c, d, e) { var f = Math.sin(a); b = c / b * a; c = Math.cos(b); e.x = d * (2 + c) * .5 * Math.cos(a); e.y = d * (2 + c) * f * .5; e.z = d * Math.sin(b) * .5; } B.call(this); this.type = "TorusKnotBufferGeometry"; this.parameters = { radius: a, tube: b, tubularSegments: c, radialSegments: d, p: e, q: f }; a = a || 1; b = b || .4; c = Math.floor(c) ||
          64; d = Math.floor(d) || 8; e = e || 2; f = f || 3; var h = [], l = [], m = [], q = [], p, k = new n, t = new n, r = new n, u = new n, w = new n, z = new n, x = new n; for (p = 0; p <= c; ++p) {
            var y = p / c * e * Math.PI * 2; g(y, e, f, a, r); g(y + .01, e, f, a, u); z.subVectors(u, r); x.addVectors(u, r); w.crossVectors(z, x); x.crossVectors(w, z); w.normalize(); x.normalize(); for (y = 0; y <= d; ++y) {
              var F = y / d * Math.PI * 2, G = -b * Math.cos(F); F = b * Math.sin(F); k.x = r.x + (G * x.x + F * w.x); k.y = r.y + (G * x.y + F * w.y); k.z = r.z + (G * x.z + F * w.z); l.push(k.x, k.y, k.z); t.subVectors(k, r).normalize(); m.push(t.x, t.y, t.z); q.push(p /
                c); q.push(y / d);
            }
          } for (y = 1; y <= c; y++)for (p = 1; p <= d; p++)a = (d + 1) * y + (p - 1), b = (d + 1) * y + p, e = (d + 1) * (y - 1) + p, h.push((d + 1) * (y - 1) + (p - 1), a, e), h.push(a, b, e); this.setIndex(h); this.addAttribute("position", new E(l, 3)); this.addAttribute("normal", new E(m, 3)); this.addAttribute("uv", new E(q, 2));
      } function Yc(a, b, c, d, e) { K.call(this); this.type = "TorusGeometry"; this.parameters = { radius: a, tube: b, radialSegments: c, tubularSegments: d, arc: e }; this.fromBufferGeometry(new gc(a, b, c, d, e)); this.mergeVertices(); } function gc(a, b, c, d, e) {
        B.call(this);
        this.type = "TorusBufferGeometry"; this.parameters = { radius: a, tube: b, radialSegments: c, tubularSegments: d, arc: e }; a = a || 1; b = b || .4; c = Math.floor(c) || 8; d = Math.floor(d) || 6; e = e || 2 * Math.PI; var f = [], g = [], h = [], l = [], m = new n, q = new n, p = new n, k, t; for (k = 0; k <= c; k++)for (t = 0; t <= d; t++) {
          var r = t / d * e, u = k / c * Math.PI * 2; q.x = (a + b * Math.cos(u)) * Math.cos(r); q.y = (a + b * Math.cos(u)) * Math.sin(r); q.z = b * Math.sin(u); g.push(q.x, q.y, q.z); m.x = a * Math.cos(r); m.y = a * Math.sin(r); p.subVectors(q, m).normalize(); h.push(p.x, p.y, p.z); l.push(t / d); l.push(k /
            c);
        } for (k = 1; k <= c; k++)for (t = 1; t <= d; t++)a = (d + 1) * (k - 1) + t - 1, b = (d + 1) * (k - 1) + t, e = (d + 1) * k + t, f.push((d + 1) * k + t - 1, a, e), f.push(a, b, e); this.setIndex(f); this.addAttribute("position", new E(g, 3)); this.addAttribute("normal", new E(h, 3)); this.addAttribute("uv", new E(l, 2));
      } function zf(a, b, c, d, e) { for (var f, g = 0, h = b, l = c - d; h < c; h += d)g += (a[l] - a[h]) * (a[h + 1] + a[l + 1]), l = h; if (e === 0 < g) for (e = b; e < c; e += d)f = Af(e, a[e], a[e + 1], f); else for (e = c - d; e >= b; e -= d)f = Af(e, a[e], a[e + 1], f); f && Db(f, f.next) && (Zc(f), f = f.next); return f; } function $c(a, b) {
        if (!a) return a;
        b || (b = a); do { var c = !1; if (a.steiner || !Db(a, a.next) && 0 !== va(a.prev, a, a.next)) a = a.next; else { Zc(a); a = b = a.prev; if (a === a.next) break; c = !0; } } while (c || a !== b); return b;
      } function ad(a, b, c, d, e, f, g) {
        if (a) {
          if (!g && f) {
            var h = a, l = h; do null === l.z && (l.z = me(l.x, l.y, d, e, f)), l.prevZ = l.prev, l = l.nextZ = l.next; while (l !== h); l.prevZ.nextZ = null; l.prevZ = null; h = l; var m, q, p, k, t = 1; do {
              l = h; var r = h = null; for (q = 0; l;) {
                q++; var n = l; for (m = p = 0; m < t && (p++, n = n.nextZ, n); m++); for (k = t; 0 < p || 0 < k && n;)0 !== p && (0 === k || !n || l.z <= n.z) ? (m = l, l = l.nextZ, p--) : (m =
                  n, n = n.nextZ, k--), r ? r.nextZ = m : h = m, m.prevZ = r, r = m; l = n;
              } r.nextZ = null; t *= 2;
            } while (1 < q);
          } for (h = a; a.prev !== a.next;) {
            l = a.prev; n = a.next; if (f) a: {
              r = a; k = d; var w = e, z = f; q = r.prev; p = r; t = r.next; if (0 <= va(q, p, t)) r = !1; else {
                var x = q.x > p.x ? q.x > t.x ? q.x : t.x : p.x > t.x ? p.x : t.x, y = q.y > p.y ? q.y > t.y ? q.y : t.y : p.y > t.y ? p.y : t.y; m = me(q.x < p.x ? q.x < t.x ? q.x : t.x : p.x < t.x ? p.x : t.x, q.y < p.y ? q.y < t.y ? q.y : t.y : p.y < t.y ? p.y : t.y, k, w, z); k = me(x, y, k, w, z); for (w = r.nextZ; w && w.z <= k;) {
                  if (w !== r.prev && w !== r.next && Fd(q.x, q.y, p.x, p.y, t.x, t.y, w.x, w.y) && 0 <= va(w.prev, w,
                    w.next)) { r = !1; break a; } w = w.nextZ;
                } for (w = r.prevZ; w && w.z >= m;) { if (w !== r.prev && w !== r.next && Fd(q.x, q.y, p.x, p.y, t.x, t.y, w.x, w.y) && 0 <= va(w.prev, w, w.next)) { r = !1; break a; } w = w.prevZ; } r = !0;
              }
            } else a: if (r = a, q = r.prev, p = r, t = r.next, 0 <= va(q, p, t)) r = !1; else { for (m = r.next.next; m !== r.prev;) { if (Fd(q.x, q.y, p.x, p.y, t.x, t.y, m.x, m.y) && 0 <= va(m.prev, m, m.next)) { r = !1; break a; } m = m.next; } r = !0; } if (r) b.push(l.i / c), b.push(a.i / c), b.push(n.i / c), Zc(a), h = a = n.next; else if (a = n, a === h) {
              if (!g) ad($c(a), b, c, d, e, f, 1); else if (1 === g) {
                g = b; h = c; l = a; do n = l.prev,
                  r = l.next.next, !Db(n, r) && Bf(n, l, l.next, r) && bd(n, r) && bd(r, n) && (g.push(n.i / h), g.push(l.i / h), g.push(r.i / h), Zc(l), Zc(l.next), l = a = r), l = l.next; while (l !== a); a = l; ad(a, b, c, d, e, f, 2);
              } else if (2 === g) a: {
                g = a; do {
                  for (h = g.next.next; h !== g.prev;) {
                    if (l = g.i !== h.i) {
                      l = g; n = h; if (r = l.next.i !== n.i && l.prev.i !== n.i) { b: { r = l; do { if (r.i !== l.i && r.next.i !== l.i && r.i !== n.i && r.next.i !== n.i && Bf(r, r.next, l, n)) { r = !0; break b; } r = r.next; } while (r !== l); r = !1; } r = !r; } if (r = r && bd(l, n) && bd(n, l)) {
                        r = l; q = !1; p = (l.x + n.x) / 2; n = (l.y + n.y) / 2; do r.y > n !== r.next.y > n &&
                          r.next.y !== r.y && p < (r.next.x - r.x) * (n - r.y) / (r.next.y - r.y) + r.x && (q = !q), r = r.next; while (r !== l); r = q;
                      } l = r;
                    } if (l) { a = Cf(g, h); g = $c(g, g.next); a = $c(a, a.next); ad(g, b, c, d, e, f); ad(a, b, c, d, e, f); break a; } h = h.next;
                  } g = g.next;
                } while (g !== a);
              } break;
            }
          }
        }
      } function hh(a, b) { return a.x - b.x; } function ih(a, b) {
        var c = b, d = a.x, e = a.y, f = -Infinity; do {
          if (e <= c.y && e >= c.next.y && c.next.y !== c.y) { var g = c.x + (e - c.y) * (c.next.x - c.x) / (c.next.y - c.y); if (g <= d && g > f) { f = g; if (g === d) { if (e === c.y) return c; if (e === c.next.y) return c.next; } var h = c.x < c.next.x ? c : c.next; } } c =
            c.next;
        } while (c !== b); if (!h) return null; if (d === f) return h.prev; b = h; g = h.x; var l = h.y, m = Infinity; for (c = h.next; c !== b;) { if (d >= c.x && c.x >= g && d !== c.x && Fd(e < l ? d : f, e, g, l, e < l ? f : d, e, c.x, c.y)) { var q = Math.abs(e - c.y) / (d - c.x); (q < m || q === m && c.x > h.x) && bd(c, a) && (h = c, m = q); } c = c.next; } return h;
      } function me(a, b, c, d, e) { a = 32767 * (a - c) * e; b = 32767 * (b - d) * e; a = (a | a << 8) & 16711935; a = (a | a << 4) & 252645135; a = (a | a << 2) & 858993459; b = (b | b << 8) & 16711935; b = (b | b << 4) & 252645135; b = (b | b << 2) & 858993459; return (a | a << 1) & 1431655765 | ((b | b << 1) & 1431655765) << 1; } function jh(a) {
        var b =
          a, c = a; do b.x < c.x && (c = b), b = b.next; while (b !== a); return c;
      } function Fd(a, b, c, d, e, f, g, h) { return 0 <= (e - g) * (b - h) - (a - g) * (f - h) && 0 <= (a - g) * (d - h) - (c - g) * (b - h) && 0 <= (c - g) * (f - h) - (e - g) * (d - h); } function va(a, b, c) { return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y); } function Db(a, b) { return a.x === b.x && a.y === b.y; } function Bf(a, b, c, d) { return Db(a, b) && Db(c, d) || Db(a, d) && Db(c, b) ? !0 : 0 < va(a, b, c) !== 0 < va(a, b, d) && 0 < va(c, d, a) !== 0 < va(c, d, b); } function bd(a, b) {
        return 0 > va(a.prev, a, a.next) ? 0 <= va(a, b, a.next) && 0 <= va(a, a.prev, b) : 0 > va(a, b, a.prev) ||
          0 > va(a, a.next, b);
      } function Cf(a, b) { var c = new ne(a.i, a.x, a.y), d = new ne(b.i, b.x, b.y), e = a.next, f = b.prev; a.next = b; b.prev = a; c.next = e; e.prev = c; d.next = c; c.prev = d; f.next = d; d.prev = f; return d; } function Af(a, b, c, d) { a = new ne(a, b, c); d ? (a.next = d.next, a.prev = d, d.next.prev = a, d.next = a) : (a.prev = a, a.next = a); return a; } function Zc(a) { a.next.prev = a.prev; a.prev.next = a.next; a.prevZ && (a.prevZ.nextZ = a.nextZ); a.nextZ && (a.nextZ.prevZ = a.prevZ); } function ne(a, b, c) {
        this.i = a; this.x = b; this.y = c; this.nextZ = this.prevZ = this.z = this.next =
          this.prev = null; this.steiner = !1;
      } function Df(a) { var b = a.length; 2 < b && a[b - 1].equals(a[0]) && a.pop(); } function Ef(a, b) { for (var c = 0; c < b.length; c++)a.push(b[c].x), a.push(b[c].y); } function Eb(a, b) { K.call(this); this.type = "ExtrudeGeometry"; this.parameters = { shapes: a, options: b }; this.fromBufferGeometry(new Ya(a, b)); this.mergeVertices(); } function Ya(a, b) {
        function c(a) {
          function c(a, b, c) { b || console.error("THREE.ExtrudeGeometry: vec does not exist"); return b.clone().multiplyScalar(c).add(a); } function g(a, b, c) {
            var d = a.x -
              b.x; var e = a.y - b.y; var f = c.x - a.x; var g = c.y - a.y, h = d * d + e * e; if (Math.abs(d * g - e * f) > Number.EPSILON) { var l = Math.sqrt(h), m = Math.sqrt(f * f + g * g); h = b.x - e / l; b = b.y + d / l; g = ((c.x - g / m - h) * g - (c.y + f / m - b) * f) / (d * g - e * f); f = h + d * g - a.x; d = b + e * g - a.y; e = f * f + d * d; if (2 >= e) return new C(f, d); e = Math.sqrt(e / 2); } else a = !1, d > Number.EPSILON ? f > Number.EPSILON && (a = !0) : d < -Number.EPSILON ? f < -Number.EPSILON && (a = !0) : Math.sign(e) === Math.sign(g) && (a = !0), a ? (f = -e, e = Math.sqrt(h)) : (f = d, d = e, e = Math.sqrt(h / 2)); return new C(f / e, d / e);
          } function h(a, b) {
            for (L = a.length; 0 <=
              --L;) { var c = L; var f = L - 1; 0 > f && (f = a.length - 1); var g, h = x + 2 * I; for (g = 0; g < h; g++) { var l = Y * g, m = Y * (g + 1), q = b + f + l, p = b + f + m; m = b + c + m; r(b + c + l); r(q); r(m); r(q); r(p); r(m); l = e.length / 3; l = E.generateSideWallUV(d, e, l - 6, l - 3, l - 2, l - 1); u(l[0]); u(l[1]); u(l[3]); u(l[1]); u(l[2]); u(l[3]); } }
          } function l(a, b, c) { w.push(a); w.push(b); w.push(c); } function k(a, b, c) { r(a); r(b); r(c); a = e.length / 3; a = E.generateTopUV(d, e, a - 3, a - 2, a - 1); u(a[0]); u(a[1]); u(a[2]); } function r(a) { e.push(w[3 * a]); e.push(w[3 * a + 1]); e.push(w[3 * a + 2]); } function u(a) {
            f.push(a.x);
            f.push(a.y);
          } var w = [], z = void 0 !== b.curveSegments ? b.curveSegments : 12, x = void 0 !== b.steps ? b.steps : 1, y = void 0 !== b.depth ? b.depth : 100, F = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0, G = void 0 !== b.bevelThickness ? b.bevelThickness : 6, B = void 0 !== b.bevelSize ? b.bevelSize : G - 2, A = void 0 !== b.bevelOffset ? b.bevelOffset : 0, I = void 0 !== b.bevelSegments ? b.bevelSegments : 3, D = b.extrudePath, E = void 0 !== b.UVGenerator ? b.UVGenerator : kh; void 0 !== b.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), y =
            b.amount); var J = !1; if (D) { var M = D.getSpacedPoints(x); J = !0; F = !1; var P = D.computeFrenetFrames(x, !1); var Q = new n; var ha = new n; var S = new n; } F || (A = B = G = I = 0); var K; z = a.extractPoints(z); a = z.shape; var O = z.holes; if (!db.isClockWise(a)) { a = a.reverse(); var H = 0; for (K = O.length; H < K; H++) { var R = O[H]; db.isClockWise(R) && (O[H] = R.reverse()); } } var X = db.triangulateShape(a, O), U = a; H = 0; for (K = O.length; H < K; H++)R = O[H], a = a.concat(R); var T, Y = a.length, V, ba = X.length; z = []; var L = 0; var Z = U.length; var W = Z - 1; for (T = L + 1; L < Z; L++, W++, T++)W === Z &&
              (W = 0), T === Z && (T = 0), z[L] = g(U[L], U[W], U[T]); D = []; var ea = z.concat(); H = 0; for (K = O.length; H < K; H++) { R = O[H]; var ca = []; L = 0; Z = R.length; W = Z - 1; for (T = L + 1; L < Z; L++, W++, T++)W === Z && (W = 0), T === Z && (T = 0), ca[L] = g(R[L], R[W], R[T]); D.push(ca); ea = ea.concat(ca); } for (W = 0; W < I; W++) { Z = W / I; var da = G * Math.cos(Z * Math.PI / 2); T = B * Math.sin(Z * Math.PI / 2) + A; L = 0; for (Z = U.length; L < Z; L++) { var fa = c(U[L], z[L], T); l(fa.x, fa.y, -da); } H = 0; for (K = O.length; H < K; H++)for (R = O[H], ca = D[H], L = 0, Z = R.length; L < Z; L++)fa = c(R[L], ca[L], T), l(fa.x, fa.y, -da); } T = B + A; for (L =
                0; L < Y; L++)fa = F ? c(a[L], ea[L], T) : a[L], J ? (ha.copy(P.normals[0]).multiplyScalar(fa.x), Q.copy(P.binormals[0]).multiplyScalar(fa.y), S.copy(M[0]).add(ha).add(Q), l(S.x, S.y, S.z)) : l(fa.x, fa.y, 0); for (Z = 1; Z <= x; Z++)for (L = 0; L < Y; L++)fa = F ? c(a[L], ea[L], T) : a[L], J ? (ha.copy(P.normals[Z]).multiplyScalar(fa.x), Q.copy(P.binormals[Z]).multiplyScalar(fa.y), S.copy(M[Z]).add(ha).add(Q), l(S.x, S.y, S.z)) : l(fa.x, fa.y, y / x * Z); for (W = I - 1; 0 <= W; W--) {
                  Z = W / I; da = G * Math.cos(Z * Math.PI / 2); T = B * Math.sin(Z * Math.PI / 2) + A; L = 0; for (Z = U.length; L < Z; L++)fa =
                    c(U[L], z[L], T), l(fa.x, fa.y, y + da); H = 0; for (K = O.length; H < K; H++)for (R = O[H], ca = D[H], L = 0, Z = R.length; L < Z; L++)fa = c(R[L], ca[L], T), J ? l(fa.x, fa.y + M[x - 1].y, M[x - 1].x + da) : l(fa.x, fa.y, y + da);
                } (function () { var a = e.length / 3; if (F) { var b = 0 * Y; for (L = 0; L < ba; L++)V = X[L], k(V[2] + b, V[1] + b, V[0] + b); b = Y * (x + 2 * I); for (L = 0; L < ba; L++)V = X[L], k(V[0] + b, V[1] + b, V[2] + b); } else { for (L = 0; L < ba; L++)V = X[L], k(V[2], V[1], V[0]); for (L = 0; L < ba; L++)V = X[L], k(V[0] + Y * x, V[1] + Y * x, V[2] + Y * x); } d.addGroup(a, e.length / 3 - a, 0); })(); (function () {
                  var a = e.length / 3, b = 0; h(U, b);
                  b += U.length; H = 0; for (K = O.length; H < K; H++)R = O[H], h(R, b), b += R.length; d.addGroup(a, e.length / 3 - a, 1);
                })();
        } B.call(this); this.type = "ExtrudeBufferGeometry"; this.parameters = { shapes: a, options: b }; a = Array.isArray(a) ? a : [a]; for (var d = this, e = [], f = [], g = 0, h = a.length; g < h; g++)c(a[g]); this.addAttribute("position", new E(e, 3)); this.addAttribute("uv", new E(f, 2)); this.computeVertexNormals();
      } function Ff(a, b, c) {
        c.shapes = []; if (Array.isArray(a)) for (var d = 0, e = a.length; d < e; d++)c.shapes.push(a[d].uuid); else c.shapes.push(a.uuid);
        void 0 !== b.extrudePath && (c.options.extrudePath = b.extrudePath.toJSON()); return c;
      } function cd(a, b) { K.call(this); this.type = "TextGeometry"; this.parameters = { text: a, parameters: b }; this.fromBufferGeometry(new hc(a, b)); this.mergeVertices(); } function hc(a, b) {
        b = b || {}; var c = b.font; if (!c || !c.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new K; a = c.generateShapes(a, b.size); b.depth = void 0 !== b.height ? b.height : 50; void 0 === b.bevelThickness && (b.bevelThickness = 10);
        void 0 === b.bevelSize && (b.bevelSize = 8); void 0 === b.bevelEnabled && (b.bevelEnabled = !1); Ya.call(this, a, b); this.type = "TextBufferGeometry";
      } function dd(a, b, c, d, e, f, g) { K.call(this); this.type = "SphereGeometry"; this.parameters = { radius: a, widthSegments: b, heightSegments: c, phiStart: d, phiLength: e, thetaStart: f, thetaLength: g }; this.fromBufferGeometry(new ob(a, b, c, d, e, f, g)); this.mergeVertices(); } function ob(a, b, c, d, e, f, g) {
        B.call(this); this.type = "SphereBufferGeometry"; this.parameters = {
          radius: a, widthSegments: b, heightSegments: c,
          phiStart: d, phiLength: e, thetaStart: f, thetaLength: g
        }; a = a || 1; b = Math.max(3, Math.floor(b) || 8); c = Math.max(2, Math.floor(c) || 6); d = void 0 !== d ? d : 0; e = void 0 !== e ? e : 2 * Math.PI; f = void 0 !== f ? f : 0; g = void 0 !== g ? g : Math.PI; var h = f + g, l, m, q = 0, p = [], k = new n, t = new n, r = [], u = [], w = [], z = []; for (m = 0; m <= c; m++) {
          var x = [], y = m / c, F = 0 == m ? .5 / b : m == c ? -.5 / b : 0; for (l = 0; l <= b; l++) {
            var G = l / b; k.x = -a * Math.cos(d + G * e) * Math.sin(f + y * g); k.y = a * Math.cos(f + y * g); k.z = a * Math.sin(d + G * e) * Math.sin(f + y * g); u.push(k.x, k.y, k.z); t.copy(k).normalize(); w.push(t.x, t.y,
              t.z); z.push(G + F, 1 - y); x.push(q++);
          } p.push(x);
        } for (m = 0; m < c; m++)for (l = 0; l < b; l++)a = p[m][l + 1], d = p[m][l], e = p[m + 1][l], g = p[m + 1][l + 1], (0 !== m || 0 < f) && r.push(a, d, g), (m !== c - 1 || h < Math.PI) && r.push(d, e, g); this.setIndex(r); this.addAttribute("position", new E(u, 3)); this.addAttribute("normal", new E(w, 3)); this.addAttribute("uv", new E(z, 2));
      } function ed(a, b, c, d, e, f) {
        K.call(this); this.type = "RingGeometry"; this.parameters = { innerRadius: a, outerRadius: b, thetaSegments: c, phiSegments: d, thetaStart: e, thetaLength: f }; this.fromBufferGeometry(new ic(a,
          b, c, d, e, f)); this.mergeVertices();
      } function ic(a, b, c, d, e, f) {
        B.call(this); this.type = "RingBufferGeometry"; this.parameters = { innerRadius: a, outerRadius: b, thetaSegments: c, phiSegments: d, thetaStart: e, thetaLength: f }; a = a || .5; b = b || 1; e = void 0 !== e ? e : 0; f = void 0 !== f ? f : 2 * Math.PI; c = void 0 !== c ? Math.max(3, c) : 8; d = void 0 !== d ? Math.max(1, d) : 1; var g = [], h = [], l = [], m = [], q = a, p = (b - a) / d, k = new n, t = new C, r, u; for (r = 0; r <= d; r++) {
          for (u = 0; u <= c; u++)a = e + u / c * f, k.x = q * Math.cos(a), k.y = q * Math.sin(a), h.push(k.x, k.y, k.z), l.push(0, 0, 1), t.x = (k.x /
            b + 1) / 2, t.y = (k.y / b + 1) / 2, m.push(t.x, t.y); q += p;
        } for (r = 0; r < d; r++)for (b = r * (c + 1), u = 0; u < c; u++)a = u + b, e = a + c + 1, f = a + c + 2, q = a + 1, g.push(a, e, q), g.push(e, f, q); this.setIndex(g); this.addAttribute("position", new E(h, 3)); this.addAttribute("normal", new E(l, 3)); this.addAttribute("uv", new E(m, 2));
      } function fd(a, b, c, d) { K.call(this); this.type = "LatheGeometry"; this.parameters = { points: a, segments: b, phiStart: c, phiLength: d }; this.fromBufferGeometry(new jc(a, b, c, d)); this.mergeVertices(); } function jc(a, b, c, d) {
        B.call(this); this.type =
          "LatheBufferGeometry"; this.parameters = { points: a, segments: b, phiStart: c, phiLength: d }; b = Math.floor(b) || 12; c = c || 0; d = d || 2 * Math.PI; d = O.clamp(d, 0, 2 * Math.PI); var e = [], f = [], g = [], h = 1 / b, l = new n, m = new C, q; for (q = 0; q <= b; q++) { var k = c + q * h * d; var v = Math.sin(k), t = Math.cos(k); for (k = 0; k <= a.length - 1; k++)l.x = a[k].x * v, l.y = a[k].y, l.z = a[k].x * t, f.push(l.x, l.y, l.z), m.x = q / b, m.y = k / (a.length - 1), g.push(m.x, m.y); } for (q = 0; q < b; q++)for (k = 0; k < a.length - 1; k++)c = k + q * a.length, h = c + a.length, l = c + a.length + 1, m = c + 1, e.push(c, h, m), e.push(h, l, m);
        this.setIndex(e); this.addAttribute("position", new E(f, 3)); this.addAttribute("uv", new E(g, 2)); this.computeVertexNormals(); if (d === 2 * Math.PI) for (d = this.attributes.normal.array, e = new n, f = new n, g = new n, c = b * a.length * 3, k = q = 0; q < a.length; q++, k += 3)e.x = d[k + 0], e.y = d[k + 1], e.z = d[k + 2], f.x = d[c + k + 0], f.y = d[c + k + 1], f.z = d[c + k + 2], g.addVectors(e, f).normalize(), d[k + 0] = d[c + k + 0] = g.x, d[k + 1] = d[c + k + 1] = g.y, d[k + 2] = d[c + k + 2] = g.z;
      } function Fb(a, b) {
        K.call(this); this.type = "ShapeGeometry"; "object" === typeof b && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."),
          b = b.curveSegments); this.parameters = { shapes: a, curveSegments: b }; this.fromBufferGeometry(new Gb(a, b)); this.mergeVertices();
      } function Gb(a, b) {
        function c(a) {
          var c, h = e.length / 3; a = a.extractPoints(b); var m = a.shape, q = a.holes; !1 === db.isClockWise(m) && (m = m.reverse()); a = 0; for (c = q.length; a < c; a++) { var k = q[a]; !0 === db.isClockWise(k) && (q[a] = k.reverse()); } var n = db.triangulateShape(m, q); a = 0; for (c = q.length; a < c; a++)k = q[a], m = m.concat(k); a = 0; for (c = m.length; a < c; a++)k = m[a], e.push(k.x, k.y, 0), f.push(0, 0, 1), g.push(k.x, k.y); a = 0;
          for (c = n.length; a < c; a++)m = n[a], d.push(m[0] + h, m[1] + h, m[2] + h), l += 3;
        } B.call(this); this.type = "ShapeBufferGeometry"; this.parameters = { shapes: a, curveSegments: b }; b = b || 12; var d = [], e = [], f = [], g = [], h = 0, l = 0; if (!1 === Array.isArray(a)) c(a); else for (var m = 0; m < a.length; m++)c(a[m]), this.addGroup(h, l, m), h += l, l = 0; this.setIndex(d); this.addAttribute("position", new E(e, 3)); this.addAttribute("normal", new E(f, 3)); this.addAttribute("uv", new E(g, 2));
      } function Gf(a, b) {
        b.shapes = []; if (Array.isArray(a)) for (var c = 0, d = a.length; c < d; c++)b.shapes.push(a[c].uuid);
        else b.shapes.push(a.uuid); return b;
      } function kc(a, b) {
        B.call(this); this.type = "EdgesGeometry"; this.parameters = { thresholdAngle: b }; var c = []; b = Math.cos(O.DEG2RAD * (void 0 !== b ? b : 1)); var d = [0, 0], e = {}, f = ["a", "b", "c"]; if (a.isBufferGeometry) { var g = new K; g.fromBufferGeometry(a); } else g = a.clone(); g.mergeVertices(); g.computeFaceNormals(); a = g.vertices; g = g.faces; for (var h = 0, l = g.length; h < l; h++)for (var m = g[h], q = 0; 3 > q; q++) {
          var k = m[f[q]]; var n = m[f[(q + 1) % 3]]; d[0] = Math.min(k, n); d[1] = Math.max(k, n); k = d[0] + "," + d[1]; void 0 ===
            e[k] ? e[k] = { index1: d[0], index2: d[1], face1: h, face2: void 0 } : e[k].face2 = h;
        } for (k in e) if (d = e[k], void 0 === d.face2 || g[d.face1].normal.dot(g[d.face2].normal) <= b) f = a[d.index1], c.push(f.x, f.y, f.z), f = a[d.index2], c.push(f.x, f.y, f.z); this.addAttribute("position", new E(c, 3));
      } function Hb(a, b, c, d, e, f, g, h) {
        K.call(this); this.type = "CylinderGeometry"; this.parameters = { radiusTop: a, radiusBottom: b, height: c, radialSegments: d, heightSegments: e, openEnded: f, thetaStart: g, thetaLength: h }; this.fromBufferGeometry(new eb(a, b, c, d, e,
          f, g, h)); this.mergeVertices();
      } function eb(a, b, c, d, e, f, g, h) {
        function l(c) { var e, f = new C, l = new n, p = 0, u = !0 === c ? a : b, x = !0 === c ? 1 : -1; var B = r; for (e = 1; e <= d; e++)k.push(0, w * x, 0), v.push(0, x, 0), t.push(.5, .5), r++; var D = r; for (e = 0; e <= d; e++) { var A = e / d * h + g, E = Math.cos(A); A = Math.sin(A); l.x = u * A; l.y = w * x; l.z = u * E; k.push(l.x, l.y, l.z); v.push(0, x, 0); f.x = .5 * E + .5; f.y = .5 * A * x + .5; t.push(f.x, f.y); r++; } for (e = 0; e < d; e++)f = B + e, l = D + e, !0 === c ? q.push(l, l + 1, f) : q.push(l + 1, l, f), p += 3; m.addGroup(z, p, !0 === c ? 1 : 2); z += p; } B.call(this); this.type = "CylinderBufferGeometry";
        this.parameters = { radiusTop: a, radiusBottom: b, height: c, radialSegments: d, heightSegments: e, openEnded: f, thetaStart: g, thetaLength: h }; var m = this; a = void 0 !== a ? a : 1; b = void 0 !== b ? b : 1; c = c || 1; d = Math.floor(d) || 8; e = Math.floor(e) || 1; f = void 0 !== f ? f : !1; g = void 0 !== g ? g : 0; h = void 0 !== h ? h : 2 * Math.PI; var q = [], k = [], v = [], t = [], r = 0, u = [], w = c / 2, z = 0; (function () {
          var f, l, p = new n, G = new n, C = 0, B = (b - a) / c; for (l = 0; l <= e; l++) {
            var I = [], A = l / e, D = A * (b - a) + a; for (f = 0; f <= d; f++) {
              var E = f / d, H = E * h + g, J = Math.sin(H); H = Math.cos(H); G.x = D * J; G.y = -A * c + w; G.z =
                D * H; k.push(G.x, G.y, G.z); p.set(J, B, H).normalize(); v.push(p.x, p.y, p.z); t.push(E, 1 - A); I.push(r++);
            } u.push(I);
          } for (f = 0; f < d; f++)for (l = 0; l < e; l++)p = u[l + 1][f], G = u[l + 1][f + 1], B = u[l][f + 1], q.push(u[l][f], p, B), q.push(p, G, B), C += 6; m.addGroup(z, C, 0); z += C;
        })(); !1 === f && (0 < a && l(!0), 0 < b && l(!1)); this.setIndex(q); this.addAttribute("position", new E(k, 3)); this.addAttribute("normal", new E(v, 3)); this.addAttribute("uv", new E(t, 2));
      } function gd(a, b, c, d, e, f, g) {
        Hb.call(this, 0, a, b, c, d, e, f, g); this.type = "ConeGeometry"; this.parameters =
          { radius: a, height: b, radialSegments: c, heightSegments: d, openEnded: e, thetaStart: f, thetaLength: g };
      } function hd(a, b, c, d, e, f, g) { eb.call(this, 0, a, b, c, d, e, f, g); this.type = "ConeBufferGeometry"; this.parameters = { radius: a, height: b, radialSegments: c, heightSegments: d, openEnded: e, thetaStart: f, thetaLength: g }; } function id(a, b, c, d) { K.call(this); this.type = "CircleGeometry"; this.parameters = { radius: a, segments: b, thetaStart: c, thetaLength: d }; this.fromBufferGeometry(new lc(a, b, c, d)); this.mergeVertices(); } function lc(a, b, c, d) {
        B.call(this);
        this.type = "CircleBufferGeometry"; this.parameters = { radius: a, segments: b, thetaStart: c, thetaLength: d }; a = a || 1; b = void 0 !== b ? Math.max(3, b) : 8; c = void 0 !== c ? c : 0; d = void 0 !== d ? d : 2 * Math.PI; var e = [], f = [], g = [], h = [], l, m = new n, q = new C; f.push(0, 0, 0); g.push(0, 0, 1); h.push(.5, .5); var k = 0; for (l = 3; k <= b; k++, l += 3) { var v = c + k / b * d; m.x = a * Math.cos(v); m.y = a * Math.sin(v); f.push(m.x, m.y, m.z); g.push(0, 0, 1); q.x = (f[l] / a + 1) / 2; q.y = (f[l + 1] / a + 1) / 2; h.push(q.x, q.y); } for (l = 1; l <= b; l++)e.push(l, l + 1, 0); this.setIndex(e); this.addAttribute("position",
          new E(f, 3)); this.addAttribute("normal", new E(g, 3)); this.addAttribute("uv", new E(h, 2));
      } function Ib(a) { Q.call(this); this.type = "ShadowMaterial"; this.color = new A(0); this.transparent = !0; this.setValues(a); } function mc(a) { ea.call(this, a); this.type = "RawShaderMaterial"; } function Za(a) {
        Q.call(this); this.defines = { STANDARD: "" }; this.type = "MeshStandardMaterial"; this.color = new A(16777215); this.metalness = this.roughness = .5; this.lightMap = this.map = null; this.lightMapIntensity = 1; this.aoMap = null; this.aoMapIntensity = 1; this.emissive =
          new A(0); this.emissiveIntensity = 1; this.bumpMap = this.emissiveMap = null; this.bumpScale = 1; this.normalMap = null; this.normalMapType = 0; this.normalScale = new C(1, 1); this.displacementMap = null; this.displacementScale = 1; this.displacementBias = 0; this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null; this.envMapIntensity = 1; this.refractionRatio = .98; this.wireframe = !1; this.wireframeLinewidth = 1; this.wireframeLinejoin = this.wireframeLinecap = "round"; this.morphNormals = this.morphTargets = this.skinning = !1; this.setValues(a);
      }
  function Jb(a) { Za.call(this); this.defines = { PHYSICAL: "" }; this.type = "MeshPhysicalMaterial"; this.reflectivity = .5; this.clearCoatRoughness = this.clearCoat = 0; this.setValues(a); } function Ja(a) {
    Q.call(this); this.type = "MeshPhongMaterial"; this.color = new A(16777215); this.specular = new A(1118481); this.shininess = 30; this.lightMap = this.map = null; this.lightMapIntensity = 1; this.aoMap = null; this.aoMapIntensity = 1; this.emissive = new A(0); this.emissiveIntensity = 1; this.bumpMap = this.emissiveMap = null; this.bumpScale = 1; this.normalMap =
      null; this.normalMapType = 0; this.normalScale = new C(1, 1); this.displacementMap = null; this.displacementScale = 1; this.displacementBias = 0; this.envMap = this.alphaMap = this.specularMap = null; this.combine = 0; this.reflectivity = 1; this.refractionRatio = .98; this.wireframe = !1; this.wireframeLinewidth = 1; this.wireframeLinejoin = this.wireframeLinecap = "round"; this.morphNormals = this.morphTargets = this.skinning = !1; this.setValues(a);
  } function Kb(a) {
    Ja.call(this); this.defines = { TOON: "" }; this.type = "MeshToonMaterial"; this.gradientMap =
      null; this.setValues(a);
  } function Lb(a) { Q.call(this); this.type = "MeshNormalMaterial"; this.bumpMap = null; this.bumpScale = 1; this.normalMap = null; this.normalMapType = 0; this.normalScale = new C(1, 1); this.displacementMap = null; this.displacementScale = 1; this.displacementBias = 0; this.wireframe = !1; this.wireframeLinewidth = 1; this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1; this.setValues(a); } function Mb(a) {
    Q.call(this); this.type = "MeshLambertMaterial"; this.color = new A(16777215); this.lightMap = this.map =
      null; this.lightMapIntensity = 1; this.aoMap = null; this.aoMapIntensity = 1; this.emissive = new A(0); this.emissiveIntensity = 1; this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null; this.combine = 0; this.reflectivity = 1; this.refractionRatio = .98; this.wireframe = !1; this.wireframeLinewidth = 1; this.wireframeLinejoin = this.wireframeLinecap = "round"; this.morphNormals = this.morphTargets = this.skinning = !1; this.setValues(a);
  } function Nb(a) {
    Q.call(this); this.defines = { MATCAP: "" }; this.type = "MeshMatcapMaterial"; this.color =
      new A(16777215); this.bumpMap = this.map = this.matcap = null; this.bumpScale = 1; this.normalMap = null; this.normalMapType = 0; this.normalScale = new C(1, 1); this.displacementMap = null; this.displacementScale = 1; this.displacementBias = 0; this.alphaMap = null; this.lights = this.morphNormals = this.morphTargets = this.skinning = !1; this.setValues(a);
  } function Ob(a) { U.call(this); this.type = "LineDashedMaterial"; this.scale = 1; this.dashSize = 3; this.gapSize = 1; this.setValues(a); } function Da(a, b, c, d) {
    this.parameterPositions = a; this._cachedIndex =
      0; this.resultBuffer = void 0 !== d ? d : new b.constructor(c); this.sampleValues = b; this.valueSize = c;
  } function Gd(a, b, c, d) { Da.call(this, a, b, c, d); this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0; } function jd(a, b, c, d) { Da.call(this, a, b, c, d); } function Hd(a, b, c, d) { Da.call(this, a, b, c, d); } function da(a, b, c, d) {
    if (void 0 === a) throw Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === b || 0 === b.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + a); this.name = a; this.times =
      ba.convertArray(b, this.TimeBufferType); this.values = ba.convertArray(c, this.ValueBufferType); this.setInterpolation(d || this.DefaultInterpolation);
  } function Id(a, b, c) { da.call(this, a, b, c); } function Jd(a, b, c, d) { da.call(this, a, b, c, d); } function nc(a, b, c, d) { da.call(this, a, b, c, d); } function Kd(a, b, c, d) { Da.call(this, a, b, c, d); } function kd(a, b, c, d) { da.call(this, a, b, c, d); } function Ld(a, b, c, d) { da.call(this, a, b, c, d); } function oc(a, b, c, d) { da.call(this, a, b, c, d); } function Fa(a, b, c) {
    this.name = a; this.tracks = c; this.duration = void 0 !==
      b ? b : -1; this.uuid = O.generateUUID(); 0 > this.duration && this.resetDuration();
  } function lh(a) { switch (a.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return nc; case "vector": case "vector2": case "vector3": case "vector4": return oc; case "color": return Jd; case "quaternion": return kd; case "bool": case "boolean": return Id; case "string": return Ld; }throw Error("THREE.KeyframeTrack: Unsupported typeName: " + a); } function mh(a) {
    if (void 0 === a.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
    var b = lh(a.type); if (void 0 === a.times) { var c = [], d = []; ba.flattenJSON(a.keys, c, d, "value"); a.times = c; a.values = d; } return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values, a.interpolation);
  } function oe(a, b, c) {
    var d = this, e = !1, f = 0, g = 0, h = void 0; this.onStart = void 0; this.onLoad = a; this.onProgress = b; this.onError = c; this.itemStart = function (a) { g++; if (!1 === e && void 0 !== d.onStart) d.onStart(a, f, g); e = !0; }; this.itemEnd = function (a) { f++; if (void 0 !== d.onProgress) d.onProgress(a, f, g); if (f === g && (e = !1, void 0 !== d.onLoad)) d.onLoad(); };
    this.itemError = function (a) { if (void 0 !== d.onError) d.onError(a); }; this.resolveURL = function (a) { return h ? h(a) : a; }; this.setURLModifier = function (a) { h = a; return this; };
  } function Ka(a) { this.manager = void 0 !== a ? a : za; } function Hf(a) { this.manager = void 0 !== a ? a : za; } function If(a) { this.manager = void 0 !== a ? a : za; this._parser = null; } function pe(a) { this.manager = void 0 !== a ? a : za; this._parser = null; } function ld(a) { this.manager = void 0 !== a ? a : za; } function qe(a) { this.manager = void 0 !== a ? a : za; } function Md(a) { this.manager = void 0 !== a ? a : za; }
  function M() { this.type = "Curve"; this.arcLengthDivisions = 200; } function Ea(a, b, c, d, e, f, g, h) { M.call(this); this.type = "EllipseCurve"; this.aX = a || 0; this.aY = b || 0; this.xRadius = c || 1; this.yRadius = d || 1; this.aStartAngle = e || 0; this.aEndAngle = f || 2 * Math.PI; this.aClockwise = g || !1; this.aRotation = h || 0; } function pc(a, b, c, d, e, f) { Ea.call(this, a, b, c, c, d, e, f); this.type = "ArcCurve"; } function re() {
    var a = 0, b = 0, c = 0, d = 0; return {
      initCatmullRom: function (e, f, g, h, l) { e = l * (g - e); h = l * (h - f); a = f; b = e; c = -3 * f + 3 * g - 2 * e - h; d = 2 * f - 2 * g + e + h; }, initNonuniformCatmullRom: function (e,
        f, g, h, l, m, q) { e = ((f - e) / l - (g - e) / (l + m) + (g - f) / m) * m; h = ((g - f) / m - (h - f) / (m + q) + (h - g) / q) * m; a = f; b = e; c = -3 * f + 3 * g - 2 * e - h; d = 2 * f - 2 * g + e + h; }, calc: function (e) { var f = e * e; return a + b * e + c * f + d * f * e; }
    };
  } function oa(a, b, c, d) { M.call(this); this.type = "CatmullRomCurve3"; this.points = a || []; this.closed = b || !1; this.curveType = c || "centripetal"; this.tension = d || .5; } function Jf(a, b, c, d, e) { b = .5 * (d - b); e = .5 * (e - c); var f = a * a; return (2 * c - 2 * d + b + e) * a * f + (-3 * c + 3 * d - 2 * b - e) * f + b * a + c; } function md(a, b, c, d) { var e = 1 - a; return e * e * b + 2 * (1 - a) * a * c + a * a * d; } function nd(a,
    b, c, d, e) { var f = 1 - a, g = 1 - a; return f * f * f * b + 3 * g * g * a * c + 3 * (1 - a) * a * a * d + a * a * a * e; } function La(a, b, c, d) { M.call(this); this.type = "CubicBezierCurve"; this.v0 = a || new C; this.v1 = b || new C; this.v2 = c || new C; this.v3 = d || new C; } function $a(a, b, c, d) { M.call(this); this.type = "CubicBezierCurve3"; this.v0 = a || new n; this.v1 = b || new n; this.v2 = c || new n; this.v3 = d || new n; } function wa(a, b) { M.call(this); this.type = "LineCurve"; this.v1 = a || new C; this.v2 = b || new C; } function Ma(a, b) {
      M.call(this); this.type = "LineCurve3"; this.v1 = a || new n; this.v2 = b ||
        new n;
    } function Na(a, b, c) { M.call(this); this.type = "QuadraticBezierCurve"; this.v0 = a || new C; this.v1 = b || new C; this.v2 = c || new C; } function ab(a, b, c) { M.call(this); this.type = "QuadraticBezierCurve3"; this.v0 = a || new n; this.v1 = b || new n; this.v2 = c || new n; } function Oa(a) { M.call(this); this.type = "SplineCurve"; this.points = a || []; } function fb() { M.call(this); this.type = "CurvePath"; this.curves = []; this.autoClose = !1; } function Pa(a) { fb.call(this); this.type = "Path"; this.currentPoint = new C; a && this.setFromPoints(a); } function pb(a) {
      Pa.call(this,
        a); this.uuid = O.generateUUID(); this.type = "Shape"; this.holes = [];
    } function T(a, b) { D.call(this); this.type = "Light"; this.color = new A(a); this.intensity = void 0 !== b ? b : 1; this.receiveShadow = void 0; } function Nd(a, b, c) { T.call(this, a, c); this.type = "HemisphereLight"; this.castShadow = void 0; this.position.copy(D.DefaultUp); this.updateMatrix(); this.groundColor = new A(b); } function Pb(a) { this.camera = a; this.bias = 0; this.radius = 1; this.mapSize = new C(512, 512); this.map = null; this.matrix = new P; } function Od() {
      Pb.call(this, new ca(50,
        1, .5, 500));
    } function Pd(a, b, c, d, e, f) { T.call(this, a, b); this.type = "SpotLight"; this.position.copy(D.DefaultUp); this.updateMatrix(); this.target = new D; Object.defineProperty(this, "power", { get: function () { return this.intensity * Math.PI; }, set: function (a) { this.intensity = a / Math.PI; } }); this.distance = void 0 !== c ? c : 0; this.angle = void 0 !== d ? d : Math.PI / 3; this.penumbra = void 0 !== e ? e : 0; this.decay = void 0 !== f ? f : 1; this.shadow = new Od; } function Qd(a, b, c, d) {
      T.call(this, a, b); this.type = "PointLight"; Object.defineProperty(this, "power",
        { get: function () { return 4 * this.intensity * Math.PI; }, set: function (a) { this.intensity = a / (4 * Math.PI); } }); this.distance = void 0 !== c ? c : 0; this.decay = void 0 !== d ? d : 1; this.shadow = new Pb(new ca(90, 1, .5, 500));
    } function od(a, b, c, d, e, f) { Xa.call(this); this.type = "OrthographicCamera"; this.zoom = 1; this.view = null; this.left = void 0 !== a ? a : -1; this.right = void 0 !== b ? b : 1; this.top = void 0 !== c ? c : 1; this.bottom = void 0 !== d ? d : -1; this.near = void 0 !== e ? e : .1; this.far = void 0 !== f ? f : 2E3; this.updateProjectionMatrix(); } function Rd() {
      Pb.call(this,
        new od(-5, 5, 5, -5, .5, 500));
    } function Sd(a, b) { T.call(this, a, b); this.type = "DirectionalLight"; this.position.copy(D.DefaultUp); this.updateMatrix(); this.target = new D; this.shadow = new Rd; } function Td(a, b) { T.call(this, a, b); this.type = "AmbientLight"; this.castShadow = void 0; } function Ud(a, b, c, d) { T.call(this, a, b); this.type = "RectAreaLight"; this.width = void 0 !== c ? c : 10; this.height = void 0 !== d ? d : 10; } function Vd(a) { this.manager = void 0 !== a ? a : za; this.textures = {}; } function se(a) { this.manager = void 0 !== a ? a : za; } function te(a) {
      this.manager =
      void 0 !== a ? a : za; this.resourcePath = "";
    } function ue(a) { "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."); "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."); this.manager = void 0 !== a ? a : za; this.options = void 0; } function ve() { this.type = "ShapePath"; this.color = new A; this.subPaths = []; this.currentPath = null; } function we(a) { this.type = "Font"; this.data = a; } function Kf(a) { this.manager = void 0 !== a ? a : za; } function pd() { }
  function xe(a) { this.manager = void 0 !== a ? a : za; } function Wd() { this.coefficients = []; for (var a = 0; 9 > a; a++)this.coefficients.push(new n); } function Qa(a, b) { T.call(this, void 0, b); this.sh = void 0 !== a ? a : new Wd; } function ye(a, b, c) { Qa.call(this, void 0, c); a = (new A).set(a); c = (new A).set(b); b = new n(a.r, a.g, a.b); a = new n(c.r, c.g, c.b); c = Math.sqrt(Math.PI); var d = c * Math.sqrt(.75); this.sh.coefficients[0].copy(b).add(a).multiplyScalar(c); this.sh.coefficients[1].copy(b).sub(a).multiplyScalar(d); } function ze(a, b) {
    Qa.call(this,
      void 0, b); a = (new A).set(a); this.sh.coefficients[0].set(a.r, a.g, a.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  } function Lf() { this.type = "StereoCamera"; this.aspect = 1; this.eyeSep = .064; this.cameraL = new ca; this.cameraL.layers.enable(1); this.cameraL.matrixAutoUpdate = !1; this.cameraR = new ca; this.cameraR.layers.enable(2); this.cameraR.matrixAutoUpdate = !1; } function qd(a, b, c, d) {
    D.call(this); this.type = "CubeCamera"; var e = new ca(90, 1, a, b); e.up.set(0, -1, 0); e.lookAt(new n(1, 0, 0)); this.add(e); var f = new ca(90, 1, a, b); f.up.set(0,
      -1, 0); f.lookAt(new n(-1, 0, 0)); this.add(f); var g = new ca(90, 1, a, b); g.up.set(0, 0, 1); g.lookAt(new n(0, 1, 0)); this.add(g); var h = new ca(90, 1, a, b); h.up.set(0, 0, -1); h.lookAt(new n(0, -1, 0)); this.add(h); var l = new ca(90, 1, a, b); l.up.set(0, -1, 0); l.lookAt(new n(0, 0, 1)); this.add(l); var m = new ca(90, 1, a, b); m.up.set(0, -1, 0); m.lookAt(new n(0, 0, -1)); this.add(m); d = d || { format: 1022, magFilter: 1006, minFilter: 1006 }; this.renderTarget = new rb(c, c, d); this.renderTarget.texture.name = "CubeCamera"; this.update = function (a, b) {
        null ===
        this.parent && this.updateMatrixWorld(); var c = a.getRenderTarget(), d = this.renderTarget, q = d.texture.generateMipmaps; d.texture.generateMipmaps = !1; a.setRenderTarget(d, 0); a.render(b, e); a.setRenderTarget(d, 1); a.render(b, f); a.setRenderTarget(d, 2); a.render(b, g); a.setRenderTarget(d, 3); a.render(b, h); a.setRenderTarget(d, 4); a.render(b, l); d.texture.generateMipmaps = q; a.setRenderTarget(d, 5); a.render(b, m); a.setRenderTarget(c);
      }; this.clear = function (a, b, c, d) {
        for (var e = a.getRenderTarget(), f = this.renderTarget, g = 0; 6 > g; g++)a.setRenderTarget(f,
          g), a.clear(b, c, d); a.setRenderTarget(e);
      };
  } function Ae(a) { this.autoStart = void 0 !== a ? a : !0; this.elapsedTime = this.oldTime = this.startTime = 0; this.running = !1; } function Be() { D.call(this); this.type = "AudioListener"; this.context = Ce.getContext(); this.gain = this.context.createGain(); this.gain.connect(this.context.destination); this.filter = null; this.timeDelta = 0; } function qc(a) {
    D.call(this); this.type = "Audio"; this.listener = a; this.context = a.context; this.gain = this.context.createGain(); this.gain.connect(a.getInput()); this.autoplay =
      !1; this.buffer = null; this.detune = 0; this.loop = !1; this.offset = this.startTime = 0; this.playbackRate = 1; this.isPlaying = !1; this.hasPlaybackControl = !0; this.sourceType = "empty"; this.filters = [];
  } function De(a) { qc.call(this, a); this.panner = this.context.createPanner(); this.panner.connect(this.gain); } function Ee(a, b) { this.analyser = a.context.createAnalyser(); this.analyser.fftSize = void 0 !== b ? b : 2048; this.data = new Uint8Array(this.analyser.frequencyBinCount); a.getOutput().connect(this.analyser); } function Fe(a, b, c) {
    this.binding =
    a; this.valueSize = c; a = Float64Array; switch (b) { case "quaternion": b = this._slerp; break; case "string": case "bool": a = Array; b = this._select; break; default: b = this._lerp; }this.buffer = new a(4 * c); this._mixBufferRegion = b; this.referenceCount = this.useCount = this.cumulativeWeight = 0;
  } function Mf(a, b, c) { c = c || ia.parseTrackName(b); this._targetGroup = a; this._bindings = a.subscribe_(b, c); } function ia(a, b, c) { this.path = b; this.parsedPath = c || ia.parseTrackName(b); this.node = ia.findNode(a, this.parsedPath.nodeName) || a; this.rootNode = a; }
  function Nf() { this.uuid = O.generateUUID(); this._objects = Array.prototype.slice.call(arguments); this.nCachedObjects_ = 0; var a = {}; this._indicesByUUID = a; for (var b = 0, c = arguments.length; b !== c; ++b)a[arguments[b].uuid] = b; this._paths = []; this._parsedPaths = []; this._bindings = []; this._bindingsIndicesByPath = {}; var d = this; this.stats = { objects: { get total() { return d._objects.length; }, get inUse() { return this.total - d.nCachedObjects_; } }, get bindingsPerObject() { return d._bindings.length; } }; } function Of(a, b, c) {
    this._mixer = a;
    this._clip = b; this._localRoot = c || null; a = b.tracks; b = a.length; c = Array(b); for (var d = { endingStart: 2400, endingEnd: 2400 }, e = 0; e !== b; ++e) { var f = a[e].createInterpolant(null); c[e] = f; f.settings = d; } this._interpolantSettings = d; this._interpolants = c; this._propertyBindings = Array(b); this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null; this.loop = 2201; this._loopCount = -1; this._startTime = null; this.time = 0; this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale =
      1; this.repetitions = Infinity; this.paused = !1; this.enabled = !0; this.clampWhenFinished = !1; this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0;
  } function Ge(a) { this._root = a; this._initMemoryManager(); this.time = this._accuIndex = 0; this.timeScale = 1; } function Xd(a, b) { "string" === typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), a = b); this.value = a; } function He() { B.call(this); this.type = "InstancedBufferGeometry"; this.maxInstancedCount = void 0; } function Ie(a, b, c) {
    Ab.call(this, a, b); this.meshPerAttribute =
      c || 1;
  } function Je(a, b, c, d) { "number" === typeof c && (d = c, c = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")); H.call(this, a, b, c); this.meshPerAttribute = d || 1; } function Pf(a, b, c, d) {
    this.ray = new zb(a, b); this.near = c || 0; this.far = d || Infinity; this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }; Object.defineProperties(this.params, {
      PointCloud: {
        get: function () {
          console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
          return this.Points;
        }
      }
    });
  } function Qf(a, b) { return a.distance - b.distance; } function Ke(a, b, c, d) { if (!1 !== a.visible && (a.raycast(b, c), !0 === d)) { a = a.children; d = 0; for (var e = a.length; d < e; d++)Ke(a[d], b, c, !0); } } function Rf(a, b, c) { this.radius = void 0 !== a ? a : 1; this.phi = void 0 !== b ? b : 0; this.theta = void 0 !== c ? c : 0; return this; } function Sf(a, b, c) { this.radius = void 0 !== a ? a : 1; this.theta = void 0 !== b ? b : 0; this.y = void 0 !== c ? c : 0; return this; } function Le(a, b) {
    this.min = void 0 !== a ? a : new C(Infinity, Infinity); this.max = void 0 !== b ? b : new C(-Infinity,
      -Infinity);
  } function Me(a, b) { this.start = void 0 !== a ? a : new n; this.end = void 0 !== b ? b : new n; } function rd(a) { D.call(this); this.material = a; this.render = function () { }; } function sd(a, b, c, d) { this.object = a; this.size = void 0 !== b ? b : 1; a = void 0 !== c ? c : 16711680; d = void 0 !== d ? d : 1; b = 0; (c = this.object.geometry) && c.isGeometry ? b = 3 * c.faces.length : c && c.isBufferGeometry && (b = c.attributes.normal.count); c = new B; b = new E(6 * b, 3); c.addAttribute("position", b); V.call(this, c, new U({ color: a, linewidth: d })); this.matrixAutoUpdate = !1; this.update(); }
  function rc(a, b) { D.call(this); this.light = a; this.light.updateMatrixWorld(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.color = b; a = new B; b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (var c = 0, d = 1; 32 > c; c++, d++) { var e = c / 32 * Math.PI * 2, f = d / 32 * Math.PI * 2; b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1); } a.addAttribute("position", new E(b, 3)); b = new U({ fog: !1 }); this.cone = new V(a, b); this.add(this.cone); this.update(); } function Tf(a) {
    var b = []; a && a.isBone && b.push(a); for (var c =
      0; c < a.children.length; c++)b.push.apply(b, Tf(a.children[c])); return b;
  } function sc(a) {
    for (var b = Tf(a), c = new B, d = [], e = [], f = new A(0, 0, 1), g = new A(0, 1, 0), h = 0; h < b.length; h++) { var l = b[h]; l.parent && l.parent.isBone && (d.push(0, 0, 0), d.push(0, 0, 0), e.push(f.r, f.g, f.b), e.push(g.r, g.g, g.b)); } c.addAttribute("position", new E(d, 3)); c.addAttribute("color", new E(e, 3)); d = new U({ vertexColors: 2, depthTest: !1, depthWrite: !1, transparent: !0 }); V.call(this, c, d); this.root = a; this.bones = b; this.matrix = a.matrixWorld; this.matrixAutoUpdate =
      !1;
  } function tc(a, b, c) { this.light = a; this.light.updateMatrixWorld(); this.color = c; a = new ob(b, 4, 2); b = new Ca({ wireframe: !0, fog: !1 }); qa.call(this, a, b); this.matrix = this.light.matrixWorld; this.matrixAutoUpdate = !1; this.update(); } function uc(a, b) {
    this.type = "RectAreaLightHelper"; this.light = a; this.color = b; a = new B; a.addAttribute("position", new E([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)); a.computeBoundingSphere(); b = new U({ fog: !1 }); ka.call(this, a, b); a = new B; a.addAttribute("position", new E([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1,
      0, -1, -1, 0, 1, -1, 0], 3)); a.computeBoundingSphere(); this.add(new qa(a, new Ca({ side: 1, fog: !1 }))); this.update();
  } function vc(a, b, c) {
    D.call(this); this.light = a; this.light.updateMatrixWorld(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.color = c; a = new Bb(b); a.rotateY(.5 * Math.PI); this.material = new Ca({ wireframe: !0, fog: !1 }); void 0 === this.color && (this.material.vertexColors = 2); b = a.getAttribute("position"); b = new Float32Array(3 * b.count); a.addAttribute("color", new H(b, 3)); this.add(new qa(a, this.material));
    this.update();
  } function wc(a, b) {
    this.lightProbe = a; this.size = b; a = new ea({ defines: { GAMMA_OUTPUT: "" }, uniforms: { sh: { value: this.lightProbe.sh.coefficients }, intensity: { value: this.lightProbe.intensity } }, vertexShader: "varying vec3 vNormal;\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader: "#define RECIPROCAL_PI 0.318309886\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\t// matrix is assumed to be orthogonal\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 linearToOutput( in vec3 a ) {\n\t#ifdef GAMMA_OUTPUT\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\t// normal is assumed to have unit length\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nuniform vec3 sh[ 9 ]; // sh coefficients\nuniform float intensity; // light probe intensity\nvarying vec3 vNormal;\nvoid main() {\n\tvec3 normal = normalize( vNormal );\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\toutgoingLight = linearToOutput( outgoingLight );\n\tgl_FragColor = vec4( outgoingLight, 1.0 );\n}" });
    b = new ob(1, 32, 16); qa.call(this, b, a); this.onBeforeRender();
  } function Yd(a, b, c, d) { a = a || 10; b = b || 10; c = new A(void 0 !== c ? c : 4473924); d = new A(void 0 !== d ? d : 8947848); var e = b / 2, f = a / b, g = a / 2; a = []; for (var h = [], l = 0, m = 0, q = -g; l <= b; l++, q += f) { a.push(-g, 0, q, g, 0, q); a.push(q, 0, -g, q, 0, g); var k = l === e ? c : d; k.toArray(h, m); m += 3; k.toArray(h, m); m += 3; k.toArray(h, m); m += 3; k.toArray(h, m); m += 3; } b = new B; b.addAttribute("position", new E(a, 3)); b.addAttribute("color", new E(h, 3)); c = new U({ vertexColors: 2 }); V.call(this, b, c); } function Zd(a, b,
    c, d, e, f) {
      a = a || 10; b = b || 16; c = c || 8; d = d || 64; e = new A(void 0 !== e ? e : 4473924); f = new A(void 0 !== f ? f : 8947848); var g = [], h = [], l; for (l = 0; l <= b; l++) { var m = l / b * 2 * Math.PI; var q = Math.sin(m) * a; m = Math.cos(m) * a; g.push(0, 0, 0); g.push(q, 0, m); var k = l & 1 ? e : f; h.push(k.r, k.g, k.b); h.push(k.r, k.g, k.b); } for (l = 0; l <= c; l++) { k = l & 1 ? e : f; var n = a - a / c * l; for (b = 0; b < d; b++)m = b / d * 2 * Math.PI, q = Math.sin(m) * n, m = Math.cos(m) * n, g.push(q, 0, m), h.push(k.r, k.g, k.b), m = (b + 1) / d * 2 * Math.PI, q = Math.sin(m) * n, m = Math.cos(m) * n, g.push(q, 0, m), h.push(k.r, k.g, k.b); } a = new B;
    a.addAttribute("position", new E(g, 3)); a.addAttribute("color", new E(h, 3)); g = new U({ vertexColors: 2 }); V.call(this, a, g);
  } function xc(a, b, c, d) { this.audio = a; this.range = b || 1; this.divisionsInnerAngle = c || 16; this.divisionsOuterAngle = d || 2; a = new B; b = new Float32Array(3 * (3 * (this.divisionsInnerAngle + 2 * this.divisionsOuterAngle) + 3)); a.addAttribute("position", new H(b, 3)); b = new U({ color: 65280 }); c = new U({ color: 16776960 }); ka.call(this, a, [c, b]); this.update(); } function td(a, b, c, d) {
    this.object = a; this.size = void 0 !== b ? b : 1; a =
      void 0 !== c ? c : 16776960; d = void 0 !== d ? d : 1; b = 0; (c = this.object.geometry) && c.isGeometry ? b = c.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."); c = new B; b = new E(6 * b, 3); c.addAttribute("position", b); V.call(this, c, new U({ color: a, linewidth: d })); this.matrixAutoUpdate = !1; this.update();
  } function yc(a, b, c) {
    D.call(this); this.light = a; this.light.updateMatrixWorld(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.color = c; void 0 === b &&
      (b = 1); a = new B; a.addAttribute("position", new E([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3)); b = new U({ fog: !1 }); this.lightPlane = new ka(a, b); this.add(this.lightPlane); a = new B; a.addAttribute("position", new E([0, 0, 0, 0, 0, 1], 3)); this.targetLine = new ka(a, b); this.add(this.targetLine); this.update();
  } function ud(a) {
    function b(a, b, d) { c(a, d); c(b, d); } function c(a, b) { f.push(0, 0, 0); g.push(b.r, b.g, b.b); void 0 === h[a] && (h[a] = []); h[a].push(f.length / 3 - 1); } var d = new B, e = new U({ color: 16777215, vertexColors: 1 }), f = [], g = [], h = {}, l =
      new A(16755200), m = new A(16711680), k = new A(43775), p = new A(16777215), n = new A(3355443); b("n1", "n2", l); b("n2", "n4", l); b("n4", "n3", l); b("n3", "n1", l); b("f1", "f2", l); b("f2", "f4", l); b("f4", "f3", l); b("f3", "f1", l); b("n1", "f1", l); b("n2", "f2", l); b("n3", "f3", l); b("n4", "f4", l); b("p", "n1", m); b("p", "n2", m); b("p", "n3", m); b("p", "n4", m); b("u1", "u2", k); b("u2", "u3", k); b("u3", "u1", k); b("c", "t", p); b("p", "c", n); b("cn1", "cn2", n); b("cn3", "cn4", n); b("cf1", "cf2", n); b("cf3", "cf4", n); d.addAttribute("position", new E(f, 3)); d.addAttribute("color",
        new E(g, 3)); V.call(this, d, e); this.camera = a; this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(); this.matrix = a.matrixWorld; this.matrixAutoUpdate = !1; this.pointMap = h; this.update();
  } function gb(a, b) { this.object = a; void 0 === b && (b = 16776960); a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]); var c = new Float32Array(24), d = new B; d.setIndex(new H(a, 1)); d.addAttribute("position", new H(c, 3)); V.call(this, d, new U({ color: b })); this.matrixAutoUpdate = !1; this.update(); } function vd(a,
    b) { this.type = "Box3Helper"; this.box = a; a = void 0 !== b ? b : 16776960; b = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]); var c = new B; c.setIndex(new H(b, 1)); c.addAttribute("position", new E([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)); V.call(this, c, new U({ color: a })); this.geometry.computeBoundingSphere(); } function wd(a, b, c) {
      this.type = "PlaneHelper"; this.plane = a; this.size = void 0 === b ? 1 : b; a = void 0 !== c ? c : 16776960; b = new B; b.addAttribute("position", new E([1, -1, 1, -1, 1, 1, -1, -1, 1,
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)); b.computeBoundingSphere(); ka.call(this, b, new U({ color: a })); b = new B; b.addAttribute("position", new E([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)); b.computeBoundingSphere(); this.add(new qa(b, new Ca({ color: a, opacity: .2, transparent: !0, depthWrite: !1 })));
    } function hb(a, b, c, d, e, f) {
      D.call(this); void 0 === a && (a = new n(0, 0, 1)); void 0 === b && (b = new n(0, 0, 0)); void 0 === c && (c = 1); void 0 === d && (d = 16776960); void 0 === e && (e = .2 * c); void 0 === f && (f = .2 * e); void 0 === $d && ($d = new B,
        $d.addAttribute("position", new E([0, 0, 0, 0, 1, 0], 3)), Ne = new eb(0, .5, 1, 5, 1), Ne.translate(0, -.5, 0)); this.position.copy(b); this.line = new ka($d, new U({ color: d })); this.line.matrixAutoUpdate = !1; this.add(this.line); this.cone = new qa(Ne, new Ca({ color: d })); this.cone.matrixAutoUpdate = !1; this.add(this.cone); this.setDirection(a); this.setLength(c, e, f);
    } function xd(a) {
      a = a || 1; var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a]; a = new B; a.addAttribute("position", new E(b, 3)); a.addAttribute("color", new E([1, 0, 0, 1, .6, 0, 0, 1, 0, .6,
        1, 0, 0, 0, 1, 0, .6, 1], 3)); b = new U({ vertexColors: 2 }); V.call(this, a, b);
    } function Uf(a) { console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."); oa.call(this, a); this.type = "catmullrom"; this.closed = !0; } function Vf(a) { console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."); oa.call(this, a); this.type = "catmullrom"; } function Oe(a) {
      console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."); oa.call(this, a); this.type =
        "catmullrom";
    } void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)); void 0 === Number.isInteger && (Number.isInteger = function (a) { return "number" === typeof a && isFinite(a) && Math.floor(a) === a; }); void 0 === Math.sign && (Math.sign = function (a) { return 0 > a ? -1 : 0 < a ? 1 : +a; }); !1 === "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", { get: function () { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]; } }); void 0 === Object.assign && function () {
      Object.assign = function (a) {
        if (void 0 === a || null ===
          a) throw new TypeError("Cannot convert undefined or null to object"); for (var b = Object(a), c = 1; c < arguments.length; c++) { var d = arguments[c]; if (void 0 !== d && null !== d) for (var e in d) Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e]); } return b;
      };
    }(); Object.assign(ta.prototype, {
      addEventListener: function (a, b) { void 0 === this._listeners && (this._listeners = {}); var c = this._listeners; void 0 === c[a] && (c[a] = []); -1 === c[a].indexOf(b) && c[a].push(b); }, hasEventListener: function (a, b) {
        if (void 0 === this._listeners) return !1; var c =
          this._listeners; return void 0 !== c[a] && -1 !== c[a].indexOf(b);
      }, removeEventListener: function (a, b) { void 0 !== this._listeners && (a = this._listeners[a], void 0 !== a && (b = a.indexOf(b), -1 !== b && a.splice(b, 1))); }, dispatchEvent: function (a) { if (void 0 !== this._listeners) { var b = this._listeners[a.type]; if (void 0 !== b) { a.target = this; b = b.slice(0); for (var c = 0, d = b.length; c < d; c++)b[c].call(this, a); } } }
    }); var O = {
      DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () {
        for (var a = [], b = 0; 256 > b; b++)a[b] = (16 > b ? "0" : "") + b.toString(16);
        return function () { var b = 4294967295 * Math.random() | 0, d = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, f = 4294967295 * Math.random() | 0; return (a[b & 255] + a[b >> 8 & 255] + a[b >> 16 & 255] + a[b >> 24 & 255] + "-" + a[d & 255] + a[d >> 8 & 255] + "-" + a[d >> 16 & 15 | 64] + a[d >> 24 & 255] + "-" + a[e & 63 | 128] + a[e >> 8 & 255] + "-" + a[e >> 16 & 255] + a[e >> 24 & 255] + a[f & 255] + a[f >> 8 & 255] + a[f >> 16 & 255] + a[f >> 24 & 255]).toUpperCase(); };
      }(), clamp: function (a, b, c) { return Math.max(b, Math.min(c, a)); }, euclideanModulo: function (a, b) { return (a % b + b) % b; }, mapLinear: function (a, b, c,
        d, e) { return d + (a - b) * (e - d) / (c - b); }, lerp: function (a, b, c) { return (1 - c) * a + c * b; }, smoothstep: function (a, b, c) { if (a <= b) return 0; if (a >= c) return 1; a = (a - b) / (c - b); return a * a * (3 - 2 * a); }, smootherstep: function (a, b, c) { if (a <= b) return 0; if (a >= c) return 1; a = (a - b) / (c - b); return a * a * a * (a * (6 * a - 15) + 10); }, randInt: function (a, b) { return a + Math.floor(Math.random() * (b - a + 1)); }, randFloat: function (a, b) { return a + Math.random() * (b - a); }, randFloatSpread: function (a) { return a * (.5 - Math.random()); }, degToRad: function (a) { return a * O.DEG2RAD; }, radToDeg: function (a) {
          return a *
            O.RAD2DEG;
        }, isPowerOfTwo: function (a) { return 0 === (a & a - 1) && 0 !== a; }, ceilPowerOfTwo: function (a) { return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2)); }, floorPowerOfTwo: function (a) { return Math.pow(2, Math.floor(Math.log(a) / Math.LN2)); }
    }; Object.defineProperties(C.prototype, { width: { get: function () { return this.x; }, set: function (a) { this.x = a; } }, height: { get: function () { return this.y; }, set: function (a) { this.y = a; } } }); Object.assign(C.prototype, {
      isVector2: !0, set: function (a, b) { this.x = a; this.y = b; return this; }, setScalar: function (a) {
        this.y =
        this.x = a; return this;
      }, setX: function (a) { this.x = a; return this; }, setY: function (a) { this.y = a; return this; }, setComponent: function (a, b) { switch (a) { case 0: this.x = b; break; case 1: this.y = b; break; default: throw Error("index is out of range: " + a); }return this; }, getComponent: function (a) { switch (a) { case 0: return this.x; case 1: return this.y; default: throw Error("index is out of range: " + a); } }, clone: function () { return new this.constructor(this.x, this.y); }, copy: function (a) { this.x = a.x; this.y = a.y; return this; }, add: function (a,
        b) { if (void 0 !== b) return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b); this.x += a.x; this.y += a.y; return this; }, addScalar: function (a) { this.x += a; this.y += a; return this; }, addVectors: function (a, b) { this.x = a.x + b.x; this.y = a.y + b.y; return this; }, addScaledVector: function (a, b) { this.x += a.x * b; this.y += a.y * b; return this; }, sub: function (a, b) {
          if (void 0 !== b) return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(a, b); this.x -= a.x; this.y -= a.y; return this;
        }, subScalar: function (a) { this.x -= a; this.y -= a; return this; }, subVectors: function (a, b) { this.x = a.x - b.x; this.y = a.y - b.y; return this; }, multiply: function (a) { this.x *= a.x; this.y *= a.y; return this; }, multiplyScalar: function (a) { this.x *= a; this.y *= a; return this; }, divide: function (a) { this.x /= a.x; this.y /= a.y; return this; }, divideScalar: function (a) { return this.multiplyScalar(1 / a); }, applyMatrix3: function (a) {
          var b = this.x, c = this.y; a = a.elements; this.x = a[0] * b + a[3] * c + a[6]; this.y =
            a[1] * b + a[4] * c + a[7]; return this;
        }, min: function (a) { this.x = Math.min(this.x, a.x); this.y = Math.min(this.y, a.y); return this; }, max: function (a) { this.x = Math.max(this.x, a.x); this.y = Math.max(this.y, a.y); return this; }, clamp: function (a, b) { this.x = Math.max(a.x, Math.min(b.x, this.x)); this.y = Math.max(a.y, Math.min(b.y, this.y)); return this; }, clampScalar: function (a, b) { this.x = Math.max(a, Math.min(b, this.x)); this.y = Math.max(a, Math.min(b, this.y)); return this; }, clampLength: function (a, b) {
          var c = this.length(); return this.divideScalar(c ||
            1).multiplyScalar(Math.max(a, Math.min(b, c)));
        }, floor: function () { this.x = Math.floor(this.x); this.y = Math.floor(this.y); return this; }, ceil: function () { this.x = Math.ceil(this.x); this.y = Math.ceil(this.y); return this; }, round: function () { this.x = Math.round(this.x); this.y = Math.round(this.y); return this; }, roundToZero: function () { this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x); this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y); return this; }, negate: function () { this.x = -this.x; this.y = -this.y; return this; }, dot: function (a) {
          return this.x *
            a.x + this.y * a.y;
        }, cross: function (a) { return this.x * a.y - this.y * a.x; }, lengthSq: function () { return this.x * this.x + this.y * this.y; }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y); }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y); }, normalize: function () { return this.divideScalar(this.length() || 1); }, angle: function () { var a = Math.atan2(this.y, this.x); 0 > a && (a += 2 * Math.PI); return a; }, distanceTo: function (a) { return Math.sqrt(this.distanceToSquared(a)); }, distanceToSquared: function (a) {
          var b =
            this.x - a.x; a = this.y - a.y; return b * b + a * a;
        }, manhattanDistanceTo: function (a) { return Math.abs(this.x - a.x) + Math.abs(this.y - a.y); }, setLength: function (a) { return this.normalize().multiplyScalar(a); }, lerp: function (a, b) { this.x += (a.x - this.x) * b; this.y += (a.y - this.y) * b; return this; }, lerpVectors: function (a, b, c) { return this.subVectors(b, a).multiplyScalar(c).add(a); }, equals: function (a) { return a.x === this.x && a.y === this.y; }, fromArray: function (a, b) { void 0 === b && (b = 0); this.x = a[b]; this.y = a[b + 1]; return this; }, toArray: function (a,
          b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this.x; a[b + 1] = this.y; return a; }, fromBufferAttribute: function (a, b, c) { void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."); this.x = a.getX(b); this.y = a.getY(b); return this; }, rotateAround: function (a, b) { var c = Math.cos(b); b = Math.sin(b); var d = this.x - a.x, e = this.y - a.y; this.x = d * c - e * b + a.x; this.y = d * b + e * c + a.y; return this; }
    }); Object.assign(ma, {
      slerp: function (a, b, c, d) { return c.copy(a).slerp(b, d); }, slerpFlat: function (a, b, c, d, e, f, g) {
        var h =
          c[d + 0], l = c[d + 1], m = c[d + 2]; c = c[d + 3]; d = e[f + 0]; var k = e[f + 1], p = e[f + 2]; e = e[f + 3]; if (c !== e || h !== d || l !== k || m !== p) { f = 1 - g; var n = h * d + l * k + m * p + c * e, t = 0 <= n ? 1 : -1, r = 1 - n * n; r > Number.EPSILON && (r = Math.sqrt(r), n = Math.atan2(r, n * t), f = Math.sin(f * n) / r, g = Math.sin(g * n) / r); t *= g; h = h * f + d * t; l = l * f + k * t; m = m * f + p * t; c = c * f + e * t; f === 1 - g && (g = 1 / Math.sqrt(h * h + l * l + m * m + c * c), h *= g, l *= g, m *= g, c *= g); } a[b] = h; a[b + 1] = l; a[b + 2] = m; a[b + 3] = c;
      }
    }); Object.defineProperties(ma.prototype, {
      x: { get: function () { return this._x; }, set: function (a) { this._x = a; this.onChangeCallback(); } },
      y: { get: function () { return this._y; }, set: function (a) { this._y = a; this.onChangeCallback(); } }, z: { get: function () { return this._z; }, set: function (a) { this._z = a; this.onChangeCallback(); } }, w: { get: function () { return this._w; }, set: function (a) { this._w = a; this.onChangeCallback(); } }
    }); Object.assign(ma.prototype, {
      isQuaternion: !0, set: function (a, b, c, d) { this._x = a; this._y = b; this._z = c; this._w = d; this.onChangeCallback(); return this; }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._w); }, copy: function (a) {
        this._x =
        a.x; this._y = a.y; this._z = a.z; this._w = a.w; this.onChangeCallback(); return this;
      }, setFromEuler: function (a, b) {
        if (!a || !a.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); var c = a._x, d = a._y, e = a._z; a = a.order; var f = Math.cos, g = Math.sin, h = f(c / 2), l = f(d / 2); f = f(e / 2); c = g(c / 2); d = g(d / 2); e = g(e / 2); "XYZ" === a ? (this._x = c * l * f + h * d * e, this._y = h * d * f - c * l * e, this._z = h * l * e + c * d * f, this._w = h * l * f - c * d * e) : "YXZ" === a ? (this._x = c * l * f + h * d * e, this._y = h * d * f - c * l * e, this._z = h *
          l * e - c * d * f, this._w = h * l * f + c * d * e) : "ZXY" === a ? (this._x = c * l * f - h * d * e, this._y = h * d * f + c * l * e, this._z = h * l * e + c * d * f, this._w = h * l * f - c * d * e) : "ZYX" === a ? (this._x = c * l * f - h * d * e, this._y = h * d * f + c * l * e, this._z = h * l * e - c * d * f, this._w = h * l * f + c * d * e) : "YZX" === a ? (this._x = c * l * f + h * d * e, this._y = h * d * f + c * l * e, this._z = h * l * e - c * d * f, this._w = h * l * f - c * d * e) : "XZY" === a && (this._x = c * l * f - h * d * e, this._y = h * d * f - c * l * e, this._z = h * l * e + c * d * f, this._w = h * l * f + c * d * e); if (!1 !== b) this.onChangeCallback(); return this;
      }, setFromAxisAngle: function (a, b) {
        b /= 2; var c = Math.sin(b);
        this._x = a.x * c; this._y = a.y * c; this._z = a.z * c; this._w = Math.cos(b); this.onChangeCallback(); return this;
      }, setFromRotationMatrix: function (a) {
        var b = a.elements, c = b[0]; a = b[4]; var d = b[8], e = b[1], f = b[5], g = b[9], h = b[2], l = b[6]; b = b[10]; var m = c + f + b; 0 < m ? (c = .5 / Math.sqrt(m + 1), this._w = .25 / c, this._x = (l - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (l - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + l) /
          c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + l) / c, this._z = .25 * c); this.onChangeCallback(); return this;
      }, setFromUnitVectors: function (a, b) { var c = a.dot(b) + 1; 1E-6 > c ? (c = 0, Math.abs(a.x) > Math.abs(a.z) ? (this._x = -a.y, this._y = a.x, this._z = 0) : (this._x = 0, this._y = -a.z, this._z = a.y)) : (this._x = a.y * b.z - a.z * b.y, this._y = a.z * b.x - a.x * b.z, this._z = a.x * b.y - a.y * b.x); this._w = c; return this.normalize(); }, angleTo: function (a) { return 2 * Math.acos(Math.abs(O.clamp(this.dot(a), -1, 1))); }, rotateTowards: function (a,
        b) { var c = this.angleTo(a); if (0 === c) return this; this.slerp(a, Math.min(1, b / c)); return this; }, inverse: function () { return this.conjugate(); }, conjugate: function () { this._x *= -1; this._y *= -1; this._z *= -1; this.onChangeCallback(); return this; }, dot: function (a) { return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w; }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w; }, length: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w); }, normalize: function () {
          var a =
            this.length(); 0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a); this.onChangeCallback(); return this;
        }, multiply: function (a, b) { return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a); }, premultiply: function (a) { return this.multiplyQuaternions(a, this); }, multiplyQuaternions: function (a, b) {
          var c = a._x, d = a._y, e = a._z; a = a._w;
          var f = b._x, g = b._y, h = b._z; b = b._w; this._x = c * b + a * f + d * h - e * g; this._y = d * b + a * g + e * f - c * h; this._z = e * b + a * h + c * g - d * f; this._w = a * b - c * f - d * g - e * h; this.onChangeCallback(); return this;
        }, slerp: function (a, b) {
          if (0 === b) return this; if (1 === b) return this.copy(a); var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z; 0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a); if (1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, this; a = 1 - g * g; if (a <= Number.EPSILON) return g = 1 - b, this._w = g *
            f + b * this._w, this._x = g * c + b * this._x, this._y = g * d + b * this._y, this._z = g * e + b * this._z, this.normalize(); a = Math.sqrt(a); var h = Math.atan2(a, g); g = Math.sin((1 - b) * h) / a; b = Math.sin(b * h) / a; this._w = f * g + this._w * b; this._x = c * g + this._x * b; this._y = d * g + this._y * b; this._z = e * g + this._z * b; this.onChangeCallback(); return this;
        }, equals: function (a) { return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w; }, fromArray: function (a, b) {
          void 0 === b && (b = 0); this._x = a[b]; this._y = a[b + 1]; this._z = a[b + 2]; this._w = a[b + 3]; this.onChangeCallback();
          return this;
        }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this._x; a[b + 1] = this._y; a[b + 2] = this._z; a[b + 3] = this._w; return a; }, onChange: function (a) { this.onChangeCallback = a; return this; }, onChangeCallback: function () { }
    }); Object.assign(n.prototype, {
      isVector3: !0, set: function (a, b, c) { this.x = a; this.y = b; this.z = c; return this; }, setScalar: function (a) { this.z = this.y = this.x = a; return this; }, setX: function (a) { this.x = a; return this; }, setY: function (a) { this.y = a; return this; }, setZ: function (a) { this.z = a; return this; },
      setComponent: function (a, b) { switch (a) { case 0: this.x = b; break; case 1: this.y = b; break; case 2: this.z = b; break; default: throw Error("index is out of range: " + a); }return this; }, getComponent: function (a) { switch (a) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw Error("index is out of range: " + a); } }, clone: function () { return new this.constructor(this.x, this.y, this.z); }, copy: function (a) { this.x = a.x; this.y = a.y; this.z = a.z; return this; }, add: function (a, b) {
        if (void 0 !== b) return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
          this.addVectors(a, b); this.x += a.x; this.y += a.y; this.z += a.z; return this;
      }, addScalar: function (a) { this.x += a; this.y += a; this.z += a; return this; }, addVectors: function (a, b) { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; return this; }, addScaledVector: function (a, b) { this.x += a.x * b; this.y += a.y * b; this.z += a.z * b; return this; }, sub: function (a, b) {
        if (void 0 !== b) return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b); this.x -= a.x; this.y -= a.y; this.z -= a.z;
        return this;
      }, subScalar: function (a) { this.x -= a; this.y -= a; this.z -= a; return this; }, subVectors: function (a, b) { this.x = a.x - b.x; this.y = a.y - b.y; this.z = a.z - b.z; return this; }, multiply: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b); this.x *= a.x; this.y *= a.y; this.z *= a.z; return this; }, multiplyScalar: function (a) { this.x *= a; this.y *= a; this.z *= a; return this; }, multiplyVectors: function (a, b) {
        this.x = a.x *
          b.x; this.y = a.y * b.y; this.z = a.z * b.z; return this;
      }, applyEuler: function () { var a = new ma; return function (b) { b && b.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."); return this.applyQuaternion(a.setFromEuler(b)); }; }(), applyAxisAngle: function () { var a = new ma; return function (b, c) { return this.applyQuaternion(a.setFromAxisAngle(b, c)); }; }(), applyMatrix3: function (a) {
        var b = this.x, c = this.y, d = this.z; a = a.elements; this.x = a[0] * b + a[3] * c + a[6] * d; this.y = a[1] *
          b + a[4] * c + a[7] * d; this.z = a[2] * b + a[5] * c + a[8] * d; return this;
      }, applyMatrix4: function (a) { var b = this.x, c = this.y, d = this.z; a = a.elements; var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]); this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e; this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e; this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e; return this; }, applyQuaternion: function (a) {
        var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z; a = a.w; var h = a * b + f * d - g * c, l = a * c + g * b - e * d, m = a * d + e * c - f * b; b = -e * b - f * c - g * d; this.x = h * a + b * -e + l * -g - m * -f; this.y = l * a + b * -f + m * -e - h * -g; this.z = m * a + b *
          -g + h * -f - l * -e; return this;
      }, project: function (a) { return this.applyMatrix4(a.matrixWorldInverse).applyMatrix4(a.projectionMatrix); }, unproject: function (a) { return this.applyMatrix4(a.projectionMatrixInverse).applyMatrix4(a.matrixWorld); }, transformDirection: function (a) { var b = this.x, c = this.y, d = this.z; a = a.elements; this.x = a[0] * b + a[4] * c + a[8] * d; this.y = a[1] * b + a[5] * c + a[9] * d; this.z = a[2] * b + a[6] * c + a[10] * d; return this.normalize(); }, divide: function (a) { this.x /= a.x; this.y /= a.y; this.z /= a.z; return this; }, divideScalar: function (a) {
        return this.multiplyScalar(1 /
          a);
      }, min: function (a) { this.x = Math.min(this.x, a.x); this.y = Math.min(this.y, a.y); this.z = Math.min(this.z, a.z); return this; }, max: function (a) { this.x = Math.max(this.x, a.x); this.y = Math.max(this.y, a.y); this.z = Math.max(this.z, a.z); return this; }, clamp: function (a, b) { this.x = Math.max(a.x, Math.min(b.x, this.x)); this.y = Math.max(a.y, Math.min(b.y, this.y)); this.z = Math.max(a.z, Math.min(b.z, this.z)); return this; }, clampScalar: function (a, b) {
        this.x = Math.max(a, Math.min(b, this.x)); this.y = Math.max(a, Math.min(b, this.y)); this.z = Math.max(a,
          Math.min(b, this.z)); return this;
      }, clampLength: function (a, b) { var c = this.length(); return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c))); }, floor: function () { this.x = Math.floor(this.x); this.y = Math.floor(this.y); this.z = Math.floor(this.z); return this; }, ceil: function () { this.x = Math.ceil(this.x); this.y = Math.ceil(this.y); this.z = Math.ceil(this.z); return this; }, round: function () { this.x = Math.round(this.x); this.y = Math.round(this.y); this.z = Math.round(this.z); return this; }, roundToZero: function () {
        this.x =
        0 > this.x ? Math.ceil(this.x) : Math.floor(this.x); this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y); this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z); return this;
      }, negate: function () { this.x = -this.x; this.y = -this.y; this.z = -this.z; return this; }, dot: function (a) { return this.x * a.x + this.y * a.y + this.z * a.z; }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z; }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }, manhattanLength: function () {
        return Math.abs(this.x) + Math.abs(this.y) +
          Math.abs(this.z);
      }, normalize: function () { return this.divideScalar(this.length() || 1); }, setLength: function (a) { return this.normalize().multiplyScalar(a); }, lerp: function (a, b) { this.x += (a.x - this.x) * b; this.y += (a.y - this.y) * b; this.z += (a.z - this.z) * b; return this; }, lerpVectors: function (a, b, c) { return this.subVectors(b, a).multiplyScalar(c).add(a); }, cross: function (a, b) {
        return void 0 !== b ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b)) : this.crossVectors(this,
          a);
      }, crossVectors: function (a, b) { var c = a.x, d = a.y; a = a.z; var e = b.x, f = b.y; b = b.z; this.x = d * b - a * f; this.y = a * e - c * b; this.z = c * f - d * e; return this; }, projectOnVector: function (a) { var b = a.dot(this) / a.lengthSq(); return this.copy(a).multiplyScalar(b); }, projectOnPlane: function () { var a = new n; return function (b) { a.copy(this).projectOnVector(b); return this.sub(a); }; }(), reflect: function () { var a = new n; return function (b) { return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b))); }; }(), angleTo: function (a) {
        a = this.dot(a) / Math.sqrt(this.lengthSq() *
          a.lengthSq()); return Math.acos(O.clamp(a, -1, 1));
      }, distanceTo: function (a) { return Math.sqrt(this.distanceToSquared(a)); }, distanceToSquared: function (a) { var b = this.x - a.x, c = this.y - a.y; a = this.z - a.z; return b * b + c * c + a * a; }, manhattanDistanceTo: function (a) { return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z); }, setFromSpherical: function (a) { return this.setFromSphericalCoords(a.radius, a.phi, a.theta); }, setFromSphericalCoords: function (a, b, c) {
        var d = Math.sin(b) * a; this.x = d * Math.sin(c); this.y = Math.cos(b) *
          a; this.z = d * Math.cos(c); return this;
      }, setFromCylindrical: function (a) { return this.setFromCylindricalCoords(a.radius, a.theta, a.y); }, setFromCylindricalCoords: function (a, b, c) { this.x = a * Math.sin(b); this.y = c; this.z = a * Math.cos(b); return this; }, setFromMatrixPosition: function (a) { a = a.elements; this.x = a[12]; this.y = a[13]; this.z = a[14]; return this; }, setFromMatrixScale: function (a) {
        var b = this.setFromMatrixColumn(a, 0).length(), c = this.setFromMatrixColumn(a, 1).length(); a = this.setFromMatrixColumn(a, 2).length(); this.x = b; this.y =
          c; this.z = a; return this;
      }, setFromMatrixColumn: function (a, b) { return this.fromArray(a.elements, 4 * b); }, equals: function (a) { return a.x === this.x && a.y === this.y && a.z === this.z; }, fromArray: function (a, b) { void 0 === b && (b = 0); this.x = a[b]; this.y = a[b + 1]; this.z = a[b + 2]; return this; }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this.x; a[b + 1] = this.y; a[b + 2] = this.z; return a; }, fromBufferAttribute: function (a, b, c) {
        void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
        this.x = a.getX(b); this.y = a.getY(b); this.z = a.getZ(b); return this;
      }
    }); Object.assign(na.prototype, {
      isMatrix3: !0, set: function (a, b, c, d, e, f, g, h, l) { var m = this.elements; m[0] = a; m[1] = d; m[2] = g; m[3] = b; m[4] = e; m[5] = h; m[6] = c; m[7] = f; m[8] = l; return this; }, identity: function () { this.set(1, 0, 0, 0, 1, 0, 0, 0, 1); return this; }, clone: function () { return (new this.constructor).fromArray(this.elements); }, copy: function (a) {
        var b = this.elements; a = a.elements; b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = a[3]; b[4] = a[4]; b[5] = a[5]; b[6] = a[6]; b[7] = a[7]; b[8] =
          a[8]; return this;
      }, setFromMatrix4: function (a) { a = a.elements; this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]); return this; }, applyToBufferAttribute: function () { var a = new n; return function (b) { for (var c = 0, d = b.count; c < d; c++)a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix3(this), b.setXYZ(c, a.x, a.y, a.z); return b; }; }(), multiply: function (a) { return this.multiplyMatrices(this, a); }, premultiply: function (a) { return this.multiplyMatrices(a, this); }, multiplyMatrices: function (a, b) {
        var c = a.elements, d = b.elements;
        b = this.elements; a = c[0]; var e = c[3], f = c[6], g = c[1], h = c[4], l = c[7], m = c[2], k = c[5]; c = c[8]; var p = d[0], n = d[3], t = d[6], r = d[1], u = d[4], w = d[7], z = d[2], x = d[5]; d = d[8]; b[0] = a * p + e * r + f * z; b[3] = a * n + e * u + f * x; b[6] = a * t + e * w + f * d; b[1] = g * p + h * r + l * z; b[4] = g * n + h * u + l * x; b[7] = g * t + h * w + l * d; b[2] = m * p + k * r + c * z; b[5] = m * n + k * u + c * x; b[8] = m * t + k * w + c * d; return this;
      }, multiplyScalar: function (a) { var b = this.elements; b[0] *= a; b[3] *= a; b[6] *= a; b[1] *= a; b[4] *= a; b[7] *= a; b[2] *= a; b[5] *= a; b[8] *= a; return this; }, determinant: function () {
        var a = this.elements, b = a[0], c = a[1],
        d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], l = a[7]; a = a[8]; return b * f * a - b * g * l - c * e * a + c * g * h + d * e * l - d * f * h;
      }, getInverse: function (a, b) {
        a && a.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."); var c = a.elements; a = this.elements; var d = c[0], e = c[1], f = c[2], g = c[3], h = c[4], l = c[5], m = c[6], k = c[7]; c = c[8]; var p = c * h - l * k, n = l * m - c * g, t = k * g - h * m, r = d * p + e * n + f * t; if (0 === r) {
          if (!0 === b) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"); console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
          return this.identity();
        } b = 1 / r; a[0] = p * b; a[1] = (f * k - c * e) * b; a[2] = (l * e - f * h) * b; a[3] = n * b; a[4] = (c * d - f * m) * b; a[5] = (f * g - l * d) * b; a[6] = t * b; a[7] = (e * m - k * d) * b; a[8] = (h * d - e * g) * b; return this;
      }, transpose: function () { var a = this.elements; var b = a[1]; a[1] = a[3]; a[3] = b; b = a[2]; a[2] = a[6]; a[6] = b; b = a[5]; a[5] = a[7]; a[7] = b; return this; }, getNormalMatrix: function (a) { return this.setFromMatrix4(a).getInverse(this).transpose(); }, transposeIntoArray: function (a) {
        var b = this.elements; a[0] = b[0]; a[1] = b[3]; a[2] = b[6]; a[3] = b[1]; a[4] = b[4]; a[5] = b[7]; a[6] =
          b[2]; a[7] = b[5]; a[8] = b[8]; return this;
      }, setUvTransform: function (a, b, c, d, e, f, g) { var h = Math.cos(e); e = Math.sin(e); this.set(c * h, c * e, -c * (h * f + e * g) + f + a, -d * e, d * h, -d * (-e * f + h * g) + g + b, 0, 0, 1); }, scale: function (a, b) { var c = this.elements; c[0] *= a; c[3] *= a; c[6] *= a; c[1] *= b; c[4] *= b; c[7] *= b; return this; }, rotate: function (a) { var b = Math.cos(a); a = Math.sin(a); var c = this.elements, d = c[0], e = c[3], f = c[6], g = c[1], h = c[4], l = c[7]; c[0] = b * d + a * g; c[3] = b * e + a * h; c[6] = b * f + a * l; c[1] = -a * d + b * g; c[4] = -a * e + b * h; c[7] = -a * f + b * l; return this; }, translate: function (a,
        b) { var c = this.elements; c[0] += a * c[2]; c[3] += a * c[5]; c[6] += a * c[8]; c[1] += b * c[2]; c[4] += b * c[5]; c[7] += b * c[8]; return this; }, equals: function (a) { var b = this.elements; a = a.elements; for (var c = 0; 9 > c; c++)if (b[c] !== a[c]) return !1; return !0; }, fromArray: function (a, b) { void 0 === b && (b = 0); for (var c = 0; 9 > c; c++)this.elements[c] = a[c + b]; return this; }, toArray: function (a, b) {
          void 0 === a && (a = []); void 0 === b && (b = 0); var c = this.elements; a[b] = c[0]; a[b + 1] = c[1]; a[b + 2] = c[2]; a[b + 3] = c[3]; a[b + 4] = c[4]; a[b + 5] = c[5]; a[b + 6] = c[6]; a[b + 7] = c[7]; a[b + 8] = c[8];
          return a;
        }
    }); var zc, qb = { getDataURL: function (a) { if ("undefined" == typeof HTMLCanvasElement) return a.src; if (!(a instanceof HTMLCanvasElement)) { void 0 === zc && (zc = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")); zc.width = a.width; zc.height = a.height; var b = zc.getContext("2d"); a instanceof ImageData ? b.putImageData(a, 0, 0) : b.drawImage(a, 0, 0, a.width, a.height); a = zc; } return 2048 < a.width || 2048 < a.height ? a.toDataURL("image/jpeg", .6) : a.toDataURL("image/png"); } }, Yf = 0; Y.DEFAULT_IMAGE = void 0; Y.DEFAULT_MAPPING =
      300; Y.prototype = Object.assign(Object.create(ta.prototype), {
        constructor: Y, isTexture: !0, updateMatrix: function () { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y); }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) {
          this.name = a.name; this.image = a.image; this.mipmaps = a.mipmaps.slice(0); this.mapping = a.mapping; this.wrapS = a.wrapS; this.wrapT = a.wrapT; this.magFilter = a.magFilter; this.minFilter = a.minFilter; this.anisotropy =
            a.anisotropy; this.format = a.format; this.type = a.type; this.offset.copy(a.offset); this.repeat.copy(a.repeat); this.center.copy(a.center); this.rotation = a.rotation; this.matrixAutoUpdate = a.matrixAutoUpdate; this.matrix.copy(a.matrix); this.generateMipmaps = a.generateMipmaps; this.premultiplyAlpha = a.premultiplyAlpha; this.flipY = a.flipY; this.unpackAlignment = a.unpackAlignment; this.encoding = a.encoding; return this;
        }, toJSON: function (a) {
          var b = void 0 === a || "string" === typeof a; if (!b && void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
          var c = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
          if (void 0 !== this.image) { var d = this.image; void 0 === d.uuid && (d.uuid = O.generateUUID()); if (!b && void 0 === a.images[d.uuid]) { if (Array.isArray(d)) { var e = []; for (var f = 0, g = d.length; f < g; f++)e.push(qb.getDataURL(d[f])); } else e = qb.getDataURL(d); a.images[d.uuid] = { uuid: d.uuid, url: e }; } c.image = d.uuid; } b || (a.textures[this.uuid] = c); return c;
        }, dispose: function () { this.dispatchEvent({ type: "dispose" }); }, transformUv: function (a) {
          if (300 !== this.mapping) return a; a.applyMatrix3(this.matrix); if (0 > a.x || 1 < a.x) switch (this.wrapS) {
            case 1E3: a.x -=
              Math.floor(a.x); break; case 1001: a.x = 0 > a.x ? 0 : 1; break; case 1002: a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x);
          }if (0 > a.y || 1 < a.y) switch (this.wrapT) { case 1E3: a.y -= Math.floor(a.y); break; case 1001: a.y = 0 > a.y ? 0 : 1; break; case 1002: a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y); }this.flipY && (a.y = 1 - a.y); return a;
        }
      }); Object.defineProperty(Y.prototype, "needsUpdate", { set: function (a) { !0 === a && this.version++; } }); Object.assign(W.prototype, {
        isVector4: !0, set: function (a,
          b, c, d) { this.x = a; this.y = b; this.z = c; this.w = d; return this; }, setScalar: function (a) { this.w = this.z = this.y = this.x = a; return this; }, setX: function (a) { this.x = a; return this; }, setY: function (a) { this.y = a; return this; }, setZ: function (a) { this.z = a; return this; }, setW: function (a) { this.w = a; return this; }, setComponent: function (a, b) { switch (a) { case 0: this.x = b; break; case 1: this.y = b; break; case 2: this.z = b; break; case 3: this.w = b; break; default: throw Error("index is out of range: " + a); }return this; }, getComponent: function (a) {
            switch (a) {
              case 0: return this.x;
              case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw Error("index is out of range: " + a);
            }
          }, clone: function () { return new this.constructor(this.x, this.y, this.z, this.w); }, copy: function (a) { this.x = a.x; this.y = a.y; this.z = a.z; this.w = void 0 !== a.w ? a.w : 1; return this; }, add: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b); this.x += a.x; this.y += a.y; this.z += a.z; this.w += a.w; return this; },
        addScalar: function (a) { this.x += a; this.y += a; this.z += a; this.w += a; return this; }, addVectors: function (a, b) { this.x = a.x + b.x; this.y = a.y + b.y; this.z = a.z + b.z; this.w = a.w + b.w; return this; }, addScaledVector: function (a, b) { this.x += a.x * b; this.y += a.y * b; this.z += a.z * b; this.w += a.w * b; return this; }, sub: function (a, b) { if (void 0 !== b) return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b); this.x -= a.x; this.y -= a.y; this.z -= a.z; this.w -= a.w; return this; }, subScalar: function (a) {
          this.x -=
          a; this.y -= a; this.z -= a; this.w -= a; return this;
        }, subVectors: function (a, b) { this.x = a.x - b.x; this.y = a.y - b.y; this.z = a.z - b.z; this.w = a.w - b.w; return this; }, multiplyScalar: function (a) { this.x *= a; this.y *= a; this.z *= a; this.w *= a; return this; }, applyMatrix4: function (a) { var b = this.x, c = this.y, d = this.z, e = this.w; a = a.elements; this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e; this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e; this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e; this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e; return this; }, divideScalar: function (a) {
          return this.multiplyScalar(1 /
            a);
        }, setAxisAngleFromQuaternion: function (a) { this.w = 2 * Math.acos(a.w); var b = Math.sqrt(1 - a.w * a.w); 1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b); return this; }, setAxisAngleFromRotationMatrix: function (a) {
          a = a.elements; var b = a[0]; var c = a[4]; var d = a[8], e = a[1], f = a[5], g = a[9]; var h = a[2]; var l = a[6]; var m = a[10]; if (.01 > Math.abs(c - e) && .01 > Math.abs(d - h) && .01 > Math.abs(g - l)) {
            if (.1 > Math.abs(c + e) && .1 > Math.abs(d + h) && .1 > Math.abs(g + l) && .1 > Math.abs(b + f + m - 3)) return this.set(1, 0, 0, 0), this; a = Math.PI;
            b = (b + 1) / 2; f = (f + 1) / 2; m = (m + 1) / 2; c = (c + e) / 4; d = (d + h) / 4; g = (g + l) / 4; b > f && b > m ? .01 > b ? (l = 0, c = h = .707106781) : (l = Math.sqrt(b), h = c / l, c = d / l) : f > m ? .01 > f ? (l = .707106781, h = 0, c = .707106781) : (h = Math.sqrt(f), l = c / h, c = g / h) : .01 > m ? (h = l = .707106781, c = 0) : (c = Math.sqrt(m), l = d / c, h = g / c); this.set(l, h, c, a); return this;
          } a = Math.sqrt((l - g) * (l - g) + (d - h) * (d - h) + (e - c) * (e - c)); .001 > Math.abs(a) && (a = 1); this.x = (l - g) / a; this.y = (d - h) / a; this.z = (e - c) / a; this.w = Math.acos((b + f + m - 1) / 2); return this;
        }, min: function (a) {
          this.x = Math.min(this.x, a.x); this.y = Math.min(this.y,
            a.y); this.z = Math.min(this.z, a.z); this.w = Math.min(this.w, a.w); return this;
        }, max: function (a) { this.x = Math.max(this.x, a.x); this.y = Math.max(this.y, a.y); this.z = Math.max(this.z, a.z); this.w = Math.max(this.w, a.w); return this; }, clamp: function (a, b) { this.x = Math.max(a.x, Math.min(b.x, this.x)); this.y = Math.max(a.y, Math.min(b.y, this.y)); this.z = Math.max(a.z, Math.min(b.z, this.z)); this.w = Math.max(a.w, Math.min(b.w, this.w)); return this; }, clampScalar: function () {
          var a, b; return function (c, d) {
            void 0 === a && (a = new W, b = new W); a.set(c,
              c, c, c); b.set(d, d, d, d); return this.clamp(a, b);
          };
        }(), clampLength: function (a, b) { var c = this.length(); return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c))); }, floor: function () { this.x = Math.floor(this.x); this.y = Math.floor(this.y); this.z = Math.floor(this.z); this.w = Math.floor(this.w); return this; }, ceil: function () { this.x = Math.ceil(this.x); this.y = Math.ceil(this.y); this.z = Math.ceil(this.z); this.w = Math.ceil(this.w); return this; }, round: function () {
          this.x = Math.round(this.x); this.y = Math.round(this.y);
          this.z = Math.round(this.z); this.w = Math.round(this.w); return this;
        }, roundToZero: function () { this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x); this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y); this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z); this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w); return this; }, negate: function () { this.x = -this.x; this.y = -this.y; this.z = -this.z; this.w = -this.w; return this; }, dot: function (a) { return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w; }, lengthSq: function () {
          return this.x *
            this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w); }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w); }, normalize: function () { return this.divideScalar(this.length() || 1); }, setLength: function (a) { return this.normalize().multiplyScalar(a); }, lerp: function (a, b) { this.x += (a.x - this.x) * b; this.y += (a.y - this.y) * b; this.z += (a.z - this.z) * b; this.w += (a.w - this.w) * b; return this; }, lerpVectors: function (a,
          b, c) { return this.subVectors(b, a).multiplyScalar(c).add(a); }, equals: function (a) { return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w; }, fromArray: function (a, b) { void 0 === b && (b = 0); this.x = a[b]; this.y = a[b + 1]; this.z = a[b + 2]; this.w = a[b + 3]; return this; }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this.x; a[b + 1] = this.y; a[b + 2] = this.z; a[b + 3] = this.w; return a; }, fromBufferAttribute: function (a, b, c) {
            void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
            this.x = a.getX(b); this.y = a.getY(b); this.z = a.getZ(b); this.w = a.getW(b); return this;
          }
      }); Sa.prototype = Object.assign(Object.create(ta.prototype), {
        constructor: Sa, isWebGLRenderTarget: !0, setSize: function (a, b) { if (this.width !== a || this.height !== b) this.width = a, this.height = b, this.dispose(); this.viewport.set(0, 0, a, b); this.scissor.set(0, 0, a, b); }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) {
          this.width = a.width; this.height = a.height; this.viewport.copy(a.viewport); this.texture = a.texture.clone();
          this.depthBuffer = a.depthBuffer; this.stencilBuffer = a.stencilBuffer; this.depthTexture = a.depthTexture; return this;
        }, dispose: function () { this.dispatchEvent({ type: "dispose" }); }
      }); ce.prototype = Object.assign(Object.create(Sa.prototype), { constructor: ce, isWebGLMultisampleRenderTarget: !0, copy: function (a) { Sa.prototype.copy.call(this, a); this.samples = a.samples; return this; } }); rb.prototype = Object.create(Sa.prototype); rb.prototype.constructor = rb; rb.prototype.isWebGLRenderTargetCube = !0; sb.prototype = Object.create(Y.prototype);
  sb.prototype.constructor = sb; sb.prototype.isDataTexture = !0; Object.assign(Ga.prototype, {
    isBox3: !0, set: function (a, b) { this.min.copy(a); this.max.copy(b); return this; }, setFromArray: function (a) { for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0, l = a.length; h < l; h += 3) { var m = a[h], k = a[h + 1], p = a[h + 2]; m < b && (b = m); k < c && (c = k); p < d && (d = p); m > e && (e = m); k > f && (f = k); p > g && (g = p); } this.min.set(b, c, d); this.max.set(e, f, g); return this; }, setFromBufferAttribute: function (a) {
      for (var b = Infinity, c = Infinity,
        d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0, l = a.count; h < l; h++) { var m = a.getX(h), k = a.getY(h), p = a.getZ(h); m < b && (b = m); k < c && (c = k); p < d && (d = p); m > e && (e = m); k > f && (f = k); p > g && (g = p); } this.min.set(b, c, d); this.max.set(e, f, g); return this;
    }, setFromPoints: function (a) { this.makeEmpty(); for (var b = 0, c = a.length; b < c; b++)this.expandByPoint(a[b]); return this; }, setFromCenterAndSize: function () { var a = new n; return function (b, c) { c = a.copy(c).multiplyScalar(.5); this.min.copy(b).sub(c); this.max.copy(b).add(c); return this; }; }(),
    setFromObject: function (a) { this.makeEmpty(); return this.expandByObject(a); }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { this.min.copy(a.min); this.max.copy(a.max); return this; }, makeEmpty: function () { this.min.x = this.min.y = this.min.z = Infinity; this.max.x = this.max.y = this.max.z = -Infinity; return this; }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z; }, getCenter: function (a) {
      void 0 === a && (console.warn("THREE.Box3: .getCenter() target is now required"),
        a = new n); return this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5);
    }, getSize: function (a) { void 0 === a && (console.warn("THREE.Box3: .getSize() target is now required"), a = new n); return this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min); }, expandByPoint: function (a) { this.min.min(a); this.max.max(a); return this; }, expandByVector: function (a) { this.min.sub(a); this.max.add(a); return this; }, expandByScalar: function (a) { this.min.addScalar(-a); this.max.addScalar(a); return this; }, expandByObject: function () {
      function a(a) {
        var f =
          a.geometry; if (void 0 !== f) if (f.isGeometry) for (f = f.vertices, c = 0, d = f.length; c < d; c++)e.copy(f[c]), e.applyMatrix4(a.matrixWorld), b.expandByPoint(e); else if (f.isBufferGeometry && (f = f.attributes.position, void 0 !== f)) for (c = 0, d = f.count; c < d; c++)e.fromBufferAttribute(f, c).applyMatrix4(a.matrixWorld), b.expandByPoint(e);
      } var b, c, d, e = new n; return function (c) { b = this; c.updateMatrixWorld(!0); c.traverse(a); return this; };
    }(), containsPoint: function (a) {
      return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ||
        a.z < this.min.z || a.z > this.max.z ? !1 : !0;
    }, containsBox: function (a) { return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z; }, getParameter: function (a, b) { void 0 === b && (console.warn("THREE.Box3: .getParameter() target is now required"), b = new n); return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z)); }, intersectsBox: function (a) {
      return a.max.x < this.min.x ||
        a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0;
    }, intersectsSphere: function () { var a = new n; return function (b) { this.clampPoint(b.center, a); return a.distanceToSquared(b.center) <= b.radius * b.radius; }; }(), intersectsPlane: function (a) {
      if (0 < a.normal.x) { var b = a.normal.x * this.min.x; var c = a.normal.x * this.max.x; } else b = a.normal.x * this.max.x, c = a.normal.x * this.min.x; 0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c +=
        a.normal.y * this.min.y); 0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z); return b <= -a.constant && c >= -a.constant;
    }, intersectsTriangle: function () {
      function a(a) { var e; var f = 0; for (e = a.length - 3; f <= e; f += 3) { h.fromArray(a, f); var g = m.x * Math.abs(h.x) + m.y * Math.abs(h.y) + m.z * Math.abs(h.z), l = b.dot(h), k = c.dot(h), q = d.dot(h); if (Math.max(-Math.max(l, k, q), Math.min(l, k, q)) > g) return !1; } return !0; } var b = new n, c = new n, d = new n, e = new n, f = new n, g = new n, h = new n,
        l = new n, m = new n, k = new n; return function (h) { if (this.isEmpty()) return !1; this.getCenter(l); m.subVectors(this.max, l); b.subVectors(h.a, l); c.subVectors(h.b, l); d.subVectors(h.c, l); e.subVectors(c, b); f.subVectors(d, c); g.subVectors(b, d); h = [0, -e.z, e.y, 0, -f.z, f.y, 0, -g.z, g.y, e.z, 0, -e.x, f.z, 0, -f.x, g.z, 0, -g.x, -e.y, e.x, 0, -f.y, f.x, 0, -g.y, g.x, 0]; if (!a(h)) return !1; h = [1, 0, 0, 0, 1, 0, 0, 0, 1]; if (!a(h)) return !1; k.crossVectors(e, f); h = [k.x, k.y, k.z]; return a(h); };
    }(), clampPoint: function (a, b) {
      void 0 === b && (console.warn("THREE.Box3: .clampPoint() target is now required"),
        b = new n); return b.copy(a).clamp(this.min, this.max);
    }, distanceToPoint: function () { var a = new n; return function (b) { return a.copy(b).clamp(this.min, this.max).sub(b).length(); }; }(), getBoundingSphere: function () { var a = new n; return function (b) { void 0 === b && console.error("THREE.Box3: .getBoundingSphere() target is now required"); this.getCenter(b.center); b.radius = .5 * this.getSize(a).length(); return b; }; }(), intersect: function (a) { this.min.max(a.min); this.max.min(a.max); this.isEmpty() && this.makeEmpty(); return this; }, union: function (a) {
      this.min.min(a.min);
      this.max.max(a.max); return this;
    }, applyMatrix4: function () {
      var a = [new n, new n, new n, new n, new n, new n, new n, new n]; return function (b) {
        if (this.isEmpty()) return this; a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b); a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b); a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b); a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b); a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b); a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
        a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b); a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b); this.setFromPoints(a); return this;
      };
    }(), translate: function (a) { this.min.add(a); this.max.add(a); return this; }, equals: function (a) { return a.min.equals(this.min) && a.max.equals(this.max); }
  }); Object.assign(Ta.prototype, {
    set: function (a, b) { this.center.copy(a); this.radius = b; return this; }, setFromPoints: function () {
      var a = new Ga; return function (b, c) {
        var d = this.center; void 0 !== c ? d.copy(c) : a.setFromPoints(b).getCenter(d);
        for (var e = c = 0, f = b.length; e < f; e++)c = Math.max(c, d.distanceToSquared(b[e])); this.radius = Math.sqrt(c); return this;
      };
    }(), clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { this.center.copy(a.center); this.radius = a.radius; return this; }, empty: function () { return 0 >= this.radius; }, containsPoint: function (a) { return a.distanceToSquared(this.center) <= this.radius * this.radius; }, distanceToPoint: function (a) { return a.distanceTo(this.center) - this.radius; }, intersectsSphere: function (a) {
      var b = this.radius +
        a.radius; return a.center.distanceToSquared(this.center) <= b * b;
    }, intersectsBox: function (a) { return a.intersectsSphere(this); }, intersectsPlane: function (a) { return Math.abs(a.distanceToPoint(this.center)) <= this.radius; }, clampPoint: function (a, b) { var c = this.center.distanceToSquared(a); void 0 === b && (console.warn("THREE.Sphere: .clampPoint() target is now required"), b = new n); b.copy(a); c > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center)); return b; }, getBoundingBox: function (a) {
      void 0 ===
      a && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), a = new Ga); a.set(this.center, this.center); a.expandByScalar(this.radius); return a;
    }, applyMatrix4: function (a) { this.center.applyMatrix4(a); this.radius *= a.getMaxScaleOnAxis(); return this; }, translate: function (a) { this.center.add(a); return this; }, equals: function (a) { return a.center.equals(this.center) && a.radius === this.radius; }
  }); Object.assign(Ua.prototype, {
    set: function (a, b) { this.normal.copy(a); this.constant = b; return this; }, setComponents: function (a,
      b, c, d) { this.normal.set(a, b, c); this.constant = d; return this; }, setFromNormalAndCoplanarPoint: function (a, b) { this.normal.copy(a); this.constant = -b.dot(this.normal); return this; }, setFromCoplanarPoints: function () { var a = new n, b = new n; return function (c, d, e) { d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize(); this.setFromNormalAndCoplanarPoint(d, c); return this; }; }(), clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { this.normal.copy(a.normal); this.constant = a.constant; return this; }, normalize: function () {
        var a =
          1 / this.normal.length(); this.normal.multiplyScalar(a); this.constant *= a; return this;
      }, negate: function () { this.constant *= -1; this.normal.negate(); return this; }, distanceToPoint: function (a) { return this.normal.dot(a) + this.constant; }, distanceToSphere: function (a) { return this.distanceToPoint(a.center) - a.radius; }, projectPoint: function (a, b) { void 0 === b && (console.warn("THREE.Plane: .projectPoint() target is now required"), b = new n); return b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a); }, intersectLine: function () {
        var a =
          new n; return function (b, c) { void 0 === c && (console.warn("THREE.Plane: .intersectLine() target is now required"), c = new n); var d = b.delta(a), e = this.normal.dot(d); if (0 === e) { if (0 === this.distanceToPoint(b.start)) return c.copy(b.start); } else if (e = -(b.start.dot(this.normal) + this.constant) / e, !(0 > e || 1 < e)) return c.copy(d).multiplyScalar(e).add(b.start); };
      }(), intersectsLine: function (a) { var b = this.distanceToPoint(a.start); a = this.distanceToPoint(a.end); return 0 > b && 0 < a || 0 > a && 0 < b; }, intersectsBox: function (a) { return a.intersectsPlane(this); },
    intersectsSphere: function (a) { return a.intersectsPlane(this); }, coplanarPoint: function (a) { void 0 === a && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), a = new n); return a.copy(this.normal).multiplyScalar(-this.constant); }, applyMatrix4: function () { var a = new n, b = new na; return function (c, d) { d = d || b.getNormalMatrix(c); c = this.coplanarPoint(a).applyMatrix4(c); d = this.normal.applyMatrix3(d).normalize(); this.constant = -c.dot(d); return this; }; }(), translate: function (a) {
      this.constant -= a.dot(this.normal);
      return this;
    }, equals: function (a) { return a.normal.equals(this.normal) && a.constant === this.constant; }
  }); Object.assign(yd.prototype, {
    set: function (a, b, c, d, e, f) { var g = this.planes; g[0].copy(a); g[1].copy(b); g[2].copy(c); g[3].copy(d); g[4].copy(e); g[5].copy(f); return this; }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { for (var b = this.planes, c = 0; 6 > c; c++)b[c].copy(a.planes[c]); return this; }, setFromMatrix: function (a) {
      var b = this.planes, c = a.elements; a = c[0]; var d = c[1], e = c[2], f = c[3], g = c[4],
        h = c[5], l = c[6], m = c[7], k = c[8], p = c[9], n = c[10], t = c[11], r = c[12], u = c[13], w = c[14]; c = c[15]; b[0].setComponents(f - a, m - g, t - k, c - r).normalize(); b[1].setComponents(f + a, m + g, t + k, c + r).normalize(); b[2].setComponents(f + d, m + h, t + p, c + u).normalize(); b[3].setComponents(f - d, m - h, t - p, c - u).normalize(); b[4].setComponents(f - e, m - l, t - n, c - w).normalize(); b[5].setComponents(f + e, m + l, t + n, c + w).normalize(); return this;
    }, intersectsObject: function () {
      var a = new Ta; return function (b) {
        var c = b.geometry; null === c.boundingSphere && c.computeBoundingSphere();
        a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld); return this.intersectsSphere(a);
      };
    }(), intersectsSprite: function () { var a = new Ta; return function (b) { a.center.set(0, 0, 0); a.radius = .7071067811865476; a.applyMatrix4(b.matrixWorld); return this.intersectsSphere(a); }; }(), intersectsSphere: function (a) { var b = this.planes, c = a.center; a = -a.radius; for (var d = 0; 6 > d; d++)if (b[d].distanceToPoint(c) < a) return !1; return !0; }, intersectsBox: function () {
      var a = new n; return function (b) {
        for (var c = this.planes, d = 0; 6 > d; d++) {
          var e = c[d];
          a.x = 0 < e.normal.x ? b.max.x : b.min.x; a.y = 0 < e.normal.y ? b.max.y : b.min.y; a.z = 0 < e.normal.z ? b.max.z : b.min.z; if (0 > e.distanceToPoint(a)) return !1;
        } return !0;
      };
    }(), containsPoint: function (a) { for (var b = this.planes, c = 0; 6 > c; c++)if (0 > b[c].distanceToPoint(a)) return !1; return !0; }
  }); Object.assign(P.prototype, {
    isMatrix4: !0, set: function (a, b, c, d, e, f, g, h, l, m, k, p, n, t, r, u) { var q = this.elements; q[0] = a; q[4] = b; q[8] = c; q[12] = d; q[1] = e; q[5] = f; q[9] = g; q[13] = h; q[2] = l; q[6] = m; q[10] = k; q[14] = p; q[3] = n; q[7] = t; q[11] = r; q[15] = u; return this; }, identity: function () {
      this.set(1,
        0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); return this;
    }, clone: function () { return (new P).fromArray(this.elements); }, copy: function (a) { var b = this.elements; a = a.elements; b[0] = a[0]; b[1] = a[1]; b[2] = a[2]; b[3] = a[3]; b[4] = a[4]; b[5] = a[5]; b[6] = a[6]; b[7] = a[7]; b[8] = a[8]; b[9] = a[9]; b[10] = a[10]; b[11] = a[11]; b[12] = a[12]; b[13] = a[13]; b[14] = a[14]; b[15] = a[15]; return this; }, copyPosition: function (a) { var b = this.elements; a = a.elements; b[12] = a[12]; b[13] = a[13]; b[14] = a[14]; return this; }, extractBasis: function (a, b, c) {
      a.setFromMatrixColumn(this, 0);
      b.setFromMatrixColumn(this, 1); c.setFromMatrixColumn(this, 2); return this;
    }, makeBasis: function (a, b, c) { this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1); return this; }, extractRotation: function () {
      var a = new n; return function (b) {
        var c = this.elements, d = b.elements, e = 1 / a.setFromMatrixColumn(b, 0).length(), f = 1 / a.setFromMatrixColumn(b, 1).length(); b = 1 / a.setFromMatrixColumn(b, 2).length(); c[0] = d[0] * e; c[1] = d[1] * e; c[2] = d[2] * e; c[3] = 0; c[4] = d[4] * f; c[5] = d[5] * f; c[6] = d[6] * f; c[7] = 0; c[8] = d[8] * b; c[9] = d[9] * b; c[10] = d[10] *
          b; c[11] = 0; c[12] = 0; c[13] = 0; c[14] = 0; c[15] = 1; return this;
      };
    }(), makeRotationFromEuler: function (a) {
      a && a.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c); c = Math.sin(c); var g = Math.cos(d); d = Math.sin(d); var h = Math.cos(e); e = Math.sin(e); if ("XYZ" === a.order) { a = f * h; var l = f * e, m = c * h, k = c * e; b[0] = g * h; b[4] = -g * e; b[8] = d; b[1] = l + m * d; b[5] = a - k * d; b[9] = -c * g; b[2] = k - a * d; b[6] = m + l * d; b[10] = f * g; } else "YXZ" ===
        a.order ? (a = g * h, l = g * e, m = d * h, k = d * e, b[0] = a + k * c, b[4] = m * c - l, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = l * c - m, b[6] = k + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, l = g * e, m = d * h, k = d * e, b[0] = a - k * c, b[4] = -f * e, b[8] = m + l * c, b[1] = l + m * c, b[5] = f * h, b[9] = k - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, l = f * e, m = c * h, k = c * e, b[0] = g * h, b[4] = m * d - l, b[8] = a * d + k, b[1] = g * e, b[5] = k * d + a, b[9] = l * d - m, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, l = f * d, m = c * g, k = c * d, b[0] = g * h, b[4] = k - a * e, b[8] = m * e + l, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = l *
          e + m, b[10] = a - k * e) : "XZY" === a.order && (a = f * g, l = f * d, m = c * g, k = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + k, b[5] = f * h, b[9] = l * e - m, b[2] = m * e - l, b[6] = c * h, b[10] = k * e + a); b[3] = 0; b[7] = 0; b[11] = 0; b[12] = 0; b[13] = 0; b[14] = 0; b[15] = 1; return this;
    }, makeRotationFromQuaternion: function () { var a = new n(0, 0, 0), b = new n(1, 1, 1); return function (c) { return this.compose(a, c, b); }; }(), lookAt: function () {
      var a = new n, b = new n, c = new n; return function (d, e, f) {
        var g = this.elements; c.subVectors(d, e); 0 === c.lengthSq() && (c.z = 1); c.normalize(); a.crossVectors(f,
          c); 0 === a.lengthSq() && (1 === Math.abs(f.z) ? c.x += 1E-4 : c.z += 1E-4, c.normalize(), a.crossVectors(f, c)); a.normalize(); b.crossVectors(c, a); g[0] = a.x; g[4] = b.x; g[8] = c.x; g[1] = a.y; g[5] = b.y; g[9] = c.y; g[2] = a.z; g[6] = b.z; g[10] = c.z; return this;
      };
    }(), multiply: function (a, b) { return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a); }, premultiply: function (a) { return this.multiplyMatrices(a, this); },
    multiplyMatrices: function (a, b) {
      var c = a.elements, d = b.elements; b = this.elements; a = c[0]; var e = c[4], f = c[8], g = c[12], h = c[1], l = c[5], m = c[9], k = c[13], p = c[2], n = c[6], t = c[10], r = c[14], u = c[3], w = c[7], z = c[11]; c = c[15]; var x = d[0], y = d[4], F = d[8], G = d[12], C = d[1], B = d[5], I = d[9], A = d[13], D = d[2], E = d[6], H = d[10], J = d[14], K = d[3], M = d[7], S = d[11]; d = d[15]; b[0] = a * x + e * C + f * D + g * K; b[4] = a * y + e * B + f * E + g * M; b[8] = a * F + e * I + f * H + g * S; b[12] = a * G + e * A + f * J + g * d; b[1] = h * x + l * C + m * D + k * K; b[5] = h * y + l * B + m * E + k * M; b[9] = h * F + l * I + m * H + k * S; b[13] = h * G + l * A + m * J + k * d; b[2] = p * x + n *
        C + t * D + r * K; b[6] = p * y + n * B + t * E + r * M; b[10] = p * F + n * I + t * H + r * S; b[14] = p * G + n * A + t * J + r * d; b[3] = u * x + w * C + z * D + c * K; b[7] = u * y + w * B + z * E + c * M; b[11] = u * F + w * I + z * H + c * S; b[15] = u * G + w * A + z * J + c * d; return this;
    }, multiplyScalar: function (a) { var b = this.elements; b[0] *= a; b[4] *= a; b[8] *= a; b[12] *= a; b[1] *= a; b[5] *= a; b[9] *= a; b[13] *= a; b[2] *= a; b[6] *= a; b[10] *= a; b[14] *= a; b[3] *= a; b[7] *= a; b[11] *= a; b[15] *= a; return this; }, applyToBufferAttribute: function () {
      var a = new n; return function (b) {
        for (var c = 0, d = b.count; c < d; c++)a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c),
          a.applyMatrix4(this), b.setXYZ(c, a.x, a.y, a.z); return b;
      };
    }(), determinant: function () { var a = this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], h = a[9], l = a[13], m = a[2], k = a[6], p = a[10], n = a[14]; return a[3] * (+e * h * k - d * l * k - e * g * p + c * l * p + d * g * n - c * h * n) + a[7] * (+b * h * n - b * l * p + e * f * p - d * f * n + d * l * m - e * h * m) + a[11] * (+b * l * k - b * g * n - e * f * k + c * f * n + e * g * m - c * l * m) + a[15] * (-d * g * m - b * h * k + b * g * p + d * f * k - c * f * p + c * h * m); }, transpose: function () {
      var a = this.elements; var b = a[1]; a[1] = a[4]; a[4] = b; b = a[2]; a[2] = a[8]; a[8] = b; b = a[6]; a[6] = a[9]; a[9] = b; b = a[3]; a[3] =
        a[12]; a[12] = b; b = a[7]; a[7] = a[13]; a[13] = b; b = a[11]; a[11] = a[14]; a[14] = b; return this;
    }, setPosition: function (a) { var b = this.elements; b[12] = a.x; b[13] = a.y; b[14] = a.z; return this; }, getInverse: function (a, b) {
      var c = this.elements, d = a.elements; a = d[0]; var e = d[1], f = d[2], g = d[3], h = d[4], l = d[5], m = d[6], k = d[7], p = d[8], n = d[9], t = d[10], r = d[11], u = d[12], w = d[13], z = d[14]; d = d[15]; var x = n * z * k - w * t * k + w * m * r - l * z * r - n * m * d + l * t * d, y = u * t * k - p * z * k - u * m * r + h * z * r + p * m * d - h * t * d, F = p * w * k - u * n * k + u * l * r - h * w * r - p * l * d + h * n * d, G = u * n * m - p * w * m - u * l * t + h * w * t + p * l * z - h * n *
        z, C = a * x + e * y + f * F + g * G; if (0 === C) { if (!0 === b) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"); console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"); return this.identity(); } b = 1 / C; c[0] = x * b; c[1] = (w * t * g - n * z * g - w * f * r + e * z * r + n * f * d - e * t * d) * b; c[2] = (l * z * g - w * m * g + w * f * k - e * z * k - l * f * d + e * m * d) * b; c[3] = (n * m * g - l * t * g - n * f * k + e * t * k + l * f * r - e * m * r) * b; c[4] = y * b; c[5] = (p * z * g - u * t * g + u * f * r - a * z * r - p * f * d + a * t * d) * b; c[6] = (u * m * g - h * z * g - u * f * k + a * z * k + h * f * d - a * m * d) * b; c[7] = (h * t * g - p * m * g + p * f * k -
          a * t * k - h * f * r + a * m * r) * b; c[8] = F * b; c[9] = (u * n * g - p * w * g - u * e * r + a * w * r + p * e * d - a * n * d) * b; c[10] = (h * w * g - u * l * g + u * e * k - a * w * k - h * e * d + a * l * d) * b; c[11] = (p * l * g - h * n * g - p * e * k + a * n * k + h * e * r - a * l * r) * b; c[12] = G * b; c[13] = (p * w * f - u * n * f + u * e * t - a * w * t - p * e * z + a * n * z) * b; c[14] = (u * l * f - h * w * f - u * e * m + a * w * m + h * e * z - a * l * z) * b; c[15] = (h * n * f - p * l * f + p * e * m - a * n * m - h * e * t + a * l * t) * b; return this;
    }, scale: function (a) { var b = this.elements, c = a.x, d = a.y; a = a.z; b[0] *= c; b[4] *= d; b[8] *= a; b[1] *= c; b[5] *= d; b[9] *= a; b[2] *= c; b[6] *= d; b[10] *= a; b[3] *= c; b[7] *= d; b[11] *= a; return this; }, getMaxScaleOnAxis: function () {
      var a =
        this.elements; return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]));
    }, makeTranslation: function (a, b, c) { this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1); return this; }, makeRotationX: function (a) { var b = Math.cos(a); a = Math.sin(a); this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1); return this; }, makeRotationY: function (a) { var b = Math.cos(a); a = Math.sin(a); this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1); return this; }, makeRotationZ: function (a) {
      var b = Math.cos(a); a = Math.sin(a);
      this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); return this;
    }, makeRotationAxis: function (a, b) { var c = Math.cos(b); b = Math.sin(b); var d = 1 - c, e = a.x, f = a.y; a = a.z; var g = d * e, h = d * f; this.set(g * e + c, g * f - b * a, g * a + b * f, 0, g * f + b * a, h * f + c, h * a - b * e, 0, g * a - b * f, h * a + b * e, d * a * a + c, 0, 0, 0, 0, 1); return this; }, makeScale: function (a, b, c) { this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1); return this; }, makeShear: function (a, b, c) { this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1); return this; }, compose: function (a, b, c) {
      var d = this.elements, e = b._x, f = b._y, g = b._z, h = b._w,
      l = e + e, m = f + f, k = g + g; b = e * l; var p = e * m; e *= k; var n = f * m; f *= k; g *= k; l *= h; m *= h; h *= k; k = c.x; var t = c.y; c = c.z; d[0] = (1 - (n + g)) * k; d[1] = (p + h) * k; d[2] = (e - m) * k; d[3] = 0; d[4] = (p - h) * t; d[5] = (1 - (b + g)) * t; d[6] = (f + l) * t; d[7] = 0; d[8] = (e + m) * c; d[9] = (f - l) * c; d[10] = (1 - (b + n)) * c; d[11] = 0; d[12] = a.x; d[13] = a.y; d[14] = a.z; d[15] = 1; return this;
    }, decompose: function () {
      var a = new n, b = new P; return function (c, d, e) {
        var f = this.elements, g = a.set(f[0], f[1], f[2]).length(), h = a.set(f[4], f[5], f[6]).length(), l = a.set(f[8], f[9], f[10]).length(); 0 > this.determinant() &&
          (g = -g); c.x = f[12]; c.y = f[13]; c.z = f[14]; b.copy(this); c = 1 / g; f = 1 / h; var m = 1 / l; b.elements[0] *= c; b.elements[1] *= c; b.elements[2] *= c; b.elements[4] *= f; b.elements[5] *= f; b.elements[6] *= f; b.elements[8] *= m; b.elements[9] *= m; b.elements[10] *= m; d.setFromRotationMatrix(b); e.x = g; e.y = h; e.z = l; return this;
      };
    }(), makePerspective: function (a, b, c, d, e, f) {
      void 0 === f && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); var g = this.elements; g[0] = 2 * e / (b - a); g[4] = 0; g[8] =
        (b + a) / (b - a); g[12] = 0; g[1] = 0; g[5] = 2 * e / (c - d); g[9] = (c + d) / (c - d); g[13] = 0; g[2] = 0; g[6] = 0; g[10] = -(f + e) / (f - e); g[14] = -2 * f * e / (f - e); g[3] = 0; g[7] = 0; g[11] = -1; g[15] = 0; return this;
    }, makeOrthographic: function (a, b, c, d, e, f) { var g = this.elements, h = 1 / (b - a), l = 1 / (c - d), m = 1 / (f - e); g[0] = 2 * h; g[4] = 0; g[8] = 0; g[12] = -((b + a) * h); g[1] = 0; g[5] = 2 * l; g[9] = 0; g[13] = -((c + d) * l); g[2] = 0; g[6] = 0; g[10] = -2 * m; g[14] = -((f + e) * m); g[3] = 0; g[7] = 0; g[11] = 0; g[15] = 1; return this; }, equals: function (a) {
      var b = this.elements; a = a.elements; for (var c = 0; 16 > c; c++)if (b[c] !== a[c]) return !1;
      return !0;
    }, fromArray: function (a, b) { void 0 === b && (b = 0); for (var c = 0; 16 > c; c++)this.elements[c] = a[c + b]; return this; }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); var c = this.elements; a[b] = c[0]; a[b + 1] = c[1]; a[b + 2] = c[2]; a[b + 3] = c[3]; a[b + 4] = c[4]; a[b + 5] = c[5]; a[b + 6] = c[6]; a[b + 7] = c[7]; a[b + 8] = c[8]; a[b + 9] = c[9]; a[b + 10] = c[10]; a[b + 11] = c[11]; a[b + 12] = c[12]; a[b + 13] = c[13]; a[b + 14] = c[14]; a[b + 15] = c[15]; return a; }
  }); var R = {
    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
    color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
    defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
    envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
    envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
    envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
    fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
    gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
    lights_pars_begin: "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif", map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
    normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif",
    normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
    uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
    uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
    cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}", shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
  },
    nh = { clone: Rb, merge: ya }, oh = {
      aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643,
      darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055,
      grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184,
      lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130,
      palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780,
      teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074
    }; Object.assign(A.prototype, {
      isColor: !0, r: 1, g: 1, b: 1, set: function (a) { a && a.isColor ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a); return this; }, setScalar: function (a) { this.b = this.g = this.r = a; return this; }, setHex: function (a) {
        a = Math.floor(a); this.r = (a >> 16 & 255) / 255; this.g = (a >> 8 & 255) / 255; this.b = (a & 255) / 255;
        return this;
      }, setRGB: function (a, b, c) { this.r = a; this.g = b; this.b = c; return this; }, setHSL: function () { function a(a, c, d) { 0 > d && (d += 1); 1 < d && --d; return d < 1 / 6 ? a + 6 * (c - a) * d : .5 > d ? c : d < 2 / 3 ? a + 6 * (c - a) * (2 / 3 - d) : a; } return function (b, c, d) { b = O.euclideanModulo(b, 1); c = O.clamp(c, 0, 1); d = O.clamp(d, 0, 1); 0 === c ? this.r = this.g = this.b = d : (c = .5 >= d ? d * (1 + c) : d + c - d * c, d = 2 * d - c, this.r = a(d, c, b + 1 / 3), this.g = a(d, c, b), this.b = a(d, c, b - 1 / 3)); return this; }; }(), setStyle: function (a) {
        function b(b) {
          void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " +
            a + " will be ignored.");
        } var c; if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
          var d = c[2]; switch (c[1]) {
            case "rgb": case "rgba": if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(255, parseInt(c[1], 10)) / 255, this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255, parseInt(c[3], 10)) / 255, b(c[5]), this; if (c = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(100, parseInt(c[1], 10)) / 100, this.g = Math.min(100, parseInt(c[2],
              10)) / 100, this.b = Math.min(100, parseInt(c[3], 10)) / 100, b(c[5]), this; break; case "hsl": case "hsla": if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) { d = parseFloat(c[1]) / 360; var e = parseInt(c[2], 10) / 100, f = parseInt(c[3], 10) / 100; b(c[5]); return this.setHSL(d, e, f); }
          }
        } else if (c = /^#([A-Fa-f0-9]+)$/.exec(a)) {
          c = c[1]; d = c.length; if (3 === d) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2),
            16) / 255, this; if (6 === d) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this;
        } a && 0 < a.length && (c = oh[a], void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + a)); return this;
      }, clone: function () { return new this.constructor(this.r, this.g, this.b); }, copy: function (a) { this.r = a.r; this.g = a.g; this.b = a.b; return this; }, copyGammaToLinear: function (a, b) {
        void 0 === b && (b = 2); this.r = Math.pow(a.r, b); this.g = Math.pow(a.g,
          b); this.b = Math.pow(a.b, b); return this;
      }, copyLinearToGamma: function (a, b) { void 0 === b && (b = 2); b = 0 < b ? 1 / b : 1; this.r = Math.pow(a.r, b); this.g = Math.pow(a.g, b); this.b = Math.pow(a.b, b); return this; }, convertGammaToLinear: function (a) { this.copyGammaToLinear(this, a); return this; }, convertLinearToGamma: function (a) { this.copyLinearToGamma(this, a); return this; }, copySRGBToLinear: function () {
        function a(a) { return .04045 > a ? .0773993808 * a : Math.pow(.9478672986 * a + .0521327014, 2.4); } return function (b) {
          this.r = a(b.r); this.g = a(b.g); this.b =
            a(b.b); return this;
        };
      }(), copyLinearToSRGB: function () { function a(a) { return .0031308 > a ? 12.92 * a : 1.055 * Math.pow(a, .41666) - .055; } return function (b) { this.r = a(b.r); this.g = a(b.g); this.b = a(b.b); return this; }; }(), convertSRGBToLinear: function () { this.copySRGBToLinear(this); return this; }, convertLinearToSRGB: function () { this.copyLinearToSRGB(this); return this; }, getHex: function () { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0; }, getHexString: function () { return ("000000" + this.getHex().toString(16)).slice(-6); }, getHSL: function (a) {
        void 0 ===
        a && (console.warn("THREE.Color: .getHSL() target is now required"), a = { h: 0, s: 0, l: 0 }); var b = this.r, c = this.g, d = this.b, e = Math.max(b, c, d), f = Math.min(b, c, d), g, h = (f + e) / 2; if (f === e) f = g = 0; else { var l = e - f; f = .5 >= h ? l / (e + f) : l / (2 - e - f); switch (e) { case b: g = (c - d) / l + (c < d ? 6 : 0); break; case c: g = (d - b) / l + 2; break; case d: g = (b - c) / l + 4; }g /= 6; } a.h = g; a.s = f; a.l = h; return a;
      }, getStyle: function () { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"; }, offsetHSL: function () {
        var a = {}; return function (b, c, d) {
          this.getHSL(a); a.h +=
            b; a.s += c; a.l += d; this.setHSL(a.h, a.s, a.l); return this;
        };
      }(), add: function (a) { this.r += a.r; this.g += a.g; this.b += a.b; return this; }, addColors: function (a, b) { this.r = a.r + b.r; this.g = a.g + b.g; this.b = a.b + b.b; return this; }, addScalar: function (a) { this.r += a; this.g += a; this.b += a; return this; }, sub: function (a) { this.r = Math.max(0, this.r - a.r); this.g = Math.max(0, this.g - a.g); this.b = Math.max(0, this.b - a.b); return this; }, multiply: function (a) { this.r *= a.r; this.g *= a.g; this.b *= a.b; return this; }, multiplyScalar: function (a) {
        this.r *= a; this.g *=
          a; this.b *= a; return this;
      }, lerp: function (a, b) { this.r += (a.r - this.r) * b; this.g += (a.g - this.g) * b; this.b += (a.b - this.b) * b; return this; }, lerpHSL: function () { var a = { h: 0, s: 0, l: 0 }, b = { h: 0, s: 0, l: 0 }; return function (c, d) { this.getHSL(a); c.getHSL(b); c = O.lerp(a.h, b.h, d); var e = O.lerp(a.s, b.s, d); d = O.lerp(a.l, b.l, d); this.setHSL(c, e, d); return this; }; }(), equals: function (a) { return a.r === this.r && a.g === this.g && a.b === this.b; }, fromArray: function (a, b) { void 0 === b && (b = 0); this.r = a[b]; this.g = a[b + 1]; this.b = a[b + 2]; return this; }, toArray: function (a,
        b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this.r; a[b + 1] = this.g; a[b + 2] = this.b; return a; }, toJSON: function () { return this.getHex(); }
    }); var J = {
      common: { diffuse: { value: new A(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new na }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: {
        lightMap: { value: null },
        lightMapIntensity: { value: 1 }
      }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new C(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 2.5E-4 }, fogNear: { value: 1 }, fogFar: { value: 2E3 }, fogColor: { value: new A(16777215) } },
      lights: {
        ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: {
          value: [], properties: {
            color: {},
            position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {}
          }
        }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }
      }, points: { diffuse: { value: new A(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, uvTransform: { value: new na } }, sprite: {
        diffuse: { value: new A(15658734) },
        opacity: { value: 1 }, center: { value: new C(.5, .5) }, rotation: { value: 0 }, map: { value: null }, uvTransform: { value: new na }
      }
    }, Va = {
      basic: { uniforms: ya([J.common, J.specularmap, J.envmap, J.aomap, J.lightmap, J.fog]), vertexShader: R.meshbasic_vert, fragmentShader: R.meshbasic_frag }, lambert: { uniforms: ya([J.common, J.specularmap, J.envmap, J.aomap, J.lightmap, J.emissivemap, J.fog, J.lights, { emissive: { value: new A(0) } }]), vertexShader: R.meshlambert_vert, fragmentShader: R.meshlambert_frag }, phong: {
        uniforms: ya([J.common, J.specularmap, J.envmap,
        J.aomap, J.lightmap, J.emissivemap, J.bumpmap, J.normalmap, J.displacementmap, J.gradientmap, J.fog, J.lights, { emissive: { value: new A(0) }, specular: { value: new A(1118481) }, shininess: { value: 30 } }]), vertexShader: R.meshphong_vert, fragmentShader: R.meshphong_frag
      }, standard: {
        uniforms: ya([J.common, J.envmap, J.aomap, J.lightmap, J.emissivemap, J.bumpmap, J.normalmap, J.displacementmap, J.roughnessmap, J.metalnessmap, J.fog, J.lights, { emissive: { value: new A(0) }, roughness: { value: .5 }, metalness: { value: .5 }, envMapIntensity: { value: 1 } }]),
        vertexShader: R.meshphysical_vert, fragmentShader: R.meshphysical_frag
      }, matcap: { uniforms: ya([J.common, J.bumpmap, J.normalmap, J.displacementmap, J.fog, { matcap: { value: null } }]), vertexShader: R.meshmatcap_vert, fragmentShader: R.meshmatcap_frag }, points: { uniforms: ya([J.points, J.fog]), vertexShader: R.points_vert, fragmentShader: R.points_frag }, dashed: { uniforms: ya([J.common, J.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: R.linedashed_vert, fragmentShader: R.linedashed_frag }, depth: {
        uniforms: ya([J.common,
        J.displacementmap]), vertexShader: R.depth_vert, fragmentShader: R.depth_frag
      }, normal: { uniforms: ya([J.common, J.bumpmap, J.normalmap, J.displacementmap, { opacity: { value: 1 } }]), vertexShader: R.normal_vert, fragmentShader: R.normal_frag }, sprite: { uniforms: ya([J.sprite, J.fog]), vertexShader: R.sprite_vert, fragmentShader: R.sprite_frag }, background: { uniforms: { uvTransform: { value: new na }, t2D: { value: null } }, vertexShader: R.background_vert, fragmentShader: R.background_frag }, cube: {
        uniforms: {
          tCube: { value: null }, tFlip: { value: -1 },
          opacity: { value: 1 }
        }, vertexShader: R.cube_vert, fragmentShader: R.cube_frag
      }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: R.equirect_vert, fragmentShader: R.equirect_frag }, distanceRGBA: { uniforms: ya([J.common, J.displacementmap, { referencePosition: { value: new n }, nearDistance: { value: 1 }, farDistance: { value: 1E3 } }]), vertexShader: R.distanceRGBA_vert, fragmentShader: R.distanceRGBA_frag }, shadow: { uniforms: ya([J.lights, J.fog, { color: { value: new A(0) }, opacity: { value: 1 } }]), vertexShader: R.shadow_vert, fragmentShader: R.shadow_frag }
    };
  Va.physical = { uniforms: ya([Va.standard.uniforms, { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }]), vertexShader: R.meshphysical_vert, fragmentShader: R.meshphysical_frag }; Object.assign(Sb.prototype, {
    clone: function () { return (new this.constructor).copy(this); }, copy: function (a) {
      this.a = a.a; this.b = a.b; this.c = a.c; this.normal.copy(a.normal); this.color.copy(a.color); this.materialIndex = a.materialIndex; for (var b = 0, c = a.vertexNormals.length; b < c; b++)this.vertexNormals[b] = a.vertexNormals[b].clone(); b = 0; for (c = a.vertexColors.length; b <
        c; b++)this.vertexColors[b] = a.vertexColors[b].clone(); return this;
    }
  }); tb.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "); tb.DefaultOrder = "XYZ"; Object.defineProperties(tb.prototype, {
    x: { get: function () { return this._x; }, set: function (a) { this._x = a; this.onChangeCallback(); } }, y: { get: function () { return this._y; }, set: function (a) { this._y = a; this.onChangeCallback(); } }, z: { get: function () { return this._z; }, set: function (a) { this._z = a; this.onChangeCallback(); } }, order: {
      get: function () { return this._order; }, set: function (a) {
        this._order =
        a; this.onChangeCallback();
      }
    }
  }); Object.assign(tb.prototype, {
    isEuler: !0, set: function (a, b, c, d) { this._x = a; this._y = b; this._z = c; this._order = d || this._order; this.onChangeCallback(); return this; }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._order); }, copy: function (a) { this._x = a._x; this._y = a._y; this._z = a._z; this._order = a._order; this.onChangeCallback(); return this; }, setFromRotationMatrix: function (a, b, c) {
      var d = O.clamp, e = a.elements; a = e[0]; var f = e[4], g = e[8], h = e[1], l = e[5], m = e[9], k = e[2], p =
        e[6]; e = e[10]; b = b || this._order; "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-m, e), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(p, l), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(m, -1, 1)), .99999 > Math.abs(m) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, l)) : (this._y = Math.atan2(-k, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(p, -1, 1)), .99999 > Math.abs(p) ? (this._y = Math.atan2(-k, e), this._z = Math.atan2(-f, l)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(k,
          -1, 1)), .99999 > Math.abs(k) ? (this._x = Math.atan2(p, e), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-f, l))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(-m, l), this._y = Math.atan2(-k, a)) : (this._x = 0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(p, l), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-m, e), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b); this._order =
            b; if (!1 !== c) this.onChangeCallback(); return this;
    }, setFromQuaternion: function () { var a = new P; return function (b, c, d) { a.makeRotationFromQuaternion(b); return this.setFromRotationMatrix(a, c, d); }; }(), setFromVector3: function (a, b) { return this.set(a.x, a.y, a.z, b || this._order); }, reorder: function () { var a = new ma; return function (b) { a.setFromEuler(this); return this.setFromQuaternion(a, b); }; }(), equals: function (a) { return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order; }, fromArray: function (a) {
      this._x =
      a[0]; this._y = a[1]; this._z = a[2]; void 0 !== a[3] && (this._order = a[3]); this.onChangeCallback(); return this;
    }, toArray: function (a, b) { void 0 === a && (a = []); void 0 === b && (b = 0); a[b] = this._x; a[b + 1] = this._y; a[b + 2] = this._z; a[b + 3] = this._order; return a; }, toVector3: function (a) { return a ? a.set(this._x, this._y, this._z) : new n(this._x, this._y, this._z); }, onChange: function (a) { this.onChangeCallback = a; return this; }, onChangeCallback: function () { }
  }); Object.assign(ee.prototype, {
    set: function (a) { this.mask = 1 << a | 0; }, enable: function (a) {
      this.mask =
      this.mask | 1 << a | 0;
    }, toggle: function (a) { this.mask ^= 1 << a | 0; }, disable: function (a) { this.mask &= ~(1 << a | 0); }, test: function (a) { return 0 !== (this.mask & a.mask); }
  }); var $f = 0; D.DefaultUp = new n(0, 1, 0); D.DefaultMatrixAutoUpdate = !0; D.prototype = Object.assign(Object.create(ta.prototype), {
    constructor: D, isObject3D: !0, onBeforeRender: function () { }, onAfterRender: function () { }, applyMatrix: function (a) { this.matrixAutoUpdate && this.updateMatrix(); this.matrix.premultiply(a); this.matrix.decompose(this.position, this.quaternion, this.scale); },
    applyQuaternion: function (a) { this.quaternion.premultiply(a); return this; }, setRotationFromAxisAngle: function (a, b) { this.quaternion.setFromAxisAngle(a, b); }, setRotationFromEuler: function (a) { this.quaternion.setFromEuler(a, !0); }, setRotationFromMatrix: function (a) { this.quaternion.setFromRotationMatrix(a); }, setRotationFromQuaternion: function (a) { this.quaternion.copy(a); }, rotateOnAxis: function () { var a = new ma; return function (b, c) { a.setFromAxisAngle(b, c); this.quaternion.multiply(a); return this; }; }(), rotateOnWorldAxis: function () {
      var a =
        new ma; return function (b, c) { a.setFromAxisAngle(b, c); this.quaternion.premultiply(a); return this; };
    }(), rotateX: function () { var a = new n(1, 0, 0); return function (b) { return this.rotateOnAxis(a, b); }; }(), rotateY: function () { var a = new n(0, 1, 0); return function (b) { return this.rotateOnAxis(a, b); }; }(), rotateZ: function () { var a = new n(0, 0, 1); return function (b) { return this.rotateOnAxis(a, b); }; }(), translateOnAxis: function () {
      var a = new n; return function (b, c) {
        a.copy(b).applyQuaternion(this.quaternion); this.position.add(a.multiplyScalar(c));
        return this;
      };
    }(), translateX: function () { var a = new n(1, 0, 0); return function (b) { return this.translateOnAxis(a, b); }; }(), translateY: function () { var a = new n(0, 1, 0); return function (b) { return this.translateOnAxis(a, b); }; }(), translateZ: function () { var a = new n(0, 0, 1); return function (b) { return this.translateOnAxis(a, b); }; }(), localToWorld: function (a) { return a.applyMatrix4(this.matrixWorld); }, worldToLocal: function () { var a = new P; return function (b) { return b.applyMatrix4(a.getInverse(this.matrixWorld)); }; }(), lookAt: function () {
      var a =
        new ma, b = new P, c = new n, d = new n; return function (e, f, g) { e.isVector3 ? c.copy(e) : c.set(e, f, g); e = this.parent; this.updateWorldMatrix(!0, !1); d.setFromMatrixPosition(this.matrixWorld); this.isCamera || this.isLight ? b.lookAt(d, c, this.up) : b.lookAt(c, d, this.up); this.quaternion.setFromRotationMatrix(b); e && (b.extractRotation(e.matrixWorld), a.setFromRotationMatrix(b), this.quaternion.premultiply(a.inverse())); };
    }(), add: function (a) {
      if (1 < arguments.length) { for (var b = 0; b < arguments.length; b++)this.add(arguments[b]); return this; } if (a ===
        this) return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this; a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({ type: "added" }), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a); return this;
    }, remove: function (a) {
      if (1 < arguments.length) { for (var b = 0; b < arguments.length; b++)this.remove(arguments[b]); return this; } b = this.children.indexOf(a); -1 !== b && (a.parent = null, a.dispatchEvent({ type: "removed" }),
        this.children.splice(b, 1)); return this;
    }, getObjectById: function (a) { return this.getObjectByProperty("id", a); }, getObjectByName: function (a) { return this.getObjectByProperty("name", a); }, getObjectByProperty: function (a, b) { if (this[a] === b) return this; for (var c = 0, d = this.children.length; c < d; c++) { var e = this.children[c].getObjectByProperty(a, b); if (void 0 !== e) return e; } }, getWorldPosition: function (a) {
      void 0 === a && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), a = new n); this.updateMatrixWorld(!0);
      return a.setFromMatrixPosition(this.matrixWorld);
    }, getWorldQuaternion: function () { var a = new n, b = new n; return function (c) { void 0 === c && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), c = new ma); this.updateMatrixWorld(!0); this.matrixWorld.decompose(a, c, b); return c; }; }(), getWorldScale: function () {
      var a = new n, b = new ma; return function (c) {
        void 0 === c && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), c = new n); this.updateMatrixWorld(!0); this.matrixWorld.decompose(a,
          b, c); return c;
      };
    }(), getWorldDirection: function (a) { void 0 === a && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), a = new n); this.updateMatrixWorld(!0); var b = this.matrixWorld.elements; return a.set(b[8], b[9], b[10]).normalize(); }, raycast: function () { }, traverse: function (a) { a(this); for (var b = this.children, c = 0, d = b.length; c < d; c++)b[c].traverse(a); }, traverseVisible: function (a) { if (!1 !== this.visible) { a(this); for (var b = this.children, c = 0, d = b.length; c < d; c++)b[c].traverseVisible(a); } }, traverseAncestors: function (a) {
      var b =
        this.parent; null !== b && (a(b), b.traverseAncestors(a));
    }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale); this.matrixWorldNeedsUpdate = !0; }, updateMatrixWorld: function (a) { this.matrixAutoUpdate && this.updateMatrix(); if (this.matrixWorldNeedsUpdate || a) null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0; for (var b = this.children, c = 0, d = b.length; c < d; c++)b[c].updateMatrixWorld(a); },
    updateWorldMatrix: function (a, b) { var c = this.parent; !0 === a && null !== c && c.updateWorldMatrix(!0, !1); this.matrixAutoUpdate && this.updateMatrix(); null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix); if (!0 === b) for (a = this.children, b = 0, c = a.length; b < c; b++)a[b].updateWorldMatrix(!1, !0); }, toJSON: function (a) {
      function b(b, c) { void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a)); return c.uuid; } function c(a) {
        var b = [], c; for (c in a) {
          var d = a[c]; delete d.metadata;
          b.push(d);
        } return b;
      } var d = void 0 === a || "string" === typeof a, e = {}; d && (a = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, e.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); var f = {}; f.uuid = this.uuid; f.type = this.type; "" !== this.name && (f.name = this.name); !0 === this.castShadow && (f.castShadow = !0); !0 === this.receiveShadow && (f.receiveShadow = !0); !1 === this.visible && (f.visible = !1); !1 === this.frustumCulled && (f.frustumCulled = !1); 0 !== this.renderOrder && (f.renderOrder = this.renderOrder); "{}" !==
        JSON.stringify(this.userData) && (f.userData = this.userData); f.layers = this.layers.mask; f.matrix = this.matrix.toArray(); !1 === this.matrixAutoUpdate && (f.matrixAutoUpdate = !1); this.isMesh && 0 !== this.drawMode && (f.drawMode = this.drawMode); if (this.isMesh || this.isLine || this.isPoints) { f.geometry = b(a.geometries, this.geometry); var g = this.geometry.parameters; if (void 0 !== g && void 0 !== g.shapes) if (g = g.shapes, Array.isArray(g)) for (var h = 0, l = g.length; h < l; h++)b(a.shapes, g[h]); else b(a.shapes, g); } if (void 0 !== this.material) if (Array.isArray(this.material)) {
          g =
          []; h = 0; for (l = this.material.length; h < l; h++)g.push(b(a.materials, this.material[h])); f.material = g;
        } else f.material = b(a.materials, this.material); if (0 < this.children.length) for (f.children = [], h = 0; h < this.children.length; h++)f.children.push(this.children[h].toJSON(a).object); if (d) { d = c(a.geometries); h = c(a.materials); l = c(a.textures); var m = c(a.images); g = c(a.shapes); 0 < d.length && (e.geometries = d); 0 < h.length && (e.materials = h); 0 < l.length && (e.textures = l); 0 < m.length && (e.images = m); 0 < g.length && (e.shapes = g); } e.object = f; return e;
    },
    clone: function (a) { return (new this.constructor).copy(this, a); }, copy: function (a, b) {
      void 0 === b && (b = !0); this.name = a.name; this.up.copy(a.up); this.position.copy(a.position); this.quaternion.copy(a.quaternion); this.scale.copy(a.scale); this.matrix.copy(a.matrix); this.matrixWorld.copy(a.matrixWorld); this.matrixAutoUpdate = a.matrixAutoUpdate; this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate; this.layers.mask = a.layers.mask; this.visible = a.visible; this.castShadow = a.castShadow; this.receiveShadow = a.receiveShadow;
      this.frustumCulled = a.frustumCulled; this.renderOrder = a.renderOrder; this.userData = JSON.parse(JSON.stringify(a.userData)); if (!0 === b) for (b = 0; b < a.children.length; b++)this.add(a.children[b].clone()); return this;
    }
  }); var ag = 0; K.prototype = Object.assign(Object.create(ta.prototype), {
    constructor: K, isGeometry: !0, applyMatrix: function (a) {
      for (var b = (new na).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++)this.vertices[c].applyMatrix4(a); c = 0; for (d = this.faces.length; c < d; c++) {
        a = this.faces[c]; a.normal.applyMatrix3(b).normalize();
        for (var e = 0, f = a.vertexNormals.length; e < f; e++)a.vertexNormals[e].applyMatrix3(b).normalize();
      } null !== this.boundingBox && this.computeBoundingBox(); null !== this.boundingSphere && this.computeBoundingSphere(); this.normalsNeedUpdate = this.verticesNeedUpdate = !0; return this;
    }, rotateX: function () { var a = new P; return function (b) { a.makeRotationX(b); this.applyMatrix(a); return this; }; }(), rotateY: function () { var a = new P; return function (b) { a.makeRotationY(b); this.applyMatrix(a); return this; }; }(), rotateZ: function () {
      var a = new P;
      return function (b) { a.makeRotationZ(b); this.applyMatrix(a); return this; };
    }(), translate: function () { var a = new P; return function (b, c, d) { a.makeTranslation(b, c, d); this.applyMatrix(a); return this; }; }(), scale: function () { var a = new P; return function (b, c, d) { a.makeScale(b, c, d); this.applyMatrix(a); return this; }; }(), lookAt: function () { var a = new D; return function (b) { a.lookAt(b); a.updateMatrix(); this.applyMatrix(a.matrix); }; }(), fromBufferGeometry: function (a) {
      function b(a, b, d, e) {
        var f = void 0 === h ? [] : [c.colors[a].clone(), c.colors[b].clone(),
        c.colors[d].clone()], k = void 0 === g ? [] : [(new n).fromArray(g, 3 * a), (new n).fromArray(g, 3 * b), (new n).fromArray(g, 3 * d)]; e = new Sb(a, b, d, k, f, e); c.faces.push(e); void 0 !== l && c.faceVertexUvs[0].push([(new C).fromArray(l, 2 * a), (new C).fromArray(l, 2 * b), (new C).fromArray(l, 2 * d)]); void 0 !== m && c.faceVertexUvs[1].push([(new C).fromArray(m, 2 * a), (new C).fromArray(m, 2 * b), (new C).fromArray(m, 2 * d)]);
      } var c = this, d = null !== a.index ? a.index.array : void 0, e = a.attributes, f = e.position.array, g = void 0 !== e.normal ? e.normal.array : void 0,
        h = void 0 !== e.color ? e.color.array : void 0, l = void 0 !== e.uv ? e.uv.array : void 0, m = void 0 !== e.uv2 ? e.uv2.array : void 0; void 0 !== m && (this.faceVertexUvs[1] = []); for (var k = e = 0; e < f.length; e += 3, k += 2)c.vertices.push((new n).fromArray(f, e)), void 0 !== h && c.colors.push((new A).fromArray(h, e)); var p = a.groups; if (0 < p.length) for (e = 0; e < p.length; e++) { f = p[e]; var v = f.start, t = f.count; k = v; for (v += t; k < v; k += 3)void 0 !== d ? b(d[k], d[k + 1], d[k + 2], f.materialIndex) : b(k, k + 1, k + 2, f.materialIndex); } else if (void 0 !== d) for (e = 0; e < d.length; e += 3)b(d[e],
          d[e + 1], d[e + 2]); else for (e = 0; e < f.length / 3; e += 3)b(e, e + 1, e + 2); this.computeFaceNormals(); null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()); null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()); return this;
    }, center: function () { var a = new n; return function () { this.computeBoundingBox(); this.boundingBox.getCenter(a).negate(); this.translate(a.x, a.y, a.z); return this; }; }(), normalize: function () {
      this.computeBoundingSphere(); var a = this.boundingSphere.center, b = this.boundingSphere.radius;
      b = 0 === b ? 1 : 1 / b; var c = new P; c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1); this.applyMatrix(c); return this;
    }, computeFaceNormals: function () { for (var a = new n, b = new n, c = 0, d = this.faces.length; c < d; c++) { var e = this.faces[c], f = this.vertices[e.a], g = this.vertices[e.b]; a.subVectors(this.vertices[e.c], g); b.subVectors(f, g); a.cross(b); a.normalize(); e.normal.copy(a); } }, computeVertexNormals: function (a) {
      void 0 === a && (a = !0); var b; var c = Array(this.vertices.length); var d = 0; for (b = this.vertices.length; d < b; d++)c[d] = new n;
      if (a) { var e = new n, f = new n; a = 0; for (d = this.faces.length; a < d; a++) { b = this.faces[a]; var g = this.vertices[b.a]; var h = this.vertices[b.b]; var l = this.vertices[b.c]; e.subVectors(l, h); f.subVectors(g, h); e.cross(f); c[b.a].add(e); c[b.b].add(e); c[b.c].add(e); } } else for (this.computeFaceNormals(), a = 0, d = this.faces.length; a < d; a++)b = this.faces[a], c[b.a].add(b.normal), c[b.b].add(b.normal), c[b.c].add(b.normal); d = 0; for (b = this.vertices.length; d < b; d++)c[d].normalize(); a = 0; for (d = this.faces.length; a < d; a++)b = this.faces[a], g = b.vertexNormals,
        3 === g.length ? (g[0].copy(c[b.a]), g[1].copy(c[b.b]), g[2].copy(c[b.c])) : (g[0] = c[b.a].clone(), g[1] = c[b.b].clone(), g[2] = c[b.c].clone()); 0 < this.faces.length && (this.normalsNeedUpdate = !0);
    }, computeFlatVertexNormals: function () {
      var a; this.computeFaceNormals(); var b = 0; for (a = this.faces.length; b < a; b++) { var c = this.faces[b]; var d = c.vertexNormals; 3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal)) : (d[0] = c.normal.clone(), d[1] = c.normal.clone(), d[2] = c.normal.clone()); } 0 < this.faces.length && (this.normalsNeedUpdate =
        !0);
    }, computeMorphNormals: function () {
      var a, b; var c = 0; for (b = this.faces.length; c < b; c++) { var d = this.faces[c]; d.__originalFaceNormal ? d.__originalFaceNormal.copy(d.normal) : d.__originalFaceNormal = d.normal.clone(); d.__originalVertexNormals || (d.__originalVertexNormals = []); var e = 0; for (a = d.vertexNormals.length; e < a; e++)d.__originalVertexNormals[e] ? d.__originalVertexNormals[e].copy(d.vertexNormals[e]) : d.__originalVertexNormals[e] = d.vertexNormals[e].clone(); } var f = new K; f.faces = this.faces; e = 0; for (a = this.morphTargets.length; e <
        a; e++) {
          if (!this.morphNormals[e]) { this.morphNormals[e] = {}; this.morphNormals[e].faceNormals = []; this.morphNormals[e].vertexNormals = []; d = this.morphNormals[e].faceNormals; var g = this.morphNormals[e].vertexNormals; c = 0; for (b = this.faces.length; c < b; c++) { var h = new n; var l = { a: new n, b: new n, c: new n }; d.push(h); g.push(l); } } g = this.morphNormals[e]; f.vertices = this.morphTargets[e].vertices; f.computeFaceNormals(); f.computeVertexNormals(); c = 0; for (b = this.faces.length; c < b; c++)d = this.faces[c], h = g.faceNormals[c], l = g.vertexNormals[c],
            h.copy(d.normal), l.a.copy(d.vertexNormals[0]), l.b.copy(d.vertexNormals[1]), l.c.copy(d.vertexNormals[2]);
      } c = 0; for (b = this.faces.length; c < b; c++)d = this.faces[c], d.normal = d.__originalFaceNormal, d.vertexNormals = d.__originalVertexNormals;
    }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new Ga); this.boundingBox.setFromPoints(this.vertices); }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new Ta); this.boundingSphere.setFromPoints(this.vertices); }, merge: function (a,
      b, c) {
        if (a && a.isGeometry) {
          var d, e = this.vertices.length, f = this.vertices, g = a.vertices, h = this.faces, l = a.faces, m = this.faceVertexUvs[0], k = a.faceVertexUvs[0], p = this.colors, n = a.colors; void 0 === c && (c = 0); void 0 !== b && (d = (new na).getNormalMatrix(b)); a = 0; for (var t = g.length; a < t; a++) { var r = g[a].clone(); void 0 !== b && r.applyMatrix4(b); f.push(r); } a = 0; for (t = n.length; a < t; a++)p.push(n[a].clone()); a = 0; for (t = l.length; a < t; a++) {
            g = l[a]; var u = g.vertexNormals; n = g.vertexColors; p = new Sb(g.a + e, g.b + e, g.c + e); p.normal.copy(g.normal);
            void 0 !== d && p.normal.applyMatrix3(d).normalize(); b = 0; for (f = u.length; b < f; b++)r = u[b].clone(), void 0 !== d && r.applyMatrix3(d).normalize(), p.vertexNormals.push(r); p.color.copy(g.color); b = 0; for (f = n.length; b < f; b++)r = n[b], p.vertexColors.push(r.clone()); p.materialIndex = g.materialIndex + c; h.push(p);
          } a = 0; for (t = k.length; a < t; a++)if (c = k[a], d = [], void 0 !== c) { b = 0; for (f = c.length; b < f; b++)d.push(c[b].clone()); m.push(d); }
        } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a);
    }, mergeMesh: function (a) {
      a &&
      a.isMesh ? (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a);
    }, mergeVertices: function () {
      var a = {}, b = [], c = [], d = Math.pow(10, 4), e; var f = 0; for (e = this.vertices.length; f < e; f++) { var g = this.vertices[f]; g = Math.round(g.x * d) + "_" + Math.round(g.y * d) + "_" + Math.round(g.z * d); void 0 === a[g] ? (a[g] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[g]]; } a = []; f = 0; for (e = this.faces.length; f < e; f++)for (d = this.faces[f], d.a = c[d.a],
        d.b = c[d.b], d.c = c[d.c], d = [d.a, d.b, d.c], g = 0; 3 > g; g++)if (d[g] === d[(g + 1) % 3]) { a.push(f); break; } for (f = a.length - 1; 0 <= f; f--)for (d = a[f], this.faces.splice(d, 1), c = 0, e = this.faceVertexUvs.length; c < e; c++)this.faceVertexUvs[c].splice(d, 1); f = this.vertices.length - b.length; this.vertices = b; return f;
    }, setFromPoints: function (a) { this.vertices = []; for (var b = 0, c = a.length; b < c; b++) { var d = a[b]; this.vertices.push(new n(d.x, d.y, d.z || 0)); } return this; }, sortFacesByMaterialIndex: function () {
      for (var a = this.faces, b = a.length, c = 0; c < b; c++)a[c]._id =
        c; a.sort(function (a, b) { return a.materialIndex - b.materialIndex; }); var d = this.faceVertexUvs[0], e = this.faceVertexUvs[1], f, g; d && d.length === b && (f = []); e && e.length === b && (g = []); for (c = 0; c < b; c++) { var h = a[c]._id; f && f.push(d[h]); g && g.push(e[h]); } f && (this.faceVertexUvs[0] = f); g && (this.faceVertexUvs[1] = g);
    }, toJSON: function () {
      function a(a, b, c) { return c ? a | 1 << b : a & ~(1 << b); } function b(a) { var b = a.x.toString() + a.y.toString() + a.z.toString(); if (void 0 !== m[b]) return m[b]; m[b] = l.length / 3; l.push(a.x, a.y, a.z); return m[b]; } function c(a) {
        var b =
          a.r.toString() + a.g.toString() + a.b.toString(); if (void 0 !== p[b]) return p[b]; p[b] = k.length; k.push(a.getHex()); return p[b];
      } function d(a) { var b = a.x.toString() + a.y.toString(); if (void 0 !== t[b]) return t[b]; t[b] = n.length / 2; n.push(a.x, a.y); return t[b]; } var e = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } }; e.uuid = this.uuid; e.type = this.type; "" !== this.name && (e.name = this.name); if (void 0 !== this.parameters) { var f = this.parameters, g; for (g in f) void 0 !== f[g] && (e[g] = f[g]); return e; } f = []; for (g = 0; g <
        this.vertices.length; g++) { var h = this.vertices[g]; f.push(h.x, h.y, h.z); } h = []; var l = [], m = {}, k = [], p = {}, n = [], t = {}; for (g = 0; g < this.faces.length; g++) {
          var r = this.faces[g], u = void 0 !== this.faceVertexUvs[0][g], w = 0 < r.normal.length(), z = 0 < r.vertexNormals.length, x = 1 !== r.color.r || 1 !== r.color.g || 1 !== r.color.b, y = 0 < r.vertexColors.length, F = 0; F = a(F, 0, 0); F = a(F, 1, !0); F = a(F, 2, !1); F = a(F, 3, u); F = a(F, 4, w); F = a(F, 5, z); F = a(F, 6, x); F = a(F, 7, y); h.push(F); h.push(r.a, r.b, r.c); h.push(r.materialIndex); u && (u = this.faceVertexUvs[0][g], h.push(d(u[0]),
            d(u[1]), d(u[2]))); w && h.push(b(r.normal)); z && (w = r.vertexNormals, h.push(b(w[0]), b(w[1]), b(w[2]))); x && h.push(c(r.color)); y && (r = r.vertexColors, h.push(c(r[0]), c(r[1]), c(r[2])));
        } e.data = {}; e.data.vertices = f; e.data.normals = l; 0 < k.length && (e.data.colors = k); 0 < n.length && (e.data.uvs = [n]); e.data.faces = h; return e;
    }, clone: function () { return (new K).copy(this); }, copy: function (a) {
      var b, c, d; this.vertices = []; this.colors = []; this.faces = []; this.faceVertexUvs = [[]]; this.morphTargets = []; this.morphNormals = []; this.skinWeights = [];
      this.skinIndices = []; this.lineDistances = []; this.boundingSphere = this.boundingBox = null; this.name = a.name; var e = a.vertices; var f = 0; for (b = e.length; f < b; f++)this.vertices.push(e[f].clone()); e = a.colors; f = 0; for (b = e.length; f < b; f++)this.colors.push(e[f].clone()); e = a.faces; f = 0; for (b = e.length; f < b; f++)this.faces.push(e[f].clone()); f = 0; for (b = a.faceVertexUvs.length; f < b; f++) {
        var g = a.faceVertexUvs[f]; void 0 === this.faceVertexUvs[f] && (this.faceVertexUvs[f] = []); e = 0; for (c = g.length; e < c; e++) {
          var h = g[e], l = []; var m = 0; for (d =
            h.length; m < d; m++)l.push(h[m].clone()); this.faceVertexUvs[f].push(l);
        }
      } m = a.morphTargets; f = 0; for (b = m.length; f < b; f++) { d = {}; d.name = m[f].name; if (void 0 !== m[f].vertices) for (d.vertices = [], e = 0, c = m[f].vertices.length; e < c; e++)d.vertices.push(m[f].vertices[e].clone()); if (void 0 !== m[f].normals) for (d.normals = [], e = 0, c = m[f].normals.length; e < c; e++)d.normals.push(m[f].normals[e].clone()); this.morphTargets.push(d); } m = a.morphNormals; f = 0; for (b = m.length; f < b; f++) {
        d = {}; if (void 0 !== m[f].vertexNormals) for (d.vertexNormals = [],
          e = 0, c = m[f].vertexNormals.length; e < c; e++)g = m[f].vertexNormals[e], h = {}, h.a = g.a.clone(), h.b = g.b.clone(), h.c = g.c.clone(), d.vertexNormals.push(h); if (void 0 !== m[f].faceNormals) for (d.faceNormals = [], e = 0, c = m[f].faceNormals.length; e < c; e++)d.faceNormals.push(m[f].faceNormals[e].clone()); this.morphNormals.push(d);
      } e = a.skinWeights; f = 0; for (b = e.length; f < b; f++)this.skinWeights.push(e[f].clone()); e = a.skinIndices; f = 0; for (b = e.length; f < b; f++)this.skinIndices.push(e[f].clone()); e = a.lineDistances; f = 0; for (b = e.length; f < b; f++)this.lineDistances.push(e[f]);
      f = a.boundingBox; null !== f && (this.boundingBox = f.clone()); f = a.boundingSphere; null !== f && (this.boundingSphere = f.clone()); this.elementsNeedUpdate = a.elementsNeedUpdate; this.verticesNeedUpdate = a.verticesNeedUpdate; this.uvsNeedUpdate = a.uvsNeedUpdate; this.normalsNeedUpdate = a.normalsNeedUpdate; this.colorsNeedUpdate = a.colorsNeedUpdate; this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate; this.groupsNeedUpdate = a.groupsNeedUpdate; return this;
    }, dispose: function () { this.dispatchEvent({ type: "dispose" }); }
  }); Object.defineProperty(H.prototype,
    "needsUpdate", { set: function (a) { !0 === a && this.version++; } }); Object.assign(H.prototype, {
      isBufferAttribute: !0, onUploadCallback: function () { }, setArray: function (a) { if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.count = void 0 !== a ? a.length / this.itemSize : 0; this.array = a; return this; }, setDynamic: function (a) { this.dynamic = a; return this; }, copy: function (a) {
        this.name = a.name; this.array = new a.array.constructor(a.array); this.itemSize = a.itemSize; this.count = a.count; this.normalized =
          a.normalized; this.dynamic = a.dynamic; return this;
      }, copyAt: function (a, b, c) { a *= this.itemSize; c *= b.itemSize; for (var d = 0, e = this.itemSize; d < e; d++)this.array[a + d] = b.array[c + d]; return this; }, copyArray: function (a) { this.array.set(a); return this; }, copyColorsArray: function (a) { for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) { var f = a[d]; void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), f = new A); b[c++] = f.r; b[c++] = f.g; b[c++] = f.b; } return this; }, copyVector2sArray: function (a) {
        for (var b =
          this.array, c = 0, d = 0, e = a.length; d < e; d++) { var f = a[d]; void 0 === f && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", d), f = new C); b[c++] = f.x; b[c++] = f.y; } return this;
      }, copyVector3sArray: function (a) { for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) { var f = a[d]; void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), f = new n); b[c++] = f.x; b[c++] = f.y; b[c++] = f.z; } return this; }, copyVector4sArray: function (a) {
        for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
          var f =
            a[d]; void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), f = new W); b[c++] = f.x; b[c++] = f.y; b[c++] = f.z; b[c++] = f.w;
        } return this;
      }, set: function (a, b) { void 0 === b && (b = 0); this.array.set(a, b); return this; }, getX: function (a) { return this.array[a * this.itemSize]; }, setX: function (a, b) { this.array[a * this.itemSize] = b; return this; }, getY: function (a) { return this.array[a * this.itemSize + 1]; }, setY: function (a, b) { this.array[a * this.itemSize + 1] = b; return this; }, getZ: function (a) {
        return this.array[a *
          this.itemSize + 2];
      }, setZ: function (a, b) { this.array[a * this.itemSize + 2] = b; return this; }, getW: function (a) { return this.array[a * this.itemSize + 3]; }, setW: function (a, b) { this.array[a * this.itemSize + 3] = b; return this; }, setXY: function (a, b, c) { a *= this.itemSize; this.array[a + 0] = b; this.array[a + 1] = c; return this; }, setXYZ: function (a, b, c, d) { a *= this.itemSize; this.array[a + 0] = b; this.array[a + 1] = c; this.array[a + 2] = d; return this; }, setXYZW: function (a, b, c, d, e) {
        a *= this.itemSize; this.array[a + 0] = b; this.array[a + 1] = c; this.array[a + 2] = d; this.array[a +
          3] = e; return this;
      }, onUpload: function (a) { this.onUploadCallback = a; return this; }, clone: function () { return (new this.constructor(this.array, this.itemSize)).copy(this); }
    }); Ac.prototype = Object.create(H.prototype); Ac.prototype.constructor = Ac; Bc.prototype = Object.create(H.prototype); Bc.prototype.constructor = Bc; Cc.prototype = Object.create(H.prototype); Cc.prototype.constructor = Cc; Dc.prototype = Object.create(H.prototype); Dc.prototype.constructor = Dc; ub.prototype = Object.create(H.prototype); ub.prototype.constructor = ub;
  Ec.prototype = Object.create(H.prototype); Ec.prototype.constructor = Ec; vb.prototype = Object.create(H.prototype); vb.prototype.constructor = vb; E.prototype = Object.create(H.prototype); E.prototype.constructor = E; Fc.prototype = Object.create(H.prototype); Fc.prototype.constructor = Fc; Object.assign(Ve.prototype, {
    computeGroups: function (a) {
      var b = [], c = void 0; a = a.faces; for (var d = 0; d < a.length; d++) { var e = a[d]; if (e.materialIndex !== c) { c = e.materialIndex; void 0 !== f && (f.count = 3 * d - f.start, b.push(f)); var f = { start: 3 * d, materialIndex: c }; } } void 0 !==
        f && (f.count = 3 * d - f.start, b.push(f)); this.groups = b;
    }, fromGeometry: function (a) {
      var b = a.faces, c = a.vertices, d = a.faceVertexUvs, e = d[0] && 0 < d[0].length, f = d[1] && 0 < d[1].length, g = a.morphTargets, h = g.length; if (0 < h) { var l = []; for (var m = 0; m < h; m++)l[m] = { name: g[m].name, data: [] }; this.morphTargets.position = l; } var k = a.morphNormals, p = k.length; if (0 < p) { var n = []; for (m = 0; m < p; m++)n[m] = { name: k[m].name, data: [] }; this.morphTargets.normal = n; } var t = a.skinIndices, r = a.skinWeights, u = t.length === c.length, w = r.length === c.length; 0 < c.length &&
        0 === b.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."); for (m = 0; m < b.length; m++) {
          var z = b[m]; this.vertices.push(c[z.a], c[z.b], c[z.c]); var x = z.vertexNormals; 3 === x.length ? this.normals.push(x[0], x[1], x[2]) : (x = z.normal, this.normals.push(x, x, x)); x = z.vertexColors; 3 === x.length ? this.colors.push(x[0], x[1], x[2]) : (x = z.color, this.colors.push(x, x, x)); !0 === e && (x = d[0][m], void 0 !== x ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
            m), this.uvs.push(new C, new C, new C))); !0 === f && (x = d[1][m], void 0 !== x ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", m), this.uvs2.push(new C, new C, new C))); for (x = 0; x < h; x++) { var y = g[x].vertices; l[x].data.push(y[z.a], y[z.b], y[z.c]); } for (x = 0; x < p; x++)y = k[x].vertexNormals[m], n[x].data.push(y.a, y.b, y.c); u && this.skinIndices.push(t[z.a], t[z.b], t[z.c]); w && this.skinWeights.push(r[z.a], r[z.b], r[z.c]);
        } this.computeGroups(a); this.verticesNeedUpdate = a.verticesNeedUpdate;
      this.normalsNeedUpdate = a.normalsNeedUpdate; this.colorsNeedUpdate = a.colorsNeedUpdate; this.uvsNeedUpdate = a.uvsNeedUpdate; this.groupsNeedUpdate = a.groupsNeedUpdate; return this;
    }
  }); var bg = 1; B.prototype = Object.assign(Object.create(ta.prototype), {
    constructor: B, isBufferGeometry: !0, getIndex: function () { return this.index; }, setIndex: function (a) { Array.isArray(a) ? this.index = new (65535 < We(a) ? vb : ub)(a, 1) : this.index = a; }, addAttribute: function (a, b, c) {
      if (!(b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute)) return console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
        this.addAttribute(a, new H(b, c)); if ("index" === a) return console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b), this; this.attributes[a] = b; return this;
    }, getAttribute: function (a) { return this.attributes[a]; }, removeAttribute: function (a) { delete this.attributes[a]; return this; }, addGroup: function (a, b, c) { this.groups.push({ start: a, count: b, materialIndex: void 0 !== c ? c : 0 }); }, clearGroups: function () { this.groups = []; }, setDrawRange: function (a, b) {
      this.drawRange.start = a; this.drawRange.count =
        b;
    }, applyMatrix: function (a) { var b = this.attributes.position; void 0 !== b && (a.applyToBufferAttribute(b), b.needsUpdate = !0); var c = this.attributes.normal; void 0 !== c && (b = (new na).getNormalMatrix(a), b.applyToBufferAttribute(c), c.needsUpdate = !0); c = this.attributes.tangent; void 0 !== c && (b = (new na).getNormalMatrix(a), b.applyToBufferAttribute(c), c.needsUpdate = !0); null !== this.boundingBox && this.computeBoundingBox(); null !== this.boundingSphere && this.computeBoundingSphere(); return this; }, rotateX: function () {
      var a = new P;
      return function (b) { a.makeRotationX(b); this.applyMatrix(a); return this; };
    }(), rotateY: function () { var a = new P; return function (b) { a.makeRotationY(b); this.applyMatrix(a); return this; }; }(), rotateZ: function () { var a = new P; return function (b) { a.makeRotationZ(b); this.applyMatrix(a); return this; }; }(), translate: function () { var a = new P; return function (b, c, d) { a.makeTranslation(b, c, d); this.applyMatrix(a); return this; }; }(), scale: function () { var a = new P; return function (b, c, d) { a.makeScale(b, c, d); this.applyMatrix(a); return this; }; }(),
    lookAt: function () { var a = new D; return function (b) { a.lookAt(b); a.updateMatrix(); this.applyMatrix(a.matrix); }; }(), center: function () { var a = new n; return function () { this.computeBoundingBox(); this.boundingBox.getCenter(a).negate(); this.translate(a.x, a.y, a.z); return this; }; }(), setFromObject: function (a) {
      var b = a.geometry; if (a.isPoints || a.isLine) {
        a = new E(3 * b.vertices.length, 3); var c = new E(3 * b.colors.length, 3); this.addAttribute("position", a.copyVector3sArray(b.vertices)); this.addAttribute("color", c.copyColorsArray(b.colors));
        b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new E(b.lineDistances.length, 1), this.addAttribute("lineDistance", a.copyArray(b.lineDistances))); null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone()); null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone());
      } else a.isMesh && b && b.isGeometry && this.fromGeometry(b); return this;
    }, setFromPoints: function (a) { for (var b = [], c = 0, d = a.length; c < d; c++) { var e = a[c]; b.push(e.x, e.y, e.z || 0); } this.addAttribute("position", new E(b, 3)); return this; },
    updateFromObject: function (a) {
      var b = a.geometry; if (a.isMesh) { var c = b.__directGeometry; !0 === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = !1); if (void 0 === c) return this.fromGeometry(b); c.verticesNeedUpdate = b.verticesNeedUpdate; c.normalsNeedUpdate = b.normalsNeedUpdate; c.colorsNeedUpdate = b.colorsNeedUpdate; c.uvsNeedUpdate = b.uvsNeedUpdate; c.groupsNeedUpdate = b.groupsNeedUpdate; b.verticesNeedUpdate = !1; b.normalsNeedUpdate = !1; b.colorsNeedUpdate = !1; b.uvsNeedUpdate = !1; b.groupsNeedUpdate = !1; b = c; } !0 === b.verticesNeedUpdate &&
        (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), c.needsUpdate = !0), b.verticesNeedUpdate = !1); !0 === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = !0), b.normalsNeedUpdate = !1); !0 === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = !0), b.colorsNeedUpdate = !1); b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0), b.uvsNeedUpdate = !1);
      b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), c.needsUpdate = !0), b.lineDistancesNeedUpdate = !1); b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1); return this;
    }, fromGeometry: function (a) { a.__directGeometry = (new Ve).fromGeometry(a); return this.fromDirectGeometry(a.__directGeometry); }, fromDirectGeometry: function (a) {
      var b = new Float32Array(3 * a.vertices.length); this.addAttribute("position", (new H(b, 3)).copyVector3sArray(a.vertices));
      0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", (new H(b, 3)).copyVector3sArray(a.normals))); 0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", (new H(b, 3)).copyColorsArray(a.colors))); 0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.addAttribute("uv", (new H(b, 2)).copyVector2sArray(a.uvs))); 0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", (new H(b, 2)).copyVector2sArray(a.uvs2))); this.groups =
        a.groups; for (var c in a.morphTargets) { b = []; for (var d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) { var g = d[e], h = new E(3 * g.data.length, 3); h.name = g.name; b.push(h.copyVector3sArray(g.data)); } this.morphAttributes[c] = b; } 0 < a.skinIndices.length && (c = new E(4 * a.skinIndices.length, 4), this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices))); 0 < a.skinWeights.length && (c = new E(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights))); null !== a.boundingSphere && (this.boundingSphere =
          a.boundingSphere.clone()); null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()); return this;
    }, computeBoundingBox: function () {
      var a = new Ga; return function () {
        null === this.boundingBox && (this.boundingBox = new Ga); var b = this.attributes.position, c = this.morphAttributes.position; if (void 0 !== b) { if (this.boundingBox.setFromBufferAttribute(b), c) { b = 0; for (var d = c.length; b < d; b++)a.setFromBufferAttribute(c[b]), this.boundingBox.expandByPoint(a.min), this.boundingBox.expandByPoint(a.max); } } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      };
    }(), computeBoundingSphere: function () {
      var a = new Ga, b = new Ga, c = new n; return function () {
        null === this.boundingSphere && (this.boundingSphere = new Ta); var d = this.attributes.position, e = this.morphAttributes.position; if (d) {
          var f = this.boundingSphere.center; a.setFromBufferAttribute(d);
          if (e) for (var g = 0, h = e.length; g < h; g++) { var l = e[g]; b.setFromBufferAttribute(l); a.expandByPoint(b.min); a.expandByPoint(b.max); } a.getCenter(f); var m = 0; g = 0; for (h = d.count; g < h; g++)c.fromBufferAttribute(d, g), m = Math.max(m, f.distanceToSquared(c)); if (e) for (g = 0, h = e.length; g < h; g++) { l = e[g]; d = 0; for (var k = l.count; d < k; d++)c.fromBufferAttribute(l, d), m = Math.max(m, f.distanceToSquared(c)); } this.boundingSphere.radius = Math.sqrt(m); isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this);
        }
      };
    }(), computeFaceNormals: function () { }, computeVertexNormals: function () {
      var a = this.index, b = this.attributes; if (b.position) {
        var c = b.position.array; if (void 0 === b.normal) this.addAttribute("normal", new H(new Float32Array(c.length), 3)); else for (var d = b.normal.array, e = 0, f = d.length; e < f; e++)d[e] = 0; d = b.normal.array; var g = new n, h = new n, l = new n, m = new n, k = new n; if (a) {
          var p = a.array; e = 0; for (f = a.count; e < f; e += 3) {
            a = 3 * p[e + 0]; var v = 3 * p[e + 1]; var t = 3 * p[e + 2]; g.fromArray(c, a); h.fromArray(c, v); l.fromArray(c, t); m.subVectors(l,
              h); k.subVectors(g, h); m.cross(k); d[a] += m.x; d[a + 1] += m.y; d[a + 2] += m.z; d[v] += m.x; d[v + 1] += m.y; d[v + 2] += m.z; d[t] += m.x; d[t + 1] += m.y; d[t + 2] += m.z;
          }
        } else for (e = 0, f = c.length; e < f; e += 9)g.fromArray(c, e), h.fromArray(c, e + 3), l.fromArray(c, e + 6), m.subVectors(l, h), k.subVectors(g, h), m.cross(k), d[e] = m.x, d[e + 1] = m.y, d[e + 2] = m.z, d[e + 3] = m.x, d[e + 4] = m.y, d[e + 5] = m.z, d[e + 6] = m.x, d[e + 7] = m.y, d[e + 8] = m.z; this.normalizeNormals(); b.normal.needsUpdate = !0;
      }
    }, merge: function (a, b) {
      if (a && a.isBufferGeometry) {
        void 0 === b && (b = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
        var c = this.attributes, d; for (d in c) if (void 0 !== a.attributes[d]) { var e = c[d].array, f = a.attributes[d], g = f.array, h = f.itemSize * b; f = Math.min(g.length, e.length - h); for (var l = 0; l < f; l++, h++)e[h] = g[l]; } return this;
      } console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a);
    }, normalizeNormals: function () { var a = new n; return function () { for (var b = this.attributes.normal, c = 0, d = b.count; c < d; c++)a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.normalize(), b.setXYZ(c, a.x, a.y, a.z); }; }(), toNonIndexed: function () {
      function a(a,
        b) { var c = a.array; a = a.itemSize; for (var d = new c.constructor(b.length * a), e, f = 0, g = 0, h = b.length; g < h; g++) { e = b[g] * a; for (var l = 0; l < a; l++)d[f++] = c[e++]; } return new H(d, a); } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this; var b = new B, c = this.index.array, d = this.attributes, e; for (e in d) { var f = d[e]; f = a(f, c); b.addAttribute(e, f); } var g = this.morphAttributes; for (e in g) {
          var h = [], l = g[e]; d = 0; for (var m = l.length; d < m; d++)f = l[d], f = a(f, c), h.push(f); b.morphAttributes[e] =
            h;
        } c = this.groups; d = 0; for (e = c.length; d < e; d++)f = c[d], b.addGroup(f.start, f.count, f.materialIndex); return b;
    }, toJSON: function () {
      var a = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; a.uuid = this.uuid; a.type = this.type; "" !== this.name && (a.name = this.name); 0 < Object.keys(this.userData).length && (a.userData = this.userData); if (void 0 !== this.parameters) { var b = this.parameters; for (m in b) void 0 !== b[m] && (a[m] = b[m]); return a; } a.data = { attributes: {} }; b = this.index; null !== b && (a.data.index = {
        type: b.array.constructor.name,
        array: Array.prototype.slice.call(b.array)
      }); var c = this.attributes; for (m in c) { b = c[m]; var d = { itemSize: b.itemSize, type: b.array.constructor.name, array: Array.prototype.slice.call(b.array), normalized: b.normalized }; "" !== b.name && (d.name = b.name); a.data.attributes[m] = d; } c = {}; var e = !1; for (m in this.morphAttributes) {
        for (var f = this.morphAttributes[m], g = [], h = 0, l = f.length; h < l; h++)b = f[h], d = { itemSize: b.itemSize, type: b.array.constructor.name, array: Array.prototype.slice.call(b.array), normalized: b.normalized }, "" !== b.name &&
          (d.name = b.name), g.push(d); 0 < g.length && (c[m] = g, e = !0);
      } e && (a.data.morphAttributes = c); var m = this.groups; 0 < m.length && (a.data.groups = JSON.parse(JSON.stringify(m))); m = this.boundingSphere; null !== m && (a.data.boundingSphere = { center: m.center.toArray(), radius: m.radius }); return a;
    }, clone: function () { return (new B).copy(this); }, copy: function (a) {
      var b; this.index = null; this.attributes = {}; this.morphAttributes = {}; this.groups = []; this.boundingSphere = this.boundingBox = null; this.name = a.name; var c = a.index; null !== c && this.setIndex(c.clone());
      c = a.attributes; for (g in c) this.addAttribute(g, c[g].clone()); var d = a.morphAttributes; for (g in d) { var e = [], f = d[g]; c = 0; for (b = f.length; c < b; c++)e.push(f[c].clone()); this.morphAttributes[g] = e; } var g = a.groups; c = 0; for (b = g.length; c < b; c++)d = g[c], this.addGroup(d.start, d.count, d.materialIndex); g = a.boundingBox; null !== g && (this.boundingBox = g.clone()); g = a.boundingSphere; null !== g && (this.boundingSphere = g.clone()); this.drawRange.start = a.drawRange.start; this.drawRange.count = a.drawRange.count; this.userData = a.userData;
      return this;
    }, dispose: function () { this.dispatchEvent({ type: "dispose" }); }
  }); Tb.prototype = Object.create(K.prototype); Tb.prototype.constructor = Tb; wb.prototype = Object.create(B.prototype); wb.prototype.constructor = wb; Gc.prototype = Object.create(K.prototype); Gc.prototype.constructor = Gc; yb.prototype = Object.create(B.prototype); yb.prototype.constructor = yb; var cg = 0; Q.prototype = Object.assign(Object.create(ta.prototype), {
    constructor: Q, isMaterial: !0, onBeforeCompile: function () { }, setValues: function (a) {
      if (void 0 !== a) for (var b in a) {
        var c =
          a[b]; if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined."); else if ("shading" === b) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === c ? !0 : !1; else { var d = this[b]; void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = c; }
      }
    }, toJSON: function (a) {
      function b(a) {
        var b = [], c; for (c in a) {
          var d = a[c]; delete d.metadata;
          b.push(d);
        } return b;
      } var c = void 0 === a || "string" === typeof a; c && (a = { textures: {}, images: {} }); var d = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; d.uuid = this.uuid; d.type = this.type; "" !== this.name && (d.name = this.name); this.color && this.color.isColor && (d.color = this.color.getHex()); void 0 !== this.roughness && (d.roughness = this.roughness); void 0 !== this.metalness && (d.metalness = this.metalness); this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex()); 1 !== this.emissiveIntensity &&
        (d.emissiveIntensity = this.emissiveIntensity); this.specular && this.specular.isColor && (d.specular = this.specular.getHex()); void 0 !== this.shininess && (d.shininess = this.shininess); void 0 !== this.clearCoat && (d.clearCoat = this.clearCoat); void 0 !== this.clearCoatRoughness && (d.clearCoatRoughness = this.clearCoatRoughness); this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid); this.matcap && this.matcap.isTexture && (d.matcap = this.matcap.toJSON(a).uuid); this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid);
      this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid); this.aoMap && this.aoMap.isTexture && (d.aoMap = this.aoMap.toJSON(a).uuid, d.aoMapIntensity = this.aoMapIntensity); this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale); this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalMapType = this.normalMapType, d.normalScale = this.normalScale.toArray()); this.displacementMap && this.displacementMap.isTexture &&
        (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias); this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid); this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid); this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid); this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid);
      this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity, void 0 !== this.combine && (d.combine = this.combine), void 0 !== this.envMapIntensity && (d.envMapIntensity = this.envMapIntensity)); this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid); void 0 !== this.size && (d.size = this.size); void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation); 1 !== this.blending && (d.blending = this.blending); !0 === this.flatShading &&
        (d.flatShading = this.flatShading); 0 !== this.side && (d.side = this.side); 0 !== this.vertexColors && (d.vertexColors = this.vertexColors); 1 > this.opacity && (d.opacity = this.opacity); !0 === this.transparent && (d.transparent = this.transparent); d.depthFunc = this.depthFunc; d.depthTest = this.depthTest; d.depthWrite = this.depthWrite; 0 !== this.rotation && (d.rotation = this.rotation); !0 === this.polygonOffset && (d.polygonOffset = !0); 0 !== this.polygonOffsetFactor && (d.polygonOffsetFactor = this.polygonOffsetFactor); 0 !== this.polygonOffsetUnits &&
          (d.polygonOffsetUnits = this.polygonOffsetUnits); 1 !== this.linewidth && (d.linewidth = this.linewidth); void 0 !== this.dashSize && (d.dashSize = this.dashSize); void 0 !== this.gapSize && (d.gapSize = this.gapSize); void 0 !== this.scale && (d.scale = this.scale); !0 === this.dithering && (d.dithering = !0); 0 < this.alphaTest && (d.alphaTest = this.alphaTest); !0 === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha); !0 === this.wireframe && (d.wireframe = this.wireframe); 1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth);
      "round" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap); "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin); !0 === this.morphTargets && (d.morphTargets = !0); !0 === this.skinning && (d.skinning = !0); !1 === this.visible && (d.visible = !1); "{}" !== JSON.stringify(this.userData) && (d.userData = this.userData); c && (c = b(a.textures), a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a)); return d;
    }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) {
      this.name =
      a.name; this.fog = a.fog; this.lights = a.lights; this.blending = a.blending; this.side = a.side; this.flatShading = a.flatShading; this.vertexColors = a.vertexColors; this.opacity = a.opacity; this.transparent = a.transparent; this.blendSrc = a.blendSrc; this.blendDst = a.blendDst; this.blendEquation = a.blendEquation; this.blendSrcAlpha = a.blendSrcAlpha; this.blendDstAlpha = a.blendDstAlpha; this.blendEquationAlpha = a.blendEquationAlpha; this.depthFunc = a.depthFunc; this.depthTest = a.depthTest; this.depthWrite = a.depthWrite; this.colorWrite =
        a.colorWrite; this.precision = a.precision; this.polygonOffset = a.polygonOffset; this.polygonOffsetFactor = a.polygonOffsetFactor; this.polygonOffsetUnits = a.polygonOffsetUnits; this.dithering = a.dithering; this.alphaTest = a.alphaTest; this.premultipliedAlpha = a.premultipliedAlpha; this.visible = a.visible; this.userData = JSON.parse(JSON.stringify(a.userData)); this.clipShadows = a.clipShadows; this.clipIntersection = a.clipIntersection; var b = a.clippingPlanes, c = null; if (null !== b) {
          var d = b.length; c = Array(d); for (var e = 0; e !== d; ++e)c[e] =
            b[e].clone();
        } this.clippingPlanes = c; this.shadowSide = a.shadowSide; return this;
    }, dispose: function () { this.dispatchEvent({ type: "dispose" }); }
  }); ea.prototype = Object.create(Q.prototype); ea.prototype.constructor = ea; ea.prototype.isShaderMaterial = !0; ea.prototype.copy = function (a) {
    Q.prototype.copy.call(this, a); this.fragmentShader = a.fragmentShader; this.vertexShader = a.vertexShader; this.uniforms = Rb(a.uniforms); this.defines = Object.assign({}, a.defines); this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth;
    this.lights = a.lights; this.clipping = a.clipping; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; this.extensions = a.extensions; return this;
  }; ea.prototype.toJSON = function (a) {
    var b = Q.prototype.toJSON.call(this, a); b.uniforms = {}; for (var c in this.uniforms) {
      var d = this.uniforms[c].value; b.uniforms[c] = d && d.isTexture ? { type: "t", value: d.toJSON(a).uuid } : d && d.isColor ? { type: "c", value: d.getHex() } : d && d.isVector2 ? { type: "v2", value: d.toArray() } : d && d.isVector3 ? { type: "v3", value: d.toArray() } :
        d && d.isVector4 ? { type: "v4", value: d.toArray() } : d && d.isMatrix3 ? { type: "m3", value: d.toArray() } : d && d.isMatrix4 ? { type: "m4", value: d.toArray() } : { value: d };
    } 0 < Object.keys(this.defines).length && (b.defines = this.defines); b.vertexShader = this.vertexShader; b.fragmentShader = this.fragmentShader; a = {}; for (var e in this.extensions) !0 === this.extensions[e] && (a[e] = !0); 0 < Object.keys(a).length && (b.extensions = a); return b;
  }; Object.assign(zb.prototype, {
    set: function (a, b) { this.origin.copy(a); this.direction.copy(b); return this; }, clone: function () { return (new this.constructor).copy(this); },
    copy: function (a) { this.origin.copy(a.origin); this.direction.copy(a.direction); return this; }, at: function (a, b) { void 0 === b && (console.warn("THREE.Ray: .at() target is now required"), b = new n); return b.copy(this.direction).multiplyScalar(a).add(this.origin); }, lookAt: function (a) { this.direction.copy(a).sub(this.origin).normalize(); return this; }, recast: function () { var a = new n; return function (b) { this.origin.copy(this.at(b, a)); return this; }; }(), closestPointToPoint: function (a, b) {
      void 0 === b && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
        b = new n); b.subVectors(a, this.origin); a = b.dot(this.direction); return 0 > a ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin);
    }, distanceToPoint: function (a) { return Math.sqrt(this.distanceSqToPoint(a)); }, distanceSqToPoint: function () { var a = new n; return function (b) { var c = a.subVectors(b, this.origin).dot(this.direction); if (0 > c) return this.origin.distanceToSquared(b); a.copy(this.direction).multiplyScalar(c).add(this.origin); return a.distanceToSquared(b); }; }(), distanceSqToSegment: function () {
      var a =
        new n, b = new n, c = new n; return function (d, e, f, g) {
          a.copy(d).add(e).multiplyScalar(.5); b.copy(e).sub(d).normalize(); c.copy(this.origin).sub(a); var h = .5 * d.distanceTo(e), l = -this.direction.dot(b), m = c.dot(this.direction), k = -c.dot(b), p = c.lengthSq(), n = Math.abs(1 - l * l); if (0 < n) {
            d = l * k - m; e = l * m - k; var t = h * n; 0 <= d ? e >= -t ? e <= t ? (h = 1 / n, d *= h, e *= h, l = d * (d + l * e + 2 * m) + e * (l * d + e + 2 * k) + p) : (e = h, d = Math.max(0, -(l * e + m)), l = -d * d + e * (e + 2 * k) + p) : (e = -h, d = Math.max(0, -(l * e + m)), l = -d * d + e * (e + 2 * k) + p) : e <= -t ? (d = Math.max(0, -(-l * h + m)), e = 0 < d ? -h : Math.min(Math.max(-h,
              -k), h), l = -d * d + e * (e + 2 * k) + p) : e <= t ? (d = 0, e = Math.min(Math.max(-h, -k), h), l = e * (e + 2 * k) + p) : (d = Math.max(0, -(l * h + m)), e = 0 < d ? h : Math.min(Math.max(-h, -k), h), l = -d * d + e * (e + 2 * k) + p);
          } else e = 0 < l ? -h : h, d = Math.max(0, -(l * e + m)), l = -d * d + e * (e + 2 * k) + p; f && f.copy(this.direction).multiplyScalar(d).add(this.origin); g && g.copy(b).multiplyScalar(e).add(a); return l;
        };
    }(), intersectSphere: function () {
      var a = new n; return function (b, c) {
        a.subVectors(b.center, this.origin); var d = a.dot(this.direction), e = a.dot(a) - d * d; b = b.radius * b.radius; if (e > b) return null;
        b = Math.sqrt(b - e); e = d - b; d += b; return 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c);
      };
    }(), intersectsSphere: function (a) { return this.distanceSqToPoint(a.center) <= a.radius * a.radius; }, distanceToPlane: function (a) { var b = a.normal.dot(this.direction); if (0 === b) return 0 === a.distanceToPoint(this.origin) ? 0 : null; a = -(this.origin.dot(a.normal) + a.constant) / b; return 0 <= a ? a : null; }, intersectPlane: function (a, b) { a = this.distanceToPlane(a); return null === a ? null : this.at(a, b); }, intersectsPlane: function (a) {
      var b = a.distanceToPoint(this.origin);
      return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1;
    }, intersectBox: function (a, b) {
      var c = 1 / this.direction.x; var d = 1 / this.direction.y; var e = 1 / this.direction.z, f = this.origin; if (0 <= c) { var g = (a.min.x - f.x) * c; c *= a.max.x - f.x; } else g = (a.max.x - f.x) * c, c *= a.min.x - f.x; if (0 <= d) { var h = (a.min.y - f.y) * d; d *= a.max.y - f.y; } else h = (a.max.y - f.y) * d, d *= a.min.y - f.y; if (g > d || h > c) return null; if (h > g || g !== g) g = h; if (d < c || c !== c) c = d; 0 <= e ? (h = (a.min.z - f.z) * e, a = (a.max.z - f.z) * e) : (h = (a.max.z - f.z) * e, a = (a.min.z - f.z) * e); if (g > a || h > c) return null;
      if (h > g || g !== g) g = h; if (a < c || c !== c) c = a; return 0 > c ? null : this.at(0 <= g ? g : c, b);
    }, intersectsBox: function () { var a = new n; return function (b) { return null !== this.intersectBox(b, a); }; }(), intersectTriangle: function () {
      var a = new n, b = new n, c = new n, d = new n; return function (e, f, g, h, l) {
        b.subVectors(f, e); c.subVectors(g, e); d.crossVectors(b, c); f = this.direction.dot(d); if (0 < f) { if (h) return null; h = 1; } else if (0 > f) h = -1, f = -f; else return null; a.subVectors(this.origin, e); e = h * this.direction.dot(c.crossVectors(a, c)); if (0 > e) return null;
        g = h * this.direction.dot(b.cross(a)); if (0 > g || e + g > f) return null; e = -h * a.dot(d); return 0 > e ? null : this.at(e / f, l);
      };
    }(), applyMatrix4: function (a) { this.origin.applyMatrix4(a); this.direction.transformDirection(a); return this; }, equals: function (a) { return a.origin.equals(this.origin) && a.direction.equals(this.direction); }
  }); Object.assign(ra, {
    getNormal: function () {
      var a = new n; return function (b, c, d, e) {
        void 0 === e && (console.warn("THREE.Triangle: .getNormal() target is now required"), e = new n); e.subVectors(d, c); a.subVectors(b,
          c); e.cross(a); b = e.lengthSq(); return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0);
      };
    }(), getBarycoord: function () { var a = new n, b = new n, c = new n; return function (d, e, f, g, h) { a.subVectors(g, e); b.subVectors(f, e); c.subVectors(d, e); d = a.dot(a); e = a.dot(b); f = a.dot(c); var l = b.dot(b); g = b.dot(c); var m = d * l - e * e; void 0 === h && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), h = new n); if (0 === m) return h.set(-2, -1, -1); m = 1 / m; l = (l * f - e * g) * m; d = (d * g - e * f) * m; return h.set(1 - l - d, d, l); }; }(), containsPoint: function () {
      var a =
        new n; return function (b, c, d, e) { ra.getBarycoord(b, c, d, e, a); return 0 <= a.x && 0 <= a.y && 1 >= a.x + a.y; };
    }(), getUV: function () { var a = new n; return function (b, c, d, e, f, g, h, l) { this.getBarycoord(b, c, d, e, a); l.set(0, 0); l.addScaledVector(f, a.x); l.addScaledVector(g, a.y); l.addScaledVector(h, a.z); return l; }; }()
  }); Object.assign(ra.prototype, {
    set: function (a, b, c) { this.a.copy(a); this.b.copy(b); this.c.copy(c); return this; }, setFromPointsAndIndices: function (a, b, c, d) { this.a.copy(a[b]); this.b.copy(a[c]); this.c.copy(a[d]); return this; },
    clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { this.a.copy(a.a); this.b.copy(a.b); this.c.copy(a.c); return this; }, getArea: function () { var a = new n, b = new n; return function () { a.subVectors(this.c, this.b); b.subVectors(this.a, this.b); return .5 * a.cross(b).length(); }; }(), getMidpoint: function (a) { void 0 === a && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), a = new n); return a.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3); }, getNormal: function (a) {
      return ra.getNormal(this.a,
        this.b, this.c, a);
    }, getPlane: function (a) { void 0 === a && (console.warn("THREE.Triangle: .getPlane() target is now required"), a = new n); return a.setFromCoplanarPoints(this.a, this.b, this.c); }, getBarycoord: function (a, b) { return ra.getBarycoord(a, this.a, this.b, this.c, b); }, containsPoint: function (a) { return ra.containsPoint(a, this.a, this.b, this.c); }, getUV: function (a, b, c, d, e) { return ra.getUV(a, this.a, this.b, this.c, b, c, d, e); }, intersectsBox: function (a) { return a.intersectsTriangle(this); }, closestPointToPoint: function () {
      var a =
        new n, b = new n, c = new n, d = new n, e = new n, f = new n; return function (g, h) {
          void 0 === h && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), h = new n); var l = this.a, m = this.b, k = this.c; a.subVectors(m, l); b.subVectors(k, l); d.subVectors(g, l); var p = a.dot(d), v = b.dot(d); if (0 >= p && 0 >= v) return h.copy(l); e.subVectors(g, m); var t = a.dot(e), r = b.dot(e); if (0 <= t && r <= t) return h.copy(m); var u = p * r - t * v; if (0 >= u && 0 <= p && 0 >= t) return m = p / (p - t), h.copy(l).addScaledVector(a, m); f.subVectors(g, k); g = a.dot(f); var w =
            b.dot(f); if (0 <= w && g <= w) return h.copy(k); p = g * v - p * w; if (0 >= p && 0 <= v && 0 >= w) return u = v / (v - w), h.copy(l).addScaledVector(b, u); v = t * w - g * r; if (0 >= v && 0 <= r - t && 0 <= g - w) return c.subVectors(k, m), u = (r - t) / (r - t + (g - w)), h.copy(m).addScaledVector(c, u); k = 1 / (v + p + u); m = p * k; u *= k; return h.copy(l).addScaledVector(a, m).addScaledVector(b, u);
        };
    }(), equals: function (a) { return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c); }
  }); Ca.prototype = Object.create(Q.prototype); Ca.prototype.constructor = Ca; Ca.prototype.isMeshBasicMaterial =
    !0; Ca.prototype.copy = function (a) {
      Q.prototype.copy.call(this, a); this.color.copy(a.color); this.map = a.map; this.lightMap = a.lightMap; this.lightMapIntensity = a.lightMapIntensity; this.aoMap = a.aoMap; this.aoMapIntensity = a.aoMapIntensity; this.specularMap = a.specularMap; this.alphaMap = a.alphaMap; this.envMap = a.envMap; this.combine = a.combine; this.reflectivity = a.reflectivity; this.refractionRatio = a.refractionRatio; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.wireframeLinecap = a.wireframeLinecap;
      this.wireframeLinejoin = a.wireframeLinejoin; this.skinning = a.skinning; this.morphTargets = a.morphTargets; return this;
    }; qa.prototype = Object.assign(Object.create(D.prototype), {
      constructor: qa, isMesh: !0, setDrawMode: function (a) { this.drawMode = a; }, copy: function (a) {
        D.prototype.copy.call(this, a); this.drawMode = a.drawMode; void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice()); void 0 !== a.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, a.morphTargetDictionary));
        return this;
      }, updateMorphTargets: function () { var a = this.geometry; if (a.isBufferGeometry) { a = a.morphAttributes; var b = Object.keys(a); if (0 < b.length) { var c = a[b[0]]; if (void 0 !== c) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) { var d = c[a].name || String(a); this.morphTargetInfluences.push(0); this.morphTargetDictionary[d] = a; } } } else a = a.morphTargets, void 0 !== a && 0 < a.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); },
      raycast: function () {
        function a(a, b, c, d, e, f, g, h) { if (null === (1 === b.side ? d.intersectTriangle(g, f, e, !0, h) : d.intersectTriangle(e, f, g, 2 !== b.side, h))) return null; x.copy(h); x.applyMatrix4(a.matrixWorld); b = c.ray.origin.distanceTo(x); return b < c.near || b > c.far ? null : { distance: b, point: x.clone(), object: a }; } function b(b, c, d, e, q, n, x, B, A, D) {
          f.fromBufferAttribute(q, B); g.fromBufferAttribute(q, A); h.fromBufferAttribute(q, D); q = b.morphTargetInfluences; if (c.morphTargets && n && q) {
            p.set(0, 0, 0); v.set(0, 0, 0); t.set(0, 0, 0); for (var y =
              0, G = n.length; y < G; y++) { var F = q[y], E = n[y]; 0 !== F && (l.fromBufferAttribute(E, B), m.fromBufferAttribute(E, A), k.fromBufferAttribute(E, D), p.addScaledVector(l.sub(f), F), v.addScaledVector(m.sub(g), F), t.addScaledVector(k.sub(h), F)); } f.add(p); g.add(v); h.add(t);
          } if (b = a(b, c, d, e, f, g, h, z)) x && (r.fromBufferAttribute(x, B), u.fromBufferAttribute(x, A), w.fromBufferAttribute(x, D), b.uv = ra.getUV(z, f, g, h, r, u, w, new C)), x = new Sb(B, A, D), ra.getNormal(f, g, h, x.normal), b.face = x; return b;
        } var c = new P, d = new zb, e = new Ta, f = new n, g = new n,
          h = new n, l = new n, m = new n, k = new n, p = new n, v = new n, t = new n, r = new C, u = new C, w = new C, z = new n, x = new n; return function (f, g) {
            var h = this.geometry, l = this.material, m = this.matrixWorld; if (void 0 !== l && (null === h.boundingSphere && h.computeBoundingSphere(), e.copy(h.boundingSphere), e.applyMatrix4(m), !1 !== f.ray.intersectsSphere(e) && (c.getInverse(m), d.copy(f.ray).applyMatrix4(c), null === h.boundingBox || !1 !== d.intersectsBox(h.boundingBox)))) if (h.isBufferGeometry) {
              var k = h.index; m = h.attributes.position; var q = h.morphAttributes.position,
                p = h.attributes.uv, n = h.groups, t = h.drawRange, v, x; if (null !== k) if (Array.isArray(l)) { var y = 0; for (v = n.length; y < v; y++) { var B = n[y]; var F = l[B.materialIndex]; var A = Math.max(B.start, t.start); for (x = h = Math.min(B.start + B.count, t.start + t.count); A < x; A += 3) { h = k.getX(A); var D = k.getX(A + 1); var E = k.getX(A + 2); if (h = b(this, F, f, d, m, q, p, h, D, E)) h.faceIndex = Math.floor(A / 3), h.face.materialIndex = B.materialIndex, g.push(h); } } } else for (A = Math.max(0, t.start), h = Math.min(k.count, t.start + t.count), y = A, v = h; y < v; y += 3) {
                  if (h = k.getX(y), D = k.getX(y +
                    1), E = k.getX(y + 2), h = b(this, l, f, d, m, q, p, h, D, E)) h.faceIndex = Math.floor(y / 3), g.push(h);
                } else if (void 0 !== m) if (Array.isArray(l)) for (y = 0, v = n.length; y < v; y++)for (B = n[y], F = l[B.materialIndex], A = Math.max(B.start, t.start), x = h = Math.min(B.start + B.count, t.start + t.count); A < x; A += 3) { if (h = A, D = A + 1, E = A + 2, h = b(this, F, f, d, m, q, p, h, D, E)) h.faceIndex = Math.floor(A / 3), h.face.materialIndex = B.materialIndex, g.push(h); } else for (A = Math.max(0, t.start), h = Math.min(m.count, t.start + t.count), y = A, v = h; y < v; y += 3)if (h = y, D = y + 1, E = y + 2, h = b(this, l,
                  f, d, m, q, p, h, D, E)) h.faceIndex = Math.floor(y / 3), g.push(h);
            } else if (h.isGeometry) for (m = Array.isArray(l), q = h.vertices, p = h.faces, h = h.faceVertexUvs[0], 0 < h.length && (k = h), v = 0, B = p.length; v < B; v++)if (F = p[v], h = m ? l[F.materialIndex] : l, void 0 !== h && (n = q[F.a], t = q[F.b], y = q[F.c], h = a(this, h, f, d, n, t, y, z))) k && k[v] && (A = k[v], r.copy(A[0]), u.copy(A[1]), w.copy(A[2]), h.uv = ra.getUV(z, n, t, y, r, u, w, new C)), h.face = F, h.faceIndex = v, g.push(h);
          };
      }(), clone: function () { return (new this.constructor(this.geometry, this.material)).copy(this); }
    });
  cb.prototype = Object.create(Y.prototype); cb.prototype.constructor = cb; cb.prototype.isCubeTexture = !0; Object.defineProperty(cb.prototype, "images", { get: function () { return this.image; }, set: function (a) { this.image = a; } }); Ub.prototype = Object.create(Y.prototype); Ub.prototype.constructor = Ub; Ub.prototype.isDataTexture2DArray = !0; Vb.prototype = Object.create(Y.prototype); Vb.prototype.constructor = Vb; Vb.prototype.isDataTexture3D = !0; var cf = new Y, yg = new Ub, Ag = new Vb, df = new cb, Xe = [], Ze = [], bf = new Float32Array(16), af = new Float32Array(9),
    $e = new Float32Array(4); hf.prototype.updateCache = function (a) { var b = this.cache; a instanceof Float32Array && b.length !== a.length && (this.cache = new Float32Array(a.length)); sa(b, a); }; jf.prototype.setValue = function (a, b, c) { for (var d = this.seq, e = 0, f = d.length; e !== f; ++e) { var g = d[e]; g.setValue(a, b[g.id], c); } }; var he = /([\w\d_]+)(\])?(\[|\.)?/g; ib.prototype.setValue = function (a, b, c, d) { b = this.map[b]; void 0 !== b && b.setValue(a, c, d); }; ib.prototype.setOptional = function (a, b, c) { b = b[c]; void 0 !== b && this.setValue(a, c, b); }; ib.upload =
      function (a, b, c, d) { for (var e = 0, f = b.length; e !== f; ++e) { var g = b[e], h = c[g.id]; !1 !== h.needsUpdate && g.setValue(a, h.value, d); } }; ib.seqWithValue = function (a, b) { for (var c = [], d = 0, e = a.length; d !== e; ++d) { var f = a[d]; f.id in b && c.push(f); } return c; }; var Vg = 0, ch = 0; jb.prototype = Object.create(Q.prototype); jb.prototype.constructor = jb; jb.prototype.isMeshDepthMaterial = !0; jb.prototype.copy = function (a) {
        Q.prototype.copy.call(this, a); this.depthPacking = a.depthPacking; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.map =
          a.map; this.alphaMap = a.alphaMap; this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; return this;
      }; kb.prototype = Object.create(Q.prototype); kb.prototype.constructor = kb; kb.prototype.isMeshDistanceMaterial = !0; kb.prototype.copy = function (a) {
        Q.prototype.copy.call(this, a); this.referencePosition.copy(a.referencePosition); this.nearDistance = a.nearDistance; this.farDistance =
          a.farDistance; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.map = a.map; this.alphaMap = a.alphaMap; this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias; return this;
      }; Xb.prototype = Object.assign(Object.create(D.prototype), { constructor: Xb, isGroup: !0 }); Xa.prototype = Object.assign(Object.create(D.prototype), {
        constructor: Xa, isCamera: !0, copy: function (a, b) {
          D.prototype.copy.call(this, a, b); this.matrixWorldInverse.copy(a.matrixWorldInverse);
          this.projectionMatrix.copy(a.projectionMatrix); this.projectionMatrixInverse.copy(a.projectionMatrixInverse); return this;
        }, getWorldDirection: function (a) { void 0 === a && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), a = new n); this.updateMatrixWorld(!0); var b = this.matrixWorld.elements; return a.set(-b[8], -b[9], -b[10]).normalize(); }, updateMatrixWorld: function (a) { D.prototype.updateMatrixWorld.call(this, a); this.matrixWorldInverse.getInverse(this.matrixWorld); }, clone: function () { return (new this.constructor).copy(this); }
      });
  ca.prototype = Object.assign(Object.create(Xa.prototype), {
    constructor: ca, isPerspectiveCamera: !0, copy: function (a, b) { Xa.prototype.copy.call(this, a, b); this.fov = a.fov; this.zoom = a.zoom; this.near = a.near; this.far = a.far; this.focus = a.focus; this.aspect = a.aspect; this.view = null === a.view ? null : Object.assign({}, a.view); this.filmGauge = a.filmGauge; this.filmOffset = a.filmOffset; return this; }, setFocalLength: function (a) { a = .5 * this.getFilmHeight() / a; this.fov = 2 * O.RAD2DEG * Math.atan(a); this.updateProjectionMatrix(); }, getFocalLength: function () {
      var a =
        Math.tan(.5 * O.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / a;
    }, getEffectiveFOV: function () { return 2 * O.RAD2DEG * Math.atan(Math.tan(.5 * O.DEG2RAD * this.fov) / this.zoom); }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1); }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1); }, setViewOffset: function (a, b, c, d, e, f) {
      this.aspect = a / b; null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }); this.view.enabled = !0; this.view.fullWidth =
        a; this.view.fullHeight = b; this.view.offsetX = c; this.view.offsetY = d; this.view.width = e; this.view.height = f; this.updateProjectionMatrix();
    }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1); this.updateProjectionMatrix(); }, updateProjectionMatrix: function () {
      var a = this.near, b = a * Math.tan(.5 * O.DEG2RAD * this.fov) / this.zoom, c = 2 * b, d = this.aspect * c, e = -.5 * d, f = this.view; if (null !== this.view && this.view.enabled) {
        var g = f.fullWidth, h = f.fullHeight; e += f.offsetX * d / g; b -= f.offsetY * c / h; d *= f.width / g; c *= f.height /
          h;
      } f = this.filmOffset; 0 !== f && (e += a * f / this.getFilmWidth()); this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far); this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    }, toJSON: function (a) {
      a = D.prototype.toJSON.call(this, a); a.object.fov = this.fov; a.object.zoom = this.zoom; a.object.near = this.near; a.object.far = this.far; a.object.focus = this.focus; a.object.aspect = this.aspect; null !== this.view && (a.object.view = Object.assign({}, this.view)); a.object.filmGauge = this.filmGauge; a.object.filmOffset = this.filmOffset;
      return a;
    }
  }); Jc.prototype = Object.assign(Object.create(ca.prototype), { constructor: Jc, isArrayCamera: !0 }); var vf = new n, wf = new n; Object.assign(Ad.prototype, { isFogExp2: !0, clone: function () { return new Ad(this.color, this.density); }, toJSON: function () { return { type: "FogExp2", color: this.color.getHex(), density: this.density }; } }); Object.assign(Bd.prototype, { isFog: !0, clone: function () { return new Bd(this.color, this.near, this.far); }, toJSON: function () { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far }; } });
  Cd.prototype = Object.assign(Object.create(D.prototype), {
    constructor: Cd, isScene: !0, copy: function (a, b) { D.prototype.copy.call(this, a, b); null !== a.background && (this.background = a.background.clone()); null !== a.fog && (this.fog = a.fog.clone()); null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone()); this.autoUpdate = a.autoUpdate; this.matrixAutoUpdate = a.matrixAutoUpdate; return this; }, toJSON: function (a) {
      var b = D.prototype.toJSON.call(this, a); null !== this.background && (b.object.background = this.background.toJSON(a));
      null !== this.fog && (b.object.fog = this.fog.toJSON()); return b;
    }, dispose: function () { this.dispatchEvent({ type: "dispose" }); }
  }); Object.defineProperty(Ab.prototype, "needsUpdate", { set: function (a) { !0 === a && this.version++; } }); Object.assign(Ab.prototype, {
    isInterleavedBuffer: !0, onUploadCallback: function () { }, setArray: function (a) { if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.count = void 0 !== a ? a.length / this.stride : 0; this.array = a; return this; }, setDynamic: function (a) {
      this.dynamic =
      a; return this;
    }, copy: function (a) { this.array = new a.array.constructor(a.array); this.count = a.count; this.stride = a.stride; this.dynamic = a.dynamic; return this; }, copyAt: function (a, b, c) { a *= this.stride; c *= b.stride; for (var d = 0, e = this.stride; d < e; d++)this.array[a + d] = b.array[c + d]; return this; }, set: function (a, b) { void 0 === b && (b = 0); this.array.set(a, b); return this; }, clone: function () { return (new this.constructor).copy(this); }, onUpload: function (a) { this.onUploadCallback = a; return this; }
  }); Object.defineProperties(Kc.prototype,
    { count: { get: function () { return this.data.count; } }, array: { get: function () { return this.data.array; } } }); Object.assign(Kc.prototype, {
      isInterleavedBufferAttribute: !0, setX: function (a, b) { this.data.array[a * this.data.stride + this.offset] = b; return this; }, setY: function (a, b) { this.data.array[a * this.data.stride + this.offset + 1] = b; return this; }, setZ: function (a, b) { this.data.array[a * this.data.stride + this.offset + 2] = b; return this; }, setW: function (a, b) { this.data.array[a * this.data.stride + this.offset + 3] = b; return this; }, getX: function (a) {
        return this.data.array[a *
          this.data.stride + this.offset];
      }, getY: function (a) { return this.data.array[a * this.data.stride + this.offset + 1]; }, getZ: function (a) { return this.data.array[a * this.data.stride + this.offset + 2]; }, getW: function (a) { return this.data.array[a * this.data.stride + this.offset + 3]; }, setXY: function (a, b, c) { a = a * this.data.stride + this.offset; this.data.array[a + 0] = b; this.data.array[a + 1] = c; return this; }, setXYZ: function (a, b, c, d) { a = a * this.data.stride + this.offset; this.data.array[a + 0] = b; this.data.array[a + 1] = c; this.data.array[a + 2] = d; return this; },
      setXYZW: function (a, b, c, d, e) { a = a * this.data.stride + this.offset; this.data.array[a + 0] = b; this.data.array[a + 1] = c; this.data.array[a + 2] = d; this.data.array[a + 3] = e; return this; }
    }); nb.prototype = Object.create(Q.prototype); nb.prototype.constructor = nb; nb.prototype.isSpriteMaterial = !0; nb.prototype.copy = function (a) { Q.prototype.copy.call(this, a); this.color.copy(a.color); this.map = a.map; this.rotation = a.rotation; this.sizeAttenuation = a.sizeAttenuation; return this; }; var Yb; Lc.prototype = Object.assign(Object.create(D.prototype),
      {
        constructor: Lc, isSprite: !0, raycast: function () {
          function a(a, b, c, d, h, l) { e.subVectors(a, c).addScalar(.5).multiply(d); void 0 !== h ? (f.x = l * e.x - h * e.y, f.y = h * e.x + l * e.y) : f.copy(e); a.copy(b); a.x += f.x; a.y += f.y; a.applyMatrix4(g); } var b = new n, c = new n, d = new n, e = new C, f = new C, g = new P, h = new n, l = new n, m = new n, k = new C, p = new C, v = new C; return function (e, f) {
            c.setFromMatrixScale(this.matrixWorld); g.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld); d.setFromMatrixPosition(this.modelViewMatrix); var q = this.material.rotation;
            if (0 !== q) { var n = Math.cos(q); var r = Math.sin(q); } q = this.center; a(h.set(-.5, -.5, 0), d, q, c, r, n); a(l.set(.5, -.5, 0), d, q, c, r, n); a(m.set(.5, .5, 0), d, q, c, r, n); k.set(0, 0); p.set(1, 0); v.set(1, 1); var t = e.ray.intersectTriangle(h, l, m, !1, b); if (null === t && (a(l.set(-.5, .5, 0), d, q, c, r, n), p.set(0, 1), t = e.ray.intersectTriangle(h, m, l, !1, b), null === t)) return; r = e.ray.origin.distanceTo(b); r < e.near || r > e.far || f.push({ distance: r, point: b.clone(), uv: ra.getUV(b, h, l, m, k, p, v, new C), face: null, object: this });
          };
        }(), clone: function () { return (new this.constructor(this.material)).copy(this); },
        copy: function (a) { D.prototype.copy.call(this, a); void 0 !== a.center && this.center.copy(a.center); return this; }
      }); Mc.prototype = Object.assign(Object.create(D.prototype), {
        constructor: Mc, isLOD: !0, copy: function (a) { D.prototype.copy.call(this, a, !1); a = a.levels; for (var b = 0, c = a.length; b < c; b++) { var d = a[b]; this.addLevel(d.object.clone(), d.distance); } return this; }, addLevel: function (a, b) {
          void 0 === b && (b = 0); b = Math.abs(b); for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++); c.splice(d, 0, { distance: b, object: a }); this.add(a);
          return this;
        }, getObjectForDistance: function (a) { for (var b = this.levels, c = 1, d = b.length; c < d && !(a < b[c].distance); c++); return b[c - 1].object; }, raycast: function () { var a = new n; return function (b, c) { a.setFromMatrixPosition(this.matrixWorld); var d = b.ray.origin.distanceTo(a); this.getObjectForDistance(d).raycast(b, c); }; }(), update: function () {
          var a = new n, b = new n; return function (c) {
            var d = this.levels; if (1 < d.length) {
              a.setFromMatrixPosition(c.matrixWorld); b.setFromMatrixPosition(this.matrixWorld); c = a.distanceTo(b); d[0].object.visible =
                !0; for (var e = 1, f = d.length; e < f; e++)if (c >= d[e].distance) d[e - 1].object.visible = !1, d[e].object.visible = !0; else break; for (; e < f; e++)d[e].object.visible = !1;
            }
          };
        }(), toJSON: function (a) { a = D.prototype.toJSON.call(this, a); a.object.levels = []; for (var b = this.levels, c = 0, d = b.length; c < d; c++) { var e = b[c]; a.object.levels.push({ object: e.object.uuid, distance: e.distance }); } return a; }
      }); Nc.prototype = Object.assign(Object.create(qa.prototype), {
        constructor: Nc, isSkinnedMesh: !0, bind: function (a, b) {
          this.skeleton = a; void 0 === b && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(), b = this.matrixWorld); this.bindMatrix.copy(b); this.bindMatrixInverse.getInverse(b);
        }, pose: function () { this.skeleton.pose(); }, normalizeSkinWeights: function () { for (var a = new W, b = this.geometry.attributes.skinWeight, c = 0, d = b.count; c < d; c++) { a.x = b.getX(c); a.y = b.getY(c); a.z = b.getZ(c); a.w = b.getW(c); var e = 1 / a.manhattanLength(); Infinity !== e ? a.multiplyScalar(e) : a.set(1, 0, 0, 0); b.setXYZW(c, a.x, a.y, a.z, a.w); } }, updateMatrixWorld: function (a) {
          qa.prototype.updateMatrixWorld.call(this, a); "attached" ===
            this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }, clone: function () { return (new this.constructor(this.geometry, this.material)).copy(this); }
      }); Object.assign(Dd.prototype, {
        calculateInverses: function () { this.boneInverses = []; for (var a = 0, b = this.bones.length; a < b; a++) { var c = new P; this.bones[a] && c.getInverse(this.bones[a].matrixWorld); this.boneInverses.push(c); } },
        pose: function () { var a, b; var c = 0; for (b = this.bones.length; c < b; c++)(a = this.bones[c]) && a.matrixWorld.getInverse(this.boneInverses[c]); c = 0; for (b = this.bones.length; c < b; c++)if (a = this.bones[c]) a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale); }, update: function () {
          var a = new P, b = new P; return function () {
            for (var c = this.bones, d = this.boneInverses, e = this.boneMatrices, f = this.boneTexture,
              g = 0, h = c.length; g < h; g++)a.multiplyMatrices(c[g] ? c[g].matrixWorld : b, d[g]), a.toArray(e, 16 * g); void 0 !== f && (f.needsUpdate = !0);
          };
        }(), clone: function () { return new Dd(this.bones, this.boneInverses); }, getBoneByName: function (a) { for (var b = 0, c = this.bones.length; b < c; b++) { var d = this.bones[b]; if (d.name === a) return d; } }
      }); ke.prototype = Object.assign(Object.create(D.prototype), { constructor: ke, isBone: !0 }); U.prototype = Object.create(Q.prototype); U.prototype.constructor = U; U.prototype.isLineBasicMaterial = !0; U.prototype.copy = function (a) {
        Q.prototype.copy.call(this,
          a); this.color.copy(a.color); this.linewidth = a.linewidth; this.linecap = a.linecap; this.linejoin = a.linejoin; return this;
      }; ka.prototype = Object.assign(Object.create(D.prototype), {
        constructor: ka, isLine: !0, computeLineDistances: function () {
          var a = new n, b = new n; return function () {
            var c = this.geometry; if (c.isBufferGeometry) if (null === c.index) {
              for (var d = c.attributes.position, e = [0], f = 1, g = d.count; f < g; f++)a.fromBufferAttribute(d, f - 1), b.fromBufferAttribute(d, f), e[f] = e[f - 1], e[f] += a.distanceTo(b); c.addAttribute("lineDistance",
                new E(e, 1));
            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (c.isGeometry) for (d = c.vertices, e = c.lineDistances, e[0] = 0, f = 1, g = d.length; f < g; f++)e[f] = e[f - 1], e[f] += d[f - 1].distanceTo(d[f]); return this;
          };
        }(), raycast: function () {
          var a = new P, b = new zb, c = new Ta; return function (d, e) {
            var f = d.linePrecision, g = this.geometry, h = this.matrixWorld; null === g.boundingSphere && g.computeBoundingSphere(); c.copy(g.boundingSphere); c.applyMatrix4(h); c.radius +=
              f; if (!1 !== d.ray.intersectsSphere(c)) {
                a.getInverse(h); b.copy(d.ray).applyMatrix4(a); f /= (this.scale.x + this.scale.y + this.scale.z) / 3; f *= f; var l = new n, m = new n; h = new n; var k = new n, p = this && this.isLineSegments ? 2 : 1; if (g.isBufferGeometry) {
                  var v = g.index, t = g.attributes.position.array; if (null !== v) {
                    v = v.array; g = 0; for (var r = v.length - 1; g < r; g += p) {
                      var u = v[g + 1]; l.fromArray(t, 3 * v[g]); m.fromArray(t, 3 * u); u = b.distanceSqToSegment(l, m, k, h); u > f || (k.applyMatrix4(this.matrixWorld), u = d.ray.origin.distanceTo(k), u < d.near || u > d.far ||
                        e.push({ distance: u, point: h.clone().applyMatrix4(this.matrixWorld), index: g, face: null, faceIndex: null, object: this }));
                    }
                  } else for (g = 0, r = t.length / 3 - 1; g < r; g += p)l.fromArray(t, 3 * g), m.fromArray(t, 3 * g + 3), u = b.distanceSqToSegment(l, m, k, h), u > f || (k.applyMatrix4(this.matrixWorld), u = d.ray.origin.distanceTo(k), u < d.near || u > d.far || e.push({ distance: u, point: h.clone().applyMatrix4(this.matrixWorld), index: g, face: null, faceIndex: null, object: this }));
                } else if (g.isGeometry) for (l = g.vertices, m = l.length, g = 0; g < m - 1; g += p)u = b.distanceSqToSegment(l[g],
                  l[g + 1], k, h), u > f || (k.applyMatrix4(this.matrixWorld), u = d.ray.origin.distanceTo(k), u < d.near || u > d.far || e.push({ distance: u, point: h.clone().applyMatrix4(this.matrixWorld), index: g, face: null, faceIndex: null, object: this }));
              }
          };
        }(), clone: function () { return (new this.constructor(this.geometry, this.material)).copy(this); }
      }); V.prototype = Object.assign(Object.create(ka.prototype), {
        constructor: V, isLineSegments: !0, computeLineDistances: function () {
          var a = new n, b = new n; return function () {
            var c = this.geometry; if (c.isBufferGeometry) if (null ===
              c.index) { for (var d = c.attributes.position, e = [], f = 0, g = d.count; f < g; f += 2)a.fromBufferAttribute(d, f), b.fromBufferAttribute(d, f + 1), e[f] = 0 === f ? 0 : e[f - 1], e[f + 1] = e[f] + a.distanceTo(b); c.addAttribute("lineDistance", new E(e, 1)); } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (c.isGeometry) for (d = c.vertices, e = c.lineDistances, f = 0, g = d.length; f < g; f += 2)a.copy(d[f]), b.copy(d[f + 1]), e[f] = 0 === f ? 0 : e[f - 1], e[f + 1] = e[f] + a.distanceTo(b); return this;
          };
        }()
      });
  Ed.prototype = Object.assign(Object.create(ka.prototype), { constructor: Ed, isLineLoop: !0 }); Ia.prototype = Object.create(Q.prototype); Ia.prototype.constructor = Ia; Ia.prototype.isPointsMaterial = !0; Ia.prototype.copy = function (a) { Q.prototype.copy.call(this, a); this.color.copy(a.color); this.map = a.map; this.size = a.size; this.sizeAttenuation = a.sizeAttenuation; this.morphTargets = a.morphTargets; return this; }; Zb.prototype = Object.assign(Object.create(D.prototype), {
    constructor: Zb, isPoints: !0, raycast: function () {
      var a = new P,
      b = new zb, c = new Ta; return function (d, e) {
        function f(a, c) { var f = b.distanceSqToPoint(a); f < k && (b.closestPointToPoint(a, p), p.applyMatrix4(l), a = d.ray.origin.distanceTo(p), a < d.near || a > d.far || e.push({ distance: a, distanceToRay: Math.sqrt(f), point: p.clone(), index: c, face: null, object: g })); } var g = this, h = this.geometry, l = this.matrixWorld, m = d.params.Points.threshold; null === h.boundingSphere && h.computeBoundingSphere(); c.copy(h.boundingSphere); c.applyMatrix4(l); c.radius += m; if (!1 !== d.ray.intersectsSphere(c)) {
          a.getInverse(l);
          b.copy(d.ray).applyMatrix4(a); m /= (this.scale.x + this.scale.y + this.scale.z) / 3; var k = m * m; m = new n; var p = new n; if (h.isBufferGeometry) { var v = h.index; h = h.attributes.position.array; if (null !== v) { var t = v.array; v = 0; for (var r = t.length; v < r; v++) { var u = t[v]; m.fromArray(h, 3 * u); f(m, u); } } else for (v = 0, t = h.length / 3; v < t; v++)m.fromArray(h, 3 * v), f(m, v); } else for (m = h.vertices, v = 0, t = m.length; v < t; v++)f(m[v], v);
        }
      };
    }(), clone: function () { return (new this.constructor(this.geometry, this.material)).copy(this); }
  }); le.prototype = Object.assign(Object.create(Y.prototype),
    { constructor: le, isVideoTexture: !0, update: function () { var a = this.image; a.readyState >= a.HAVE_CURRENT_DATA && (this.needsUpdate = !0); } }); $b.prototype = Object.create(Y.prototype); $b.prototype.constructor = $b; $b.prototype.isCompressedTexture = !0; Oc.prototype = Object.create(Y.prototype); Oc.prototype.constructor = Oc; Oc.prototype.isCanvasTexture = !0; Pc.prototype = Object.create(Y.prototype); Pc.prototype.constructor = Pc; Pc.prototype.isDepthTexture = !0; ac.prototype = Object.create(B.prototype); ac.prototype.constructor = ac; Qc.prototype =
      Object.create(K.prototype); Qc.prototype.constructor = Qc; bc.prototype = Object.create(B.prototype); bc.prototype.constructor = bc; Rc.prototype = Object.create(K.prototype); Rc.prototype.constructor = Rc; la.prototype = Object.create(B.prototype); la.prototype.constructor = la; Sc.prototype = Object.create(K.prototype); Sc.prototype.constructor = Sc; cc.prototype = Object.create(la.prototype); cc.prototype.constructor = cc; Tc.prototype = Object.create(K.prototype); Tc.prototype.constructor = Tc; Bb.prototype = Object.create(la.prototype);
  Bb.prototype.constructor = Bb; Uc.prototype = Object.create(K.prototype); Uc.prototype.constructor = Uc; dc.prototype = Object.create(la.prototype); dc.prototype.constructor = dc; Vc.prototype = Object.create(K.prototype); Vc.prototype.constructor = Vc; ec.prototype = Object.create(la.prototype); ec.prototype.constructor = ec; Wc.prototype = Object.create(K.prototype); Wc.prototype.constructor = Wc; Cb.prototype = Object.create(B.prototype); Cb.prototype.constructor = Cb; Cb.prototype.toJSON = function () {
    var a = B.prototype.toJSON.call(this);
    a.path = this.parameters.path.toJSON(); return a;
  }; Xc.prototype = Object.create(K.prototype); Xc.prototype.constructor = Xc; fc.prototype = Object.create(B.prototype); fc.prototype.constructor = fc; Yc.prototype = Object.create(K.prototype); Yc.prototype.constructor = Yc; gc.prototype = Object.create(B.prototype); gc.prototype.constructor = gc; var ph = {
    triangulate: function (a, b, c) {
      c = c || 2; var d = b && b.length, e = d ? b[0] * c : a.length, f = zf(a, 0, e, c, !0), g = []; if (!f) return g; var h; if (d) {
        var l = c; d = []; var m; var k = 0; for (m = b.length; k < m; k++) {
          var p =
            b[k] * l; var n = k < m - 1 ? b[k + 1] * l : a.length; p = zf(a, p, n, l, !1); p === p.next && (p.steiner = !0); d.push(jh(p));
        } d.sort(hh); for (k = 0; k < d.length; k++) { b = d[k]; l = f; if (l = ih(b, l)) b = Cf(l, b), $c(b, b.next); f = $c(f, f.next); }
      } if (a.length > 80 * c) { var t = h = a[0]; var r = d = a[1]; for (l = c; l < e; l += c)k = a[l], b = a[l + 1], k < t && (t = k), b < r && (r = b), k > h && (h = k), b > d && (d = b); h = Math.max(h - t, d - r); h = 0 !== h ? 1 / h : 0; } ad(f, g, c, t, r, h); return g;
    }
  }, db = {
    area: function (a) { for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++)c += a[d].x * a[e].y - a[e].x * a[d].y; return .5 * c; }, isClockWise: function (a) {
      return 0 >
        db.area(a);
    }, triangulateShape: function (a, b) { var c = [], d = [], e = []; Df(a); Ef(c, a); var f = a.length; b.forEach(Df); for (a = 0; a < b.length; a++)d.push(f), f += b[a].length, Ef(c, b[a]); b = ph.triangulate(c, d); for (a = 0; a < b.length; a += 3)e.push(b.slice(a, a + 3)); return e; }
  }; Eb.prototype = Object.create(K.prototype); Eb.prototype.constructor = Eb; Eb.prototype.toJSON = function () { var a = K.prototype.toJSON.call(this); return Ff(this.parameters.shapes, this.parameters.options, a); }; Ya.prototype = Object.create(B.prototype); Ya.prototype.constructor =
    Ya; Ya.prototype.toJSON = function () { var a = B.prototype.toJSON.call(this); return Ff(this.parameters.shapes, this.parameters.options, a); }; var kh = {
      generateTopUV: function (a, b, c, d, e) { a = b[3 * d]; d = b[3 * d + 1]; var f = b[3 * e]; e = b[3 * e + 1]; return [new C(b[3 * c], b[3 * c + 1]), new C(a, d), new C(f, e)]; }, generateSideWallUV: function (a, b, c, d, e, f) {
        a = b[3 * c]; var g = b[3 * c + 1]; c = b[3 * c + 2]; var h = b[3 * d], l = b[3 * d + 1]; d = b[3 * d + 2]; var m = b[3 * e], k = b[3 * e + 1]; e = b[3 * e + 2]; var p = b[3 * f], n = b[3 * f + 1]; b = b[3 * f + 2]; return .01 > Math.abs(g - l) ? [new C(a, 1 - c), new C(h, 1 - d),
        new C(m, 1 - e), new C(p, 1 - b)] : [new C(g, 1 - c), new C(l, 1 - d), new C(k, 1 - e), new C(n, 1 - b)];
      }
    }; cd.prototype = Object.create(K.prototype); cd.prototype.constructor = cd; hc.prototype = Object.create(Ya.prototype); hc.prototype.constructor = hc; dd.prototype = Object.create(K.prototype); dd.prototype.constructor = dd; ob.prototype = Object.create(B.prototype); ob.prototype.constructor = ob; ed.prototype = Object.create(K.prototype); ed.prototype.constructor = ed; ic.prototype = Object.create(B.prototype); ic.prototype.constructor = ic; fd.prototype =
      Object.create(K.prototype); fd.prototype.constructor = fd; jc.prototype = Object.create(B.prototype); jc.prototype.constructor = jc; Fb.prototype = Object.create(K.prototype); Fb.prototype.constructor = Fb; Fb.prototype.toJSON = function () { var a = K.prototype.toJSON.call(this); return Gf(this.parameters.shapes, a); }; Gb.prototype = Object.create(B.prototype); Gb.prototype.constructor = Gb; Gb.prototype.toJSON = function () { var a = B.prototype.toJSON.call(this); return Gf(this.parameters.shapes, a); }; kc.prototype = Object.create(B.prototype);
  kc.prototype.constructor = kc; Hb.prototype = Object.create(K.prototype); Hb.prototype.constructor = Hb; eb.prototype = Object.create(B.prototype); eb.prototype.constructor = eb; gd.prototype = Object.create(Hb.prototype); gd.prototype.constructor = gd; hd.prototype = Object.create(eb.prototype); hd.prototype.constructor = hd; id.prototype = Object.create(K.prototype); id.prototype.constructor = id; lc.prototype = Object.create(B.prototype); lc.prototype.constructor = lc; var xa = Object.freeze({
    WireframeGeometry: ac, ParametricGeometry: Qc,
    ParametricBufferGeometry: bc, TetrahedronGeometry: Sc, TetrahedronBufferGeometry: cc, OctahedronGeometry: Tc, OctahedronBufferGeometry: Bb, IcosahedronGeometry: Uc, IcosahedronBufferGeometry: dc, DodecahedronGeometry: Vc, DodecahedronBufferGeometry: ec, PolyhedronGeometry: Rc, PolyhedronBufferGeometry: la, TubeGeometry: Wc, TubeBufferGeometry: Cb, TorusKnotGeometry: Xc, TorusKnotBufferGeometry: fc, TorusGeometry: Yc, TorusBufferGeometry: gc, TextGeometry: cd, TextBufferGeometry: hc, SphereGeometry: dd, SphereBufferGeometry: ob, RingGeometry: ed,
    RingBufferGeometry: ic, PlaneGeometry: Gc, PlaneBufferGeometry: yb, LatheGeometry: fd, LatheBufferGeometry: jc, ShapeGeometry: Fb, ShapeBufferGeometry: Gb, ExtrudeGeometry: Eb, ExtrudeBufferGeometry: Ya, EdgesGeometry: kc, ConeGeometry: gd, ConeBufferGeometry: hd, CylinderGeometry: Hb, CylinderBufferGeometry: eb, CircleGeometry: id, CircleBufferGeometry: lc, BoxGeometry: Tb, BoxBufferGeometry: wb
  }); Ib.prototype = Object.create(Q.prototype); Ib.prototype.constructor = Ib; Ib.prototype.isShadowMaterial = !0; Ib.prototype.copy = function (a) {
    Q.prototype.copy.call(this,
      a); this.color.copy(a.color); return this;
  }; mc.prototype = Object.create(ea.prototype); mc.prototype.constructor = mc; mc.prototype.isRawShaderMaterial = !0; Za.prototype = Object.create(Q.prototype); Za.prototype.constructor = Za; Za.prototype.isMeshStandardMaterial = !0; Za.prototype.copy = function (a) {
    Q.prototype.copy.call(this, a); this.defines = { STANDARD: "" }; this.color.copy(a.color); this.roughness = a.roughness; this.metalness = a.metalness; this.map = a.map; this.lightMap = a.lightMap; this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap; this.aoMapIntensity = a.aoMapIntensity; this.emissive.copy(a.emissive); this.emissiveMap = a.emissiveMap; this.emissiveIntensity = a.emissiveIntensity; this.bumpMap = a.bumpMap; this.bumpScale = a.bumpScale; this.normalMap = a.normalMap; this.normalMapType = a.normalMapType; this.normalScale.copy(a.normalScale); this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias; this.roughnessMap = a.roughnessMap; this.metalnessMap = a.metalnessMap; this.alphaMap =
      a.alphaMap; this.envMap = a.envMap; this.envMapIntensity = a.envMapIntensity; this.refractionRatio = a.refractionRatio; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.wireframeLinecap = a.wireframeLinecap; this.wireframeLinejoin = a.wireframeLinejoin; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; return this;
  }; Jb.prototype = Object.create(Za.prototype); Jb.prototype.constructor = Jb; Jb.prototype.isMeshPhysicalMaterial = !0; Jb.prototype.copy = function (a) {
    Za.prototype.copy.call(this,
      a); this.defines = { PHYSICAL: "" }; this.reflectivity = a.reflectivity; this.clearCoat = a.clearCoat; this.clearCoatRoughness = a.clearCoatRoughness; return this;
  }; Ja.prototype = Object.create(Q.prototype); Ja.prototype.constructor = Ja; Ja.prototype.isMeshPhongMaterial = !0; Ja.prototype.copy = function (a) {
    Q.prototype.copy.call(this, a); this.color.copy(a.color); this.specular.copy(a.specular); this.shininess = a.shininess; this.map = a.map; this.lightMap = a.lightMap; this.lightMapIntensity = a.lightMapIntensity; this.aoMap = a.aoMap; this.aoMapIntensity =
      a.aoMapIntensity; this.emissive.copy(a.emissive); this.emissiveMap = a.emissiveMap; this.emissiveIntensity = a.emissiveIntensity; this.bumpMap = a.bumpMap; this.bumpScale = a.bumpScale; this.normalMap = a.normalMap; this.normalMapType = a.normalMapType; this.normalScale.copy(a.normalScale); this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias; this.specularMap = a.specularMap; this.alphaMap = a.alphaMap; this.envMap = a.envMap; this.combine = a.combine; this.reflectivity =
        a.reflectivity; this.refractionRatio = a.refractionRatio; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.wireframeLinecap = a.wireframeLinecap; this.wireframeLinejoin = a.wireframeLinejoin; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; return this;
  }; Kb.prototype = Object.create(Ja.prototype); Kb.prototype.constructor = Kb; Kb.prototype.isMeshToonMaterial = !0; Kb.prototype.copy = function (a) {
    Ja.prototype.copy.call(this, a); this.gradientMap = a.gradientMap;
    return this;
  }; Lb.prototype = Object.create(Q.prototype); Lb.prototype.constructor = Lb; Lb.prototype.isMeshNormalMaterial = !0; Lb.prototype.copy = function (a) {
    Q.prototype.copy.call(this, a); this.bumpMap = a.bumpMap; this.bumpScale = a.bumpScale; this.normalMap = a.normalMap; this.normalMapType = a.normalMapType; this.normalScale.copy(a.normalScale); this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias; this.wireframe = a.wireframe; this.wireframeLinewidth =
      a.wireframeLinewidth; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; return this;
  }; Mb.prototype = Object.create(Q.prototype); Mb.prototype.constructor = Mb; Mb.prototype.isMeshLambertMaterial = !0; Mb.prototype.copy = function (a) {
    Q.prototype.copy.call(this, a); this.color.copy(a.color); this.map = a.map; this.lightMap = a.lightMap; this.lightMapIntensity = a.lightMapIntensity; this.aoMap = a.aoMap; this.aoMapIntensity = a.aoMapIntensity; this.emissive.copy(a.emissive); this.emissiveMap =
      a.emissiveMap; this.emissiveIntensity = a.emissiveIntensity; this.specularMap = a.specularMap; this.alphaMap = a.alphaMap; this.envMap = a.envMap; this.combine = a.combine; this.reflectivity = a.reflectivity; this.refractionRatio = a.refractionRatio; this.wireframe = a.wireframe; this.wireframeLinewidth = a.wireframeLinewidth; this.wireframeLinecap = a.wireframeLinecap; this.wireframeLinejoin = a.wireframeLinejoin; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; return this;
  }; Nb.prototype =
    Object.create(Q.prototype); Nb.prototype.constructor = Nb; Nb.prototype.isMeshMatcapMaterial = !0; Nb.prototype.copy = function (a) {
      Q.prototype.copy.call(this, a); this.defines = { MATCAP: "" }; this.color.copy(a.color); this.matcap = a.matcap; this.map = a.map; this.bumpMap = a.bumpMap; this.bumpScale = a.bumpScale; this.normalMap = a.normalMap; this.normalMapType = a.normalMapType; this.normalScale.copy(a.normalScale); this.displacementMap = a.displacementMap; this.displacementScale = a.displacementScale; this.displacementBias = a.displacementBias;
      this.alphaMap = a.alphaMap; this.skinning = a.skinning; this.morphTargets = a.morphTargets; this.morphNormals = a.morphNormals; return this;
    }; Ob.prototype = Object.create(U.prototype); Ob.prototype.constructor = Ob; Ob.prototype.isLineDashedMaterial = !0; Ob.prototype.copy = function (a) { U.prototype.copy.call(this, a); this.scale = a.scale; this.dashSize = a.dashSize; this.gapSize = a.gapSize; return this; }; var qh = Object.freeze({
      ShadowMaterial: Ib, SpriteMaterial: nb, RawShaderMaterial: mc, ShaderMaterial: ea, PointsMaterial: Ia, MeshPhysicalMaterial: Jb,
      MeshStandardMaterial: Za, MeshPhongMaterial: Ja, MeshToonMaterial: Kb, MeshNormalMaterial: Lb, MeshLambertMaterial: Mb, MeshDepthMaterial: jb, MeshDistanceMaterial: kb, MeshBasicMaterial: Ca, MeshMatcapMaterial: Nb, LineDashedMaterial: Ob, LineBasicMaterial: U, Material: Q
    }), ba = {
      arraySlice: function (a, b, c) { return ba.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length)) : a.slice(b, c); }, convertArray: function (a, b, c) { return !a || !c && a.constructor === b ? a : "number" === typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a); },
      isTypedArray: function (a) { return ArrayBuffer.isView(a) && !(a instanceof DataView); }, getKeyframeOrder: function (a) { for (var b = a.length, c = Array(b), d = 0; d !== b; ++d)c[d] = d; c.sort(function (b, c) { return a[b] - a[c]; }); return c; }, sortedArray: function (a, b, c) { for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f)for (var h = c[f] * b, l = 0; l !== b; ++l)e[g++] = a[h + l]; return e; }, flattenJSON: function (a, b, c, d) {
        for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d];)f = a[e++]; if (void 0 !== f) {
          var g = f[d]; if (void 0 !== g) if (Array.isArray(g)) {
            do g =
              f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++]; while (void 0 !== f);
          } else if (void 0 !== g.toArray) { do g = f[d], void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++]; while (void 0 !== f); } else { do g = f[d], void 0 !== g && (b.push(f.time), c.push(g)), f = a[e++]; while (void 0 !== f); }
        }
      }
    }; Object.assign(Da.prototype, {
      evaluate: function (a) {
        var b = this.parameterPositions, c = this._cachedIndex, d = b[c], e = b[c - 1]; a: {
          b: {
            c: {
              d: if (!(a < d)) {
                for (var f = c + 2; ;) {
                  if (void 0 === d) {
                    if (a < e) break d; this._cachedIndex = c = b.length; return this.afterEnd_(c -
                      1, a, e);
                  } if (c === f) break; e = d; d = b[++c]; if (a < d) break b;
                } d = b.length; break c;
              } if (a >= e) break a; else { f = b[1]; a < f && (c = 2, e = f); for (f = c - 2; ;) { if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d); if (c === f) break; d = e; e = b[--c - 1]; if (a >= e) break b; } d = c; c = 0; }
            } for (; c < d;)e = c + d >>> 1, a < b[e] ? d = e : c = e + 1; d = b[c]; e = b[c - 1]; if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d); if (void 0 === d) return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, e, a);
          } this._cachedIndex = c; this.intervalChanged_(c, e, d);
        } return this.interpolate_(c,
          e, a, d);
      }, settings: null, DefaultSettings_: {}, getSettings_: function () { return this.settings || this.DefaultSettings_; }, copySampleValue_: function (a) { var b = this.resultBuffer, c = this.sampleValues, d = this.valueSize; a *= d; for (var e = 0; e !== d; ++e)b[e] = c[a + e]; return b; }, interpolate_: function () { throw Error("call to abstract method"); }, intervalChanged_: function () { }
    }); Object.assign(Da.prototype, { beforeStart_: Da.prototype.copySampleValue_, afterEnd_: Da.prototype.copySampleValue_ }); Gd.prototype = Object.assign(Object.create(Da.prototype),
      {
        constructor: Gd, DefaultSettings_: { endingStart: 2400, endingEnd: 2400 }, intervalChanged_: function (a, b, c) {
          var d = this.parameterPositions, e = a - 2, f = a + 1, g = d[e], h = d[f]; if (void 0 === g) switch (this.getSettings_().endingStart) { case 2401: e = a; g = 2 * b - c; break; case 2402: e = d.length - 2; g = b + d[e] - d[e + 1]; break; default: e = a, g = c; }if (void 0 === h) switch (this.getSettings_().endingEnd) { case 2401: f = a; h = 2 * c - b; break; case 2402: f = 1; h = c + d[1] - d[0]; break; default: f = a - 1, h = b; }a = .5 * (c - b); d = this.valueSize; this._weightPrev = a / (b - g); this._weightNext =
            a / (h - c); this._offsetPrev = e * d; this._offsetNext = f * d;
        }, interpolate_: function (a, b, c, d) { var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize; a *= g; var h = a - g, l = this._offsetPrev, m = this._offsetNext, k = this._weightPrev, p = this._weightNext, n = (c - b) / (d - b); c = n * n; d = c * n; b = -k * d + 2 * k * c - k * n; k = (1 + k) * d + (-1.5 - 2 * k) * c + (-.5 + k) * n + 1; n = (-1 - p) * d + (1.5 + p) * c + .5 * n; p = p * d - p * c; for (c = 0; c !== g; ++c)e[c] = b * f[l + c] + k * f[h + c] + n * f[a + c] + p * f[m + c]; return e; }
      }); jd.prototype = Object.assign(Object.create(Da.prototype), {
        constructor: jd, interpolate_: function (a,
          b, c, d) { var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize; a *= g; var h = a - g; b = (c - b) / (d - b); c = 1 - b; for (d = 0; d !== g; ++d)e[d] = f[h + d] * c + f[a + d] * b; return e; }
      }); Hd.prototype = Object.assign(Object.create(Da.prototype), { constructor: Hd, interpolate_: function (a) { return this.copySampleValue_(a - 1); } }); Object.assign(da, {
        toJSON: function (a) {
          var b = a.constructor; if (void 0 !== b.toJSON) b = b.toJSON(a); else {
            b = { name: a.name, times: ba.convertArray(a.times, Array), values: ba.convertArray(a.values, Array) }; var c = a.getInterpolation();
            c !== a.DefaultInterpolation && (b.interpolation = c);
          } b.type = a.ValueTypeName; return b;
        }
      }); Object.assign(da.prototype, {
        constructor: da, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function (a) { return new Hd(this.times, this.values, this.getValueSize(), a); }, InterpolantFactoryMethodLinear: function (a) { return new jd(this.times, this.values, this.getValueSize(), a); }, InterpolantFactoryMethodSmooth: function (a) {
          return new Gd(this.times, this.values, this.getValueSize(),
            a);
        }, setInterpolation: function (a) {
          switch (a) { case 2300: var b = this.InterpolantFactoryMethodDiscrete; break; case 2301: b = this.InterpolantFactoryMethodLinear; break; case 2302: b = this.InterpolantFactoryMethodSmooth; }if (void 0 === b) { b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) if (a !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw Error(b); console.warn("THREE.KeyframeTrack:", b); return this; } this.createInterpolant =
            b; return this;
        }, getInterpolation: function () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return 2300; case this.InterpolantFactoryMethodLinear: return 2301; case this.InterpolantFactoryMethodSmooth: return 2302; } }, getValueSize: function () { return this.values.length / this.times.length; }, shift: function (a) { if (0 !== a) for (var b = this.times, c = 0, d = b.length; c !== d; ++c)b[c] += a; return this; }, scale: function (a) { if (1 !== a) for (var b = this.times, c = 0, d = b.length; c !== d; ++c)b[c] *= a; return this; }, trim: function (a,
          b) { for (var c = this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a;)++e; for (; -1 !== f && c[f] > b;)--f; ++f; if (0 !== e || f !== d) e >= f && (f = Math.max(f, 1), e = f - 1), a = this.getValueSize(), this.times = ba.arraySlice(c, e, f), this.values = ba.arraySlice(this.values, e * a, f * a); return this; }, validate: function () {
            var a = !0, b = this.getValueSize(); 0 !== b - Math.floor(b) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), a = !1); var c = this.times; b = this.values; var d = c.length; 0 === d && (console.error("THREE.KeyframeTrack: Track is empty.",
              this), a = !1); for (var e = null, f = 0; f !== d; f++) { var g = c[f]; if ("number" === typeof g && isNaN(g)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, f, g); a = !1; break; } if (null !== e && e > g) { console.error("THREE.KeyframeTrack: Out of order keys.", this, f, g, e); a = !1; break; } e = g; } if (void 0 !== b && ba.isTypedArray(b)) for (f = 0, c = b.length; f !== c; ++f)if (d = b[f], isNaN(d)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, f, d); a = !1; break; } return a;
          }, optimize: function () {
            for (var a = this.times, b = this.values,
              c = this.getValueSize(), d = 2302 === this.getInterpolation(), e = 1, f = a.length - 1, g = 1; g < f; ++g) { var h = !1, l = a[g]; if (l !== a[g + 1] && (1 !== g || l !== l[0])) if (d) h = !0; else { var k = g * c, n = k - c, p = k + c; for (l = 0; l !== c; ++l) { var v = b[k + l]; if (v !== b[n + l] || v !== b[p + l]) { h = !0; break; } } } if (h) { if (g !== e) for (a[e] = a[g], h = g * c, k = e * c, l = 0; l !== c; ++l)b[k + l] = b[h + l]; ++e; } } if (0 < f) { a[e] = a[f]; h = f * c; k = e * c; for (l = 0; l !== c; ++l)b[k + l] = b[h + l]; ++e; } e !== a.length && (this.times = ba.arraySlice(a, 0, e), this.values = ba.arraySlice(b, 0, e * c)); return this;
          }, clone: function () {
            var a =
              ba.arraySlice(this.times, 0), b = ba.arraySlice(this.values, 0); a = new this.constructor(this.name, a, b); a.createInterpolant = this.createInterpolant; return a;
          }
      }); Id.prototype = Object.assign(Object.create(da.prototype), { constructor: Id, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }); Jd.prototype = Object.assign(Object.create(da.prototype), { constructor: Jd, ValueTypeName: "color" }); nc.prototype = Object.assign(Object.create(da.prototype),
        { constructor: nc, ValueTypeName: "number" }); Kd.prototype = Object.assign(Object.create(Da.prototype), { constructor: Kd, interpolate_: function (a, b, c, d) { var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize; a *= g; b = (c - b) / (d - b); for (c = a + g; a !== c; a += 4)ma.slerpFlat(e, 0, f, a - g, f, a, b); return e; } }); kd.prototype = Object.assign(Object.create(da.prototype), {
          constructor: kd, ValueTypeName: "quaternion", DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function (a) {
            return new Kd(this.times, this.values, this.getValueSize(),
              a);
          }, InterpolantFactoryMethodSmooth: void 0
        }); Ld.prototype = Object.assign(Object.create(da.prototype), { constructor: Ld, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }); oc.prototype = Object.assign(Object.create(da.prototype), { constructor: oc, ValueTypeName: "vector" }); Object.assign(Fa, {
          parse: function (a) {
            for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e)b.push(mh(c[e]).scale(d)); return new Fa(a.name,
              a.duration, b);
          }, toJSON: function (a) { var b = [], c = a.tracks; a = { name: a.name, duration: a.duration, tracks: b, uuid: a.uuid }; for (var d = 0, e = c.length; d !== e; ++d)b.push(da.toJSON(c[d])); return a; }, CreateFromMorphTargetSequence: function (a, b, c, d) {
            for (var e = b.length, f = [], g = 0; g < e; g++) {
              var h = [], l = []; h.push((g + e - 1) % e, g, (g + 1) % e); l.push(0, 1, 0); var k = ba.getKeyframeOrder(h); h = ba.sortedArray(h, 1, k); l = ba.sortedArray(l, 1, k); d || 0 !== h[0] || (h.push(e), l.push(l[0])); f.push((new nc(".morphTargetInfluences[" + b[g].name + "]", h, l)).scale(1 /
                c));
            } return new Fa(a, -1, f);
          }, findByName: function (a, b) { var c = a; Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations); for (a = 0; a < c.length; a++)if (c[a].name === b) return c[a]; return null; }, CreateClipsFromMorphTargetSequences: function (a, b, c) { for (var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, g = a.length; f < g; f++) { var h = a[f], l = h.name.match(e); if (l && 1 < l.length) { var k = l[1]; (l = d[k]) || (d[k] = l = []); l.push(h); } } a = []; for (k in d) a.push(Fa.CreateFromMorphTargetSequence(k, d[k], b, c)); return a; }, parseAnimation: function (a,
            b) {
              if (!a) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; var c = function (a, b, c, d, e) { if (0 !== c.length) { var f = [], g = []; ba.flattenJSON(c, f, g, d); 0 !== f.length && e.push(new a(b, f, g)); } }, d = [], e = a.name || "default", f = a.length || -1, g = a.fps || 30; a = a.hierarchy || []; for (var h = 0; h < a.length; h++) {
                var l = a[h].keys; if (l && 0 !== l.length) if (l[0].morphTargets) {
                  f = {}; for (var k = 0; k < l.length; k++)if (l[k].morphTargets) for (var n = 0; n < l[k].morphTargets.length; n++)f[l[k].morphTargets[n]] = -1; for (var p in f) {
                    var v =
                      [], t = []; for (n = 0; n !== l[k].morphTargets.length; ++n) { var r = l[k]; v.push(r.time); t.push(r.morphTarget === p ? 1 : 0); } d.push(new nc(".morphTargetInfluence[" + p + "]", v, t));
                  } f = f.length * (g || 1);
                } else k = ".bones[" + b[h].name + "]", c(oc, k + ".position", l, "pos", d), c(kd, k + ".quaternion", l, "rot", d), c(oc, k + ".scale", l, "scl", d);
              } return 0 === d.length ? null : new Fa(e, f, d);
          }
        }); Object.assign(Fa.prototype, {
          resetDuration: function () {
            for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) { var d = this.tracks[b]; a = Math.max(a, d.times[d.times.length - 1]); } this.duration =
              a; return this;
          }, trim: function () { for (var a = 0; a < this.tracks.length; a++)this.tracks[a].trim(0, this.duration); return this; }, validate: function () { for (var a = !0, b = 0; b < this.tracks.length; b++)a = a && this.tracks[b].validate(); return a; }, optimize: function () { for (var a = 0; a < this.tracks.length; a++)this.tracks[a].optimize(); return this; }, clone: function () { for (var a = [], b = 0; b < this.tracks.length; b++)a.push(this.tracks[b].clone()); return new Fa(this.name, this.duration, a); }
        }); var Qb = {
          enabled: !1, files: {}, add: function (a, b) {
            !1 !==
            this.enabled && (this.files[a] = b);
          }, get: function (a) { if (!1 !== this.enabled) return this.files[a]; }, remove: function (a) { delete this.files[a]; }, clear: function () { this.files = {}; }
        }, za = new oe, Ra = {}; Object.assign(Ka.prototype, {
          load: function (a, b, c, d) {
            void 0 === a && (a = ""); void 0 !== this.path && (a = this.path + a); a = this.manager.resolveURL(a); var e = this, f = Qb.get(a); if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function () { b && b(f); e.manager.itemEnd(a); }, 0), f; if (void 0 !== Ra[a]) Ra[a].push({ onLoad: b, onProgress: c, onError: d });
            else {
              var g = a.match(/^data:(.*?)(;base64)?,(.*)$/); if (g) {
                c = g[1]; var h = !!g[2]; g = g[3]; g = decodeURIComponent(g); h && (g = atob(g)); try {
                  var l = (this.responseType || "").toLowerCase(); switch (l) { case "arraybuffer": case "blob": var k = new Uint8Array(g.length); for (h = 0; h < g.length; h++)k[h] = g.charCodeAt(h); var n = "blob" === l ? new Blob([k.buffer], { type: c }) : k.buffer; break; case "document": n = (new DOMParser).parseFromString(g, c); break; case "json": n = JSON.parse(g); break; default: n = g; }setTimeout(function () { b && b(n); e.manager.itemEnd(a); },
                    0);
                } catch (v) { setTimeout(function () { d && d(v); e.manager.itemError(a); e.manager.itemEnd(a); }, 0); }
              } else {
                Ra[a] = []; Ra[a].push({ onLoad: b, onProgress: c, onError: d }); var p = new XMLHttpRequest; p.open("GET", a, !0); p.addEventListener("load", function (b) {
                  var c = this.response; Qb.add(a, c); var d = Ra[a]; delete Ra[a]; if (200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."); for (var f = 0, g = d.length; f < g; f++) { var h = d[f]; if (h.onLoad) h.onLoad(c); } } else {
                    f = 0; for (g = d.length; f < g; f++)if (h =
                      d[f], h.onError) h.onError(b); e.manager.itemError(a);
                  } e.manager.itemEnd(a);
                }, !1); p.addEventListener("progress", function (b) { for (var c = Ra[a], d = 0, e = c.length; d < e; d++) { var f = c[d]; if (f.onProgress) f.onProgress(b); } }, !1); p.addEventListener("error", function (b) { var c = Ra[a]; delete Ra[a]; for (var d = 0, f = c.length; d < f; d++) { var g = c[d]; if (g.onError) g.onError(b); } e.manager.itemError(a); e.manager.itemEnd(a); }, !1); p.addEventListener("abort", function (b) {
                  var c = Ra[a]; delete Ra[a]; for (var d = 0, f = c.length; d < f; d++) { var g = c[d]; if (g.onError) g.onError(b); } e.manager.itemError(a);
                  e.manager.itemEnd(a);
                }, !1); void 0 !== this.responseType && (p.responseType = this.responseType); void 0 !== this.withCredentials && (p.withCredentials = this.withCredentials); p.overrideMimeType && p.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"); for (h in this.requestHeader) p.setRequestHeader(h, this.requestHeader[h]); p.send(null);
              } e.manager.itemStart(a); return p;
            }
          }, setPath: function (a) { this.path = a; return this; }, setResponseType: function (a) { this.responseType = a; return this; }, setWithCredentials: function (a) {
            this.withCredentials =
            a; return this;
          }, setMimeType: function (a) { this.mimeType = a; return this; }, setRequestHeader: function (a) { this.requestHeader = a; return this; }
        }); Object.assign(Hf.prototype, { load: function (a, b, c, d) { var e = this, f = new Ka(e.manager); f.setPath(e.path); f.load(a, function (a) { b(e.parse(JSON.parse(a))); }, c, d); }, parse: function (a) { for (var b = [], c = 0; c < a.length; c++) { var d = Fa.parse(a[c]); b.push(d); } return b; }, setPath: function (a) { this.path = a; return this; } }); Object.assign(If.prototype, {
          load: function (a, b, c, d) {
            function e(e) {
              l.load(a[e],
                function (a) { a = f._parser(a, !0); g[e] = { width: a.width, height: a.height, format: a.format, mipmaps: a.mipmaps }; k += 1; 6 === k && (1 === a.mipmapCount && (h.minFilter = 1006), h.format = a.format, h.needsUpdate = !0, b && b(h)); }, c, d);
            } var f = this, g = [], h = new $b; h.image = g; var l = new Ka(this.manager); l.setPath(this.path); l.setResponseType("arraybuffer"); if (Array.isArray(a)) for (var k = 0, n = 0, p = a.length; n < p; ++n)e(n); else l.load(a, function (a) {
              a = f._parser(a, !0); if (a.isCubemap) for (var c = a.mipmaps.length / a.mipmapCount, d = 0; d < c; d++) {
                g[d] = { mipmaps: [] };
                for (var e = 0; e < a.mipmapCount; e++)g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]), g[d].format = a.format, g[d].width = a.width, g[d].height = a.height;
              } else h.image.width = a.width, h.image.height = a.height, h.mipmaps = a.mipmaps; 1 === a.mipmapCount && (h.minFilter = 1006); h.format = a.format; h.needsUpdate = !0; b && b(h);
            }, c, d); return h;
          }, setPath: function (a) { this.path = a; return this; }
        }); Object.assign(pe.prototype, {
          load: function (a, b, c, d) {
            var e = this, f = new sb, g = new Ka(this.manager); g.setResponseType("arraybuffer"); g.setPath(this.path);
            g.load(a, function (a) {
              if (a = e._parser(a)) void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, f.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001, f.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006, f.minFilter = void 0 !== a.minFilter ? a.minFilter : 1008, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 ===
                a.mipmapCount && (f.minFilter = 1006), f.needsUpdate = !0, b && b(f, a);
            }, c, d); return f;
          }, setPath: function (a) { this.path = a; return this; }
        }); Object.assign(ld.prototype, {
          crossOrigin: "anonymous", load: function (a, b, c, d) {
            function e() { l.removeEventListener("load", e, !1); l.removeEventListener("error", f, !1); Qb.add(a, this); b && b(this); g.manager.itemEnd(a); } function f(b) { l.removeEventListener("load", e, !1); l.removeEventListener("error", f, !1); d && d(b); g.manager.itemError(a); g.manager.itemEnd(a); } void 0 === a && (a = ""); void 0 !== this.path &&
              (a = this.path + a); a = this.manager.resolveURL(a); var g = this, h = Qb.get(a); if (void 0 !== h) return g.manager.itemStart(a), setTimeout(function () { b && b(h); g.manager.itemEnd(a); }, 0), h; var l = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); l.addEventListener("load", e, !1); l.addEventListener("error", f, !1); "data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (l.crossOrigin = this.crossOrigin); g.manager.itemStart(a); l.src = a; return l;
          }, setCrossOrigin: function (a) { this.crossOrigin = a; return this; }, setPath: function (a) {
            this.path =
            a; return this;
          }
        }); Object.assign(qe.prototype, { crossOrigin: "anonymous", load: function (a, b, c, d) { function e(c) { g.load(a[c], function (a) { f.images[c] = a; h++; 6 === h && (f.needsUpdate = !0, b && b(f)); }, void 0, d); } var f = new cb, g = new ld(this.manager); g.setCrossOrigin(this.crossOrigin); g.setPath(this.path); var h = 0; for (c = 0; c < a.length; ++c)e(c); return f; }, setCrossOrigin: function (a) { this.crossOrigin = a; return this; }, setPath: function (a) { this.path = a; return this; } }); Object.assign(Md.prototype, {
          crossOrigin: "anonymous", load: function (a,
            b, c, d) { var e = new Y, f = new ld(this.manager); f.setCrossOrigin(this.crossOrigin); f.setPath(this.path); f.load(a, function (c) { e.image = c; c = 0 < a.search(/\.jpe?g($|\?)/i) || 0 === a.search(/^data:image\/jpeg/); e.format = c ? 1022 : 1023; e.needsUpdate = !0; void 0 !== b && b(e); }, c, d); return e; }, setCrossOrigin: function (a) { this.crossOrigin = a; return this; }, setPath: function (a) { this.path = a; return this; }
        }); Object.assign(M.prototype, {
          getPoint: function () { console.warn("THREE.Curve: .getPoint() not implemented."); return null; }, getPointAt: function (a,
            b) { a = this.getUtoTmapping(a); return this.getPoint(a, b); }, getPoints: function (a) { void 0 === a && (a = 5); for (var b = [], c = 0; c <= a; c++)b.push(this.getPoint(c / a)); return b; }, getSpacedPoints: function (a) { void 0 === a && (a = 5); for (var b = [], c = 0; c <= a; c++)b.push(this.getPointAt(c / a)); return b; }, getLength: function () { var a = this.getLengths(); return a[a.length - 1]; }, getLengths: function (a) {
              void 0 === a && (a = this.arcLengthDivisions); if (this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths;
              this.needsUpdate = !1; var b = [], c = this.getPoint(0), d, e = 0; b.push(0); for (d = 1; d <= a; d++) { var f = this.getPoint(d / a); e += f.distanceTo(c); b.push(e); c = f; } return this.cacheArcLengths = b;
            }, updateArcLengths: function () { this.needsUpdate = !0; this.getLengths(); }, getUtoTmapping: function (a, b) { var c = this.getLengths(), d = c.length; b = b ? b : a * c[d - 1]; for (var e = 0, f = d - 1, g; e <= f;)if (a = Math.floor(e + (f - e) / 2), g = c[a] - b, 0 > g) e = a + 1; else if (0 < g) f = a - 1; else { f = a; break; } a = f; if (c[a] === b) return a / (d - 1); e = c[a]; return (a + (b - e) / (c[a + 1] - e)) / (d - 1); }, getTangent: function (a) {
              var b =
                a - 1E-4; a += 1E-4; 0 > b && (b = 0); 1 < a && (a = 1); b = this.getPoint(b); return this.getPoint(a).clone().sub(b).normalize();
            }, getTangentAt: function (a) { a = this.getUtoTmapping(a); return this.getTangent(a); }, computeFrenetFrames: function (a, b) {
              var c = new n, d = [], e = [], f = [], g = new n, h = new P, l; for (l = 0; l <= a; l++) { var k = l / a; d[l] = this.getTangentAt(k); d[l].normalize(); } e[0] = new n; f[0] = new n; l = Number.MAX_VALUE; k = Math.abs(d[0].x); var q = Math.abs(d[0].y), p = Math.abs(d[0].z); k <= l && (l = k, c.set(1, 0, 0)); q <= l && (l = q, c.set(0, 1, 0)); p <= l && c.set(0,
                0, 1); g.crossVectors(d[0], c).normalize(); e[0].crossVectors(d[0], g); f[0].crossVectors(d[0], e[0]); for (l = 1; l <= a; l++)e[l] = e[l - 1].clone(), f[l] = f[l - 1].clone(), g.crossVectors(d[l - 1], d[l]), g.length() > Number.EPSILON && (g.normalize(), c = Math.acos(O.clamp(d[l - 1].dot(d[l]), -1, 1)), e[l].applyMatrix4(h.makeRotationAxis(g, c))), f[l].crossVectors(d[l], e[l]); if (!0 === b) for (c = Math.acos(O.clamp(e[0].dot(e[a]), -1, 1)), c /= a, 0 < d[0].dot(g.crossVectors(e[0], e[a])) && (c = -c), l = 1; l <= a; l++)e[l].applyMatrix4(h.makeRotationAxis(d[l],
                  c * l)), f[l].crossVectors(d[l], e[l]); return { tangents: d, normals: e, binormals: f };
            }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { this.arcLengthDivisions = a.arcLengthDivisions; return this; }, toJSON: function () { var a = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; a.arcLengthDivisions = this.arcLengthDivisions; a.type = this.type; return a; }, fromJSON: function (a) { this.arcLengthDivisions = a.arcLengthDivisions; return this; }
        }); Ea.prototype = Object.create(M.prototype); Ea.prototype.constructor =
          Ea; Ea.prototype.isEllipseCurve = !0; Ea.prototype.getPoint = function (a, b) {
            b = b || new C; for (var c = 2 * Math.PI, d = this.aEndAngle - this.aStartAngle, e = Math.abs(d) < Number.EPSILON; 0 > d;)d += c; for (; d > c;)d -= c; d < Number.EPSILON && (d = e ? 0 : c); !0 !== this.aClockwise || e || (d = d === c ? -c : d - c); c = this.aStartAngle + a * d; a = this.aX + this.xRadius * Math.cos(c); var f = this.aY + this.yRadius * Math.sin(c); 0 !== this.aRotation && (c = Math.cos(this.aRotation), d = Math.sin(this.aRotation), e = a - this.aX, f -= this.aY, a = e * c - f * d + this.aX, f = e * d + f * c + this.aY); return b.set(a,
              f);
          }; Ea.prototype.copy = function (a) { M.prototype.copy.call(this, a); this.aX = a.aX; this.aY = a.aY; this.xRadius = a.xRadius; this.yRadius = a.yRadius; this.aStartAngle = a.aStartAngle; this.aEndAngle = a.aEndAngle; this.aClockwise = a.aClockwise; this.aRotation = a.aRotation; return this; }; Ea.prototype.toJSON = function () {
            var a = M.prototype.toJSON.call(this); a.aX = this.aX; a.aY = this.aY; a.xRadius = this.xRadius; a.yRadius = this.yRadius; a.aStartAngle = this.aStartAngle; a.aEndAngle = this.aEndAngle; a.aClockwise = this.aClockwise; a.aRotation =
              this.aRotation; return a;
          }; Ea.prototype.fromJSON = function (a) { M.prototype.fromJSON.call(this, a); this.aX = a.aX; this.aY = a.aY; this.xRadius = a.xRadius; this.yRadius = a.yRadius; this.aStartAngle = a.aStartAngle; this.aEndAngle = a.aEndAngle; this.aClockwise = a.aClockwise; this.aRotation = a.aRotation; return this; }; pc.prototype = Object.create(Ea.prototype); pc.prototype.constructor = pc; pc.prototype.isArcCurve = !0; var ae = new n, Pe = new re, Qe = new re, Re = new re; oa.prototype = Object.create(M.prototype); oa.prototype.constructor = oa; oa.prototype.isCatmullRomCurve3 =
            !0; oa.prototype.getPoint = function (a, b) {
              b = b || new n; var c = this.points, d = c.length; a *= d - (this.closed ? 0 : 1); var e = Math.floor(a); a -= e; this.closed ? e += 0 < e ? 0 : (Math.floor(Math.abs(e) / d) + 1) * d : 0 === a && e === d - 1 && (e = d - 2, a = 1); if (this.closed || 0 < e) var f = c[(e - 1) % d]; else ae.subVectors(c[0], c[1]).add(c[0]), f = ae; var g = c[e % d]; var h = c[(e + 1) % d]; this.closed || e + 2 < d ? c = c[(e + 2) % d] : (ae.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]), c = ae); if ("centripetal" === this.curveType || "chordal" === this.curveType) {
                var l = "chordal" === this.curveType ? .5 : .25;
                d = Math.pow(f.distanceToSquared(g), l); e = Math.pow(g.distanceToSquared(h), l); l = Math.pow(h.distanceToSquared(c), l); 1E-4 > e && (e = 1); 1E-4 > d && (d = e); 1E-4 > l && (l = e); Pe.initNonuniformCatmullRom(f.x, g.x, h.x, c.x, d, e, l); Qe.initNonuniformCatmullRom(f.y, g.y, h.y, c.y, d, e, l); Re.initNonuniformCatmullRom(f.z, g.z, h.z, c.z, d, e, l);
              } else "catmullrom" === this.curveType && (Pe.initCatmullRom(f.x, g.x, h.x, c.x, this.tension), Qe.initCatmullRom(f.y, g.y, h.y, c.y, this.tension), Re.initCatmullRom(f.z, g.z, h.z, c.z, this.tension)); b.set(Pe.calc(a),
                Qe.calc(a), Re.calc(a)); return b;
            }; oa.prototype.copy = function (a) { M.prototype.copy.call(this, a); this.points = []; for (var b = 0, c = a.points.length; b < c; b++)this.points.push(a.points[b].clone()); this.closed = a.closed; this.curveType = a.curveType; this.tension = a.tension; return this; }; oa.prototype.toJSON = function () { var a = M.prototype.toJSON.call(this); a.points = []; for (var b = 0, c = this.points.length; b < c; b++)a.points.push(this.points[b].toArray()); a.closed = this.closed; a.curveType = this.curveType; a.tension = this.tension; return a; };
  oa.prototype.fromJSON = function (a) { M.prototype.fromJSON.call(this, a); this.points = []; for (var b = 0, c = a.points.length; b < c; b++) { var d = a.points[b]; this.points.push((new n).fromArray(d)); } this.closed = a.closed; this.curveType = a.curveType; this.tension = a.tension; return this; }; La.prototype = Object.create(M.prototype); La.prototype.constructor = La; La.prototype.isCubicBezierCurve = !0; La.prototype.getPoint = function (a, b) {
    b = b || new C; var c = this.v0, d = this.v1, e = this.v2, f = this.v3; b.set(nd(a, c.x, d.x, e.x, f.x), nd(a, c.y, d.y, e.y,
      f.y)); return b;
  }; La.prototype.copy = function (a) { M.prototype.copy.call(this, a); this.v0.copy(a.v0); this.v1.copy(a.v1); this.v2.copy(a.v2); this.v3.copy(a.v3); return this; }; La.prototype.toJSON = function () { var a = M.prototype.toJSON.call(this); a.v0 = this.v0.toArray(); a.v1 = this.v1.toArray(); a.v2 = this.v2.toArray(); a.v3 = this.v3.toArray(); return a; }; La.prototype.fromJSON = function (a) { M.prototype.fromJSON.call(this, a); this.v0.fromArray(a.v0); this.v1.fromArray(a.v1); this.v2.fromArray(a.v2); this.v3.fromArray(a.v3); return this; };
  $a.prototype = Object.create(M.prototype); $a.prototype.constructor = $a; $a.prototype.isCubicBezierCurve3 = !0; $a.prototype.getPoint = function (a, b) { b = b || new n; var c = this.v0, d = this.v1, e = this.v2, f = this.v3; b.set(nd(a, c.x, d.x, e.x, f.x), nd(a, c.y, d.y, e.y, f.y), nd(a, c.z, d.z, e.z, f.z)); return b; }; $a.prototype.copy = function (a) { M.prototype.copy.call(this, a); this.v0.copy(a.v0); this.v1.copy(a.v1); this.v2.copy(a.v2); this.v3.copy(a.v3); return this; }; $a.prototype.toJSON = function () {
    var a = M.prototype.toJSON.call(this); a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray(); a.v2 = this.v2.toArray(); a.v3 = this.v3.toArray(); return a;
  }; $a.prototype.fromJSON = function (a) { M.prototype.fromJSON.call(this, a); this.v0.fromArray(a.v0); this.v1.fromArray(a.v1); this.v2.fromArray(a.v2); this.v3.fromArray(a.v3); return this; }; wa.prototype = Object.create(M.prototype); wa.prototype.constructor = wa; wa.prototype.isLineCurve = !0; wa.prototype.getPoint = function (a, b) { b = b || new C; 1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1)); return b; }; wa.prototype.getPointAt =
    function (a, b) { return this.getPoint(a, b); }; wa.prototype.getTangent = function () { return this.v2.clone().sub(this.v1).normalize(); }; wa.prototype.copy = function (a) { M.prototype.copy.call(this, a); this.v1.copy(a.v1); this.v2.copy(a.v2); return this; }; wa.prototype.toJSON = function () { var a = M.prototype.toJSON.call(this); a.v1 = this.v1.toArray(); a.v2 = this.v2.toArray(); return a; }; wa.prototype.fromJSON = function (a) { M.prototype.fromJSON.call(this, a); this.v1.fromArray(a.v1); this.v2.fromArray(a.v2); return this; }; Ma.prototype =
      Object.create(M.prototype); Ma.prototype.constructor = Ma; Ma.prototype.isLineCurve3 = !0; Ma.prototype.getPoint = function (a, b) { b = b || new n; 1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1)); return b; }; Ma.prototype.getPointAt = function (a, b) { return this.getPoint(a, b); }; Ma.prototype.copy = function (a) { M.prototype.copy.call(this, a); this.v1.copy(a.v1); this.v2.copy(a.v2); return this; }; Ma.prototype.toJSON = function () {
        var a = M.prototype.toJSON.call(this); a.v1 = this.v1.toArray(); a.v2 = this.v2.toArray();
        return a;
      }; Ma.prototype.fromJSON = function (a) { M.prototype.fromJSON.call(this, a); this.v1.fromArray(a.v1); this.v2.fromArray(a.v2); return this; }; Na.prototype = Object.create(M.prototype); Na.prototype.constructor = Na; Na.prototype.isQuadraticBezierCurve = !0; Na.prototype.getPoint = function (a, b) { b = b || new C; var c = this.v0, d = this.v1, e = this.v2; b.set(md(a, c.x, d.x, e.x), md(a, c.y, d.y, e.y)); return b; }; Na.prototype.copy = function (a) { M.prototype.copy.call(this, a); this.v0.copy(a.v0); this.v1.copy(a.v1); this.v2.copy(a.v2); return this; };
  Na.prototype.toJSON = function () { var a = M.prototype.toJSON.call(this); a.v0 = this.v0.toArray(); a.v1 = this.v1.toArray(); a.v2 = this.v2.toArray(); return a; }; Na.prototype.fromJSON = function (a) { M.prototype.fromJSON.call(this, a); this.v0.fromArray(a.v0); this.v1.fromArray(a.v1); this.v2.fromArray(a.v2); return this; }; ab.prototype = Object.create(M.prototype); ab.prototype.constructor = ab; ab.prototype.isQuadraticBezierCurve3 = !0; ab.prototype.getPoint = function (a, b) {
    b = b || new n; var c = this.v0, d = this.v1, e = this.v2; b.set(md(a, c.x,
      d.x, e.x), md(a, c.y, d.y, e.y), md(a, c.z, d.z, e.z)); return b;
  }; ab.prototype.copy = function (a) { M.prototype.copy.call(this, a); this.v0.copy(a.v0); this.v1.copy(a.v1); this.v2.copy(a.v2); return this; }; ab.prototype.toJSON = function () { var a = M.prototype.toJSON.call(this); a.v0 = this.v0.toArray(); a.v1 = this.v1.toArray(); a.v2 = this.v2.toArray(); return a; }; ab.prototype.fromJSON = function (a) { M.prototype.fromJSON.call(this, a); this.v0.fromArray(a.v0); this.v1.fromArray(a.v1); this.v2.fromArray(a.v2); return this; }; Oa.prototype = Object.create(M.prototype);
  Oa.prototype.constructor = Oa; Oa.prototype.isSplineCurve = !0; Oa.prototype.getPoint = function (a, b) { b = b || new C; var c = this.points, d = (c.length - 1) * a; a = Math.floor(d); d -= a; var e = c[0 === a ? a : a - 1], f = c[a], g = c[a > c.length - 2 ? c.length - 1 : a + 1]; c = c[a > c.length - 3 ? c.length - 1 : a + 2]; b.set(Jf(d, e.x, f.x, g.x, c.x), Jf(d, e.y, f.y, g.y, c.y)); return b; }; Oa.prototype.copy = function (a) { M.prototype.copy.call(this, a); this.points = []; for (var b = 0, c = a.points.length; b < c; b++)this.points.push(a.points[b].clone()); return this; }; Oa.prototype.toJSON = function () {
    var a =
      M.prototype.toJSON.call(this); a.points = []; for (var b = 0, c = this.points.length; b < c; b++)a.points.push(this.points[b].toArray()); return a;
  }; Oa.prototype.fromJSON = function (a) { M.prototype.fromJSON.call(this, a); this.points = []; for (var b = 0, c = a.points.length; b < c; b++) { var d = a.points[b]; this.points.push((new C).fromArray(d)); } return this; }; var Se = Object.freeze({
    ArcCurve: pc, CatmullRomCurve3: oa, CubicBezierCurve: La, CubicBezierCurve3: $a, EllipseCurve: Ea, LineCurve: wa, LineCurve3: Ma, QuadraticBezierCurve: Na, QuadraticBezierCurve3: ab,
    SplineCurve: Oa
  }); fb.prototype = Object.assign(Object.create(M.prototype), {
    constructor: fb, add: function (a) { this.curves.push(a); }, closePath: function () { var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1); a.equals(b) || this.curves.push(new wa(b, a)); }, getPoint: function (a) { var b = a * this.getLength(), c = this.getCurveLengths(); for (a = 0; a < c.length;) { if (c[a] >= b) return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 - b / c); a++; } return null; }, getLength: function () {
      var a = this.getCurveLengths();
      return a[a.length - 1];
    }, updateArcLengths: function () { this.needsUpdate = !0; this.cacheLengths = null; this.getCurveLengths(); }, getCurveLengths: function () { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++)b += this.curves[c].getLength(), a.push(b); return this.cacheLengths = a; }, getSpacedPoints: function (a) { void 0 === a && (a = 40); for (var b = [], c = 0; c <= a; c++)b.push(this.getPoint(c / a)); this.autoClose && b.push(b[0]); return b; }, getPoints: function (a) {
      a =
      a || 12; for (var b = [], c, d = 0, e = this.curves; d < e.length; d++) { var f = e[d]; f = f.getPoints(f && f.isEllipseCurve ? 2 * a : f && (f.isLineCurve || f.isLineCurve3) ? 1 : f && f.isSplineCurve ? a * f.points.length : a); for (var g = 0; g < f.length; g++) { var h = f[g]; c && c.equals(h) || (b.push(h), c = h); } } this.autoClose && 1 < b.length && !b[b.length - 1].equals(b[0]) && b.push(b[0]); return b;
    }, copy: function (a) { M.prototype.copy.call(this, a); this.curves = []; for (var b = 0, c = a.curves.length; b < c; b++)this.curves.push(a.curves[b].clone()); this.autoClose = a.autoClose; return this; },
    toJSON: function () { var a = M.prototype.toJSON.call(this); a.autoClose = this.autoClose; a.curves = []; for (var b = 0, c = this.curves.length; b < c; b++)a.curves.push(this.curves[b].toJSON()); return a; }, fromJSON: function (a) { M.prototype.fromJSON.call(this, a); this.autoClose = a.autoClose; this.curves = []; for (var b = 0, c = a.curves.length; b < c; b++) { var d = a.curves[b]; this.curves.push((new Se[d.type]).fromJSON(d)); } return this; }
  }); Pa.prototype = Object.assign(Object.create(fb.prototype), {
    constructor: Pa, setFromPoints: function (a) {
      this.moveTo(a[0].x,
        a[0].y); for (var b = 1, c = a.length; b < c; b++)this.lineTo(a[b].x, a[b].y);
    }, moveTo: function (a, b) { this.currentPoint.set(a, b); }, lineTo: function (a, b) { var c = new wa(this.currentPoint.clone(), new C(a, b)); this.curves.push(c); this.currentPoint.set(a, b); }, quadraticCurveTo: function (a, b, c, d) { a = new Na(this.currentPoint.clone(), new C(a, b), new C(c, d)); this.curves.push(a); this.currentPoint.set(c, d); }, bezierCurveTo: function (a, b, c, d, e, f) {
      a = new La(this.currentPoint.clone(), new C(a, b), new C(c, d), new C(e, f)); this.curves.push(a);
      this.currentPoint.set(e, f);
    }, splineThru: function (a) { var b = [this.currentPoint.clone()].concat(a); b = new Oa(b); this.curves.push(b); this.currentPoint.copy(a[a.length - 1]); }, arc: function (a, b, c, d, e, f) { this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f); }, absarc: function (a, b, c, d, e, f) { this.absellipse(a, b, c, c, d, e, f); }, ellipse: function (a, b, c, d, e, f, g, h) { this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f, g, h); }, absellipse: function (a, b, c, d, e, f, g, h) {
      a = new Ea(a, b, c, d, e, f, g, h); 0 < this.curves.length &&
        (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y)); this.curves.push(a); a = a.getPoint(1); this.currentPoint.copy(a);
    }, copy: function (a) { fb.prototype.copy.call(this, a); this.currentPoint.copy(a.currentPoint); return this; }, toJSON: function () { var a = fb.prototype.toJSON.call(this); a.currentPoint = this.currentPoint.toArray(); return a; }, fromJSON: function (a) { fb.prototype.fromJSON.call(this, a); this.currentPoint.fromArray(a.currentPoint); return this; }
  }); pb.prototype = Object.assign(Object.create(Pa.prototype),
    {
      constructor: pb, getPointsHoles: function (a) { for (var b = [], c = 0, d = this.holes.length; c < d; c++)b[c] = this.holes[c].getPoints(a); return b; }, extractPoints: function (a) { return { shape: this.getPoints(a), holes: this.getPointsHoles(a) }; }, copy: function (a) { Pa.prototype.copy.call(this, a); this.holes = []; for (var b = 0, c = a.holes.length; b < c; b++)this.holes.push(a.holes[b].clone()); return this; }, toJSON: function () {
        var a = Pa.prototype.toJSON.call(this); a.uuid = this.uuid; a.holes = []; for (var b = 0, c = this.holes.length; b < c; b++)a.holes.push(this.holes[b].toJSON());
        return a;
      }, fromJSON: function (a) { Pa.prototype.fromJSON.call(this, a); this.uuid = a.uuid; this.holes = []; for (var b = 0, c = a.holes.length; b < c; b++) { var d = a.holes[b]; this.holes.push((new Pa).fromJSON(d)); } return this; }
    }); T.prototype = Object.assign(Object.create(D.prototype), {
      constructor: T, isLight: !0, copy: function (a) { D.prototype.copy.call(this, a); this.color.copy(a.color); this.intensity = a.intensity; return this; }, toJSON: function (a) {
        a = D.prototype.toJSON.call(this, a); a.object.color = this.color.getHex(); a.object.intensity =
          this.intensity; void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex()); void 0 !== this.distance && (a.object.distance = this.distance); void 0 !== this.angle && (a.object.angle = this.angle); void 0 !== this.decay && (a.object.decay = this.decay); void 0 !== this.penumbra && (a.object.penumbra = this.penumbra); void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON()); return a;
      }
    }); Nd.prototype = Object.assign(Object.create(T.prototype), {
      constructor: Nd, isHemisphereLight: !0, copy: function (a) {
        T.prototype.copy.call(this,
          a); this.groundColor.copy(a.groundColor); return this;
      }
    }); Object.assign(Pb.prototype, {
      copy: function (a) { this.camera = a.camera.clone(); this.bias = a.bias; this.radius = a.radius; this.mapSize.copy(a.mapSize); return this; }, clone: function () { return (new this.constructor).copy(this); }, toJSON: function () {
        var a = {}; 0 !== this.bias && (a.bias = this.bias); 1 !== this.radius && (a.radius = this.radius); if (512 !== this.mapSize.x || 512 !== this.mapSize.y) a.mapSize = this.mapSize.toArray(); a.camera = this.camera.toJSON(!1).object; delete a.camera.matrix;
        return a;
      }
    }); Od.prototype = Object.assign(Object.create(Pb.prototype), { constructor: Od, isSpotLightShadow: !0, update: function (a) { var b = this.camera, c = 2 * O.RAD2DEG * a.angle, d = this.mapSize.width / this.mapSize.height; a = a.distance || b.far; if (c !== b.fov || d !== b.aspect || a !== b.far) b.fov = c, b.aspect = d, b.far = a, b.updateProjectionMatrix(); } }); Pd.prototype = Object.assign(Object.create(T.prototype), {
      constructor: Pd, isSpotLight: !0, copy: function (a) {
        T.prototype.copy.call(this, a); this.distance = a.distance; this.angle = a.angle; this.penumbra =
          a.penumbra; this.decay = a.decay; this.target = a.target.clone(); this.shadow = a.shadow.clone(); return this;
      }
    }); Qd.prototype = Object.assign(Object.create(T.prototype), { constructor: Qd, isPointLight: !0, copy: function (a) { T.prototype.copy.call(this, a); this.distance = a.distance; this.decay = a.decay; this.shadow = a.shadow.clone(); return this; } }); od.prototype = Object.assign(Object.create(Xa.prototype), {
      constructor: od, isOrthographicCamera: !0, copy: function (a, b) {
        Xa.prototype.copy.call(this, a, b); this.left = a.left; this.right = a.right;
        this.top = a.top; this.bottom = a.bottom; this.near = a.near; this.far = a.far; this.zoom = a.zoom; this.view = null === a.view ? null : Object.assign({}, a.view); return this;
      }, setViewOffset: function (a, b, c, d, e, f) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }); this.view.enabled = !0; this.view.fullWidth = a; this.view.fullHeight = b; this.view.offsetX = c; this.view.offsetY = d; this.view.width = e; this.view.height = f; this.updateProjectionMatrix(); }, clearViewOffset: function () {
        null !==
        this.view && (this.view.enabled = !1); this.updateProjectionMatrix();
      }, updateProjectionMatrix: function () {
        var a = (this.right - this.left) / (2 * this.zoom), b = (this.top - this.bottom) / (2 * this.zoom), c = (this.right + this.left) / 2, d = (this.top + this.bottom) / 2, e = c - a; c += a; a = d + b; b = d - b; if (null !== this.view && this.view.enabled) {
          c = this.zoom / (this.view.width / this.view.fullWidth); b = this.zoom / (this.view.height / this.view.fullHeight); var f = (this.right - this.left) / this.view.width; d = (this.top - this.bottom) / this.view.height; e += this.view.offsetX /
            c * f; c = e + this.view.width / c * f; a -= this.view.offsetY / b * d; b = a - this.view.height / b * d;
        } this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far); this.projectionMatrixInverse.getInverse(this.projectionMatrix);
      }, toJSON: function (a) { a = D.prototype.toJSON.call(this, a); a.object.zoom = this.zoom; a.object.left = this.left; a.object.right = this.right; a.object.top = this.top; a.object.bottom = this.bottom; a.object.near = this.near; a.object.far = this.far; null !== this.view && (a.object.view = Object.assign({}, this.view)); return a; }
    });
  Rd.prototype = Object.assign(Object.create(Pb.prototype), { constructor: Rd }); Sd.prototype = Object.assign(Object.create(T.prototype), { constructor: Sd, isDirectionalLight: !0, copy: function (a) { T.prototype.copy.call(this, a); this.target = a.target.clone(); this.shadow = a.shadow.clone(); return this; } }); Td.prototype = Object.assign(Object.create(T.prototype), { constructor: Td, isAmbientLight: !0 }); Ud.prototype = Object.assign(Object.create(T.prototype), {
    constructor: Ud, isRectAreaLight: !0, copy: function (a) {
      T.prototype.copy.call(this,
        a); this.width = a.width; this.height = a.height; return this;
    }, toJSON: function (a) { a = T.prototype.toJSON.call(this, a); a.object.width = this.width; a.object.height = this.height; return a; }
  }); Object.assign(Vd.prototype, {
    load: function (a, b, c, d) { var e = this, f = new Ka(e.manager); f.setPath(e.path); f.load(a, function (a) { b(e.parse(JSON.parse(a))); }, c, d); }, parse: function (a) {
      function b(a) { void 0 === c[a] && console.warn("THREE.MaterialLoader: Undefined texture", a); return c[a]; } var c = this.textures, d = new qh[a.type]; void 0 !== a.uuid && (d.uuid =
        a.uuid); void 0 !== a.name && (d.name = a.name); void 0 !== a.color && d.color.setHex(a.color); void 0 !== a.roughness && (d.roughness = a.roughness); void 0 !== a.metalness && (d.metalness = a.metalness); void 0 !== a.emissive && d.emissive.setHex(a.emissive); void 0 !== a.specular && d.specular.setHex(a.specular); void 0 !== a.shininess && (d.shininess = a.shininess); void 0 !== a.clearCoat && (d.clearCoat = a.clearCoat); void 0 !== a.clearCoatRoughness && (d.clearCoatRoughness = a.clearCoatRoughness); void 0 !== a.vertexColors && (d.vertexColors = a.vertexColors);
      void 0 !== a.fog && (d.fog = a.fog); void 0 !== a.flatShading && (d.flatShading = a.flatShading); void 0 !== a.blending && (d.blending = a.blending); void 0 !== a.combine && (d.combine = a.combine); void 0 !== a.side && (d.side = a.side); void 0 !== a.opacity && (d.opacity = a.opacity); void 0 !== a.transparent && (d.transparent = a.transparent); void 0 !== a.alphaTest && (d.alphaTest = a.alphaTest); void 0 !== a.depthTest && (d.depthTest = a.depthTest); void 0 !== a.depthWrite && (d.depthWrite = a.depthWrite); void 0 !== a.colorWrite && (d.colorWrite = a.colorWrite); void 0 !==
        a.wireframe && (d.wireframe = a.wireframe); void 0 !== a.wireframeLinewidth && (d.wireframeLinewidth = a.wireframeLinewidth); void 0 !== a.wireframeLinecap && (d.wireframeLinecap = a.wireframeLinecap); void 0 !== a.wireframeLinejoin && (d.wireframeLinejoin = a.wireframeLinejoin); void 0 !== a.rotation && (d.rotation = a.rotation); 1 !== a.linewidth && (d.linewidth = a.linewidth); void 0 !== a.dashSize && (d.dashSize = a.dashSize); void 0 !== a.gapSize && (d.gapSize = a.gapSize); void 0 !== a.scale && (d.scale = a.scale); void 0 !== a.polygonOffset && (d.polygonOffset =
          a.polygonOffset); void 0 !== a.polygonOffsetFactor && (d.polygonOffsetFactor = a.polygonOffsetFactor); void 0 !== a.polygonOffsetUnits && (d.polygonOffsetUnits = a.polygonOffsetUnits); void 0 !== a.skinning && (d.skinning = a.skinning); void 0 !== a.morphTargets && (d.morphTargets = a.morphTargets); void 0 !== a.dithering && (d.dithering = a.dithering); void 0 !== a.visible && (d.visible = a.visible); void 0 !== a.userData && (d.userData = a.userData); if (void 0 !== a.uniforms) for (var e in a.uniforms) {
            var f = a.uniforms[e]; d.uniforms[e] = {}; switch (f.type) {
              case "t": d.uniforms[e].value =
                b(f.value); break; case "c": d.uniforms[e].value = (new A).setHex(f.value); break; case "v2": d.uniforms[e].value = (new C).fromArray(f.value); break; case "v3": d.uniforms[e].value = (new n).fromArray(f.value); break; case "v4": d.uniforms[e].value = (new W).fromArray(f.value); break; case "m3": d.uniforms[e].value = (new na).fromArray(f.value); case "m4": d.uniforms[e].value = (new P).fromArray(f.value); break; default: d.uniforms[e].value = f.value;
            }
          } void 0 !== a.defines && (d.defines = a.defines); void 0 !== a.vertexShader && (d.vertexShader =
            a.vertexShader); void 0 !== a.fragmentShader && (d.fragmentShader = a.fragmentShader); if (void 0 !== a.extensions) for (var g in a.extensions) d.extensions[g] = a.extensions[g]; void 0 !== a.shading && (d.flatShading = 1 === a.shading); void 0 !== a.size && (d.size = a.size); void 0 !== a.sizeAttenuation && (d.sizeAttenuation = a.sizeAttenuation); void 0 !== a.map && (d.map = b(a.map)); void 0 !== a.matcap && (d.matcap = b(a.matcap)); void 0 !== a.alphaMap && (d.alphaMap = b(a.alphaMap), d.transparent = !0); void 0 !== a.bumpMap && (d.bumpMap = b(a.bumpMap)); void 0 !==
              a.bumpScale && (d.bumpScale = a.bumpScale); void 0 !== a.normalMap && (d.normalMap = b(a.normalMap)); void 0 !== a.normalMapType && (d.normalMapType = a.normalMapType); void 0 !== a.normalScale && (e = a.normalScale, !1 === Array.isArray(e) && (e = [e, e]), d.normalScale = (new C).fromArray(e)); void 0 !== a.displacementMap && (d.displacementMap = b(a.displacementMap)); void 0 !== a.displacementScale && (d.displacementScale = a.displacementScale); void 0 !== a.displacementBias && (d.displacementBias = a.displacementBias); void 0 !== a.roughnessMap && (d.roughnessMap =
                b(a.roughnessMap)); void 0 !== a.metalnessMap && (d.metalnessMap = b(a.metalnessMap)); void 0 !== a.emissiveMap && (d.emissiveMap = b(a.emissiveMap)); void 0 !== a.emissiveIntensity && (d.emissiveIntensity = a.emissiveIntensity); void 0 !== a.specularMap && (d.specularMap = b(a.specularMap)); void 0 !== a.envMap && (d.envMap = b(a.envMap)); void 0 !== a.envMapIntensity && (d.envMapIntensity = a.envMapIntensity); void 0 !== a.reflectivity && (d.reflectivity = a.reflectivity); void 0 !== a.lightMap && (d.lightMap = b(a.lightMap)); void 0 !== a.lightMapIntensity &&
                  (d.lightMapIntensity = a.lightMapIntensity); void 0 !== a.aoMap && (d.aoMap = b(a.aoMap)); void 0 !== a.aoMapIntensity && (d.aoMapIntensity = a.aoMapIntensity); void 0 !== a.gradientMap && (d.gradientMap = b(a.gradientMap)); return d;
    }, setPath: function (a) { this.path = a; return this; }, setTextures: function (a) { this.textures = a; return this; }
  }); var Te = {
    decodeText: function (a) { if ("undefined" !== typeof TextDecoder) return (new TextDecoder).decode(a); for (var b = "", c = 0, d = a.length; c < d; c++)b += String.fromCharCode(a[c]); return decodeURIComponent(escape(b)); },
    extractUrlBase: function (a) { var b = a.lastIndexOf("/"); return -1 === b ? "./" : a.substr(0, b + 1); }
  }; Object.assign(se.prototype, {
    load: function (a, b, c, d) { var e = this, f = new Ka(e.manager); f.setPath(e.path); f.load(a, function (a) { b(e.parse(JSON.parse(a))); }, c, d); }, parse: function (a) {
      var b = new B, c = a.data.index; if (void 0 !== c) { var d = new Ue[c.type](c.array); b.setIndex(new H(d, 1)); } c = a.data.attributes; for (var e in c) {
        var f = c[e]; d = new Ue[f.type](f.array); d = new H(d, f.itemSize, f.normalized); void 0 !== f.name && (d.name = f.name); b.addAttribute(e,
          d);
      } var g = a.data.morphAttributes; if (g) for (e in g) { var h = g[e], l = []; c = 0; for (var k = h.length; c < k; c++)f = h[c], d = new Ue[f.type](f.array), d = new H(d, f.itemSize, f.normalized), void 0 !== f.name && (d.name = f.name), l.push(d); b.morphAttributes[e] = l; } e = a.data.groups || a.data.drawcalls || a.data.offsets; if (void 0 !== e) for (c = 0, f = e.length; c !== f; ++c)d = e[c], b.addGroup(d.start, d.count, d.materialIndex); c = a.data.boundingSphere; void 0 !== c && (e = new n, void 0 !== c.center && e.fromArray(c.center), b.boundingSphere = new Ta(e, c.radius)); a.name &&
        (b.name = a.name); a.userData && (b.userData = a.userData); return b;
    }, setPath: function (a) { this.path = a; return this; }
  }); var Ue = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" !== typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; Object.assign(te.prototype, {
    crossOrigin: "anonymous", load: function (a, b, c, d) {
      var e = this, f = void 0 === this.path ? Te.extractUrlBase(a) :
        this.path; this.resourcePath = this.resourcePath || f; f = new Ka(e.manager); f.setPath(this.path); f.load(a, function (c) { var f = null; try { f = JSON.parse(c); } catch (l) { void 0 !== d && d(l); console.error("THREE:ObjectLoader: Can't parse " + a + ".", l.message); return; } c = f.metadata; void 0 === c || void 0 === c.type || "geometry" === c.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + a) : e.parse(f, b); }, c, d);
    }, setPath: function (a) { this.path = a; return this; }, setResourcePath: function (a) { this.resourcePath = a; return this; }, setCrossOrigin: function (a) {
      this.crossOrigin =
      a; return this;
    }, parse: function (a, b) { var c = this.parseShape(a.shapes); c = this.parseGeometries(a.geometries, c); var d = this.parseImages(a.images, function () { void 0 !== b && b(e); }); d = this.parseTextures(a.textures, d); d = this.parseMaterials(a.materials, d); var e = this.parseObject(a.object, c, d); a.animations && (e.animations = this.parseAnimations(a.animations)); void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e); return e; }, parseShape: function (a) {
      var b = {}; if (void 0 !== a) for (var c = 0, d = a.length; c < d; c++) {
        var e = (new pb).fromJSON(a[c]);
        b[e.uuid] = e;
      } return b;
    }, parseGeometries: function (a, b) {
      var c = {}; if (void 0 !== a) for (var d = new se, e = 0, f = a.length; e < f; e++) {
        var g = a[e]; switch (g.type) {
          case "PlaneGeometry": case "PlaneBufferGeometry": var h = new xa[g.type](g.width, g.height, g.widthSegments, g.heightSegments); break; case "BoxGeometry": case "BoxBufferGeometry": case "CubeGeometry": h = new xa[g.type](g.width, g.height, g.depth, g.widthSegments, g.heightSegments, g.depthSegments); break; case "CircleGeometry": case "CircleBufferGeometry": h = new xa[g.type](g.radius,
            g.segments, g.thetaStart, g.thetaLength); break; case "CylinderGeometry": case "CylinderBufferGeometry": h = new xa[g.type](g.radiusTop, g.radiusBottom, g.height, g.radialSegments, g.heightSegments, g.openEnded, g.thetaStart, g.thetaLength); break; case "ConeGeometry": case "ConeBufferGeometry": h = new xa[g.type](g.radius, g.height, g.radialSegments, g.heightSegments, g.openEnded, g.thetaStart, g.thetaLength); break; case "SphereGeometry": case "SphereBufferGeometry": h = new xa[g.type](g.radius, g.widthSegments, g.heightSegments,
              g.phiStart, g.phiLength, g.thetaStart, g.thetaLength); break; case "DodecahedronGeometry": case "DodecahedronBufferGeometry": case "IcosahedronGeometry": case "IcosahedronBufferGeometry": case "OctahedronGeometry": case "OctahedronBufferGeometry": case "TetrahedronGeometry": case "TetrahedronBufferGeometry": h = new xa[g.type](g.radius, g.detail); break; case "RingGeometry": case "RingBufferGeometry": h = new xa[g.type](g.innerRadius, g.outerRadius, g.thetaSegments, g.phiSegments, g.thetaStart, g.thetaLength); break; case "TorusGeometry": case "TorusBufferGeometry": h =
                new xa[g.type](g.radius, g.tube, g.radialSegments, g.tubularSegments, g.arc); break; case "TorusKnotGeometry": case "TorusKnotBufferGeometry": h = new xa[g.type](g.radius, g.tube, g.tubularSegments, g.radialSegments, g.p, g.q); break; case "TubeGeometry": case "TubeBufferGeometry": h = new xa[g.type]((new Se[g.path.type]).fromJSON(g.path), g.tubularSegments, g.radius, g.radialSegments, g.closed); break; case "LatheGeometry": case "LatheBufferGeometry": h = new xa[g.type](g.points, g.segments, g.phiStart, g.phiLength); break; case "PolyhedronGeometry": case "PolyhedronBufferGeometry": h =
                  new xa[g.type](g.vertices, g.indices, g.radius, g.details); break; case "ShapeGeometry": case "ShapeBufferGeometry": h = []; for (var l = 0, k = g.shapes.length; l < k; l++) { var n = b[g.shapes[l]]; h.push(n); } h = new xa[g.type](h, g.curveSegments); break; case "ExtrudeGeometry": case "ExtrudeBufferGeometry": h = []; l = 0; for (k = g.shapes.length; l < k; l++)n = b[g.shapes[l]], h.push(n); l = g.options.extrudePath; void 0 !== l && (g.options.extrudePath = (new Se[l.type]).fromJSON(l)); h = new xa[g.type](h, g.options); break; case "BufferGeometry": h = d.parse(g);
            break; case "Geometry": "THREE" in window && "LegacyJSONLoader" in THREE ? h = (new THREE.LegacyJSONLoader).parse(g, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".'); break; default: console.warn('THREE.ObjectLoader: Unsupported geometry type "' + g.type + '"'); continue;
        }h.uuid = g.uuid; void 0 !== g.name && (h.name = g.name); !0 === h.isBufferGeometry && void 0 !== g.userData && (h.userData = g.userData); c[g.uuid] = h;
      } return c;
    }, parseMaterials: function (a,
      b) { var c = {}, d = {}; if (void 0 !== a) { var e = new Vd; e.setTextures(b); b = 0; for (var f = a.length; b < f; b++) { var g = a[b]; if ("MultiMaterial" === g.type) { for (var h = [], l = 0; l < g.materials.length; l++) { var k = g.materials[l]; void 0 === c[k.uuid] && (c[k.uuid] = e.parse(k)); h.push(c[k.uuid]); } d[g.uuid] = h; } else void 0 === c[g.uuid] && (c[g.uuid] = e.parse(g)), d[g.uuid] = c[g.uuid]; } } return d; }, parseAnimations: function (a) { for (var b = [], c = 0; c < a.length; c++) { var d = a[c], e = Fa.parse(d); void 0 !== d.uuid && (e.uuid = d.uuid); b.push(e); } return b; }, parseImages: function (a,
        b) {
          function c(a) { d.manager.itemStart(a); return f.load(a, function () { d.manager.itemEnd(a); }, void 0, function () { d.manager.itemError(a); d.manager.itemEnd(a); }); } var d = this, e = {}; if (void 0 !== a && 0 < a.length) {
            b = new oe(b); var f = new ld(b); f.setCrossOrigin(this.crossOrigin); b = 0; for (var g = a.length; b < g; b++) {
              var h = a[b], l = h.url; if (Array.isArray(l)) { e[h.uuid] = []; for (var k = 0, n = l.length; k < n; k++) { var p = l[k]; p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : d.resourcePath + p; e[h.uuid].push(c(p)); } } else p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ?
                h.url : d.resourcePath + h.url, e[h.uuid] = c(p);
            }
          } return e;
      }, parseTextures: function (a, b) {
        function c(a, b) { if ("number" === typeof a) return a; console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a); return b[a]; } var d = {}; if (void 0 !== a) for (var e = 0, f = a.length; e < f; e++) {
          var g = a[e]; void 0 === g.image && console.warn('THREE.ObjectLoader: No "image" specified for', g.uuid); void 0 === b[g.image] && console.warn("THREE.ObjectLoader: Undefined image", g.image); var h = Array.isArray(b[g.image]) ? new cb(b[g.image]) :
            new Y(b[g.image]); h.needsUpdate = !0; h.uuid = g.uuid; void 0 !== g.name && (h.name = g.name); void 0 !== g.mapping && (h.mapping = c(g.mapping, rh)); void 0 !== g.offset && h.offset.fromArray(g.offset); void 0 !== g.repeat && h.repeat.fromArray(g.repeat); void 0 !== g.center && h.center.fromArray(g.center); void 0 !== g.rotation && (h.rotation = g.rotation); void 0 !== g.wrap && (h.wrapS = c(g.wrap[0], Wf), h.wrapT = c(g.wrap[1], Wf)); void 0 !== g.format && (h.format = g.format); void 0 !== g.type && (h.type = g.type); void 0 !== g.encoding && (h.encoding = g.encoding);
          void 0 !== g.minFilter && (h.minFilter = c(g.minFilter, Xf)); void 0 !== g.magFilter && (h.magFilter = c(g.magFilter, Xf)); void 0 !== g.anisotropy && (h.anisotropy = g.anisotropy); void 0 !== g.flipY && (h.flipY = g.flipY); void 0 !== g.premultiplyAlpha && (h.premultiplyAlpha = g.premultiplyAlpha); void 0 !== g.unpackAlignment && (h.unpackAlignment = g.unpackAlignment); d[g.uuid] = h;
        } return d;
      }, parseObject: function (a, b, c) {
        function d(a) { void 0 === b[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a); return b[a]; } function e(a) {
          if (void 0 !==
            a) { if (Array.isArray(a)) { for (var b = [], d = 0, e = a.length; d < e; d++) { var f = a[d]; void 0 === c[f] && console.warn("THREE.ObjectLoader: Undefined material", f); b.push(c[f]); } return b; } void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined material", a); return c[a]; }
        } switch (a.type) {
          case "Scene": var f = new Cd; void 0 !== a.background && Number.isInteger(a.background) && (f.background = new A(a.background)); void 0 !== a.fog && ("Fog" === a.fog.type ? f.fog = new Bd(a.fog.color, a.fog.near, a.fog.far) : "FogExp2" === a.fog.type && (f.fog = new Ad(a.fog.color,
            a.fog.density))); break; case "PerspectiveCamera": f = new ca(a.fov, a.aspect, a.near, a.far); void 0 !== a.focus && (f.focus = a.focus); void 0 !== a.zoom && (f.zoom = a.zoom); void 0 !== a.filmGauge && (f.filmGauge = a.filmGauge); void 0 !== a.filmOffset && (f.filmOffset = a.filmOffset); void 0 !== a.view && (f.view = Object.assign({}, a.view)); break; case "OrthographicCamera": f = new od(a.left, a.right, a.top, a.bottom, a.near, a.far); void 0 !== a.zoom && (f.zoom = a.zoom); void 0 !== a.view && (f.view = Object.assign({}, a.view)); break; case "AmbientLight": f =
              new Td(a.color, a.intensity); break; case "DirectionalLight": f = new Sd(a.color, a.intensity); break; case "PointLight": f = new Qd(a.color, a.intensity, a.distance, a.decay); break; case "RectAreaLight": f = new Ud(a.color, a.intensity, a.width, a.height); break; case "SpotLight": f = new Pd(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay); break; case "HemisphereLight": f = new Nd(a.color, a.groundColor, a.intensity); break; case "SkinnedMesh": console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
          case "Mesh": f = d(a.geometry); var g = e(a.material); f = f.bones && 0 < f.bones.length ? new Nc(f, g) : new qa(f, g); void 0 !== a.drawMode && f.setDrawMode(a.drawMode); break; case "LOD": f = new Mc; break; case "Line": f = new ka(d(a.geometry), e(a.material), a.mode); break; case "LineLoop": f = new Ed(d(a.geometry), e(a.material)); break; case "LineSegments": f = new V(d(a.geometry), e(a.material)); break; case "PointCloud": case "Points": f = new Zb(d(a.geometry), e(a.material)); break; case "Sprite": f = new Lc(e(a.material)); break; case "Group": f = new Xb;
            break; default: f = new D;
        }f.uuid = a.uuid; void 0 !== a.name && (f.name = a.name); void 0 !== a.matrix ? (f.matrix.fromArray(a.matrix), void 0 !== a.matrixAutoUpdate && (f.matrixAutoUpdate = a.matrixAutoUpdate), f.matrixAutoUpdate && f.matrix.decompose(f.position, f.quaternion, f.scale)) : (void 0 !== a.position && f.position.fromArray(a.position), void 0 !== a.rotation && f.rotation.fromArray(a.rotation), void 0 !== a.quaternion && f.quaternion.fromArray(a.quaternion), void 0 !== a.scale && f.scale.fromArray(a.scale)); void 0 !== a.castShadow && (f.castShadow =
          a.castShadow); void 0 !== a.receiveShadow && (f.receiveShadow = a.receiveShadow); a.shadow && (void 0 !== a.shadow.bias && (f.shadow.bias = a.shadow.bias), void 0 !== a.shadow.radius && (f.shadow.radius = a.shadow.radius), void 0 !== a.shadow.mapSize && f.shadow.mapSize.fromArray(a.shadow.mapSize), void 0 !== a.shadow.camera && (f.shadow.camera = this.parseObject(a.shadow.camera))); void 0 !== a.visible && (f.visible = a.visible); void 0 !== a.frustumCulled && (f.frustumCulled = a.frustumCulled); void 0 !== a.renderOrder && (f.renderOrder = a.renderOrder);
        void 0 !== a.userData && (f.userData = a.userData); void 0 !== a.layers && (f.layers.mask = a.layers); if (void 0 !== a.children) { g = a.children; for (var h = 0; h < g.length; h++)f.add(this.parseObject(g[h], b, c)); } if ("LOD" === a.type) for (a = a.levels, g = 0; g < a.length; g++) { h = a[g]; var l = f.getObjectByProperty("uuid", h.object); void 0 !== l && f.addLevel(l, h.distance); } return f;
      }
  }); var rh = {
    UVMapping: 300, CubeReflectionMapping: 301, CubeRefractionMapping: 302, EquirectangularReflectionMapping: 303, EquirectangularRefractionMapping: 304, SphericalReflectionMapping: 305,
    CubeUVReflectionMapping: 306, CubeUVRefractionMapping: 307
  }, Wf = { RepeatWrapping: 1E3, ClampToEdgeWrapping: 1001, MirroredRepeatWrapping: 1002 }, Xf = { NearestFilter: 1003, NearestMipMapNearestFilter: 1004, NearestMipMapLinearFilter: 1005, LinearFilter: 1006, LinearMipMapNearestFilter: 1007, LinearMipMapLinearFilter: 1008 }; ue.prototype = {
    constructor: ue, setOptions: function (a) { this.options = a; return this; }, load: function (a, b, c, d) {
      void 0 === a && (a = ""); void 0 !== this.path && (a = this.path + a); a = this.manager.resolveURL(a); var e = this, f = Qb.get(a);
      if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function () { b && b(f); e.manager.itemEnd(a); }, 0), f; fetch(a).then(function (a) { return a.blob(); }).then(function (a) { return void 0 === e.options ? createImageBitmap(a) : createImageBitmap(a, e.options); }).then(function (c) { Qb.add(a, c); b && b(c); e.manager.itemEnd(a); }).catch(function (b) { d && d(b); e.manager.itemError(a); e.manager.itemEnd(a); }); e.manager.itemStart(a);
    }, setCrossOrigin: function () { return this; }, setPath: function (a) { this.path = a; return this; }
  }; Object.assign(ve.prototype,
    {
      moveTo: function (a, b) { this.currentPath = new Pa; this.subPaths.push(this.currentPath); this.currentPath.moveTo(a, b); }, lineTo: function (a, b) { this.currentPath.lineTo(a, b); }, quadraticCurveTo: function (a, b, c, d) { this.currentPath.quadraticCurveTo(a, b, c, d); }, bezierCurveTo: function (a, b, c, d, e, f) { this.currentPath.bezierCurveTo(a, b, c, d, e, f); }, splineThru: function (a) { this.currentPath.splineThru(a); }, toShapes: function (a, b) {
        function c(a) { for (var b = [], c = 0, d = a.length; c < d; c++) { var e = a[c], f = new pb; f.curves = e.curves; b.push(f); } return b; }
        function d(a, b) { for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) { var g = b[e], h = b[f], l = h.x - g.x, k = h.y - g.y; if (Math.abs(k) > Number.EPSILON) { if (0 > k && (g = b[f], l = -l, h = b[e], k = -k), !(a.y < g.y || a.y > h.y)) if (a.y === g.y) { if (a.x === g.x) return !0; } else { e = k * (a.x - g.x) - l * (a.y - g.y); if (0 === e) return !0; 0 > e || (d = !d); } } else if (a.y === g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)) return !0; } return d; } var e = db.isClockWise, f = this.subPaths; if (0 === f.length) return []; if (!0 === b) return c(f); b = []; if (1 === f.length) {
          var g = f[0]; var h = new pb; h.curves = g.curves;
          b.push(h); return b;
        } var l = !e(f[0].getPoints()); l = a ? !l : l; h = []; var k = [], n = [], p = 0; k[p] = void 0; n[p] = []; for (var v = 0, t = f.length; v < t; v++) { g = f[v]; var r = g.getPoints(); var u = e(r); (u = a ? !u : u) ? (!l && k[p] && p++, k[p] = { s: new pb, p: r }, k[p].s.curves = g.curves, l && p++, n[p] = []) : n[p].push({ h: g, p: r[0] }); } if (!k[0]) return c(f); if (1 < k.length) {
          v = !1; a = []; e = 0; for (f = k.length; e < f; e++)h[e] = []; e = 0; for (f = k.length; e < f; e++)for (g = n[e], u = 0; u < g.length; u++) {
            l = g[u]; p = !0; for (r = 0; r < k.length; r++)d(l.p, k[r].p) && (e !== r && a.push({ froms: e, tos: r, hole: u }),
              p ? (p = !1, h[r].push(l)) : v = !0); p && h[e].push(l);
          } 0 < a.length && (v || (n = h));
        } v = 0; for (e = k.length; v < e; v++)for (h = k[v].s, b.push(h), a = n[v], f = 0, g = a.length; f < g; f++)h.holes.push(a[f].h); return b;
      }
    }); Object.assign(we.prototype, {
      isFont: !0, generateShapes: function (a, b) {
        void 0 === b && (b = 100); var c = [], d = b; b = this.data; var e = Array.from ? Array.from(a) : String(a).split(""); d /= b.resolution; var f = (b.boundingBox.yMax - b.boundingBox.yMin + b.underlineThickness) * d; a = []; for (var g = 0, h = 0, l = 0; l < e.length; l++) {
          var k = e[l]; if ("\n" === k) g = 0, h -= f;
          else {
            var n = d; var p = g, v = h; if (k = b.glyphs[k] || b.glyphs["?"]) {
              var t = new ve; if (k.o) for (var r = k._cachedOutline || (k._cachedOutline = k.o.split(" ")), u = 0, w = r.length; u < w;)switch (r[u++]) {
                case "m": var z = r[u++] * n + p; var x = r[u++] * n + v; t.moveTo(z, x); break; case "l": z = r[u++] * n + p; x = r[u++] * n + v; t.lineTo(z, x); break; case "q": var y = r[u++] * n + p; var A = r[u++] * n + v; var B = r[u++] * n + p; var C = r[u++] * n + v; t.quadraticCurveTo(B, C, y, A); break; case "b": y = r[u++] * n + p, A = r[u++] * n + v, B = r[u++] * n + p, C = r[u++] * n + v, z = r[u++] * n + p, x = r[u++] * n + v, t.bezierCurveTo(B,
                  C, z, x, y, A);
              }n = { offsetX: k.ha * n, path: t };
            } else n = void 0; g += n.offsetX; a.push(n.path);
          }
        } b = 0; for (e = a.length; b < e; b++)Array.prototype.push.apply(c, a[b].toShapes()); return c;
      }
    }); Object.assign(Kf.prototype, {
      load: function (a, b, c, d) { var e = this, f = new Ka(this.manager); f.setPath(this.path); f.load(a, function (a) { try { var c = JSON.parse(a); } catch (l) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c = JSON.parse(a.substring(65, a.length - 2)); } a = e.parse(c); b && b(a); }, c, d); }, parse: function (a) { return new we(a); },
      setPath: function (a) { this.path = a; return this; }
    }); pd.Handlers = { handlers: [], add: function (a, b) { this.handlers.push(a, b); }, get: function (a) { for (var b = this.handlers, c = 0, d = b.length; c < d; c += 2) { var e = b[c + 1]; if (b[c].test(a)) return e; } return null; } }; Object.assign(pd.prototype, {
      crossOrigin: "anonymous", onLoadStart: function () { }, onLoadProgress: function () { }, onLoadComplete: function () { }, initMaterials: function (a, b, c) { for (var d = [], e = 0; e < a.length; ++e)d[e] = this.createMaterial(a[e], b, c); return d; }, createMaterial: function () {
        var a =
          { NoBlending: 0, NormalBlending: 1, AdditiveBlending: 2, SubtractiveBlending: 3, MultiplyBlending: 4, CustomBlending: 5 }, b = new A, c = new Md, d = new Vd; return function (e, f, g) {
            function h(a, b, d, e, h) {
              a = f + a; var k = pd.Handlers.get(a); null !== k ? a = k.load(a) : (c.setCrossOrigin(g), a = c.load(a)); void 0 !== b && (a.repeat.fromArray(b), 1 !== b[0] && (a.wrapS = 1E3), 1 !== b[1] && (a.wrapT = 1E3)); void 0 !== d && a.offset.fromArray(d); void 0 !== e && ("repeat" === e[0] && (a.wrapS = 1E3), "mirror" === e[0] && (a.wrapS = 1002), "repeat" === e[1] && (a.wrapT = 1E3), "mirror" ===
                e[1] && (a.wrapT = 1002)); void 0 !== h && (a.anisotropy = h); b = O.generateUUID(); l[b] = a; return b;
            } var l = {}, k = { uuid: O.generateUUID(), type: "MeshLambertMaterial" }, n; for (n in e) {
              var p = e[n]; switch (n) {
                case "DbgColor": case "DbgIndex": case "opticalDensity": case "illumination": break; case "DbgName": k.name = p; break; case "blending": k.blending = a[p]; break; case "colorAmbient": case "mapAmbient": console.warn("THREE.Loader.createMaterial:", n, "is no longer supported."); break; case "colorDiffuse": k.color = b.fromArray(p).getHex(); break;
                case "colorSpecular": k.specular = b.fromArray(p).getHex(); break; case "colorEmissive": k.emissive = b.fromArray(p).getHex(); break; case "specularCoef": k.shininess = p; break; case "shading": "basic" === p.toLowerCase() && (k.type = "MeshBasicMaterial"); "phong" === p.toLowerCase() && (k.type = "MeshPhongMaterial"); "standard" === p.toLowerCase() && (k.type = "MeshStandardMaterial"); break; case "mapDiffuse": k.map = h(p, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy); break; case "mapDiffuseRepeat": case "mapDiffuseOffset": case "mapDiffuseWrap": case "mapDiffuseAnisotropy": break;
                case "mapEmissive": k.emissiveMap = h(p, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy); break; case "mapEmissiveRepeat": case "mapEmissiveOffset": case "mapEmissiveWrap": case "mapEmissiveAnisotropy": break; case "mapLight": k.lightMap = h(p, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy); break; case "mapLightRepeat": case "mapLightOffset": case "mapLightWrap": case "mapLightAnisotropy": break; case "mapAO": k.aoMap = h(p, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap,
                  e.mapAOAnisotropy); break; case "mapAORepeat": case "mapAOOffset": case "mapAOWrap": case "mapAOAnisotropy": break; case "mapBump": k.bumpMap = h(p, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy); break; case "mapBumpScale": k.bumpScale = p; break; case "mapBumpRepeat": case "mapBumpOffset": case "mapBumpWrap": case "mapBumpAnisotropy": break; case "mapNormal": k.normalMap = h(p, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy); break; case "mapNormalFactor": k.normalScale = p; break;
                case "mapNormalRepeat": case "mapNormalOffset": case "mapNormalWrap": case "mapNormalAnisotropy": break; case "mapSpecular": k.specularMap = h(p, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy); break; case "mapSpecularRepeat": case "mapSpecularOffset": case "mapSpecularWrap": case "mapSpecularAnisotropy": break; case "mapMetalness": k.metalnessMap = h(p, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy); break; case "mapMetalnessRepeat": case "mapMetalnessOffset": case "mapMetalnessWrap": case "mapMetalnessAnisotropy": break;
                case "mapRoughness": k.roughnessMap = h(p, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy); break; case "mapRoughnessRepeat": case "mapRoughnessOffset": case "mapRoughnessWrap": case "mapRoughnessAnisotropy": break; case "mapAlpha": k.alphaMap = h(p, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy); break; case "mapAlphaRepeat": case "mapAlphaOffset": case "mapAlphaWrap": case "mapAlphaAnisotropy": break; case "flipSided": k.side = 1; break; case "doubleSided": k.side =
                  2; break; case "transparency": console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"); k.opacity = p; break; case "depthTest": case "depthWrite": case "colorWrite": case "opacity": case "reflectivity": case "transparent": case "visible": case "wireframe": k[n] = p; break; case "vertexColors": !0 === p && (k.vertexColors = 2); "face" === p && (k.vertexColors = 1); break; default: console.error("THREE.Loader.createMaterial: Unsupported", n, p);
              }
            } "MeshBasicMaterial" === k.type && delete k.emissive; "MeshPhongMaterial" !==
              k.type && delete k.specular; 1 > k.opacity && (k.transparent = !0); d.setTextures(l); return d.parse(k);
          };
      }()
    }); var be, Ce = { getContext: function () { void 0 === be && (be = new (window.AudioContext || window.webkitAudioContext)); return be; }, setContext: function (a) { be = a; } }; Object.assign(xe.prototype, {
      load: function (a, b, c, d) { var e = new Ka(this.manager); e.setResponseType("arraybuffer"); e.setPath(this.path); e.load(a, function (a) { a = a.slice(0); Ce.getContext().decodeAudioData(a, function (a) { b(a); }); }, c, d); }, setPath: function (a) {
        this.path = a;
        return this;
      }
    }); Object.assign(Wd.prototype, {
      isSphericalHarmonics3: !0, set: function (a) { for (var b = 0; 9 > b; b++)this.coefficients[b].copy(a[b]); return this; }, zero: function () { for (var a = 0; 9 > a; a++)this.coefficients[a].set(0, 0, 0); return this; }, getAt: function (a, b) { var c = a.x, d = a.y; a = a.z; var e = this.coefficients; b = .282095 * e[0]; b += .488603 * e[1] * d; b += .488603 * e[2] * a; b += .488603 * e[3] * c; b += 1.092548 * e[4] * c * d; b += 1.092548 * e[5] * d * a; b += .315392 * e[6] * (3 * a * a - 1); b += 1.092548 * e[7] * c * a; return b += .546274 * e[8] * (c * c - d * d); }, getIrradianceAt: function (a,
        b) { var c = a.x, d = a.y; a = a.z; var e = this.coefficients; b = .886227 * e[0]; b += 1.023328 * e[1] * d; b += 1.023328 * e[2] * a; b += 1.023328 * e[3] * c; b += .858086 * e[4] * c * d; b += .858086 * e[5] * d * a; b += e[6] * (.743125 * a * a - .247708); b += .858086 * e[7] * c * a; return b += .429043 * e[8] * (c * c - d * d); }, add: function (a) { for (var b = 0; 9 > b; b++)this.coefficients[b].add(a.coefficients[b]); return this; }, scale: function (a) { for (var b = 0; 9 > b; b++)this.coefficients[b].multiplyScalar(a); return this; }, lerp: function (a, b) {
          for (var c = 0; 9 > c; c++)this.coefficients[c].lerp(a.coefficients[c],
            b); return this;
        }, equals: function (a) { for (var b = 0; 9 > b; b++)if (!this.coefficients[b].equals(a.coefficients[b])) return !1; return !0; }, copy: function (a) { return this.set(a.coefficients); }, clone: function () { return (new this.constructor).copy(this); }, fromArray: function (a) { for (var b = this.coefficients, c = 0; 9 > c; c++)b[c].fromArray(a, 3 * c); return this; }, toArray: function () { for (var a = [], b = this.coefficients, c = 0; 9 > c; c++)b[c].toArray(a, 3 * c); return a; }
    }); Object.assign(Wd, {
      getBasisAt: function (a, b) {
        var c = a.x, d = a.y; a = a.z; b[0] = .282095;
        b[1] = .488603 * d; b[2] = .488603 * a; b[3] = .488603 * c; b[4] = 1.092548 * c * d; b[5] = 1.092548 * d * a; b[6] = .315392 * (3 * a * a - 1); b[7] = 1.092548 * c * a; b[8] = .546274 * (c * c - d * d);
      }
    }); Qa.prototype = Object.assign(Object.create(T.prototype), { constructor: Qa, isLightProbe: !0, copy: function (a) { T.prototype.copy.call(this, a); this.sh.copy(a.sh); this.intensity = a.intensity; return this; }, toJSON: function (a) { return T.prototype.toJSON.call(this, a); } }); ye.prototype = Object.assign(Object.create(Qa.prototype), {
      constructor: ye, isHemisphereLightProbe: !0, copy: function (a) {
        Qa.prototype.copy.call(this,
          a); return this;
      }, toJSON: function (a) { return Qa.prototype.toJSON.call(this, a); }
    }); ze.prototype = Object.assign(Object.create(Qa.prototype), { constructor: ze, isAmbientLightProbe: !0, copy: function (a) { Qa.prototype.copy.call(this, a); return this; }, toJSON: function (a) { return Qa.prototype.toJSON.call(this, a); } }); Object.assign(Lf.prototype, {
      update: function () {
        var a, b, c, d, e, f, g, h, l = new P, k = new P; return function (m) {
          if (a !== this || b !== m.focus || c !== m.fov || d !== m.aspect * this.aspect || e !== m.near || f !== m.far || g !== m.zoom || h !== this.eyeSep) {
            a =
            this; b = m.focus; c = m.fov; d = m.aspect * this.aspect; e = m.near; f = m.far; g = m.zoom; var n = m.projectionMatrix.clone(); h = this.eyeSep / 2; var q = h * e / b, t = e * Math.tan(O.DEG2RAD * c * .5) / g; k.elements[12] = -h; l.elements[12] = h; var r = -t * d + q; var u = t * d + q; n.elements[0] = 2 * e / (u - r); n.elements[8] = (u + r) / (u - r); this.cameraL.projectionMatrix.copy(n); r = -t * d - q; u = t * d - q; n.elements[0] = 2 * e / (u - r); n.elements[8] = (u + r) / (u - r); this.cameraR.projectionMatrix.copy(n);
          } this.cameraL.matrixWorld.copy(m.matrixWorld).multiply(k); this.cameraR.matrixWorld.copy(m.matrixWorld).multiply(l);
        };
      }()
    });
  qd.prototype = Object.create(D.prototype); qd.prototype.constructor = qd; Object.assign(Ae.prototype, {
    start: function () { this.oldTime = this.startTime = ("undefined" === typeof performance ? Date : performance).now(); this.elapsedTime = 0; this.running = !0; }, stop: function () { this.getElapsedTime(); this.autoStart = this.running = !1; }, getElapsedTime: function () { this.getDelta(); return this.elapsedTime; }, getDelta: function () {
      var a = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) {
        var b = ("undefined" === typeof performance ?
          Date : performance).now(); a = (b - this.oldTime) / 1E3; this.oldTime = b; this.elapsedTime += a;
      } return a;
    }
  }); Be.prototype = Object.assign(Object.create(D.prototype), {
    constructor: Be, getInput: function () { return this.gain; }, removeFilter: function () { null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null); return this; }, getFilter: function () { return this.filter; }, setFilter: function (a) {
      null !== this.filter ? (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination); this.filter = a; this.gain.connect(this.filter); this.filter.connect(this.context.destination); return this;
    }, getMasterVolume: function () { return this.gain.gain.value; }, setMasterVolume: function (a) { this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01); return this; }, updateMatrixWorld: function () {
      var a = new n, b = new ma, c = new n, d = new n, e = new Ae; return function (f) {
        D.prototype.updateMatrixWorld.call(this, f); f = this.context.listener;
        var g = this.up; this.timeDelta = e.getDelta(); this.matrixWorld.decompose(a, b, c); d.set(0, 0, -1).applyQuaternion(b); if (f.positionX) {
          var h = this.context.currentTime + this.timeDelta; f.positionX.linearRampToValueAtTime(a.x, h); f.positionY.linearRampToValueAtTime(a.y, h); f.positionZ.linearRampToValueAtTime(a.z, h); f.forwardX.linearRampToValueAtTime(d.x, h); f.forwardY.linearRampToValueAtTime(d.y, h); f.forwardZ.linearRampToValueAtTime(d.z, h); f.upX.linearRampToValueAtTime(g.x, h); f.upY.linearRampToValueAtTime(g.y, h); f.upZ.linearRampToValueAtTime(g.z,
            h);
        } else f.setPosition(a.x, a.y, a.z), f.setOrientation(d.x, d.y, d.z, g.x, g.y, g.z);
      };
    }()
  }); qc.prototype = Object.assign(Object.create(D.prototype), {
    constructor: qc, getOutput: function () { return this.gain; }, setNodeSource: function (a) { this.hasPlaybackControl = !1; this.sourceType = "audioNode"; this.source = a; this.connect(); return this; }, setMediaElementSource: function (a) { this.hasPlaybackControl = !1; this.sourceType = "mediaNode"; this.source = this.context.createMediaElementSource(a); this.connect(); return this; }, setBuffer: function (a) {
      this.buffer =
      a; this.sourceType = "buffer"; this.autoplay && this.play(); return this;
    }, play: function () {
      if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing."); else if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else {
        var a = this.context.createBufferSource(); a.buffer = this.buffer; a.loop = this.loop; a.onended = this.onEnded.bind(this); this.startTime = this.context.currentTime; a.start(this.startTime, this.offset); this.isPlaying = !0; this.source = a; this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate); return this.connect();
      }
    }, pause: function () { if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this; }, stop: function () {
      if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return this.source.stop(), this.source.onended =
        null, this.offset = 0, this.isPlaying = !1, this;
    }, connect: function () { if (0 < this.filters.length) { this.source.connect(this.filters[0]); for (var a = 1, b = this.filters.length; a < b; a++)this.filters[a - 1].connect(this.filters[a]); this.filters[this.filters.length - 1].connect(this.getOutput()); } else this.source.connect(this.getOutput()); return this; }, disconnect: function () {
      if (0 < this.filters.length) {
        this.source.disconnect(this.filters[0]); for (var a = 1, b = this.filters.length; a < b; a++)this.filters[a - 1].disconnect(this.filters[a]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput()); return this;
    }, getFilters: function () { return this.filters; }, setFilters: function (a) { a || (a = []); !0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a; return this; }, setDetune: function (a) { this.detune = a; if (void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this; }, getDetune: function () { return this.detune; },
    getFilter: function () { return this.getFilters()[0]; }, setFilter: function (a) { return this.setFilters(a ? [a] : []); }, setPlaybackRate: function (a) { if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; }, getPlaybackRate: function () { return this.playbackRate; }, onEnded: function () { this.isPlaying = !1; }, getLoop: function () {
      return !1 === this.hasPlaybackControl ?
        (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
    }, setLoop: function (a) { if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control."); else return this.loop = a, !0 === this.isPlaying && (this.source.loop = this.loop), this; }, getVolume: function () { return this.gain.gain.value; }, setVolume: function (a) { this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01); return this; }
  }); De.prototype = Object.assign(Object.create(qc.prototype), {
    constructor: De, getOutput: function () { return this.panner; },
    getRefDistance: function () { return this.panner.refDistance; }, setRefDistance: function (a) { this.panner.refDistance = a; return this; }, getRolloffFactor: function () { return this.panner.rolloffFactor; }, setRolloffFactor: function (a) { this.panner.rolloffFactor = a; return this; }, getDistanceModel: function () { return this.panner.distanceModel; }, setDistanceModel: function (a) { this.panner.distanceModel = a; return this; }, getMaxDistance: function () { return this.panner.maxDistance; }, setMaxDistance: function (a) { this.panner.maxDistance = a; return this; },
    setDirectionalCone: function (a, b, c) { this.panner.coneInnerAngle = a; this.panner.coneOuterAngle = b; this.panner.coneOuterGain = c; return this; }, updateMatrixWorld: function () {
      var a = new n, b = new ma, c = new n, d = new n; return function (e) {
        D.prototype.updateMatrixWorld.call(this, e); if (!0 !== this.hasPlaybackControl || !1 !== this.isPlaying) if (this.matrixWorld.decompose(a, b, c), d.set(0, 0, 1).applyQuaternion(b), e = this.panner, e.positionX) {
          var f = this.context.currentTime + this.listener.timeDelta; e.positionX.linearRampToValueAtTime(a.x,
            f); e.positionY.linearRampToValueAtTime(a.y, f); e.positionZ.linearRampToValueAtTime(a.z, f); e.orientationX.linearRampToValueAtTime(d.x, f); e.orientationY.linearRampToValueAtTime(d.y, f); e.orientationZ.linearRampToValueAtTime(d.z, f);
        } else e.setPosition(a.x, a.y, a.z), e.setOrientation(d.x, d.y, d.z);
      };
    }()
  }); Object.assign(Ee.prototype, {
    getFrequencyData: function () { this.analyser.getByteFrequencyData(this.data); return this.data; }, getAverageFrequency: function () {
      for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++)a +=
        b[c]; return a / b.length;
    }
  }); Object.assign(Fe.prototype, {
    accumulate: function (a, b) { var c = this.buffer, d = this.valueSize; a = a * d + d; var e = this.cumulativeWeight; if (0 === e) { for (e = 0; e !== d; ++e)c[a + e] = c[e]; e = b; } else e += b, this._mixBufferRegion(c, a, 0, b / e, d); this.cumulativeWeight = e; }, apply: function (a) { var b = this.valueSize, c = this.buffer; a = a * b + b; var d = this.cumulativeWeight, e = this.binding; this.cumulativeWeight = 0; 1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b); d = b; for (var f = b + b; d !== f; ++d)if (c[d] !== c[d + b]) { e.setValue(c, a); break; } },
    saveOriginalState: function () { var a = this.buffer, b = this.valueSize, c = 3 * b; this.binding.getValue(a, c); for (var d = b; d !== c; ++d)a[d] = a[c + d % b]; this.cumulativeWeight = 0; }, restoreOriginalState: function () { this.binding.setValue(this.buffer, 3 * this.valueSize); }, _select: function (a, b, c, d, e) { if (.5 <= d) for (d = 0; d !== e; ++d)a[b + d] = a[c + d]; }, _slerp: function (a, b, c, d) { ma.slerpFlat(a, b, a, b, a, c, d); }, _lerp: function (a, b, c, d, e) { for (var f = 1 - d, g = 0; g !== e; ++g) { var h = b + g; a[h] = a[h] * f + a[c + g] * d; } }
  }); Object.assign(Mf.prototype, {
    getValue: function (a,
      b) { this.bind(); var c = this._bindings[this._targetGroup.nCachedObjects_]; void 0 !== c && c.getValue(a, b); }, setValue: function (a, b) { for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d)c[d].setValue(a, b); }, bind: function () { for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b)a[b].bind(); }, unbind: function () { for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b)a[b].unbind(); }
  }); Object.assign(ia, {
    Composite: Mf, create: function (a,
      b, c) { return a && a.isAnimationObjectGroup ? new ia.Composite(a, b, c) : new ia(a, b, c); }, sanitizeNodeName: function () { var a = /[\[\]\.:\/]/g; return function (b) { return b.replace(/\s/g, "_").replace(a, ""); }; }(), parseTrackName: function () {
        var a = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", b = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"); a = /(WCOD+)?/.source.replace("WCOD", a); var c = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), d = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
          e = new RegExp("^" + b + a + c + d + "$"), f = ["material", "materials", "bones"]; return function (a) {
            var b = e.exec(a); if (!b) throw Error("PropertyBinding: Cannot parse trackName: " + a); b = { nodeName: b[2], objectName: b[3], objectIndex: b[4], propertyName: b[5], propertyIndex: b[6] }; var c = b.nodeName && b.nodeName.lastIndexOf("."); if (void 0 !== c && -1 !== c) { var d = b.nodeName.substring(c + 1); -1 !== f.indexOf(d) && (b.nodeName = b.nodeName.substring(0, c), b.objectName = d); } if (null === b.propertyName || 0 === b.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " +
              a); return b;
          };
      }(), findNode: function (a, b) { if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a; if (a.skeleton) { var c = a.skeleton.getBoneByName(b); if (void 0 !== c) return c; } if (a.children) { var d = function (a) { for (var c = 0; c < a.length; c++) { var e = a[c]; if (e.name === b || e.uuid === b || (e = d(e.children))) return e; } return null; }; if (a = d(a.children)) return a; } return null; }
  }); Object.assign(ia.prototype, {
    _getValue_unavailable: function () { }, _setValue_unavailable: function () { }, BindingType: {
      Direct: 0, EntireArray: 1,
      ArrayElement: 2, HasFromToArray: 3
    }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (a, b) { a[b] = this.node[this.propertyName]; }, function (a, b) { for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)a[b++] = c[d]; }, function (a, b) { a[b] = this.resolvedProperty[this.propertyIndex]; }, function (a, b) { this.resolvedProperty.toArray(a, b); }], SetterByBindingTypeAndVersioning: [[function (a, b) { this.targetObject[this.propertyName] = a[b]; }, function (a, b) {
      this.targetObject[this.propertyName] =
      a[b]; this.targetObject.needsUpdate = !0;
    }, function (a, b) { this.targetObject[this.propertyName] = a[b]; this.targetObject.matrixWorldNeedsUpdate = !0; }], [function (a, b) { for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)c[d] = a[b++]; }, function (a, b) { for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)c[d] = a[b++]; this.targetObject.needsUpdate = !0; }, function (a, b) { for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d)c[d] = a[b++]; this.targetObject.matrixWorldNeedsUpdate = !0; }], [function (a, b) {
      this.resolvedProperty[this.propertyIndex] =
      a[b];
    }, function (a, b) { this.resolvedProperty[this.propertyIndex] = a[b]; this.targetObject.needsUpdate = !0; }, function (a, b) { this.resolvedProperty[this.propertyIndex] = a[b]; this.targetObject.matrixWorldNeedsUpdate = !0; }], [function (a, b) { this.resolvedProperty.fromArray(a, b); }, function (a, b) { this.resolvedProperty.fromArray(a, b); this.targetObject.needsUpdate = !0; }, function (a, b) { this.resolvedProperty.fromArray(a, b); this.targetObject.matrixWorldNeedsUpdate = !0; }]], getValue: function (a, b) { this.bind(); this.getValue(a, b); }, setValue: function (a,
      b) { this.bind(); this.setValue(a, b); }, bind: function () {
        var a = this.node, b = this.parsedPath, c = b.objectName, d = b.propertyName, e = b.propertyIndex; a || (this.node = a = ia.findNode(this.rootNode, b.nodeName) || this.rootNode); this.getValue = this._getValue_unavailable; this.setValue = this._setValue_unavailable; if (a) {
          if (c) {
            var f = b.objectIndex; switch (c) {
              case "materials": if (!a.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return; } if (!a.material.materials) {
                console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                  this); return;
              } a = a.material.materials; break; case "bones": if (!a.skeleton) { console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); return; } a = a.skeleton.bones; for (c = 0; c < a.length; c++)if (a[c].name === f) { f = c; break; } break; default: if (void 0 === a[c]) { console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); return; } a = a[c];
            }if (void 0 !== f) {
              if (void 0 === a[f]) {
                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this, a); return;
              } a = a[f];
            }
          } f = a[d]; if (void 0 === f) console.error("THREE.PropertyBinding: Trying to update property for track: " + b.nodeName + "." + d + " but it wasn't found.", a); else {
            b = this.Versioning.None; this.targetObject = a; void 0 !== a.needsUpdate ? b = this.Versioning.NeedsUpdate : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate); c = this.BindingType.Direct; if (void 0 !== e) {
              if ("morphTargetInfluences" === d) {
                if (!a.geometry) {
                  console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                    this); return;
                } if (a.geometry.isBufferGeometry) { if (!a.geometry.morphAttributes) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); return; } for (c = 0; c < this.node.geometry.morphAttributes.position.length; c++)if (a.geometry.morphAttributes.position[c].name === e) { e = c; break; } } else {
                  if (!a.geometry.morphTargets) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
                      this); return;
                  } for (c = 0; c < this.node.geometry.morphTargets.length; c++)if (a.geometry.morphTargets[c].name === e) { e = c; break; }
                }
              } c = this.BindingType.ArrayElement; this.resolvedProperty = f; this.propertyIndex = e;
            } else void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = f) : Array.isArray(f) ? (c = this.BindingType.EntireArray, this.resolvedProperty = f) : this.propertyName = d; this.getValue = this.GetterByBindingType[c]; this.setValue = this.SetterByBindingTypeAndVersioning[c][b];
          }
        } else console.error("THREE.PropertyBinding: Trying to update node for track: " +
          this.path + " but it wasn't found.");
      }, unbind: function () { this.node = null; this.getValue = this._getValue_unbound; this.setValue = this._setValue_unbound; }
  }); Object.assign(ia.prototype, { _getValue_unbound: ia.prototype.getValue, _setValue_unbound: ia.prototype.setValue }); Object.assign(Nf.prototype, {
    isAnimationObjectGroup: !0, add: function () {
      for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._paths, f = this._parsedPaths, g = this._bindings, h = g.length, l = void 0, k = 0, n = arguments.length; k !==
        n; ++k) { var p = arguments[k], v = p.uuid, t = d[v]; if (void 0 === t) { t = b++; d[v] = t; a.push(p); v = 0; for (var r = h; v !== r; ++v)g[v].push(new ia(p, e[v], f[v])); } else if (t < c) { l = a[t]; var u = --c; r = a[u]; d[r.uuid] = t; a[t] = r; d[v] = u; a[u] = p; v = 0; for (r = h; v !== r; ++v) { var w = g[v], z = w[t]; w[t] = w[u]; void 0 === z && (z = new ia(p, e[v], f[v])); w[u] = z; } } else a[t] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."); } this.nCachedObjects_ =
          c;
    }, remove: function () { for (var a = this._objects, b = this.nCachedObjects_, c = this._indicesByUUID, d = this._bindings, e = d.length, f = 0, g = arguments.length; f !== g; ++f) { var h = arguments[f], l = h.uuid, k = c[l]; if (void 0 !== k && k >= b) { var n = b++, p = a[n]; c[p.uuid] = k; a[k] = p; c[l] = n; a[n] = h; h = 0; for (l = e; h !== l; ++h) { p = d[h]; var v = p[k]; p[k] = p[n]; p[n] = v; } } } this.nCachedObjects_ = b; }, uncache: function () {
      for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings, f = e.length, g = 0, h = arguments.length; g !== h; ++g) {
        var l =
          arguments[g].uuid, k = d[l]; if (void 0 !== k) if (delete d[l], k < c) { l = --c; var n = a[l], p = --b, v = a[p]; d[n.uuid] = k; a[k] = n; d[v.uuid] = l; a[l] = v; a.pop(); n = 0; for (v = f; n !== v; ++n) { var t = e[n], r = t[p]; t[k] = t[l]; t[l] = r; t.pop(); } } else for (p = --b, v = a[p], d[v.uuid] = k, a[k] = v, a.pop(), n = 0, v = f; n !== v; ++n)t = e[n], t[k] = t[p], t.pop();
      } this.nCachedObjects_ = c;
    }, subscribe_: function (a, b) {
      var c = this._bindingsIndicesByPath, d = c[a], e = this._bindings; if (void 0 !== d) return e[d]; var f = this._paths, g = this._parsedPaths, h = this._objects, k = this.nCachedObjects_,
        m = Array(h.length); d = e.length; c[a] = d; f.push(a); g.push(b); e.push(m); c = k; for (d = h.length; c !== d; ++c)m[c] = new ia(h[c], a, b); return m;
    }, unsubscribe_: function (a) { var b = this._bindingsIndicesByPath, c = b[a]; if (void 0 !== c) { var d = this._paths, e = this._parsedPaths, f = this._bindings, g = f.length - 1, h = f[g]; b[a[g]] = c; f[c] = h; f.pop(); e[c] = e[g]; e.pop(); d[c] = d[g]; d.pop(); } }
  }); Object.assign(Of.prototype, {
    play: function () { this._mixer._activateAction(this); return this; }, stop: function () { this._mixer._deactivateAction(this); return this.reset(); },
    reset: function () { this.paused = !1; this.enabled = !0; this.time = 0; this._loopCount = -1; this._startTime = null; return this.stopFading().stopWarping(); }, isRunning: function () { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this); }, isScheduled: function () { return this._mixer._isActiveAction(this); }, startAt: function (a) { this._startTime = a; return this; }, setLoop: function (a, b) { this.loop = a; this.repetitions = b; return this; }, setEffectiveWeight: function (a) {
      this.weight = a;
      this._effectiveWeight = this.enabled ? a : 0; return this.stopFading();
    }, getEffectiveWeight: function () { return this._effectiveWeight; }, fadeIn: function (a) { return this._scheduleFading(a, 0, 1); }, fadeOut: function (a) { return this._scheduleFading(a, 1, 0); }, crossFadeFrom: function (a, b, c) { a.fadeOut(b); this.fadeIn(b); if (c) { c = this._clip.duration; var d = a._clip.duration, e = c / d; a.warp(1, d / c, b); this.warp(e, 1, b); } return this; }, crossFadeTo: function (a, b, c) { return a.crossFadeFrom(this, b, c); }, stopFading: function () {
      var a = this._weightInterpolant;
      null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a)); return this;
    }, setEffectiveTimeScale: function (a) { this.timeScale = a; this._effectiveTimeScale = this.paused ? 0 : a; return this.stopWarping(); }, getEffectiveTimeScale: function () { return this._effectiveTimeScale; }, setDuration: function (a) { this.timeScale = this._clip.duration / a; return this.stopWarping(); }, syncWith: function (a) { this.time = a.time; this.timeScale = a.timeScale; return this.stopWarping(); }, halt: function (a) {
      return this.warp(this._effectiveTimeScale,
        0, a);
    }, warp: function (a, b, c) { var d = this._mixer, e = d.time, f = this._timeScaleInterpolant, g = this.timeScale; null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant()); d = f.parameterPositions; f = f.sampleValues; d[0] = e; d[1] = e + c; f[0] = a / g; f[1] = b / g; return this; }, stopWarping: function () { var a = this._timeScaleInterpolant; null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a)); return this; }, getMixer: function () { return this._mixer; }, getClip: function () { return this._clip; }, getRoot: function () {
      return this._localRoot ||
        this._mixer._root;
    }, _update: function (a, b, c, d) { if (this.enabled) { var e = this._startTime; if (null !== e) { b = (a - e) * c; if (0 > b || 0 === c) return; this._startTime = null; b *= c; } b *= this._updateTimeScale(a); c = this._updateTime(b); a = this._updateWeight(a); if (0 < a) { b = this._interpolants; e = this._propertyBindings; for (var f = 0, g = b.length; f !== g; ++f)b[f].evaluate(c), e[f].accumulate(d, a); } } else this._updateWeight(a); }, _updateWeight: function (a) {
      var b = 0; if (this.enabled) {
        b = this.weight; var c = this._weightInterpolant; if (null !== c) {
          var d = c.evaluate(a)[0];
          b *= d; a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = !1));
        }
      } return this._effectiveWeight = b;
    }, _updateTimeScale: function (a) { var b = 0; if (!this.paused) { b = this.timeScale; var c = this._timeScaleInterpolant; if (null !== c) { var d = c.evaluate(a)[0]; b *= d; a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b); } } return this._effectiveTimeScale = b; }, _updateTime: function (a) {
      var b = this.time + a, c = this._clip.duration, d = this.loop, e = this._loopCount, f = 2202 === d; if (0 === a) return -1 ===
        e ? b : f && 1 === (e & 1) ? c - b : b; if (2200 === d) a: { if (-1 === e && (this._loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) b = c; else if (0 > b) b = 0; else break a; this.clampWhenFinished ? this.paused = !0 : this.enabled = !1; this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 > a ? -1 : 1 }); } else {
          -1 === e && (0 <= a ? (e = 0, this._setEndings(!0, 0 === this.repetitions, f)) : this._setEndings(0 === this.repetitions, !0, f)); if (b >= c || 0 > b) {
            d = Math.floor(b / c); b -= c * d; e += Math.abs(d); var g = this.repetitions - e; 0 >= g ? (this.clampWhenFinished ? this.paused = !0 :
              this.enabled = !1, b = 0 < a ? c : 0, this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 < a ? 1 : -1 })) : (1 === g ? (a = 0 > a, this._setEndings(a, !a, f)) : this._setEndings(!1, !1, f), this._loopCount = e, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: d }));
          } if (f && 1 === (e & 1)) return this.time = b, c - b;
        } return this.time = b;
    }, _setEndings: function (a, b, c) {
      var d = this._interpolantSettings; c ? (d.endingStart = 2401, d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, d.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 :
        2400 : 2402);
    }, _scheduleFading: function (a, b, c) { var d = this._mixer, e = d.time, f = this._weightInterpolant; null === f && (this._weightInterpolant = f = d._lendControlInterpolant()); d = f.parameterPositions; f = f.sampleValues; d[0] = e; f[0] = b; d[1] = e + a; f[1] = c; return this; }
  }); Ge.prototype = Object.assign(Object.create(ta.prototype), {
    constructor: Ge, _bindAction: function (a, b) {
      var c = a._localRoot || this._root, d = a._clip.tracks, e = d.length, f = a._propertyBindings; a = a._interpolants; var g = c.uuid, h = this._bindingsByRootAndName, k = h[g]; void 0 ===
        k && (k = {}, h[g] = k); for (h = 0; h !== e; ++h) { var m = d[h], n = m.name, p = k[n]; if (void 0 === p) { p = f[h]; if (void 0 !== p) { null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, g, n)); continue; } p = new Fe(ia.create(c, n, b && b._propertyBindings[h].binding.parsedPath), m.ValueTypeName, m.getValueSize()); ++p.referenceCount; this._addInactiveBinding(p, g, n); } f[h] = p; a[h].resultBuffer = p.buffer; }
    }, _activateAction: function (a) {
      if (!this._isActiveAction(a)) {
        if (null === a._cacheIndex) {
          var b = (a._localRoot || this._root).uuid, c = a._clip.uuid,
          d = this._actionsByClip[c]; this._bindAction(a, d && d.knownActions[0]); this._addInactiveAction(a, c, b);
        } b = a._propertyBindings; c = 0; for (d = b.length; c !== d; ++c) { var e = b[c]; 0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState()); } this._lendAction(a);
      }
    }, _deactivateAction: function (a) { if (this._isActiveAction(a)) { for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) { var e = b[c]; 0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e)); } this._takeBackAction(a); } }, _initMemoryManager: function () {
      this._actions =
      []; this._nActiveActions = 0; this._actionsByClip = {}; this._bindings = []; this._nActiveBindings = 0; this._bindingsByRootAndName = {}; this._controlInterpolants = []; this._nActiveControlInterpolants = 0; var a = this; this.stats = { actions: { get total() { return a._actions.length; }, get inUse() { return a._nActiveActions; } }, bindings: { get total() { return a._bindings.length; }, get inUse() { return a._nActiveBindings; } }, controlInterpolants: { get total() { return a._controlInterpolants.length; }, get inUse() { return a._nActiveControlInterpolants; } } };
    },
    _isActiveAction: function (a) { a = a._cacheIndex; return null !== a && a < this._nActiveActions; }, _addInactiveAction: function (a, b, c) { var d = this._actions, e = this._actionsByClip, f = e[b]; void 0 === f ? (f = { knownActions: [a], actionByRoot: {} }, a._byClipCacheIndex = 0, e[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, b.push(a)); a._cacheIndex = d.length; d.push(a); f.actionByRoot[c] = a; }, _removeInactiveAction: function (a) {
      var b = this._actions, c = b[b.length - 1], d = a._cacheIndex; c._cacheIndex = d; b[d] = c; b.pop(); a._cacheIndex = null; b = a._clip.uuid;
      c = this._actionsByClip; d = c[b]; var e = d.knownActions, f = e[e.length - 1], g = a._byClipCacheIndex; f._byClipCacheIndex = g; e[g] = f; e.pop(); a._byClipCacheIndex = null; delete d.actionByRoot[(a._localRoot || this._root).uuid]; 0 === e.length && delete c[b]; this._removeInactiveBindingsForAction(a);
    }, _removeInactiveBindingsForAction: function (a) { a = a._propertyBindings; for (var b = 0, c = a.length; b !== c; ++b) { var d = a[b]; 0 === --d.referenceCount && this._removeInactiveBinding(d); } }, _lendAction: function (a) {
      var b = this._actions, c = a._cacheIndex,
      d = this._nActiveActions++, e = b[d]; a._cacheIndex = d; b[d] = a; e._cacheIndex = c; b[c] = e;
    }, _takeBackAction: function (a) { var b = this._actions, c = a._cacheIndex, d = --this._nActiveActions, e = b[d]; a._cacheIndex = d; b[d] = a; e._cacheIndex = c; b[c] = e; }, _addInactiveBinding: function (a, b, c) { var d = this._bindingsByRootAndName, e = d[b], f = this._bindings; void 0 === e && (e = {}, d[b] = e); e[c] = a; a._cacheIndex = f.length; f.push(a); }, _removeInactiveBinding: function (a) {
      var b = this._bindings, c = a.binding, d = c.rootNode.uuid; c = c.path; var e = this._bindingsByRootAndName,
        f = e[d], g = b[b.length - 1]; a = a._cacheIndex; g._cacheIndex = a; b[a] = g; b.pop(); delete f[c]; a: { for (var h in f) break a; delete e[d]; }
    }, _lendBinding: function (a) { var b = this._bindings, c = a._cacheIndex, d = this._nActiveBindings++, e = b[d]; a._cacheIndex = d; b[d] = a; e._cacheIndex = c; b[c] = e; }, _takeBackBinding: function (a) { var b = this._bindings, c = a._cacheIndex, d = --this._nActiveBindings, e = b[d]; a._cacheIndex = d; b[d] = a; e._cacheIndex = c; b[c] = e; }, _lendControlInterpolant: function () {
      var a = this._controlInterpolants, b = this._nActiveControlInterpolants++,
      c = a[b]; void 0 === c && (c = new jd(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c); return c;
    }, _takeBackControlInterpolant: function (a) { var b = this._controlInterpolants, c = a.__cacheIndex, d = --this._nActiveControlInterpolants, e = b[d]; a.__cacheIndex = d; b[d] = a; e.__cacheIndex = c; b[c] = e; }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (a, b) {
      var c = b || this._root, d = c.uuid; c = "string" === typeof a ? Fa.findByName(c, a) : a; a = null !== c ? c.uuid : a; var e =
        this._actionsByClip[a], f = null; if (void 0 !== e) { f = e.actionByRoot[d]; if (void 0 !== f) return f; f = e.knownActions[0]; null === c && (c = f._clip); } if (null === c) return null; b = new Of(this, c, b); this._bindAction(b, f); this._addInactiveAction(b, a, d); return b;
    }, existingAction: function (a, b) { var c = b || this._root; b = c.uuid; c = "string" === typeof a ? Fa.findByName(c, a) : a; a = this._actionsByClip[c ? c.uuid : a]; return void 0 !== a ? a.actionByRoot[b] || null : null; }, stopAllAction: function () {
      for (var a = this._actions, b = this._nActiveActions, c = this._bindings,
        d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e)a[e].reset(); for (e = 0; e !== d; ++e)c[e].useCount = 0; return this;
    }, update: function (a) { a *= this.timeScale; for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g)b[g]._update(d, a, e, f); a = this._bindings; b = this._nActiveBindings; for (g = 0; g !== b; ++g)a[g].apply(f); return this; }, getRoot: function () { return this._root; }, uncacheClip: function (a) {
      var b = this._actions; a = a.uuid; var c = this._actionsByClip,
        d = c[a]; if (void 0 !== d) { d = d.knownActions; for (var e = 0, f = d.length; e !== f; ++e) { var g = d[e]; this._deactivateAction(g); var h = g._cacheIndex, k = b[b.length - 1]; g._cacheIndex = null; g._byClipCacheIndex = null; k._cacheIndex = h; b[h] = k; b.pop(); this._removeInactiveBindingsForAction(g); } delete c[a]; }
    }, uncacheRoot: function (a) {
      a = a.uuid; var b = this._actionsByClip; for (d in b) { var c = b[d].actionByRoot[a]; void 0 !== c && (this._deactivateAction(c), this._removeInactiveAction(c)); } var d = this._bindingsByRootAndName[a]; if (void 0 !== d) for (var e in d) a =
        d[e], a.restoreOriginalState(), this._removeInactiveBinding(a);
    }, uncacheAction: function (a, b) { a = this.existingAction(a, b); null !== a && (this._deactivateAction(a), this._removeInactiveAction(a)); }
  }); Xd.prototype.clone = function () { return new Xd(void 0 === this.value.clone ? this.value : this.value.clone()); }; He.prototype = Object.assign(Object.create(B.prototype), { constructor: He, isInstancedBufferGeometry: !0, copy: function (a) { B.prototype.copy.call(this, a); this.maxInstancedCount = a.maxInstancedCount; return this; }, clone: function () { return (new this.constructor).copy(this); } });
  Ie.prototype = Object.assign(Object.create(Ab.prototype), { constructor: Ie, isInstancedInterleavedBuffer: !0, copy: function (a) { Ab.prototype.copy.call(this, a); this.meshPerAttribute = a.meshPerAttribute; return this; } }); Je.prototype = Object.assign(Object.create(H.prototype), { constructor: Je, isInstancedBufferAttribute: !0, copy: function (a) { H.prototype.copy.call(this, a); this.meshPerAttribute = a.meshPerAttribute; return this; } }); Object.assign(Pf.prototype, {
    linePrecision: 1, set: function (a, b) { this.ray.set(a, b); }, setFromCamera: function (a,
      b) { b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize()) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type."); }, intersectObject: function (a, b, c) { c = c || []; Ke(a, this, c, b); c.sort(Qf); return c; }, intersectObjects: function (a, b, c) {
        c = c ||
        []; if (!1 === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), c; for (var d = 0, e = a.length; d < e; d++)Ke(a[d], this, c, b); c.sort(Qf); return c;
      }
  }); Object.assign(Rf.prototype, {
    set: function (a, b, c) { this.radius = a; this.phi = b; this.theta = c; return this; }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { this.radius = a.radius; this.phi = a.phi; this.theta = a.theta; return this; }, makeSafe: function () {
      this.phi = Math.max(1E-6, Math.min(Math.PI - 1E-6, this.phi));
      return this;
    }, setFromVector3: function (a) { return this.setFromCartesianCoords(a.x, a.y, a.z); }, setFromCartesianCoords: function (a, b, c) { this.radius = Math.sqrt(a * a + b * b + c * c); 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a, c), this.phi = Math.acos(O.clamp(b / this.radius, -1, 1))); return this; }
  }); Object.assign(Sf.prototype, {
    set: function (a, b, c) { this.radius = a; this.theta = b; this.y = c; return this; }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) {
      this.radius = a.radius; this.theta = a.theta;
      this.y = a.y; return this;
    }, setFromVector3: function (a) { return this.setFromCartesianCoords(a.x, a.y, a.z); }, setFromCartesianCoords: function (a, b, c) { this.radius = Math.sqrt(a * a + c * c); this.theta = Math.atan2(a, c); this.y = b; return this; }
  }); Object.assign(Le.prototype, {
    set: function (a, b) { this.min.copy(a); this.max.copy(b); return this; }, setFromPoints: function (a) { this.makeEmpty(); for (var b = 0, c = a.length; b < c; b++)this.expandByPoint(a[b]); return this; }, setFromCenterAndSize: function () {
      var a = new C; return function (b, c) {
        c = a.copy(c).multiplyScalar(.5);
        this.min.copy(b).sub(c); this.max.copy(b).add(c); return this;
      };
    }(), clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { this.min.copy(a.min); this.max.copy(a.max); return this; }, makeEmpty: function () { this.min.x = this.min.y = Infinity; this.max.x = this.max.y = -Infinity; return this; }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y; }, getCenter: function (a) {
      void 0 === a && (console.warn("THREE.Box2: .getCenter() target is now required"), a = new C); return this.isEmpty() ? a.set(0,
        0) : a.addVectors(this.min, this.max).multiplyScalar(.5);
    }, getSize: function (a) { void 0 === a && (console.warn("THREE.Box2: .getSize() target is now required"), a = new C); return this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min); }, expandByPoint: function (a) { this.min.min(a); this.max.max(a); return this; }, expandByVector: function (a) { this.min.sub(a); this.max.add(a); return this; }, expandByScalar: function (a) { this.min.addScalar(-a); this.max.addScalar(a); return this; }, containsPoint: function (a) {
      return a.x < this.min.x ||
        a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0;
    }, containsBox: function (a) { return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y; }, getParameter: function (a, b) { void 0 === b && (console.warn("THREE.Box2: .getParameter() target is now required"), b = new C); return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y)); }, intersectsBox: function (a) { return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0; },
    clampPoint: function (a, b) { void 0 === b && (console.warn("THREE.Box2: .clampPoint() target is now required"), b = new C); return b.copy(a).clamp(this.min, this.max); }, distanceToPoint: function () { var a = new C; return function (b) { return a.copy(b).clamp(this.min, this.max).sub(b).length(); }; }(), intersect: function (a) { this.min.max(a.min); this.max.min(a.max); return this; }, union: function (a) { this.min.min(a.min); this.max.max(a.max); return this; }, translate: function (a) { this.min.add(a); this.max.add(a); return this; }, equals: function (a) {
      return a.min.equals(this.min) &&
        a.max.equals(this.max);
    }
  }); Object.assign(Me.prototype, {
    set: function (a, b) { this.start.copy(a); this.end.copy(b); return this; }, clone: function () { return (new this.constructor).copy(this); }, copy: function (a) { this.start.copy(a.start); this.end.copy(a.end); return this; }, getCenter: function (a) { void 0 === a && (console.warn("THREE.Line3: .getCenter() target is now required"), a = new n); return a.addVectors(this.start, this.end).multiplyScalar(.5); }, delta: function (a) {
      void 0 === a && (console.warn("THREE.Line3: .delta() target is now required"),
        a = new n); return a.subVectors(this.end, this.start);
    }, distanceSq: function () { return this.start.distanceToSquared(this.end); }, distance: function () { return this.start.distanceTo(this.end); }, at: function (a, b) { void 0 === b && (console.warn("THREE.Line3: .at() target is now required"), b = new n); return this.delta(b).multiplyScalar(a).add(this.start); }, closestPointToPointParameter: function () {
      var a = new n, b = new n; return function (c, d) {
        a.subVectors(c, this.start); b.subVectors(this.end, this.start); c = b.dot(b); c = b.dot(a) / c; d &&
          (c = O.clamp(c, 0, 1)); return c;
      };
    }(), closestPointToPoint: function (a, b, c) { a = this.closestPointToPointParameter(a, b); void 0 === c && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), c = new n); return this.delta(c).multiplyScalar(a).add(this.start); }, applyMatrix4: function (a) { this.start.applyMatrix4(a); this.end.applyMatrix4(a); return this; }, equals: function (a) { return a.start.equals(this.start) && a.end.equals(this.end); }
  }); rd.prototype = Object.create(D.prototype); rd.prototype.constructor = rd; rd.prototype.isImmediateRenderObject =
    !0; sd.prototype = Object.create(V.prototype); sd.prototype.constructor = sd; sd.prototype.update = function () {
      var a = new n, b = new n, c = new na; return function () {
        var d = ["a", "b", "c"]; this.object.updateMatrixWorld(!0); c.getNormalMatrix(this.object.matrixWorld); var e = this.object.matrixWorld, f = this.geometry.attributes.position, g = this.object.geometry; if (g && g.isGeometry) for (var h = g.vertices, k = g.faces, m = g = 0, n = k.length; m < n; m++)for (var p = k[m], v = 0, t = p.vertexNormals.length; v < t; v++) {
          var r = p.vertexNormals[v]; a.copy(h[p[d[v]]]).applyMatrix4(e);
          b.copy(r).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a); f.setXYZ(g, a.x, a.y, a.z); g += 1; f.setXYZ(g, b.x, b.y, b.z); g += 1;
        } else if (g && g.isBufferGeometry) for (d = g.attributes.position, h = g.attributes.normal, v = g = 0, t = d.count; v < t; v++)a.set(d.getX(v), d.getY(v), d.getZ(v)).applyMatrix4(e), b.set(h.getX(v), h.getY(v), h.getZ(v)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1; f.needsUpdate = !0;
      };
    }(); rc.prototype = Object.create(D.prototype);
  rc.prototype.constructor = rc; rc.prototype.dispose = function () { this.cone.geometry.dispose(); this.cone.material.dispose(); }; rc.prototype.update = function () { var a = new n; return function () { this.light.updateMatrixWorld(); var b = this.light.distance ? this.light.distance : 1E3, c = b * Math.tan(this.light.angle); this.cone.scale.set(c, c, b); a.setFromMatrixPosition(this.light.target.matrixWorld); this.cone.lookAt(a); void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color); }; }();
  sc.prototype = Object.create(V.prototype); sc.prototype.constructor = sc; sc.prototype.updateMatrixWorld = function () {
    var a = new n, b = new P, c = new P; return function (d) {
      var e = this.bones, f = this.geometry, g = f.getAttribute("position"); c.getInverse(this.root.matrixWorld); for (var h = 0, k = 0; h < e.length; h++) {
        var m = e[h]; m.parent && m.parent.isBone && (b.multiplyMatrices(c, m.matrixWorld), a.setFromMatrixPosition(b), g.setXYZ(k, a.x, a.y, a.z), b.multiplyMatrices(c, m.parent.matrixWorld), a.setFromMatrixPosition(b), g.setXYZ(k + 1, a.x, a.y,
          a.z), k += 2);
      } f.getAttribute("position").needsUpdate = !0; D.prototype.updateMatrixWorld.call(this, d);
    };
  }(); tc.prototype = Object.create(qa.prototype); tc.prototype.constructor = tc; tc.prototype.dispose = function () { this.geometry.dispose(); this.material.dispose(); }; tc.prototype.update = function () { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color); }; uc.prototype = Object.create(ka.prototype); uc.prototype.constructor = uc; uc.prototype.update = function () {
    this.scale.set(.5 * this.light.width,
      .5 * this.light.height, 1); if (void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color); else { this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity); var a = this.material.color, b = Math.max(a.r, a.g, a.b); 1 < b && a.multiplyScalar(1 / b); this.children[0].material.color.copy(this.material.color); }
  }; uc.prototype.dispose = function () { this.geometry.dispose(); this.material.dispose(); this.children[0].geometry.dispose(); this.children[0].material.dispose(); };
  vc.prototype = Object.create(D.prototype); vc.prototype.constructor = vc; vc.prototype.dispose = function () { this.children[0].geometry.dispose(); this.children[0].material.dispose(); }; vc.prototype.update = function () {
    var a = new n, b = new A, c = new A; return function () {
      var d = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else {
        var e = d.geometry.getAttribute("color"); b.copy(this.light.color); c.copy(this.light.groundColor); for (var f = 0, g = e.count; f < g; f++) { var h = f < g / 2 ? b : c; e.setXYZ(f, h.r, h.g, h.b); } e.needsUpdate =
          !0;
      } d.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
    };
  }(); wc.prototype = Object.create(qa.prototype); wc.prototype.constructor = wc; wc.prototype.dispose = function () { this.geometry.dispose(); this.material.dispose(); }; wc.prototype.onBeforeRender = function () { return function () { this.position.copy(this.lightProbe.position); this.scale.set(1, 1, 1).multiplyScalar(this.size); this.material.uniforms.intensity.value = this.lightProbe.intensity; }; }(); Yd.prototype = Object.assign(Object.create(V.prototype), {
    constructor: Yd,
    copy: function (a) { V.prototype.copy.call(this, a); this.geometry.copy(a.geometry); this.material.copy(a.material); return this; }, clone: function () { return (new this.constructor).copy(this); }
  }); Zd.prototype = Object.create(V.prototype); Zd.prototype.constructor = Zd; xc.prototype = Object.create(ka.prototype); xc.prototype.constructor = xc; xc.prototype.update = function () {
    function a(a, b, d, e) {
      d = (b - a) / d; t.setXYZ(k, 0, 0, 0); m++; for (n = a; n < b; n += d)p = k + m, t.setXYZ(p, Math.sin(n) * c, 0, Math.cos(n) * c), t.setXYZ(p + 1, Math.sin(Math.min(n + d,
        b)) * c, 0, Math.cos(Math.min(n + d, b)) * c), t.setXYZ(p + 2, 0, 0, 0), m += 3; v.addGroup(k, m, e); k += m; m = 0;
    } var b = this.audio, c = this.range, d = this.divisionsInnerAngle, e = this.divisionsOuterAngle, f = O.degToRad(b.panner.coneInnerAngle); b = O.degToRad(b.panner.coneOuterAngle); var g = f / 2, h = b / 2, k = 0, m = 0, n, p, v = this.geometry, t = v.attributes.position; v.clearGroups(); a(-h, -g, e, 0); a(-g, g, d, 1); a(g, h, e, 0); t.needsUpdate = !0; f === b && (this.material[0].visible = !1);
  }; xc.prototype.dispose = function () {
    this.geometry.dispose(); this.material[0].dispose();
    this.material[1].dispose();
  }; td.prototype = Object.create(V.prototype); td.prototype.constructor = td; td.prototype.update = function () {
    var a = new n, b = new n, c = new na; return function () {
      this.object.updateMatrixWorld(!0); c.getNormalMatrix(this.object.matrixWorld); var d = this.object.matrixWorld, e = this.geometry.attributes.position, f = this.object.geometry, g = f.vertices; f = f.faces; for (var h = 0, k = 0, m = f.length; k < m; k++) {
        var n = f[k], p = n.normal; a.copy(g[n.a]).add(g[n.b]).add(g[n.c]).divideScalar(3).applyMatrix4(d); b.copy(p).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
        e.setXYZ(h, a.x, a.y, a.z); h += 1; e.setXYZ(h, b.x, b.y, b.z); h += 1;
      } e.needsUpdate = !0;
    };
  }(); yc.prototype = Object.create(D.prototype); yc.prototype.constructor = yc; yc.prototype.dispose = function () { this.lightPlane.geometry.dispose(); this.lightPlane.material.dispose(); this.targetLine.geometry.dispose(); this.targetLine.material.dispose(); }; yc.prototype.update = function () {
    var a = new n, b = new n, c = new n; return function () {
      a.setFromMatrixPosition(this.light.matrixWorld); b.setFromMatrixPosition(this.light.target.matrixWorld); c.subVectors(b,
        a); this.lightPlane.lookAt(b); void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)); this.targetLine.lookAt(b); this.targetLine.scale.z = c.length();
    };
  }(); ud.prototype = Object.create(V.prototype); ud.prototype.constructor = ud; ud.prototype.update = function () {
    function a(a, g, h, k) {
      d.set(g, h, k).unproject(e); a = c[a]; if (void 0 !== a) for (g = b.getAttribute("position"),
        h = 0, k = a.length; h < k; h++)g.setXYZ(a[h], d.x, d.y, d.z);
    } var b, c, d = new n, e = new Xa; return function () {
      b = this.geometry; c = this.pointMap; e.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); a("c", 0, 0, -1); a("t", 0, 0, 1); a("n1", -1, -1, -1); a("n2", 1, -1, -1); a("n3", -1, 1, -1); a("n4", 1, 1, -1); a("f1", -1, -1, 1); a("f2", 1, -1, 1); a("f3", -1, 1, 1); a("f4", 1, 1, 1); a("u1", .7, 1.1, -1); a("u2", -.7, 1.1, -1); a("u3", 0, 2, -1); a("cf1", -1, 0, 1); a("cf2", 1, 0, 1); a("cf3", 0, -1, 1); a("cf4", 0, 1, 1); a("cn1", -1, 0, -1); a("cn2", 1, 0, -1); a("cn3", 0,
        -1, -1); a("cn4", 0, 1, -1); b.getAttribute("position").needsUpdate = !0;
    };
  }(); gb.prototype = Object.create(V.prototype); gb.prototype.constructor = gb; gb.prototype.update = function () {
    var a = new Ga; return function (b) {
      void 0 !== b && console.warn("THREE.BoxHelper: .update() has no longer arguments."); void 0 !== this.object && a.setFromObject(this.object); if (!a.isEmpty()) {
        b = a.min; var c = a.max, d = this.geometry.attributes.position, e = d.array; e[0] = c.x; e[1] = c.y; e[2] = c.z; e[3] = b.x; e[4] = c.y; e[5] = c.z; e[6] = b.x; e[7] = b.y; e[8] = c.z; e[9] = c.x;
        e[10] = b.y; e[11] = c.z; e[12] = c.x; e[13] = c.y; e[14] = b.z; e[15] = b.x; e[16] = c.y; e[17] = b.z; e[18] = b.x; e[19] = b.y; e[20] = b.z; e[21] = c.x; e[22] = b.y; e[23] = b.z; d.needsUpdate = !0; this.geometry.computeBoundingSphere();
      }
    };
  }(); gb.prototype.setFromObject = function (a) { this.object = a; this.update(); return this; }; gb.prototype.copy = function (a) { V.prototype.copy.call(this, a); this.object = a.object; return this; }; gb.prototype.clone = function () { return (new this.constructor).copy(this); }; vd.prototype = Object.create(V.prototype); vd.prototype.constructor =
    vd; vd.prototype.updateMatrixWorld = function (a) { var b = this.box; b.isEmpty() || (b.getCenter(this.position), b.getSize(this.scale), this.scale.multiplyScalar(.5), D.prototype.updateMatrixWorld.call(this, a)); }; wd.prototype = Object.create(ka.prototype); wd.prototype.constructor = wd; wd.prototype.updateMatrixWorld = function (a) {
      var b = -this.plane.constant; 1E-8 > Math.abs(b) && (b = 1E-8); this.scale.set(.5 * this.size, .5 * this.size, b); this.children[0].material.side = 0 > b ? 1 : 0; this.lookAt(this.plane.normal); D.prototype.updateMatrixWorld.call(this,
        a);
    }; var $d, Ne; hb.prototype = Object.create(D.prototype); hb.prototype.constructor = hb; hb.prototype.setDirection = function () { var a = new n, b; return function (c) { .99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b)); }; }(); hb.prototype.setLength = function (a, b, c) {
      void 0 === b && (b = .2 * a); void 0 === c && (c = .2 * b); this.line.scale.set(1, Math.max(0, a - b), 1); this.line.updateMatrix(); this.cone.scale.set(c, b, c); this.cone.position.y =
        a; this.cone.updateMatrix();
    }; hb.prototype.setColor = function (a) { this.line.material.color.copy(a); this.cone.material.color.copy(a); }; hb.prototype.copy = function (a) { D.prototype.copy.call(this, a, !1); this.line.copy(a.line); this.cone.copy(a.cone); return this; }; hb.prototype.clone = function () { return (new this.constructor).copy(this); }; xd.prototype = Object.create(V.prototype); xd.prototype.constructor = xd; M.create = function (a, b) {
      console.log("THREE.Curve.create() has been deprecated"); a.prototype = Object.create(M.prototype);
      a.prototype.constructor = a; a.prototype.getPoint = b; return a;
    }; Object.assign(fb.prototype, {
      createPointsGeometry: function (a) { console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); a = this.getPoints(a); return this.createGeometry(a); }, createSpacedPointsGeometry: function (a) {
        console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); a = this.getSpacedPoints(a);
        return this.createGeometry(a);
      }, createGeometry: function (a) { console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); for (var b = new K, c = 0, d = a.length; c < d; c++) { var e = a[c]; b.vertices.push(new n(e.x, e.y, e.z || 0)); } return b; }
    }); Object.assign(Pa.prototype, { fromPoints: function (a) { console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."); this.setFromPoints(a); } }); Uf.prototype = Object.create(oa.prototype); Vf.prototype = Object.create(oa.prototype);
  Oe.prototype = Object.create(oa.prototype); Object.assign(Oe.prototype, { initFromArray: function () { console.error("THREE.Spline: .initFromArray() has been removed."); }, getControlPointsArray: function () { console.error("THREE.Spline: .getControlPointsArray() has been removed."); }, reparametrizeByArcLength: function () { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed."); } }); Yd.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."); };
  sc.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called."); }; Object.assign(pd.prototype, { extractUrlBase: function (a) { console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."); return Te.extractUrlBase(a); } }); Object.assign(te.prototype, { setTexturePath: function (a) { console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."); return this.setResourcePath(a); } }); Object.assign(Le.prototype,
    { center: function (a) { console.warn("THREE.Box2: .center() has been renamed to .getCenter()."); return this.getCenter(a); }, empty: function () { console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."); return this.isEmpty(); }, isIntersectionBox: function (a) { console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."); return this.intersectsBox(a); }, size: function (a) { console.warn("THREE.Box2: .size() has been renamed to .getSize()."); return this.getSize(a); } }); Object.assign(Ga.prototype,
      {
        center: function (a) { console.warn("THREE.Box3: .center() has been renamed to .getCenter()."); return this.getCenter(a); }, empty: function () { console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."); return this.isEmpty(); }, isIntersectionBox: function (a) { console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."); return this.intersectsBox(a); }, isIntersectionSphere: function (a) { console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."); return this.intersectsSphere(a); },
        size: function (a) { console.warn("THREE.Box3: .size() has been renamed to .getSize()."); return this.getSize(a); }
      }); Me.prototype.center = function (a) { console.warn("THREE.Line3: .center() has been renamed to .getCenter()."); return this.getCenter(a); }; Object.assign(O, {
        random16: function () { console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."); return Math.random(); }, nearestPowerOfTwo: function (a) {
          console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
          return O.floorPowerOfTwo(a);
        }, nextPowerOfTwo: function (a) { console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."); return O.ceilPowerOfTwo(a); }
      }); Object.assign(na.prototype, {
        flattenToArrayOffset: function (a, b) { console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."); return this.toArray(a, b); }, multiplyVector3: function (a) { console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."); return a.applyMatrix3(this); },
        multiplyVector3Array: function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed."); }, applyToBuffer: function (a) { console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."); return this.applyToBufferAttribute(a); }, applyToVector3Array: function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed."); }
      }); Object.assign(P.prototype, {
        extractPosition: function (a) {
          console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
          return this.copyPosition(a);
        }, flattenToArrayOffset: function (a, b) { console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."); return this.toArray(a, b); }, getPosition: function () { var a; return function () { void 0 === a && (a = new n); console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."); return a.setFromMatrixColumn(this, 3); }; }(), setRotationFromQuaternion: function (a) {
          console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
          return this.makeRotationFromQuaternion(a);
        }, multiplyToArray: function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed."); }, multiplyVector3: function (a) { console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."); return a.applyMatrix4(this); }, multiplyVector4: function (a) { console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."); return a.applyMatrix4(this); }, multiplyVector3Array: function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed."); },
        rotateAxis: function (a) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."); a.transformDirection(this); }, crossVector: function (a) { console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."); return a.applyMatrix4(this); }, translate: function () { console.error("THREE.Matrix4: .translate() has been removed."); }, rotateX: function () { console.error("THREE.Matrix4: .rotateX() has been removed."); }, rotateY: function () { console.error("THREE.Matrix4: .rotateY() has been removed."); },
        rotateZ: function () { console.error("THREE.Matrix4: .rotateZ() has been removed."); }, rotateByAxis: function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed."); }, applyToBuffer: function (a) { console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."); return this.applyToBufferAttribute(a); }, applyToVector3Array: function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed."); }, makeFrustum: function (a, b, c, d, e, f) {
          console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
          return this.makePerspective(a, b, d, c, e, f);
        }
      }); Ua.prototype.isIntersectionLine = function (a) { console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."); return this.intersectsLine(a); }; ma.prototype.multiplyVector3 = function (a) { console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."); return a.applyQuaternion(this); }; Object.assign(zb.prototype, {
        isIntersectionBox: function (a) {
          console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
          return this.intersectsBox(a);
        }, isIntersectionPlane: function (a) { console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."); return this.intersectsPlane(a); }, isIntersectionSphere: function (a) { console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."); return this.intersectsSphere(a); }
      }); Object.assign(ra.prototype, {
        area: function () { console.warn("THREE.Triangle: .area() has been renamed to .getArea()."); return this.getArea(); }, barycoordFromPoint: function (a,
          b) { console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."); return this.getBarycoord(a, b); }, midpoint: function (a) { console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."); return this.getMidpoint(a); }, normal: function (a) { console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."); return this.getNormal(a); }, plane: function (a) { console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."); return this.getPlane(a); }
      }); Object.assign(ra,
        { barycoordFromPoint: function (a, b, c, d, e) { console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."); return ra.getBarycoord(a, b, c, d, e); }, normal: function (a, b, c, d) { console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."); return ra.getNormal(a, b, c, d); } }); Object.assign(pb.prototype, {
          extractAllPoints: function (a) { console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."); return this.extractPoints(a); }, extrude: function (a) {
            console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
            return new Eb(this, a);
          }, makeGeometry: function (a) { console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."); return new Fb(this, a); }
        }); Object.assign(C.prototype, {
          fromAttribute: function (a, b, c) { console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."); return this.fromBufferAttribute(a, b, c); }, distanceToManhattan: function (a) { console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."); return this.manhattanDistanceTo(a); },
          lengthManhattan: function () { console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."); return this.manhattanLength(); }
        }); Object.assign(n.prototype, {
          setEulerFromRotationMatrix: function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."); }, setEulerFromQuaternion: function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."); }, getPositionFromMatrix: function (a) {
            console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
            return this.setFromMatrixPosition(a);
          }, getScaleFromMatrix: function (a) { console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."); return this.setFromMatrixScale(a); }, getColumnFromMatrix: function (a, b) { console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."); return this.setFromMatrixColumn(b, a); }, applyProjection: function (a) { console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."); return this.applyMatrix4(a); },
          fromAttribute: function (a, b, c) { console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."); return this.fromBufferAttribute(a, b, c); }, distanceToManhattan: function (a) { console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."); return this.manhattanDistanceTo(a); }, lengthManhattan: function () { console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."); return this.manhattanLength(); }
        }); Object.assign(W.prototype,
          { fromAttribute: function (a, b, c) { console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."); return this.fromBufferAttribute(a, b, c); }, lengthManhattan: function () { console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."); return this.manhattanLength(); } }); Object.assign(K.prototype, { computeTangents: function () { console.error("THREE.Geometry: .computeTangents() has been removed."); }, computeLineDistances: function () { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."); } });
  Object.assign(D.prototype, { getChildByName: function (a) { console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."); return this.getObjectByName(a); }, renderDepth: function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."); }, translate: function (a, b) { console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."); return this.translateOnAxis(b, a); }, getWorldRotation: function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."); } });
  Object.defineProperties(D.prototype, { eulerOrder: { get: function () { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."); return this.rotation.order; }, set: function (a) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."); this.rotation.order = a; } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."); }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."); } } });
  Object.defineProperties(Mc.prototype, { objects: { get: function () { console.warn("THREE.LOD: .objects has been renamed to .levels."); return this.levels; } } }); Object.defineProperty(Dd.prototype, "useVertexTexture", { get: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed."); }, set: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed."); } }); Nc.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed."); }; Object.defineProperty(M.prototype,
    "__arcLengthDivisions", { get: function () { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."); return this.arcLengthDivisions; }, set: function (a) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."); this.arcLengthDivisions = a; } }); ca.prototype.setLens = function (a, b) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."); void 0 !== b && (this.filmGauge = b); this.setFocalLength(a); }; Object.defineProperties(T.prototype,
      {
        onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed."); } }, shadowCameraFov: { set: function (a) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."); this.shadow.camera.fov = a; } }, shadowCameraLeft: { set: function (a) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."); this.shadow.camera.left = a; } }, shadowCameraRight: { set: function (a) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."); this.shadow.camera.right = a; } }, shadowCameraTop: {
          set: function (a) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
            this.shadow.camera.top = a;
          }
        }, shadowCameraBottom: { set: function (a) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."); this.shadow.camera.bottom = a; } }, shadowCameraNear: { set: function (a) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."); this.shadow.camera.near = a; } }, shadowCameraFar: { set: function (a) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."); this.shadow.camera.far = a; } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."); } },
        shadowBias: { set: function (a) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."); this.shadow.bias = a; } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed."); } }, shadowMapWidth: { set: function (a) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."); this.shadow.mapSize.width = a; } }, shadowMapHeight: { set: function (a) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."); this.shadow.mapSize.height = a; } }
      }); Object.defineProperties(H.prototype,
        { length: { get: function () { console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."); return this.array.length; } }, copyIndicesArray: function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed."); } }); Object.assign(B.prototype, {
          addIndex: function (a) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."); this.setIndex(a); }, addDrawCall: function (a, b, c) {
            void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."); this.addGroup(a, b);
          }, clearDrawCalls: function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."); this.clearGroups(); }, computeTangents: function () { console.warn("THREE.BufferGeometry: .computeTangents() has been removed."); }, computeOffsets: function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed."); }
        }); Object.defineProperties(B.prototype, {
          drawcalls: {
            get: function () {
              console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
              return this.groups;
            }
          }, offsets: { get: function () { console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."); return this.groups; } }
        }); Object.assign(Ya.prototype, { getArrays: function () { console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed."); }, addShapeList: function () { console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."); }, addShape: function () { console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed."); } }); Object.defineProperties(Xd.prototype,
          { dynamic: { set: function () { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."); } }, onUpdate: { value: function () { console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."); return this; } } }); Object.defineProperties(Q.prototype, {
            wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed."); }, set: function () { console.warn("THREE.Material: .wrapAround has been removed."); } }, overdraw: {
              get: function () { console.warn("THREE.Material: .overdraw has been removed."); },
              set: function () { console.warn("THREE.Material: .overdraw has been removed."); }
            }, wrapRGB: { get: function () { console.warn("THREE.Material: .wrapRGB has been removed."); return new A; } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."); }, set: function (a) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."); this.flatShading = 1 === a; } }
          }); Object.defineProperties(Ja.prototype, {
            metal: {
              get: function () {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
                return !1;
              }, set: function () { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"); }
            }
          }); Object.defineProperties(ea.prototype, { derivatives: { get: function () { console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."); return this.extensions.derivatives; }, set: function (a) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."); this.extensions.derivatives = a; } } }); Object.assign(je.prototype,
            {
              clearTarget: function (a, b, c, d) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."); this.setRenderTarget(a); this.clear(b, c, d); }, animate: function (a) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."); this.setAnimationLoop(a); }, getCurrentRenderTarget: function () { console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."); return this.getRenderTarget(); }, getMaxAnisotropy: function () {
                console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
                return this.capabilities.getMaxAnisotropy();
              }, getPrecision: function () { console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."); return this.capabilities.precision; }, resetGLState: function () { console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."); return this.state.reset(); }, supportsFloatTextures: function () { console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."); return this.extensions.get("OES_texture_float"); },
              supportsHalfFloatTextures: function () { console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."); return this.extensions.get("OES_texture_half_float"); }, supportsStandardDerivatives: function () { console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."); return this.extensions.get("OES_standard_derivatives"); }, supportsCompressedTextureS3TC: function () {
                console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
                return this.extensions.get("WEBGL_compressed_texture_s3tc");
              }, supportsCompressedTexturePVRTC: function () { console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."); return this.extensions.get("WEBGL_compressed_texture_pvrtc"); }, supportsBlendMinMax: function () { console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."); return this.extensions.get("EXT_blend_minmax"); }, supportsVertexTextures: function () {
                console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
                return this.capabilities.vertexTextures;
              }, supportsInstancedArrays: function () { console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."); return this.extensions.get("ANGLE_instanced_arrays"); }, enableScissorTest: function (a) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."); this.setScissorTest(a); }, initMaterial: function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed."); }, addPrePlugin: function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed."); },
              addPostPlugin: function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed."); }, updateShadowMap: function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed."); }, setFaceCulling: function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed."); }, allocTextureUnit: function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed."); }, setTexture: function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed."); }, setTexture2D: function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed."); },
              setTextureCube: function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed."); }
            }); Object.defineProperties(je.prototype, {
              shadowMapEnabled: { get: function () { return this.shadowMap.enabled; }, set: function (a) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."); this.shadowMap.enabled = a; } }, shadowMapType: { get: function () { return this.shadowMap.type; }, set: function (a) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."); this.shadowMap.type = a; } },
              shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."); }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."); } }
            }); Object.defineProperties(rf.prototype, {
              cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."); }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."); } },
              renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."); }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."); } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."); }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."); } }
            });
  Object.defineProperties(rb.prototype, { activeCubeFace: { set: function () { console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget()."); } }, activeMipMapLevel: { set: function () { console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget()."); } } }); Object.defineProperties(Sa.prototype, {
    wrapS: {
      get: function () {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
        return this.texture.wrapS;
      }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."); this.texture.wrapS = a; }
    }, wrapT: { get: function () { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."); return this.texture.wrapT; }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."); this.texture.wrapT = a; } }, magFilter: {
      get: function () { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."); return this.texture.magFilter; },
      set: function (a) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."); this.texture.magFilter = a; }
    }, minFilter: { get: function () { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."); return this.texture.minFilter; }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."); this.texture.minFilter = a; } }, anisotropy: {
      get: function () { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."); return this.texture.anisotropy; },
      set: function (a) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."); this.texture.anisotropy = a; }
    }, offset: { get: function () { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."); return this.texture.offset; }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."); this.texture.offset = a; } }, repeat: {
      get: function () { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."); return this.texture.repeat; }, set: function (a) {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
        this.texture.repeat = a;
      }
    }, format: { get: function () { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."); return this.texture.format; }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."); this.texture.format = a; } }, type: { get: function () { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."); return this.texture.type; }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."); this.texture.type = a; } }, generateMipmaps: {
      get: function () {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
        return this.texture.generateMipmaps;
      }, set: function (a) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."); this.texture.generateMipmaps = a; }
    }
  }); Object.defineProperties(xf.prototype, { standing: { set: function () { console.warn("THREE.WebVRManager: .standing has been removed."); } }, userHeight: { set: function () { console.warn("THREE.WebVRManager: .userHeight has been removed."); } } }); qc.prototype.load = function (a) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    var b = this; (new xe).load(a, function (a) { b.setBuffer(a); }); return this;
  }; Ee.prototype.getData = function () { console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."); return this.getFrequencyData(); }; qd.prototype.updateCubeMap = function (a, b) { console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."); return this.update(a, b); }; qb.crossOrigin = void 0; qb.loadTexture = function (a, b, c, d) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); var e =
      new Md; e.setCrossOrigin(this.crossOrigin); a = e.load(a, c, void 0, d); b && (a.mapping = b); return a;
  }; qb.loadTextureCube = function (a, b, c, d) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); var e = new qe; e.setCrossOrigin(this.crossOrigin); a = e.load(a, c, void 0, d); b && (a.mapping = b); return a; }; qb.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."); }; qb.loadCompressedTextureCube =
    function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."); }; k.WebGLMultisampleRenderTarget = ce; k.WebGLRenderTargetCube = rb; k.WebGLRenderTarget = Sa; k.WebGLRenderer = je; k.ShaderLib = Va; k.UniformsLib = J; k.UniformsUtils = nh; k.ShaderChunk = R; k.FogExp2 = Ad; k.Fog = Bd; k.Scene = Cd; k.Sprite = Lc; k.LOD = Mc; k.SkinnedMesh = Nc; k.Skeleton = Dd; k.Bone = ke; k.Mesh = qa; k.LineSegments = V; k.LineLoop = Ed; k.Line = ka; k.Points = Zb; k.Group = Xb; k.VideoTexture = le; k.DataTexture = sb; k.DataTexture2DArray =
      Ub; k.DataTexture3D = Vb; k.CompressedTexture = $b; k.CubeTexture = cb; k.CanvasTexture = Oc; k.DepthTexture = Pc; k.Texture = Y; k.AnimationLoader = Hf; k.CompressedTextureLoader = If; k.DataTextureLoader = pe; k.CubeTextureLoader = qe; k.TextureLoader = Md; k.ObjectLoader = te; k.MaterialLoader = Vd; k.BufferGeometryLoader = se; k.DefaultLoadingManager = za; k.LoadingManager = oe; k.ImageLoader = ld; k.ImageBitmapLoader = ue; k.FontLoader = Kf; k.FileLoader = Ka; k.Loader = pd; k.LoaderUtils = Te; k.Cache = Qb; k.AudioLoader = xe; k.SpotLightShadow = Od; k.SpotLight = Pd;
  k.PointLight = Qd; k.RectAreaLight = Ud; k.HemisphereLight = Nd; k.HemisphereLightProbe = ye; k.DirectionalLightShadow = Rd; k.DirectionalLight = Sd; k.AmbientLight = Td; k.AmbientLightProbe = ze; k.LightShadow = Pb; k.Light = T; k.LightProbe = Qa; k.StereoCamera = Lf; k.PerspectiveCamera = ca; k.OrthographicCamera = od; k.CubeCamera = qd; k.ArrayCamera = Jc; k.Camera = Xa; k.AudioListener = Be; k.PositionalAudio = De; k.AudioContext = Ce; k.AudioAnalyser = Ee; k.Audio = qc; k.VectorKeyframeTrack = oc; k.StringKeyframeTrack = Ld; k.QuaternionKeyframeTrack = kd; k.NumberKeyframeTrack =
    nc; k.ColorKeyframeTrack = Jd; k.BooleanKeyframeTrack = Id; k.PropertyMixer = Fe; k.PropertyBinding = ia; k.KeyframeTrack = da; k.AnimationUtils = ba; k.AnimationObjectGroup = Nf; k.AnimationMixer = Ge; k.AnimationClip = Fa; k.Uniform = Xd; k.InstancedBufferGeometry = He; k.BufferGeometry = B; k.Geometry = K; k.InterleavedBufferAttribute = Kc; k.InstancedInterleavedBuffer = Ie; k.InterleavedBuffer = Ab; k.InstancedBufferAttribute = Je; k.Face3 = Sb; k.Object3D = D; k.Raycaster = Pf; k.Layers = ee; k.EventDispatcher = ta; k.Clock = Ae; k.QuaternionLinearInterpolant =
      Kd; k.LinearInterpolant = jd; k.DiscreteInterpolant = Hd; k.CubicInterpolant = Gd; k.Interpolant = Da; k.Triangle = ra; k.Math = O; k.Spherical = Rf; k.Cylindrical = Sf; k.Plane = Ua; k.Frustum = yd; k.Sphere = Ta; k.Ray = zb; k.Matrix4 = P; k.Matrix3 = na; k.Box3 = Ga; k.Box2 = Le; k.Line3 = Me; k.Euler = tb; k.Vector4 = W; k.Vector3 = n; k.Vector2 = C; k.Quaternion = ma; k.Color = A; k.SphericalHarmonics3 = Wd; k.ImmediateRenderObject = rd; k.VertexNormalsHelper = sd; k.SpotLightHelper = rc; k.SkeletonHelper = sc; k.PointLightHelper = tc; k.RectAreaLightHelper = uc; k.HemisphereLightHelper =
        vc; k.LightProbeHelper = wc; k.GridHelper = Yd; k.PolarGridHelper = Zd; k.PositionalAudioHelper = xc; k.FaceNormalsHelper = td; k.DirectionalLightHelper = yc; k.CameraHelper = ud; k.BoxHelper = gb; k.Box3Helper = vd; k.PlaneHelper = wd; k.ArrowHelper = hb; k.AxesHelper = xd; k.Shape = pb; k.Path = Pa; k.ShapePath = ve; k.Font = we; k.CurvePath = fb; k.Curve = M; k.ImageUtils = qb; k.ShapeUtils = db; k.WebGLUtils = tf; k.WireframeGeometry = ac; k.ParametricGeometry = Qc; k.ParametricBufferGeometry = bc; k.TetrahedronGeometry = Sc; k.TetrahedronBufferGeometry = cc; k.OctahedronGeometry =
          Tc; k.OctahedronBufferGeometry = Bb; k.IcosahedronGeometry = Uc; k.IcosahedronBufferGeometry = dc; k.DodecahedronGeometry = Vc; k.DodecahedronBufferGeometry = ec; k.PolyhedronGeometry = Rc; k.PolyhedronBufferGeometry = la; k.TubeGeometry = Wc; k.TubeBufferGeometry = Cb; k.TorusKnotGeometry = Xc; k.TorusKnotBufferGeometry = fc; k.TorusGeometry = Yc; k.TorusBufferGeometry = gc; k.TextGeometry = cd; k.TextBufferGeometry = hc; k.SphereGeometry = dd; k.SphereBufferGeometry = ob; k.RingGeometry = ed; k.RingBufferGeometry = ic; k.PlaneGeometry = Gc; k.PlaneBufferGeometry =
            yb; k.LatheGeometry = fd; k.LatheBufferGeometry = jc; k.ShapeGeometry = Fb; k.ShapeBufferGeometry = Gb; k.ExtrudeGeometry = Eb; k.ExtrudeBufferGeometry = Ya; k.EdgesGeometry = kc; k.ConeGeometry = gd; k.ConeBufferGeometry = hd; k.CylinderGeometry = Hb; k.CylinderBufferGeometry = eb; k.CircleGeometry = id; k.CircleBufferGeometry = lc; k.BoxGeometry = Tb; k.CubeGeometry = Tb; k.BoxBufferGeometry = wb; k.ShadowMaterial = Ib; k.SpriteMaterial = nb; k.RawShaderMaterial = mc; k.ShaderMaterial = ea; k.PointsMaterial = Ia; k.MeshPhysicalMaterial = Jb; k.MeshStandardMaterial =
              Za; k.MeshPhongMaterial = Ja; k.MeshToonMaterial = Kb; k.MeshNormalMaterial = Lb; k.MeshLambertMaterial = Mb; k.MeshDepthMaterial = jb; k.MeshDistanceMaterial = kb; k.MeshBasicMaterial = Ca; k.MeshMatcapMaterial = Nb; k.LineDashedMaterial = Ob; k.LineBasicMaterial = U; k.Material = Q; k.Float64BufferAttribute = Fc; k.Float32BufferAttribute = E; k.Uint32BufferAttribute = vb; k.Int32BufferAttribute = Ec; k.Uint16BufferAttribute = ub; k.Int16BufferAttribute = Dc; k.Uint8ClampedBufferAttribute = Cc; k.Uint8BufferAttribute = Bc; k.Int8BufferAttribute = Ac; k.BufferAttribute =
                H; k.ArcCurve = pc; k.CatmullRomCurve3 = oa; k.CubicBezierCurve = La; k.CubicBezierCurve3 = $a; k.EllipseCurve = Ea; k.LineCurve = wa; k.LineCurve3 = Ma; k.QuadraticBezierCurve = Na; k.QuadraticBezierCurve3 = ab; k.SplineCurve = Oa; k.REVISION = "104"; k.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }; k.CullFaceNone = 0; k.CullFaceBack = 1; k.CullFaceFront = 2; k.CullFaceFrontBack = 3; k.FrontFaceDirectionCW = 0; k.FrontFaceDirectionCCW = 1; k.BasicShadowMap = 0; k.PCFShadowMap = 1; k.PCFSoftShadowMap = 2; k.FrontSide = 0; k.BackSide = 1; k.DoubleSide = 2; k.FlatShading = 1; k.SmoothShading =
                  2; k.NoColors = 0; k.FaceColors = 1; k.VertexColors = 2; k.NoBlending = 0; k.NormalBlending = 1; k.AdditiveBlending = 2; k.SubtractiveBlending = 3; k.MultiplyBlending = 4; k.CustomBlending = 5; k.AddEquation = 100; k.SubtractEquation = 101; k.ReverseSubtractEquation = 102; k.MinEquation = 103; k.MaxEquation = 104; k.ZeroFactor = 200; k.OneFactor = 201; k.SrcColorFactor = 202; k.OneMinusSrcColorFactor = 203; k.SrcAlphaFactor = 204; k.OneMinusSrcAlphaFactor = 205; k.DstAlphaFactor = 206; k.OneMinusDstAlphaFactor = 207; k.DstColorFactor = 208; k.OneMinusDstColorFactor =
                    209; k.SrcAlphaSaturateFactor = 210; k.NeverDepth = 0; k.AlwaysDepth = 1; k.LessDepth = 2; k.LessEqualDepth = 3; k.EqualDepth = 4; k.GreaterEqualDepth = 5; k.GreaterDepth = 6; k.NotEqualDepth = 7; k.MultiplyOperation = 0; k.MixOperation = 1; k.AddOperation = 2; k.NoToneMapping = 0; k.LinearToneMapping = 1; k.ReinhardToneMapping = 2; k.Uncharted2ToneMapping = 3; k.CineonToneMapping = 4; k.ACESFilmicToneMapping = 5; k.UVMapping = 300; k.CubeReflectionMapping = 301; k.CubeRefractionMapping = 302; k.EquirectangularReflectionMapping = 303; k.EquirectangularRefractionMapping =
                      304; k.SphericalReflectionMapping = 305; k.CubeUVReflectionMapping = 306; k.CubeUVRefractionMapping = 307; k.RepeatWrapping = 1E3; k.ClampToEdgeWrapping = 1001; k.MirroredRepeatWrapping = 1002; k.NearestFilter = 1003; k.NearestMipMapNearestFilter = 1004; k.NearestMipMapLinearFilter = 1005; k.LinearFilter = 1006; k.LinearMipMapNearestFilter = 1007; k.LinearMipMapLinearFilter = 1008; k.UnsignedByteType = 1009; k.ByteType = 1010; k.ShortType = 1011; k.UnsignedShortType = 1012; k.IntType = 1013; k.UnsignedIntType = 1014; k.FloatType = 1015; k.HalfFloatType =
                        1016; k.UnsignedShort4444Type = 1017; k.UnsignedShort5551Type = 1018; k.UnsignedShort565Type = 1019; k.UnsignedInt248Type = 1020; k.AlphaFormat = 1021; k.RGBFormat = 1022; k.RGBAFormat = 1023; k.LuminanceFormat = 1024; k.LuminanceAlphaFormat = 1025; k.RGBEFormat = 1023; k.DepthFormat = 1026; k.DepthStencilFormat = 1027; k.RedFormat = 1028; k.RGB_S3TC_DXT1_Format = 33776; k.RGBA_S3TC_DXT1_Format = 33777; k.RGBA_S3TC_DXT3_Format = 33778; k.RGBA_S3TC_DXT5_Format = 33779; k.RGB_PVRTC_4BPPV1_Format = 35840; k.RGB_PVRTC_2BPPV1_Format = 35841; k.RGBA_PVRTC_4BPPV1_Format =
                          35842; k.RGBA_PVRTC_2BPPV1_Format = 35843; k.RGB_ETC1_Format = 36196; k.RGBA_ASTC_4x4_Format = 37808; k.RGBA_ASTC_5x4_Format = 37809; k.RGBA_ASTC_5x5_Format = 37810; k.RGBA_ASTC_6x5_Format = 37811; k.RGBA_ASTC_6x6_Format = 37812; k.RGBA_ASTC_8x5_Format = 37813; k.RGBA_ASTC_8x6_Format = 37814; k.RGBA_ASTC_8x8_Format = 37815; k.RGBA_ASTC_10x5_Format = 37816; k.RGBA_ASTC_10x6_Format = 37817; k.RGBA_ASTC_10x8_Format = 37818; k.RGBA_ASTC_10x10_Format = 37819; k.RGBA_ASTC_12x10_Format = 37820; k.RGBA_ASTC_12x12_Format = 37821; k.LoopOnce = 2200; k.LoopRepeat =
                            2201; k.LoopPingPong = 2202; k.InterpolateDiscrete = 2300; k.InterpolateLinear = 2301; k.InterpolateSmooth = 2302; k.ZeroCurvatureEnding = 2400; k.ZeroSlopeEnding = 2401; k.WrapAroundEnding = 2402; k.TrianglesDrawMode = 0; k.TriangleStripDrawMode = 1; k.TriangleFanDrawMode = 2; k.LinearEncoding = 3E3; k.sRGBEncoding = 3001; k.GammaEncoding = 3007; k.RGBEEncoding = 3002; k.LogLuvEncoding = 3003; k.RGBM7Encoding = 3004; k.RGBM16Encoding = 3005; k.RGBDEncoding = 3006; k.BasicDepthPacking = 3200; k.RGBADepthPacking = 3201; k.TangentSpaceNormalMap = 0; k.ObjectSpaceNormalMap =
                              1; k.Face4 = function (a, b, c, d, e, f, g) { console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."); return new Sb(a, b, c, e, f, g); }; k.LineStrip = 0; k.LinePieces = 1; k.MeshFaceMaterial = function (a) { console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."); return a; }; k.MultiMaterial = function (a) { void 0 === a && (a = []); console.warn("THREE.MultiMaterial has been removed. Use an Array instead."); a.isMultiMaterial = !0; a.materials = a; a.clone = function () { return a.slice(); }; return a; };
  k.PointCloud = function (a, b) { console.warn("THREE.PointCloud has been renamed to THREE.Points."); return new Zb(a, b); }; k.Particle = function (a) { console.warn("THREE.Particle has been renamed to THREE.Sprite."); return new Lc(a); }; k.ParticleSystem = function (a, b) { console.warn("THREE.ParticleSystem has been renamed to THREE.Points."); return new Zb(a, b); }; k.PointCloudMaterial = function (a) { console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."); return new Ia(a); }; k.ParticleBasicMaterial = function (a) {
    console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
    return new Ia(a);
  }; k.ParticleSystemMaterial = function (a) { console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."); return new Ia(a); }; k.Vertex = function (a, b, c) { console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."); return new n(a, b, c); }; k.DynamicBufferAttribute = function (a, b) { console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."); return (new H(a, b)).setDynamic(!0); }; k.Int8Attribute = function (a,
    b) { console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."); return new Ac(a, b); }; k.Uint8Attribute = function (a, b) { console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."); return new Bc(a, b); }; k.Uint8ClampedAttribute = function (a, b) { console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."); return new Cc(a, b); }; k.Int16Attribute = function (a, b) {
      console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
      return new Dc(a, b);
    }; k.Uint16Attribute = function (a, b) { console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."); return new ub(a, b); }; k.Int32Attribute = function (a, b) { console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."); return new Ec(a, b); }; k.Uint32Attribute = function (a, b) { console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."); return new vb(a, b); }; k.Float32Attribute =
      function (a, b) { console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."); return new E(a, b); }; k.Float64Attribute = function (a, b) { console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."); return new Fc(a, b); }; k.ClosedSplineCurve3 = Uf; k.SplineCurve3 = Vf; k.Spline = Oe; k.AxisHelper = function (a) { console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."); return new xd(a); }; k.BoundingBoxHelper = function (a, b) {
        console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
        return new gb(a, b);
      }; k.EdgesHelper = function (a, b) { console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."); return new V(new kc(a.geometry), new U({ color: void 0 !== b ? b : 16777215 })); }; k.WireframeHelper = function (a, b) { console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."); return new V(new ac(a.geometry), new U({ color: void 0 !== b ? b : 16777215 })); }; k.XHRLoader = function (a) { console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."); return new Ka(a); };
  k.BinaryTextureLoader = function (a) { console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."); return new pe(a); }; k.GeometryUtils = {
    merge: function (a, b, c) { console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."); if (b.isMesh) { b.matrixAutoUpdate && b.updateMatrix(); var d = b.matrix; b = b.geometry; } a.merge(b, d, c); }, center: function (a) {
      console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
      return a.center();
    }
  }; k.Projector = function () { console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."); this.projectVector = function (a, b) { console.warn("THREE.Projector: .projectVector() is now vector.project()."); a.project(b); }; this.unprojectVector = function (a, b) { console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."); a.unproject(b); }; this.pickingRay = function () { console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera()."); }; }; k.CanvasRenderer =
    function () { console.error("THREE.CanvasRenderer has been removed"); }; k.JSONLoader = function () { console.error("THREE.JSONLoader has been removed."); }; k.SceneUtils = { createMultiMaterialObject: function () { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"); }, detach: function () { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"); }, attach: function () { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js"); } }; k.LensFlare =
      function () { console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js"); }; Object.defineProperty(k, "__esModule", { value: !0 });
});
/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 * @author moroine / https://github.com/moroine
 */

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
// This is very similar to OrbitControls, another set of touch behavior
//
//    Orbit - right mouse, or left mouse + ctrl/metaKey / touch: two-finger rotate
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - left mouse, or arrow keys / touch: one-finger move

THREE.MapControls = function (object, domElement) {

  this.object = object;

  this.domElement = (domElement !== undefined) ? domElement : document;

  // Set to false to disable this control
  this.enabled = true;

  // "target" sets the location of focus, where the object orbits around
  this.target = new THREE.Vector3();

  // How far you can dolly in and out ( PerspectiveCamera only )
  this.minDistance = 0;
  this.maxDistance = Infinity;

  // How far you can zoom in and out ( OrthographicCamera only )
  this.minZoom = 0;
  this.maxZoom = Infinity;

  // How far you can orbit vertically, upper and lower limits.
  // Range is 0 to Math.PI radians.
  this.minPolarAngle = 0; // radians
  this.maxPolarAngle = Math.PI; // radians

  // How far you can orbit horizontally, upper and lower limits.
  // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
  this.minAzimuthAngle = - Infinity; // radians
  this.maxAzimuthAngle = Infinity; // radians

  // Set to true to enable damping (inertia)
  // If damping is enabled, you must call controls.update() in your animation loop
  this.enableDamping = false;
  this.dampingFactor = 0.25;

  // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
  // Set to false to disable zooming
  this.enableZoom = true;
  this.zoomSpeed = 1.0;

  // Set to false to disable rotating
  this.enableRotate = true;
  this.rotateSpeed = 1.0;

  // Set to false to disable panning
  this.enablePan = true;
  this.panSpeed = 1.0;
  this.screenSpacePanning = false; // if true, pan in screen-space
  this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

  // Set to true to automatically rotate around the target
  // If auto-rotate is enabled, you must call controls.update() in your animation loop
  this.autoRotate = false;
  this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

  // Set to false to disable use of the keys
  this.enableKeys = true;

  // The four arrow keys
  this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

  // Mouse buttons
  this.mouseButtons = { LEFT: THREE.MOUSE.LEFT, MIDDLE: THREE.MOUSE.MIDDLE, RIGHT: THREE.MOUSE.RIGHT };

  // for reset
  this.target0 = this.target.clone();
  this.position0 = this.object.position.clone();
  this.zoom0 = this.object.zoom;

  //
  // public methods
  //

  this.getPolarAngle = function () {

    return spherical.phi;

  };

  this.getAzimuthalAngle = function () {

    return spherical.theta;

  };

  this.saveState = function () {

    scope.target0.copy(scope.target);
    scope.position0.copy(scope.object.position);
    scope.zoom0 = scope.object.zoom;

  };

  this.reset = function () {

    scope.target.copy(scope.target0);
    scope.object.position.copy(scope.position0);
    scope.object.zoom = scope.zoom0;

    scope.object.updateProjectionMatrix();
    scope.dispatchEvent(changeEvent);

    scope.update();

    state = STATE.NONE;

  };

  // this method is exposed, but perhaps it would be better if we can make it private...
  this.update = function () {

    var offset = new THREE.Vector3();

    // so camera.up is the orbit axis
    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
    var quatInverse = quat.clone().inverse();

    var lastPosition = new THREE.Vector3();
    var lastQuaternion = new THREE.Quaternion();

    return function update() {

      var position = scope.object.position;

      offset.copy(position).sub(scope.target);

      // rotate offset to "y-axis-is-up" space
      offset.applyQuaternion(quat);

      // angle from z-axis around y-axis
      spherical.setFromVector3(offset);

      if (scope.autoRotate && state === STATE.NONE) {

        rotateLeft(getAutoRotationAngle());

      }

      spherical.theta += sphericalDelta.theta;
      spherical.phi += sphericalDelta.phi;

      // restrict theta to be between desired limits
      spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));

      // restrict phi to be between desired limits
      spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));

      spherical.makeSafe();


      spherical.radius *= scale;

      // restrict radius to be between desired limits
      spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));

      // move target to panned location
      scope.target.add(panOffset);

      offset.setFromSpherical(spherical);

      // rotate offset back to "camera-up-vector-is-up" space
      offset.applyQuaternion(quatInverse);

      position.copy(scope.target).add(offset);

      scope.object.lookAt(scope.target);

      if (scope.enableDamping === true) {

        sphericalDelta.theta *= (1 - scope.dampingFactor);
        sphericalDelta.phi *= (1 - scope.dampingFactor);

        panOffset.multiplyScalar(1 - scope.dampingFactor);

      } else {

        sphericalDelta.set(0, 0, 0);

        panOffset.set(0, 0, 0);

      }

      scale = 1;

      // update condition is:
      // min(camera displacement, camera rotation in radians)^2 > EPS
      // using small-angle approximation cos(x/2) = 1 - x^2 / 8

      if (zoomChanged ||
        lastPosition.distanceToSquared(scope.object.position) > EPS ||
        8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {

        scope.dispatchEvent(changeEvent);

        lastPosition.copy(scope.object.position);
        lastQuaternion.copy(scope.object.quaternion);
        zoomChanged = false;

        return true;

      }

      return false;

    };

  }();

  this.dispose = function () {

    scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
    scope.domElement.removeEventListener('mousedown', onMouseDown, false);
    scope.domElement.removeEventListener('wheel', onMouseWheel, false);

    scope.domElement.removeEventListener('touchstart', onTouchStart, false);
    scope.domElement.removeEventListener('touchend', onTouchEnd, false);
    scope.domElement.removeEventListener('touchmove', onTouchMove, false);

    document.removeEventListener('mousemove', onMouseMove, false);
    document.removeEventListener('mouseup', onMouseUp, false);

    window.removeEventListener('keydown', onKeyDown, false);

    //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

  };

  //
  // internals
  //

  var scope = this;

  var changeEvent = { type: 'change' };
  var startEvent = { type: 'start' };
  var endEvent = { type: 'end' };

  var STATE = {
    NONE: 0,
    ROTATE_UP: 1,
    ROTATE_LEFT: 2,
    ROTATE: 3, // ROTATE_UP | ROTATE_LEFT
    DOLLY: 4,
    DOLLY_ROTATE: 7, // ROTATE | DOLLY
    PAN: 8,
    DOLLY_PAN: 12, // DOLLY | PAN
  };

  var state = STATE.NONE;

  var EPS = 0.000001;

  // current position in spherical coordinates
  var spherical = new THREE.Spherical();
  var sphericalDelta = new THREE.Spherical();

  var scale = 1;
  var panOffset = new THREE.Vector3();
  var zoomChanged = false;

  var rotateStart = new THREE.Vector2();
  var rotateStart2 = new THREE.Vector2();
  var rotateEnd = new THREE.Vector2();
  var rotateEnd2 = new THREE.Vector2();
  var rotateDelta = new THREE.Vector2();
  var rotateDelta2 = new THREE.Vector2();
  var rotateDeltaStartFingers = new THREE.Vector2();
  var rotateDeltaEndFingers = new THREE.Vector2();

  var panStart = new THREE.Vector2();
  var panEnd = new THREE.Vector2();
  var panDelta = new THREE.Vector2();

  var dollyStart = new THREE.Vector2();
  var dollyEnd = new THREE.Vector2();
  var dollyDelta = new THREE.Vector2();

  function getAutoRotationAngle() {

    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

  }

  function getZoomScale() {

    return Math.pow(0.95, scope.zoomSpeed);

  }

  function rotateLeft(angle) {

    sphericalDelta.theta -= angle;

  }

  function rotateUp(angle) {

    sphericalDelta.phi -= angle;

  }

  var panLeft = function () {

    var v = new THREE.Vector3();

    return function panLeft(distance, objectMatrix) {

      v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
      v.multiplyScalar(- distance);

      panOffset.add(v);

    };

  }();

  var panUp = function () {

    var v = new THREE.Vector3();

    return function panUp(distance, objectMatrix) {

      if (scope.screenSpacePanning === true) {

        v.setFromMatrixColumn(objectMatrix, 1);

      } else {

        v.setFromMatrixColumn(objectMatrix, 0);
        v.crossVectors(scope.object.up, v);

      }

      v.multiplyScalar(distance);

      panOffset.add(v);

    };

  }();

  // deltaX and deltaY are in pixels; right and down are positive
  var pan = function () {

    var offset = new THREE.Vector3();

    return function pan(deltaX, deltaY) {

      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

      if (scope.object.isPerspectiveCamera) {

        // perspective
        var position = scope.object.position;
        offset.copy(position).sub(scope.target);
        var targetDistance = offset.length();

        // half of the fov is center to top of screen
        targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);

        // we use only clientHeight here so aspect ratio does not distort speed
        panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
        panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);

      } else if (scope.object.isOrthographicCamera) {

        // orthographic
        panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
        panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);

      } else {

        // camera neither orthographic nor perspective
        console.warn('WARNING: MapControls.js encountered an unknown camera type - pan disabled.');
        scope.enablePan = false;

      }

    };

  }();

  function dollyIn(dollyScale) {

    if (scope.object.isPerspectiveCamera) {

      scale /= dollyScale;

    } else if (scope.object.isOrthographicCamera) {

      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;

    } else {

      console.warn('WARNING: MapControls.js encountered an unknown camera type - dolly/zoom disabled.');
      scope.enableZoom = false;

    }

  }

  function dollyOut(dollyScale) {

    if (scope.object.isPerspectiveCamera) {

      scale *= dollyScale;

    } else if (scope.object.isOrthographicCamera) {

      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;

    } else {

      console.warn('WARNING: MapControls.js encountered an unknown camera type - dolly/zoom disabled.');
      scope.enableZoom = false;

    }

  }

  //
  // event callbacks - update the object state
  //

  function handleMouseDownRotate(event) {

    //console.log( 'handleMouseDownRotate' );

    rotateStart.set(event.clientX, event.clientY);

  }

  function handleMouseDownDolly(event) {

    //console.log( 'handleMouseDownDolly' );

    dollyStart.set(event.clientX, event.clientY);

  }

  function handleMouseDownPan(event) {

    //console.log( 'handleMouseDownPan' );

    panStart.set(event.clientX, event.clientY);

  }

  function handleMouseMoveRotate(event) {

    //console.log( 'handleMouseMoveRotate' );

    rotateEnd.set(event.clientX, event.clientY);

    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);

    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);

    rotateStart.copy(rotateEnd);

    scope.update();

  }

  function handleMouseMoveDolly(event) {

    //console.log( 'handleMouseMoveDolly' );

    dollyEnd.set(event.clientX, event.clientY);

    dollyDelta.subVectors(dollyEnd, dollyStart);

    if (dollyDelta.y > 0) {

      dollyIn(getZoomScale());

    } else if (dollyDelta.y < 0) {

      dollyOut(getZoomScale());

    }

    dollyStart.copy(dollyEnd);

    scope.update();

  }

  function handleMouseMovePan(event) {

    //console.log( 'handleMouseMovePan' );

    panEnd.set(event.clientX, event.clientY);

    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);

    pan(panDelta.x, panDelta.y);

    panStart.copy(panEnd);

    scope.update();

  }

  function handleMouseUp(event) {

    // console.log( 'handleMouseUp' );

  }

  function handleMouseWheel(event) {

    // console.log( 'handleMouseWheel' );

    if (event.deltaY < 0) {

      dollyOut(getZoomScale());

    } else if (event.deltaY > 0) {

      dollyIn(getZoomScale());

    }

    scope.update();

  }

  function handleKeyDown(event) {

    //console.log( 'handleKeyDown' );

    switch (event.keyCode) {

      case scope.keys.UP:
        pan(0, scope.keyPanSpeed);
        scope.update();
        break;

      case scope.keys.BOTTOM:
        pan(0, - scope.keyPanSpeed);
        scope.update();
        break;

      case scope.keys.LEFT:
        pan(scope.keyPanSpeed, 0);
        scope.update();
        break;

      case scope.keys.RIGHT:
        pan(- scope.keyPanSpeed, 0);
        scope.update();
        break;

    }

  }

  function handleTouchStartRotate(event) {

    // console.log( 'handleTouchStartRotate' );

    // First finger
    rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);

    // Second finger
    rotateStart2.set(event.touches[1].pageX, event.touches[1].pageY);

  }

  function handleTouchStartDolly(event) {

    if (scope.enableZoom) {

      // console.log( 'handleTouchStartDolly' );

      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;

      var distance = Math.sqrt(dx * dx + dy * dy);

      dollyStart.set(0, distance);

    }

  }

  function handleTouchStartPan(event) {

    if (scope.enablePan) {

      // console.log( 'handleTouchStartPan' );

      panStart.set(event.touches[0].pageX, event.touches[0].pageY);

    }

  }

  function handleTouchMoveRotate(event) {

    if (scope.enableRotate === false) return;
    if ((state & STATE.ROTATE) === 0) return;

    // First finger
    rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);

    // Second finger
    rotateEnd2.set(event.touches[1].pageX, event.touches[1].pageY);

    rotateDelta.subVectors(rotateEnd, rotateStart);
    rotateDelta2.subVectors(rotateEnd2, rotateStart2);
    rotateDeltaStartFingers.subVectors(rotateStart2, rotateStart);
    rotateDeltaEndFingers.subVectors(rotateEnd2, rotateEnd);

    if (isRotateUp()) {

      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

      // rotating up and down along whole screen attempts to go 360, but limited to 180
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);

      // Start rotateUp ==> disable all movement to prevent flickering
      state = STATE.ROTATE_UP;

    } else if ((state & STATE.ROTATE_LEFT) !== 0) {

      rotateLeft((rotateDeltaStartFingers.angle() - rotateDeltaEndFingers.angle()) * scope.rotateSpeed);

    }

    rotateStart.copy(rotateEnd);
    rotateStart2.copy(rotateEnd2);

  }

  function isRotateUp() {

    // At start, does the two fingers are aligned horizontally
    if (!isHorizontal(rotateDeltaStartFingers)) {

      return false;

    }

    // At end, does the two fingers are aligned horizontally
    if (!isHorizontal(rotateDeltaEndFingers)) {

      return false;

    }

    // does the first finger moved vertically between start and end
    if (!isVertical(rotateDelta)) {

      return false;

    }

    // does the second finger moved vertically between start and end
    if (!isVertical(rotateDelta2)) {

      return false;

    }

    // Does the two finger moved in the same direction (prevent moving one finger vertically up while the other goes down)
    return rotateDelta.dot(rotateDelta2) > 0;

  }

  var isHorizontal = function () {

    var precision = Math.sin(Math.PI / 6);

    return function isHorizontal(vector) {

      return Math.abs(Math.sin(vector.angle())) < precision;

    };

  }();

  var isVertical = function () {

    var precision = Math.cos(Math.PI / 2 - Math.PI / 6);

    return function isVertical(vector) {

      return Math.abs(Math.cos(vector.angle())) < precision;

    };

  }();

  function handleTouchMoveDolly(event) {

    if (scope.enableZoom === false) return;
    if ((state & STATE.DOLLY) === 0) return;

    // console.log( 'handleTouchMoveDolly' );

    var dx = event.touches[0].pageX - event.touches[1].pageX;
    var dy = event.touches[0].pageY - event.touches[1].pageY;

    var distance = Math.sqrt(dx * dx + dy * dy);

    dollyEnd.set(0, distance);

    dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));

    dollyIn(dollyDelta.y);

    dollyStart.copy(dollyEnd);

  }

  function handleTouchMovePan(event) {

    if (scope.enablePan === false) return;
    if ((state & STATE.PAN) === 0) return;

    // console.log( 'handleTouchMovePan' );

    panEnd.set(event.touches[0].pageX, event.touches[0].pageY);

    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);

    pan(panDelta.x, panDelta.y);

    panStart.copy(panEnd);

  }

  function handleTouchEnd(event) {

    //console.log( 'handleTouchEnd' );

  }

  //
  // event handlers - FSM: listen for events and reset state
  //

  function onMouseDown(event) {

    if (scope.enabled === false) return;

    event.preventDefault();

    switch (event.button) {

      case scope.mouseButtons.LEFT:

        if (event.ctrlKey || event.metaKey) {

          if (scope.enableRotate === false) return;

          handleMouseDownRotate(event);

          state = STATE.ROTATE;

        } else {

          if (scope.enablePan === false) return;

          handleMouseDownPan(event);

          state = STATE.PAN;

        }

        break;

      case scope.mouseButtons.MIDDLE:

        if (scope.enableZoom === false) return;

        handleMouseDownDolly(event);

        state = STATE.DOLLY;

        break;

      case scope.mouseButtons.RIGHT:

        if (scope.enableRotate === false) return;

        handleMouseDownRotate(event);

        state = STATE.ROTATE;

        break;

    }

    if (state !== STATE.NONE) {

      document.addEventListener('mousemove', onMouseMove, false);
      document.addEventListener('mouseup', onMouseUp, false);

      scope.dispatchEvent(startEvent);

    }

  }

  function onMouseMove(event) {

    if (scope.enabled === false) return;

    event.preventDefault();

    switch (state) {

      case STATE.ROTATE:

        if (scope.enableRotate === false) return;

        handleMouseMoveRotate(event);

        break;

      case STATE.DOLLY:

        if (scope.enableZoom === false) return;

        handleMouseMoveDolly(event);

        break;

      case STATE.PAN:

        if (scope.enablePan === false) return;

        handleMouseMovePan(event);

        break;

    }

  }

  function onMouseUp(event) {

    if (scope.enabled === false) return;

    handleMouseUp(event);

    document.removeEventListener('mousemove', onMouseMove, false);
    document.removeEventListener('mouseup', onMouseUp, false);

    scope.dispatchEvent(endEvent);

    state = STATE.NONE;

  }

  function onMouseWheel(event) {

    if (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE)) return;

    event.preventDefault();
    event.stopPropagation();

    scope.dispatchEvent(startEvent);

    handleMouseWheel(event);

    scope.dispatchEvent(endEvent);

  }

  function onKeyDown(event) {

    if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;

    handleKeyDown(event);

  }

  function onTouchStart(event) {

    if (scope.enabled === false) return;

    event.preventDefault();

    switch (event.touches.length) {

      case 1:	// one-fingered touch: pan

        if (scope.enablePan === false) return;

        handleTouchStartPan(event);

        state = STATE.PAN;

        break;

      case 2:	// two-fingered touch: rotate-dolly

        if (scope.enableZoom === false && scope.enableRotate === false) return;

        handleTouchStartRotate(event);
        handleTouchStartDolly(event);

        state = STATE.DOLLY_ROTATE;

        break;

      default:

        state = STATE.NONE;

    }

    if (state !== STATE.NONE) {

      scope.dispatchEvent(startEvent);

    }

  }

  function onTouchMove(event) {

    if (scope.enabled === false) return;

    event.preventDefault();
    event.stopPropagation();

    switch (event.touches.length) {

      case 1: // one-fingered touch: pan

        if (scope.enablePan === false) return;
        if (state !== STATE.PAN) return; // is this needed?

        handleTouchMovePan(event);

        scope.update();

        break;

      case 2: // two-fingered touch: rotate-dolly

        if (scope.enableZoom === false && scope.enableRotate === false) return;
        if ((state & STATE.DOLLY_ROTATE) === 0) return; // is this needed?

        handleTouchMoveRotate(event);
        handleTouchMoveDolly(event);

        scope.update();

        break;

      default:

        state = STATE.NONE;

    }

  }

  function onTouchEnd(event) {

    if (scope.enabled === false) return;

    handleTouchEnd(event);

    scope.dispatchEvent(endEvent);

    state = STATE.NONE;

  }

  function onContextMenu(event) {

    if (scope.enabled === false) return;

    event.preventDefault();

  }

  //

  scope.domElement.addEventListener('contextmenu', onContextMenu, false);

  scope.domElement.addEventListener('mousedown', onMouseDown, false);
  scope.domElement.addEventListener('wheel', onMouseWheel, false);

  scope.domElement.addEventListener('touchstart', onTouchStart, false);
  scope.domElement.addEventListener('touchend', onTouchEnd, false);
  scope.domElement.addEventListener('touchmove', onTouchMove, false);

  window.addEventListener('keydown', onKeyDown, false);

  // force an update at start

  this.update();

};

THREE.MapControls.prototype = Object.create(THREE.EventDispatcher.prototype);
THREE.MapControls.prototype.constructor = THREE.MapControls;

Object.defineProperties(THREE.MapControls.prototype, {

  center: {

    get: function () {

      console.warn('THREE.MapControls: .center has been renamed to .target');
      return this.target;

    }

  },

  // backward compatibility

  noZoom: {

    get: function () {

      console.warn('THREE.MapControls: .noZoom has been deprecated. Use .enableZoom instead.');
      return !this.enableZoom;

    },

    set: function (value) {

      console.warn('THREE.MapControls: .noZoom has been deprecated. Use .enableZoom instead.');
      this.enableZoom = !value;

    }

  },

  noRotate: {

    get: function () {

      console.warn('THREE.MapControls: .noRotate has been deprecated. Use .enableRotate instead.');
      return !this.enableRotate;

    },

    set: function (value) {

      console.warn('THREE.MapControls: .noRotate has been deprecated. Use .enableRotate instead.');
      this.enableRotate = !value;

    }

  },

  noPan: {

    get: function () {

      console.warn('THREE.MapControls: .noPan has been deprecated. Use .enablePan instead.');
      return !this.enablePan;

    },

    set: function (value) {

      console.warn('THREE.MapControls: .noPan has been deprecated. Use .enablePan instead.');
      this.enablePan = !value;

    }

  },

  noKeys: {

    get: function () {

      console.warn('THREE.MapControls: .noKeys has been deprecated. Use .enableKeys instead.');
      return !this.enableKeys;

    },

    set: function (value) {

      console.warn('THREE.MapControls: .noKeys has been deprecated. Use .enableKeys instead.');
      this.enableKeys = !value;

    }

  },

  staticMoving: {

    get: function () {

      console.warn('THREE.MapControls: .staticMoving has been deprecated. Use .enableDamping instead.');
      return !this.enableDamping;

    },

    set: function (value) {

      console.warn('THREE.MapControls: .staticMoving has been deprecated. Use .enableDamping instead.');
      this.enableDamping = !value;

    }

  },

  dynamicDampingFactor: {

    get: function () {

      console.warn('THREE.MapControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
      return this.dampingFactor;

    },

    set: function (value) {

      console.warn('THREE.MapControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
      this.dampingFactor = value;

    }

  }

});
// javascript-astar 0.4.1
// http://github.com/bgrins/javascript-astar
// Freely distributable under the MIT License.
// Implements the astar search algorithm in javascript using a Binary Heap.
// Includes Binary Heap (with modifications) from Marijn Haverbeke.
// http://eloquentjavascript.net/appendix2.html
(function (definition) {
  /* global module, define */
  if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = definition();
  } else if (typeof define === 'function' && define.amd) {
    define([], definition);
  } else {
    var exports = definition();
    window.astar = exports.astar;
    window.Graph = exports.Graph;
  }
})(function () {

  function pathTo(node) {
    var curr = node;
    var path = [];
    while (curr.parent) {
      path.unshift(curr);
      curr = curr.parent;
    }
    return path;
  }

  function getHeap() {
    return new BinaryHeap(function (node) {
      return node.f;
    });
  }

  var astar = {
    /**
    * Perform an A* Search on a graph given a start and end node.
    * @param {Graph} graph
    * @param {GridNode} start
    * @param {GridNode} end
    * @param {Object} [options]
    * @param {bool} [options.closest] Specifies whether to return the
               path to the closest node if the target is unreachable.
    * @param {Function} [options.heuristic] Heuristic function (see
    *          astar.heuristics).
    */
    search: function (graph, start, end, options) {
      graph.cleanDirty();
      options = options || {};
      var heuristic = options.heuristic || astar.heuristics.manhattan;
      var closest = options.closest || false;

      var openHeap = getHeap();
      var closestNode = start; // set the start node to be the closest if required

      start.h = heuristic(start, end);
      graph.markDirty(start);

      openHeap.push(start);

      while (openHeap.size() > 0) {

        // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
        var currentNode = openHeap.pop();

        // End case -- result has been found, return the traced path.
        if (currentNode === end) {
          return pathTo(currentNode);
        }

        // Normal case -- move currentNode from open to closed, process each of its neighbors.
        currentNode.closed = true;

        // Find all neighbors for the current node.
        var neighbors = graph.neighbors(currentNode);

        for (var i = 0, il = neighbors.length; i < il; ++i) {
          var neighbor = neighbors[i];

          if (neighbor.closed || neighbor.isWall()) {
            // Not a valid node to process, skip to next neighbor.
            continue;
          }

          // The g score is the shortest distance from start to current node.
          // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.
          var gScore = currentNode.g + neighbor.getCost(currentNode);
          var beenVisited = neighbor.visited;

          if (!beenVisited || gScore < neighbor.g) {

            // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
            neighbor.visited = true;
            neighbor.parent = currentNode;
            neighbor.h = neighbor.h || heuristic(neighbor, end);
            neighbor.g = gScore;
            neighbor.f = neighbor.g + neighbor.h;
            graph.markDirty(neighbor);
            if (closest) {
              // If the neighbour is closer than the current closestNode or if it's equally close but has
              // a cheaper path than the current closest node then it becomes the closest node
              if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {
                closestNode = neighbor;
              }
            }

            if (!beenVisited) {
              // Pushing to heap will put it in proper place based on the 'f' value.
              openHeap.push(neighbor);
            } else {
              // Already seen the node, but since it has been rescored we need to reorder it in the heap
              openHeap.rescoreElement(neighbor);
            }
          }
        }
      }

      if (closest) {
        return pathTo(closestNode);
      }

      // No result was found - empty array signifies failure to find path.
      return [];
    },
    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
    heuristics: {
      manhattan: function (pos0, pos1) {
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return d1 + d2;
      },
      diagonal: function (pos0, pos1) {
        var D = 1;
        var D2 = Math.sqrt(2);
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));
      }
    },
    cleanNode: function (node) {
      node.f = 0;
      node.g = 0;
      node.h = 0;
      node.visited = false;
      node.closed = false;
      node.parent = null;
    }
  };

  /**
   * A graph memory structure
   * @param {Array} gridIn 2D array of input weights
   * @param {Object} [options]
   * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed
   */
  function Graph(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];
    for (var x = 0; x < gridIn.length; x++) {
      this.grid[x] = [];

      for (var y = 0, row = gridIn[x]; y < row.length; y++) {
        var node = new GridNode(x, y, row[y]);
        this.grid[x][y] = node;
        this.nodes.push(node);
      }
    }
    this.init();
  }

  Graph.prototype.init = function () {
    this.dirtyNodes = [];
    for (var i = 0; i < this.nodes.length; i++) {
      astar.cleanNode(this.nodes[i]);
    }
  };

  Graph.prototype.cleanDirty = function () {
    for (var i = 0; i < this.dirtyNodes.length; i++) {
      astar.cleanNode(this.dirtyNodes[i]);
    }
    this.dirtyNodes = [];
  };

  Graph.prototype.markDirty = function (node) {
    this.dirtyNodes.push(node);
  };

  Graph.prototype.neighbors = function (node) {
    var ret = [];
    var x = node.x;
    var y = node.y;
    var grid = this.grid;

    // West
    if (grid[x - 1] && grid[x - 1][y]) {
      ret.push(grid[x - 1][y]);
    }

    // East
    if (grid[x + 1] && grid[x + 1][y]) {
      ret.push(grid[x + 1][y]);
    }

    // South
    if (grid[x] && grid[x][y - 1]) {
      ret.push(grid[x][y - 1]);
    }

    // North
    if (grid[x] && grid[x][y + 1]) {
      ret.push(grid[x][y + 1]);
    }

    if (this.diagonal) {
      // Southwest
      if (grid[x - 1] && grid[x - 1][y - 1]) {
        ret.push(grid[x - 1][y - 1]);
      }

      // Southeast
      if (grid[x + 1] && grid[x + 1][y - 1]) {
        ret.push(grid[x + 1][y - 1]);
      }

      // Northwest
      if (grid[x - 1] && grid[x - 1][y + 1]) {
        ret.push(grid[x - 1][y + 1]);
      }

      // Northeast
      if (grid[x + 1] && grid[x + 1][y + 1]) {
        ret.push(grid[x + 1][y + 1]);
      }
    }

    return ret;
  };

  Graph.prototype.toString = function () {
    var graphString = [];
    var nodes = this.grid;
    for (var x = 0; x < nodes.length; x++) {
      var rowDebug = [];
      var row = nodes[x];
      for (var y = 0; y < row.length; y++) {
        rowDebug.push(row[y].weight);
      }
      graphString.push(rowDebug.join(" "));
    }
    return graphString.join("\n");
  };

  function GridNode(x, y, weight) {
    this.x = x;
    this.y = y;
    this.weight = weight;
  }

  GridNode.prototype.toString = function () {
    return "[" + this.x + " " + this.y + "]";
  };

  GridNode.prototype.getCost = function (fromNeighbor) {
    // Take diagonal weight into consideration.
    if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {
      return this.weight * 1.41421;
    }
    return this.weight;
  };

  GridNode.prototype.isWall = function () {
    return this.weight === 0;
  };

  function BinaryHeap(scoreFunction) {
    this.content = [];
    this.scoreFunction = scoreFunction;
  }

  BinaryHeap.prototype = {
    push: function (element) {
      // Add the new element to the end of the array.
      this.content.push(element);

      // Allow it to sink down.
      this.sinkDown(this.content.length - 1);
    },
    pop: function () {
      // Store the first element so we can return it later.
      var result = this.content[0];
      // Get the element at the end of the array.
      var end = this.content.pop();
      // If there are any elements left, put the end element at the
      // start, and let it bubble up.
      if (this.content.length > 0) {
        this.content[0] = end;
        this.bubbleUp(0);
      }
      return result;
    },
    remove: function (node) {
      var i = this.content.indexOf(node);

      // When it is found, the process seen in 'pop' is repeated
      // to fill up the hole.
      var end = this.content.pop();

      if (i !== this.content.length - 1) {
        this.content[i] = end;

        if (this.scoreFunction(end) < this.scoreFunction(node)) {
          this.sinkDown(i);
        } else {
          this.bubbleUp(i);
        }
      }
    },
    size: function () {
      return this.content.length;
    },
    rescoreElement: function (node) {
      this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function (n) {
      // Fetch the element that has to be sunk.
      var element = this.content[n];

      // When at 0, an element can not sink any further.
      while (n > 0) {

        // Compute the parent element's index, and fetch it.
        var parentN = ((n + 1) >> 1) - 1;
        var parent = this.content[parentN];
        // Swap the elements if the parent is greater.
        if (this.scoreFunction(element) < this.scoreFunction(parent)) {
          this.content[parentN] = element;
          this.content[n] = parent;
          // Update 'n' to continue at the new position.
          n = parentN;
        }
        // Found a parent that is less, no need to sink any further.
        else {
          break;
        }
      }
    },
    bubbleUp: function (n) {
      // Look up the target element and its score.
      var length = this.content.length;
      var element = this.content[n];
      var elemScore = this.scoreFunction(element);

      while (true) {
        // Compute the indices of the child elements.
        var child2N = (n + 1) << 1;
        var child1N = child2N - 1;
        // This is used to store the new position of the element, if any.
        var swap = null;
        var child1Score;
        // If the first child exists (is inside the array)...
        if (child1N < length) {
          // Look it up and compute its score.
          var child1 = this.content[child1N];
          child1Score = this.scoreFunction(child1);

          // If the score is less than our element's, we need to swap.
          if (child1Score < elemScore) {
            swap = child1N;
          }
        }

        // Do the same checks for the other child.
        if (child2N < length) {
          var child2 = this.content[child2N];
          var child2Score = this.scoreFunction(child2);
          if (child2Score < (swap === null ? elemScore : child1Score)) {
            swap = child2N;
          }
        }

        // If the element needs to be moved, swap it, and continue.
        if (swap !== null) {
          this.content[n] = this.content[swap];
          this.content[swap] = element;
          n = swap;
        }
        // Otherwise, we are done.
        else {
          break;
        }
      }
    }
  };

  return {
    astar: astar,
    Graph: Graph
  };

}); !function (e) { if ("object" == typeof exports && "undefined" != typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else { ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).pako = e(); } }(function () { return function r(o, s, f) { function l(t, e) { if (!s[t]) { if (!o[t]) { var i = "function" == typeof require && require; if (!e && i) return i(t, !0); if (d) return d(t, !0); var n = new Error("Cannot find module '" + t + "'"); throw n.code = "MODULE_NOT_FOUND", n; } var a = s[t] = { exports: {} }; o[t][0].call(a.exports, function (e) { return l(o[t][1][e] || e); }, a, a.exports, r, o, s, f); } return s[t].exports; } for (var d = "function" == typeof require && require, e = 0; e < f.length; e++)l(f[e]); return l; }({ 1: [function (e, t, i) { "use strict"; var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array; i.assign = function (e) { for (var t, i, n = Array.prototype.slice.call(arguments, 1); n.length;) { var a = n.shift(); if (a) { if ("object" != typeof a) throw new TypeError(a + "must be non-object"); for (var r in a) t = a, i = r, Object.prototype.hasOwnProperty.call(t, i) && (e[r] = a[r]); } } return e; }, i.shrinkBuf = function (e, t) { return e.length === t ? e : e.subarray ? e.subarray(0, t) : (e.length = t, e); }; var a = { arraySet: function (e, t, i, n, a) { if (t.subarray && e.subarray) e.set(t.subarray(i, i + n), a); else for (var r = 0; r < n; r++)e[a + r] = t[i + r]; }, flattenChunks: function (e) { var t, i, n, a, r, o; for (t = n = 0, i = e.length; t < i; t++)n += e[t].length; for (o = new Uint8Array(n), t = a = 0, i = e.length; t < i; t++)r = e[t], o.set(r, a), a += r.length; return o; } }, r = { arraySet: function (e, t, i, n, a) { for (var r = 0; r < n; r++)e[a + r] = t[i + r]; }, flattenChunks: function (e) { return [].concat.apply([], e); } }; i.setTyped = function (e) { e ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, a)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, r)); }, i.setTyped(n); }, {}], 2: [function (e, t, i) { "use strict"; var f = e("./common"), a = !0, r = !0; try { String.fromCharCode.apply(null, [0]); } catch (e) { a = !1; } try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (e) { r = !1; } for (var l = new f.Buf8(256), n = 0; n < 256; n++)l[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1; function d(e, t) { if (t < 65534 && (e.subarray && r || !e.subarray && a)) return String.fromCharCode.apply(null, f.shrinkBuf(e, t)); for (var i = "", n = 0; n < t; n++)i += String.fromCharCode(e[n]); return i; } l[254] = l[254] = 1, i.string2buf = function (e) { var t, i, n, a, r, o = e.length, s = 0; for (a = 0; a < o; a++)55296 == (64512 & (i = e.charCodeAt(a))) && a + 1 < o && 56320 == (64512 & (n = e.charCodeAt(a + 1))) && (i = 65536 + (i - 55296 << 10) + (n - 56320), a++), s += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4; for (t = new f.Buf8(s), a = r = 0; r < s; a++)55296 == (64512 & (i = e.charCodeAt(a))) && a + 1 < o && 56320 == (64512 & (n = e.charCodeAt(a + 1))) && (i = 65536 + (i - 55296 << 10) + (n - 56320), a++), i < 128 ? t[r++] = i : (i < 2048 ? t[r++] = 192 | i >>> 6 : (i < 65536 ? t[r++] = 224 | i >>> 12 : (t[r++] = 240 | i >>> 18, t[r++] = 128 | i >>> 12 & 63), t[r++] = 128 | i >>> 6 & 63), t[r++] = 128 | 63 & i); return t; }, i.buf2binstring = function (e) { return d(e, e.length); }, i.binstring2buf = function (e) { for (var t = new f.Buf8(e.length), i = 0, n = t.length; i < n; i++)t[i] = e.charCodeAt(i); return t; }, i.buf2string = function (e, t) { var i, n, a, r, o = t || e.length, s = new Array(2 * o); for (i = n = 0; i < o;)if ((a = e[i++]) < 128) s[n++] = a; else if (4 < (r = l[a])) s[n++] = 65533, i += r - 1; else { for (a &= 2 === r ? 31 : 3 === r ? 15 : 7; 1 < r && i < o;)a = a << 6 | 63 & e[i++], r--; 1 < r ? s[n++] = 65533 : a < 65536 ? s[n++] = a : (a -= 65536, s[n++] = 55296 | a >> 10 & 1023, s[n++] = 56320 | 1023 & a); } return d(s, n); }, i.utf8border = function (e, t) { var i; for ((t = t || e.length) > e.length && (t = e.length), i = t - 1; 0 <= i && 128 == (192 & e[i]);)i--; return i < 0 ? t : 0 === i ? t : i + l[e[i]] > t ? i : t; }; }, { "./common": 1 }], 3: [function (e, t, i) { "use strict"; t.exports = function (e, t, i, n) { for (var a = 65535 & e | 0, r = e >>> 16 & 65535 | 0, o = 0; 0 !== i;) { for (i -= o = 2e3 < i ? 2e3 : i; r = r + (a = a + t[n++] | 0) | 0, --o;); a %= 65521, r %= 65521; } return a | r << 16 | 0; }; }, {}], 4: [function (e, t, i) { "use strict"; t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 }; }, {}], 5: [function (e, t, i) { "use strict"; var s = function () { for (var e, t = [], i = 0; i < 256; i++) { e = i; for (var n = 0; n < 8; n++)e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1; t[i] = e; } return t; }(); t.exports = function (e, t, i, n) { var a = s, r = n + i; e ^= -1; for (var o = n; o < r; o++)e = e >>> 8 ^ a[255 & (e ^ t[o])]; return -1 ^ e; }; }, {}], 6: [function (e, t, i) { "use strict"; t.exports = function () { this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1; }; }, {}], 7: [function (e, t, i) { "use strict"; t.exports = function (e, t) { var i, n, a, r, o, s, f, l, d, c, u, h, b, m, w, k, _, g, v, p, x, y, S, E, Z; i = e.state, n = e.next_in, E = e.input, a = n + (e.avail_in - 5), r = e.next_out, Z = e.output, o = r - (t - e.avail_out), s = r + (e.avail_out - 257), f = i.dmax, l = i.wsize, d = i.whave, c = i.wnext, u = i.window, h = i.hold, b = i.bits, m = i.lencode, w = i.distcode, k = (1 << i.lenbits) - 1, _ = (1 << i.distbits) - 1; e: do { b < 15 && (h += E[n++] << b, b += 8, h += E[n++] << b, b += 8), g = m[h & k]; t: for (; ;) { if (h >>>= v = g >>> 24, b -= v, 0 === (v = g >>> 16 & 255)) Z[r++] = 65535 & g; else { if (!(16 & v)) { if (0 == (64 & v)) { g = m[(65535 & g) + (h & (1 << v) - 1)]; continue t; } if (32 & v) { i.mode = 12; break e; } e.msg = "invalid literal/length code", i.mode = 30; break e; } p = 65535 & g, (v &= 15) && (b < v && (h += E[n++] << b, b += 8), p += h & (1 << v) - 1, h >>>= v, b -= v), b < 15 && (h += E[n++] << b, b += 8, h += E[n++] << b, b += 8), g = w[h & _]; i: for (; ;) { if (h >>>= v = g >>> 24, b -= v, !(16 & (v = g >>> 16 & 255))) { if (0 == (64 & v)) { g = w[(65535 & g) + (h & (1 << v) - 1)]; continue i; } e.msg = "invalid distance code", i.mode = 30; break e; } if (x = 65535 & g, b < (v &= 15) && (h += E[n++] << b, (b += 8) < v && (h += E[n++] << b, b += 8)), f < (x += h & (1 << v) - 1)) { e.msg = "invalid distance too far back", i.mode = 30; break e; } if (h >>>= v, b -= v, (v = r - o) < x) { if (d < (v = x - v) && i.sane) { e.msg = "invalid distance too far back", i.mode = 30; break e; } if (S = u, (y = 0) === c) { if (y += l - v, v < p) { for (p -= v; Z[r++] = u[y++], --v;); y = r - x, S = Z; } } else if (c < v) { if (y += l + c - v, (v -= c) < p) { for (p -= v; Z[r++] = u[y++], --v;); if (y = 0, c < p) { for (p -= v = c; Z[r++] = u[y++], --v;); y = r - x, S = Z; } } } else if (y += c - v, v < p) { for (p -= v; Z[r++] = u[y++], --v;); y = r - x, S = Z; } for (; 2 < p;)Z[r++] = S[y++], Z[r++] = S[y++], Z[r++] = S[y++], p -= 3; p && (Z[r++] = S[y++], 1 < p && (Z[r++] = S[y++])); } else { for (y = r - x; Z[r++] = Z[y++], Z[r++] = Z[y++], Z[r++] = Z[y++], 2 < (p -= 3);); p && (Z[r++] = Z[y++], 1 < p && (Z[r++] = Z[y++])); } break; } } break; } } while (n < a && r < s); n -= p = b >> 3, h &= (1 << (b -= p << 3)) - 1, e.next_in = n, e.next_out = r, e.avail_in = n < a ? a - n + 5 : 5 - (n - a), e.avail_out = r < s ? s - r + 257 : 257 - (r - s), i.hold = h, i.bits = b; }; }, {}], 8: [function (e, t, i) { "use strict"; var z = e("../utils/common"), R = e("./adler32"), N = e("./crc32"), O = e("./inffast"), C = e("./inftrees"), I = 1, D = 2, T = 0, U = -2, F = 1, n = 852, a = 592; function L(e) { return (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24); } function r() { this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new z.Buf16(320), this.work = new z.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0; } function o(e) { var t; return e && e.state ? (t = e.state, e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = F, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new z.Buf32(n), t.distcode = t.distdyn = new z.Buf32(a), t.sane = 1, t.back = -1, T) : U; } function s(e) { var t; return e && e.state ? ((t = e.state).wsize = 0, t.whave = 0, t.wnext = 0, o(e)) : U; } function f(e, t) { var i, n; return e && e.state ? (n = e.state, t < 0 ? (i = 0, t = -t) : (i = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || 15 < t) ? U : (null !== n.window && n.wbits !== t && (n.window = null), n.wrap = i, n.wbits = t, s(e))) : U; } function l(e, t) { var i, n; return e ? (n = new r, (e.state = n).window = null, (i = f(e, t)) !== T && (e.state = null), i) : U; } var d, c, u = !0; function H(e) { if (u) { var t; for (d = new z.Buf32(512), c = new z.Buf32(32), t = 0; t < 144;)e.lens[t++] = 8; for (; t < 256;)e.lens[t++] = 9; for (; t < 280;)e.lens[t++] = 7; for (; t < 288;)e.lens[t++] = 8; for (C(I, e.lens, 0, 288, d, 0, e.work, { bits: 9 }), t = 0; t < 32;)e.lens[t++] = 5; C(D, e.lens, 0, 32, c, 0, e.work, { bits: 5 }), u = !1; } e.lencode = d, e.lenbits = 9, e.distcode = c, e.distbits = 5; } function j(e, t, i, n) { var a, r = e.state; return null === r.window && (r.wsize = 1 << r.wbits, r.wnext = 0, r.whave = 0, r.window = new z.Buf8(r.wsize)), n >= r.wsize ? (z.arraySet(r.window, t, i - r.wsize, r.wsize, 0), r.wnext = 0, r.whave = r.wsize) : (n < (a = r.wsize - r.wnext) && (a = n), z.arraySet(r.window, t, i - n, a, r.wnext), (n -= a) ? (z.arraySet(r.window, t, i - n, n, 0), r.wnext = n, r.whave = r.wsize) : (r.wnext += a, r.wnext === r.wsize && (r.wnext = 0), r.whave < r.wsize && (r.whave += a))), 0; } i.inflateReset = s, i.inflateReset2 = f, i.inflateResetKeep = o, i.inflateInit = function (e) { return l(e, 15); }, i.inflateInit2 = l, i.inflate = function (e, t) { var i, n, a, r, o, s, f, l, d, c, u, h, b, m, w, k, _, g, v, p, x, y, S, E, Z = 0, B = new z.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return U; 12 === (i = e.state).mode && (i.mode = 13), o = e.next_out, a = e.output, f = e.avail_out, r = e.next_in, n = e.input, s = e.avail_in, l = i.hold, d = i.bits, c = s, u = f, y = T; e: for (; ;)switch (i.mode) { case F: if (0 === i.wrap) { i.mode = 13; break; } for (; d < 16;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } if (2 & i.wrap && 35615 === l) { B[i.check = 0] = 255 & l, B[1] = l >>> 8 & 255, i.check = N(i.check, B, 2, 0), d = l = 0, i.mode = 2; break; } if (i.flags = 0, i.head && (i.head.done = !1), !(1 & i.wrap) || (((255 & l) << 8) + (l >> 8)) % 31) { e.msg = "incorrect header check", i.mode = 30; break; } if (8 != (15 & l)) { e.msg = "unknown compression method", i.mode = 30; break; } if (d -= 4, x = 8 + (15 & (l >>>= 4)), 0 === i.wbits) i.wbits = x; else if (x > i.wbits) { e.msg = "invalid window size", i.mode = 30; break; } i.dmax = 1 << x, e.adler = i.check = 1, i.mode = 512 & l ? 10 : 12, d = l = 0; break; case 2: for (; d < 16;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } if (i.flags = l, 8 != (255 & i.flags)) { e.msg = "unknown compression method", i.mode = 30; break; } if (57344 & i.flags) { e.msg = "unknown header flags set", i.mode = 30; break; } i.head && (i.head.text = l >> 8 & 1), 512 & i.flags && (B[0] = 255 & l, B[1] = l >>> 8 & 255, i.check = N(i.check, B, 2, 0)), d = l = 0, i.mode = 3; case 3: for (; d < 32;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } i.head && (i.head.time = l), 512 & i.flags && (B[0] = 255 & l, B[1] = l >>> 8 & 255, B[2] = l >>> 16 & 255, B[3] = l >>> 24 & 255, i.check = N(i.check, B, 4, 0)), d = l = 0, i.mode = 4; case 4: for (; d < 16;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } i.head && (i.head.xflags = 255 & l, i.head.os = l >> 8), 512 & i.flags && (B[0] = 255 & l, B[1] = l >>> 8 & 255, i.check = N(i.check, B, 2, 0)), d = l = 0, i.mode = 5; case 5: if (1024 & i.flags) { for (; d < 16;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } i.length = l, i.head && (i.head.extra_len = l), 512 & i.flags && (B[0] = 255 & l, B[1] = l >>> 8 & 255, i.check = N(i.check, B, 2, 0)), d = l = 0; } else i.head && (i.head.extra = null); i.mode = 6; case 6: if (1024 & i.flags && (s < (h = i.length) && (h = s), h && (i.head && (x = i.head.extra_len - i.length, i.head.extra || (i.head.extra = new Array(i.head.extra_len)), z.arraySet(i.head.extra, n, r, h, x)), 512 & i.flags && (i.check = N(i.check, n, h, r)), s -= h, r += h, i.length -= h), i.length)) break e; i.length = 0, i.mode = 7; case 7: if (2048 & i.flags) { if (0 === s) break e; for (h = 0; x = n[r + h++], i.head && x && i.length < 65536 && (i.head.name += String.fromCharCode(x)), x && h < s;); if (512 & i.flags && (i.check = N(i.check, n, h, r)), s -= h, r += h, x) break e; } else i.head && (i.head.name = null); i.length = 0, i.mode = 8; case 8: if (4096 & i.flags) { if (0 === s) break e; for (h = 0; x = n[r + h++], i.head && x && i.length < 65536 && (i.head.comment += String.fromCharCode(x)), x && h < s;); if (512 & i.flags && (i.check = N(i.check, n, h, r)), s -= h, r += h, x) break e; } else i.head && (i.head.comment = null); i.mode = 9; case 9: if (512 & i.flags) { for (; d < 16;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } if (l !== (65535 & i.check)) { e.msg = "header crc mismatch", i.mode = 30; break; } d = l = 0; } i.head && (i.head.hcrc = i.flags >> 9 & 1, i.head.done = !0), e.adler = i.check = 0, i.mode = 12; break; case 10: for (; d < 32;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } e.adler = i.check = L(l), d = l = 0, i.mode = 11; case 11: if (0 === i.havedict) return e.next_out = o, e.avail_out = f, e.next_in = r, e.avail_in = s, i.hold = l, i.bits = d, 2; e.adler = i.check = 1, i.mode = 12; case 12: if (5 === t || 6 === t) break e; case 13: if (i.last) { l >>>= 7 & d, d -= 7 & d, i.mode = 27; break; } for (; d < 3;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } switch (i.last = 1 & l, d -= 1, 3 & (l >>>= 1)) { case 0: i.mode = 14; break; case 1: if (H(i), i.mode = 20, 6 !== t) break; l >>>= 2, d -= 2; break e; case 2: i.mode = 17; break; case 3: e.msg = "invalid block type", i.mode = 30; }l >>>= 2, d -= 2; break; case 14: for (l >>>= 7 & d, d -= 7 & d; d < 32;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } if ((65535 & l) != (l >>> 16 ^ 65535)) { e.msg = "invalid stored block lengths", i.mode = 30; break; } if (i.length = 65535 & l, d = l = 0, i.mode = 15, 6 === t) break e; case 15: i.mode = 16; case 16: if (h = i.length) { if (s < h && (h = s), f < h && (h = f), 0 === h) break e; z.arraySet(a, n, r, h, o), s -= h, r += h, f -= h, o += h, i.length -= h; break; } i.mode = 12; break; case 17: for (; d < 14;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } if (i.nlen = 257 + (31 & l), l >>>= 5, d -= 5, i.ndist = 1 + (31 & l), l >>>= 5, d -= 5, i.ncode = 4 + (15 & l), l >>>= 4, d -= 4, 286 < i.nlen || 30 < i.ndist) { e.msg = "too many length or distance symbols", i.mode = 30; break; } i.have = 0, i.mode = 18; case 18: for (; i.have < i.ncode;) { for (; d < 3;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } i.lens[A[i.have++]] = 7 & l, l >>>= 3, d -= 3; } for (; i.have < 19;)i.lens[A[i.have++]] = 0; if (i.lencode = i.lendyn, i.lenbits = 7, S = { bits: i.lenbits }, y = C(0, i.lens, 0, 19, i.lencode, 0, i.work, S), i.lenbits = S.bits, y) { e.msg = "invalid code lengths set", i.mode = 30; break; } i.have = 0, i.mode = 19; case 19: for (; i.have < i.nlen + i.ndist;) { for (; k = (Z = i.lencode[l & (1 << i.lenbits) - 1]) >>> 16 & 255, _ = 65535 & Z, !((w = Z >>> 24) <= d);) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } if (_ < 16) l >>>= w, d -= w, i.lens[i.have++] = _; else { if (16 === _) { for (E = w + 2; d < E;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } if (l >>>= w, d -= w, 0 === i.have) { e.msg = "invalid bit length repeat", i.mode = 30; break; } x = i.lens[i.have - 1], h = 3 + (3 & l), l >>>= 2, d -= 2; } else if (17 === _) { for (E = w + 3; d < E;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } d -= w, x = 0, h = 3 + (7 & (l >>>= w)), l >>>= 3, d -= 3; } else { for (E = w + 7; d < E;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } d -= w, x = 0, h = 11 + (127 & (l >>>= w)), l >>>= 7, d -= 7; } if (i.have + h > i.nlen + i.ndist) { e.msg = "invalid bit length repeat", i.mode = 30; break; } for (; h--;)i.lens[i.have++] = x; } } if (30 === i.mode) break; if (0 === i.lens[256]) { e.msg = "invalid code -- missing end-of-block", i.mode = 30; break; } if (i.lenbits = 9, S = { bits: i.lenbits }, y = C(I, i.lens, 0, i.nlen, i.lencode, 0, i.work, S), i.lenbits = S.bits, y) { e.msg = "invalid literal/lengths set", i.mode = 30; break; } if (i.distbits = 6, i.distcode = i.distdyn, S = { bits: i.distbits }, y = C(D, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, S), i.distbits = S.bits, y) { e.msg = "invalid distances set", i.mode = 30; break; } if (i.mode = 20, 6 === t) break e; case 20: i.mode = 21; case 21: if (6 <= s && 258 <= f) { e.next_out = o, e.avail_out = f, e.next_in = r, e.avail_in = s, i.hold = l, i.bits = d, O(e, u), o = e.next_out, a = e.output, f = e.avail_out, r = e.next_in, n = e.input, s = e.avail_in, l = i.hold, d = i.bits, 12 === i.mode && (i.back = -1); break; } for (i.back = 0; k = (Z = i.lencode[l & (1 << i.lenbits) - 1]) >>> 16 & 255, _ = 65535 & Z, !((w = Z >>> 24) <= d);) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } if (k && 0 == (240 & k)) { for (g = w, v = k, p = _; k = (Z = i.lencode[p + ((l & (1 << g + v) - 1) >> g)]) >>> 16 & 255, _ = 65535 & Z, !(g + (w = Z >>> 24) <= d);) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } l >>>= g, d -= g, i.back += g; } if (l >>>= w, d -= w, i.back += w, i.length = _, 0 === k) { i.mode = 26; break; } if (32 & k) { i.back = -1, i.mode = 12; break; } if (64 & k) { e.msg = "invalid literal/length code", i.mode = 30; break; } i.extra = 15 & k, i.mode = 22; case 22: if (i.extra) { for (E = i.extra; d < E;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } i.length += l & (1 << i.extra) - 1, l >>>= i.extra, d -= i.extra, i.back += i.extra; } i.was = i.length, i.mode = 23; case 23: for (; k = (Z = i.distcode[l & (1 << i.distbits) - 1]) >>> 16 & 255, _ = 65535 & Z, !((w = Z >>> 24) <= d);) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } if (0 == (240 & k)) { for (g = w, v = k, p = _; k = (Z = i.distcode[p + ((l & (1 << g + v) - 1) >> g)]) >>> 16 & 255, _ = 65535 & Z, !(g + (w = Z >>> 24) <= d);) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } l >>>= g, d -= g, i.back += g; } if (l >>>= w, d -= w, i.back += w, 64 & k) { e.msg = "invalid distance code", i.mode = 30; break; } i.offset = _, i.extra = 15 & k, i.mode = 24; case 24: if (i.extra) { for (E = i.extra; d < E;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } i.offset += l & (1 << i.extra) - 1, l >>>= i.extra, d -= i.extra, i.back += i.extra; } if (i.offset > i.dmax) { e.msg = "invalid distance too far back", i.mode = 30; break; } i.mode = 25; case 25: if (0 === f) break e; if (h = u - f, i.offset > h) { if ((h = i.offset - h) > i.whave && i.sane) { e.msg = "invalid distance too far back", i.mode = 30; break; } h > i.wnext ? (h -= i.wnext, b = i.wsize - h) : b = i.wnext - h, h > i.length && (h = i.length), m = i.window; } else m = a, b = o - i.offset, h = i.length; for (f < h && (h = f), f -= h, i.length -= h; a[o++] = m[b++], --h;); 0 === i.length && (i.mode = 21); break; case 26: if (0 === f) break e; a[o++] = i.length, f--, i.mode = 21; break; case 27: if (i.wrap) { for (; d < 32;) { if (0 === s) break e; s--, l |= n[r++] << d, d += 8; } if (u -= f, e.total_out += u, i.total += u, u && (e.adler = i.check = i.flags ? N(i.check, a, u, o - u) : R(i.check, a, u, o - u)), u = f, (i.flags ? l : L(l)) !== i.check) { e.msg = "incorrect data check", i.mode = 30; break; } d = l = 0; } i.mode = 28; case 28: if (i.wrap && i.flags) { for (; d < 32;) { if (0 === s) break e; s--, l += n[r++] << d, d += 8; } if (l !== (4294967295 & i.total)) { e.msg = "incorrect length check", i.mode = 30; break; } d = l = 0; } i.mode = 29; case 29: y = 1; break e; case 30: y = -3; break e; case 31: return -4; case 32: default: return U; }return e.next_out = o, e.avail_out = f, e.next_in = r, e.avail_in = s, i.hold = l, i.bits = d, (i.wsize || u !== e.avail_out && i.mode < 30 && (i.mode < 27 || 4 !== t)) && j(e, e.output, e.next_out, u - e.avail_out) ? (i.mode = 31, -4) : (c -= e.avail_in, u -= e.avail_out, e.total_in += c, e.total_out += u, i.total += u, i.wrap && u && (e.adler = i.check = i.flags ? N(i.check, a, u, e.next_out - u) : R(i.check, a, u, e.next_out - u)), e.data_type = i.bits + (i.last ? 64 : 0) + (12 === i.mode ? 128 : 0) + (20 === i.mode || 15 === i.mode ? 256 : 0), (0 === c && 0 === u || 4 === t) && y === T && (y = -5), y); }, i.inflateEnd = function (e) { if (!e || !e.state) return U; var t = e.state; return t.window && (t.window = null), e.state = null, T; }, i.inflateGetHeader = function (e, t) { var i; return e && e.state ? 0 == (2 & (i = e.state).wrap) ? U : ((i.head = t).done = !1, T) : U; }, i.inflateSetDictionary = function (e, t) { var i, n = t.length; return e && e.state ? 0 !== (i = e.state).wrap && 11 !== i.mode ? U : 11 === i.mode && R(1, t, n, 0) !== i.check ? -3 : j(e, t, n, n) ? (i.mode = 31, -4) : (i.havedict = 1, T) : U; }, i.inflateInfo = "pako inflate (from Nodeca project)"; }, { "../utils/common": 1, "./adler32": 3, "./crc32": 5, "./inffast": 7, "./inftrees": 9 }], 9: [function (e, t, i) { "use strict"; var I = e("../utils/common"), D = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], T = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], F = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]; t.exports = function (e, t, i, n, a, r, o, s) { var f, l, d, c, u, h, b, m, w, k = s.bits, _ = 0, g = 0, v = 0, p = 0, x = 0, y = 0, S = 0, E = 0, Z = 0, B = 0, A = null, z = 0, R = new I.Buf16(16), N = new I.Buf16(16), O = null, C = 0; for (_ = 0; _ <= 15; _++)R[_] = 0; for (g = 0; g < n; g++)R[t[i + g]]++; for (x = k, p = 15; 1 <= p && 0 === R[p]; p--); if (p < x && (x = p), 0 === p) return a[r++] = 20971520, a[r++] = 20971520, s.bits = 1, 0; for (v = 1; v < p && 0 === R[v]; v++); for (x < v && (x = v), _ = E = 1; _ <= 15; _++)if (E <<= 1, (E -= R[_]) < 0) return -1; if (0 < E && (0 === e || 1 !== p)) return -1; for (N[1] = 0, _ = 1; _ < 15; _++)N[_ + 1] = N[_] + R[_]; for (g = 0; g < n; g++)0 !== t[i + g] && (o[N[t[i + g]]++] = g); if (0 === e ? (A = O = o, h = 19) : 1 === e ? (A = D, z -= 257, O = T, C -= 257, h = 256) : (A = U, O = F, h = -1), _ = v, u = r, S = g = B = 0, d = -1, c = (Z = 1 << (y = x)) - 1, 1 === e && 852 < Z || 2 === e && 592 < Z) return 1; for (; ;) { for (b = _ - S, o[g] < h ? (m = 0, w = o[g]) : o[g] > h ? (m = O[C + o[g]], w = A[z + o[g]]) : (m = 96, w = 0), f = 1 << _ - S, v = l = 1 << y; a[u + (B >> S) + (l -= f)] = b << 24 | m << 16 | w | 0, 0 !== l;); for (f = 1 << _ - 1; B & f;)f >>= 1; if (0 !== f ? (B &= f - 1, B += f) : B = 0, g++, 0 == --R[_]) { if (_ === p) break; _ = t[i + o[g]]; } if (x < _ && (B & c) !== d) { for (0 === S && (S = x), u += v, E = 1 << (y = _ - S); y + S < p && !((E -= R[y + S]) <= 0);)y++, E <<= 1; if (Z += 1 << y, 1 === e && 852 < Z || 2 === e && 592 < Z) return 1; a[d = B & c] = x << 24 | y << 16 | u - r | 0; } } return 0 !== B && (a[u + B] = _ - S << 24 | 64 << 16 | 0), s.bits = x, 0; }; }, { "../utils/common": 1 }], 10: [function (e, t, i) { "use strict"; t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }; }, {}], 11: [function (e, t, i) { "use strict"; t.exports = function () { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0; }; }, {}], "/lib/inflate.js": [function (e, t, i) { "use strict"; var c = e("./zlib/inflate"), u = e("./utils/common"), h = e("./utils/strings"), b = e("./zlib/constants"), n = e("./zlib/messages"), a = e("./zlib/zstream"), r = e("./zlib/gzheader"), m = Object.prototype.toString; function o(e) { if (!(this instanceof o)) return new o(e); this.options = u.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e || {}); var t = this.options; t.raw && 0 <= t.windowBits && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(0 <= t.windowBits && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), 15 < t.windowBits && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new a, this.strm.avail_out = 0; var i = c.inflateInit2(this.strm, t.windowBits); if (i !== b.Z_OK) throw new Error(n[i]); if (this.header = new r, c.inflateGetHeader(this.strm, this.header), t.dictionary && ("string" == typeof t.dictionary ? t.dictionary = h.string2buf(t.dictionary) : "[object ArrayBuffer]" === m.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (i = c.inflateSetDictionary(this.strm, t.dictionary)) !== b.Z_OK)) throw new Error(n[i]); } function s(e, t) { var i = new o(t); if (i.push(e, !0), i.err) throw i.msg || n[i.err]; return i.result; } o.prototype.push = function (e, t) { var i, n, a, r, o, s = this.strm, f = this.options.chunkSize, l = this.options.dictionary, d = !1; if (this.ended) return !1; n = t === ~~t ? t : !0 === t ? b.Z_FINISH : b.Z_NO_FLUSH, "string" == typeof e ? s.input = h.binstring2buf(e) : "[object ArrayBuffer]" === m.call(e) ? s.input = new Uint8Array(e) : s.input = e, s.next_in = 0, s.avail_in = s.input.length; do { if (0 === s.avail_out && (s.output = new u.Buf8(f), s.next_out = 0, s.avail_out = f), (i = c.inflate(s, b.Z_NO_FLUSH)) === b.Z_NEED_DICT && l && (i = c.inflateSetDictionary(this.strm, l)), i === b.Z_BUF_ERROR && !0 === d && (i = b.Z_OK, d = !1), i !== b.Z_STREAM_END && i !== b.Z_OK) return this.onEnd(i), !(this.ended = !0); s.next_out && (0 !== s.avail_out && i !== b.Z_STREAM_END && (0 !== s.avail_in || n !== b.Z_FINISH && n !== b.Z_SYNC_FLUSH) || ("string" === this.options.to ? (a = h.utf8border(s.output, s.next_out), r = s.next_out - a, o = h.buf2string(s.output, a), s.next_out = r, s.avail_out = f - r, r && u.arraySet(s.output, s.output, a, r, 0), this.onData(o)) : this.onData(u.shrinkBuf(s.output, s.next_out)))), 0 === s.avail_in && 0 === s.avail_out && (d = !0); } while ((0 < s.avail_in || 0 === s.avail_out) && i !== b.Z_STREAM_END); return i === b.Z_STREAM_END && (n = b.Z_FINISH), n === b.Z_FINISH ? (i = c.inflateEnd(this.strm), this.onEnd(i), this.ended = !0, i === b.Z_OK) : n !== b.Z_SYNC_FLUSH || (this.onEnd(b.Z_OK), !(s.avail_out = 0)); }, o.prototype.onData = function (e) { this.chunks.push(e); }, o.prototype.onEnd = function (e) { e === b.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = u.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg; }, i.Inflate = o, i.inflate = s, i.inflateRaw = function (e, t) { return (t = t || {}).raw = !0, s(e, t); }, i.ungzip = s; }, { "./utils/common": 1, "./utils/strings": 2, "./zlib/constants": 4, "./zlib/gzheader": 6, "./zlib/inflate": 8, "./zlib/messages": 10, "./zlib/zstream": 11 }] }, {}, [])("/lib/inflate.js"); });
// DRDrawDepth

function webglAvailable() {
  try {
    var canvas = document.createElement("canvas");
    return !!(window.WebGLRenderingContext && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl")));
  } catch (e) {
    return false;
  }
}

function DRDrawDepth() {

  this.init = () => {
    this.setupThreeGrid();
    // this.connectWebSocket();
    this.setupWheelZoom();
  };

  this.setupThreeGrid = () => {
    // Gravity Points
    this.gp = {};
    this.gp.element = document.querySelector("#graphicsContainer .threeContainer");
    this.gp.size = { width: $(this.gp.element).width(), height: $(this.gp.element).width() / 1.6 };
    if (webglAvailable()) {
      this.gp.renderer = new THREE.WebGLRenderer({
        antialias: true,	// to get smoother output
        preserveDrawingBuffer: true,	// to allow screenshot,
        alpha: true
      });
      this.gp.renderer.setClearColor(0xFFFFFF, 0.0);
      this.gp.element.appendChild(this.gp.renderer.domElement);
      this.gp.renderer.setSize(this.gp.size.width, this.gp.size.height);
    } else {
      console.error("WebGL support was not detected in your browser.");
      nonModalAlert("WebGL", "WebGL support was not detected in your browser.");
    }
    this.gp.scene = new THREE.Scene();
    this.gp.camera = new THREE.PerspectiveCamera(74, 1.6, 0.1, 100);
    // this.gp.camera = new THREE.PerspectiveCamera(60, 1.6, 0.01, 100);
    // this.gp.camera = new THREE.PerspectiveCamera(52.2, 1.778, 0.1, 10000); // Logitech c930e
    this.gp.camera.position.set(-1.31, 1.57, 0.93);
    this.gp.camera.up = new THREE.Vector3(0, 1, 0);
    this.gp.scene.add(this.gp.camera);

    this.globalGrid = {
      origin: {
        x: -10,
        y: -10
      },
      offset: {
        x: 0,
        y: 0
      },
      size: {
        width: 20,
        height: 20
      },
      step: 0.1,
      zStep: 0.01,
      buf: null,
      bufferLength: 0,
      cols: 0
    };
    this.globalGrid.bufferLength = (this.globalGrid.size.width / this.globalGrid.step) * (this.globalGrid.size.height / this.globalGrid.step);
    this.globalGrid.buf = new Uint8Array(this.globalGrid.bufferLength);
    this.globalGrid.cols = this.globalGrid.size.width / this.globalGrid.step;

    this.gp.shouldRender = true;
    this.gp.paused = false;
    this.gp.animate = () => {
      requestAnimationFrame(this.gp.animate);
      if (this.gp.shouldRender && !this.gp.paused) { // && this.gp.renderer.domElement.style.visibility != "hidden"
        this.calculateMouseIcon();
        this.gp.render();
        this.gp.shouldRender = false;
      }
    };
    this.gp.render = () => {
      if (!this.gp.renderer || this.gp.renderer.domElement.style.visibility == "hidden") {
        return;
      }

      // Crop viewport
      if (this.gp.camera && this.viewport
        && "x" in this.viewport
        && "y" in this.viewport
        && "zoom" in this.viewport
      ) {
        this.gp.setViewport(this.viewport);
      } else {
        this.gp.renderer.setViewport(0, 0, this.gp.size.width, this.gp.size.height);
      }

      // Render scene
      this.gp.renderer.render(this.gp.scene, this.gp.camera);
    };

    this.gp.setViewport = (vp) => {
      if (this.gp.renderer) {
        var size = this.gp.size;
        this.gp.renderer.setViewport(
          size.width * vp.x,
          size.height * vp.y,
          size.width * vp.zoom,
          size.height * vp.zoom);
      }
    };

    // Grid lines
    var size = 20;
    var divisions = 20;
    this.gp.gridHelper = new THREE.GridHelper(size, divisions, 0x000000, 0x555555);
    this.gp.scene.add(this.gp.gridHelper);

    // mouse object
    var mouseTargetRadius = 0.2;
    var mouseTargetRingThickness = 0.04;
    var mouseGeometry = new THREE.CircleGeometry(mouseTargetRadius, 32);
    var mouseMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide, opacity: 0.2, transparent: true });
    this.gp.mouseTarget = new THREE.Mesh(mouseGeometry, mouseMaterial);
    this.gp.mouseTarget.position.set(0, 0, 0);
    this.gp.mouseTarget.rotation.set(degToRad(90), degToRad(0), degToRad(0));
    var mouseRingGeometry = new THREE.RingGeometry(mouseTargetRadius - mouseTargetRingThickness, mouseTargetRadius + 0.01, 32);
    var mouseRingMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide, opacity: 0.75, transparent: true });
    this.gp.mouseRingMesh = new THREE.Mesh(mouseRingGeometry, mouseRingMaterial);
    this.gp.mouseRingMesh.position.z = -0.0001;
    this.gp.mouseTarget.add(this.gp.mouseRingMesh);

    // Add the blue dot for when clicking
    var mouseHitGeometry = new THREE.CircleGeometry(mouseTargetRadius, 32);
    var mouseHitMaterial = new THREE.MeshBasicMaterial({ color: "rgba(47, 142, 198, 1.0)", side: THREE.DoubleSide, opacity: 1.0, transparent: true });
    var mouseHitMesh = new THREE.Mesh(mouseHitGeometry, mouseHitMaterial);
    mouseHitMesh.position.z = -0.0002;
    var mouseHitRingGeometry = new THREE.RingGeometry(mouseTargetRadius - mouseTargetRingThickness, mouseTargetRadius + 0.01, 32);
    var mouseHitRingMaterial = new THREE.MeshBasicMaterial({ color: "rgba(0, 115, 213, 1.0)", side: THREE.DoubleSide, opacity: 1.0, transparent: true });
    var mouseHitRingMesh = new THREE.Mesh(mouseHitRingGeometry, mouseHitRingMaterial);
    mouseHitRingMesh.position.z = -0.0003;
    mouseHitMesh.add(mouseHitRingMesh);
    mouseHitMesh.visible = false;
    this.gp.blueDot = mouseHitMesh;

    var triangleShape = new THREE.Shape();
    var tx = 0.0;
    var ty = 0.25;
    var trianglePoints = [
      { x: tx - 0.15, y: ty },
      { x: tx, y: ty + 0.24 },
      { x: tx + 0.15, y: ty }
    ];
    roundedPoly(triangleShape, trianglePoints, 0.06);
    this.gp.blueDotTriangle = new THREE.Mesh(
      new THREE.ShapeGeometry(triangleShape),
      new THREE.MeshBasicMaterial({ color: "rgba(0, 115, 213, 1.0)", side: THREE.DoubleSide, opacity: 1.0, transparent: true }));
    this.gp.blueDotTriangle.visible = false;
    this.gp.blueDot.add(this.gp.blueDotTriangle);

    this.gp.mouseTarget.add(mouseHitMesh);
    this.gp.scene.add(this.gp.mouseTarget);

    // move mouse object on hover
    // var mouse = {x: 0, y: 0};
    this.hoverMouseDown = false;
    this.hoverMouseDragging = false;
    this.calculateMouseIcon = () => {
      if (this.mouseHidden || this.mousePosition.x < 0) {
        this.hideArrow();
        this.checkMouseTarget();
        return;
      }

      if (!this.hoverMouseDown) {
        // Check for edge arrow buttons first
        var position = this.mouseArrowPosition(this.mousePosition.x, this.mousePosition.y);
        switch (position) {
          case "bottomLeft":
          case "extremeLeft":
            this.showArrow(this.mousePosition.x, this.mousePosition.y, 180);
            break;
          case "bottomRight":
          case "extremeRight":
            this.showArrow(this.mousePosition.x, this.mousePosition.y, 0);
            break;
          case "extremeTop":
            this.showArrow(this.mousePosition.x, this.mousePosition.y, 270);
            break;
          case "extremeBottom":
            this.showArrow(this.mousePosition.x, this.mousePosition.y, 90);
            break;
          default:
            this.hideArrow();
            break;
        }
      }

      this.gp.scene.updateMatrixWorld(true);

      // Make the circle follow the mouse
      var x = this.mousePosition.xPercent;
      var y = this.mousePosition.yPercent;
      if (this.viewport) {
        var vp = this.viewport;

        // Switch to 0 to 1
        x = (x + 1) / 2;
        y = (-y + 1) / 2;

        x = vp.x / vp.zoom * -1 + x * (1 / vp.zoom);
        y = vp.y / vp.zoom * -1 + (1 - y) * (1 / vp.zoom);

        // switch back to -1 to 1
        x = x * 2 - 1;
        y = y * 2 - 1;
      }
      var vector = new THREE.Vector3(x, y, 0);
      // console.log(this.mousePosition, this.viewport, vector);
      vector.unproject(this.gp.camera);
      var dir = vector.sub(this.gp.camera.position).normalize();
      var distance = - this.gp.camera.position.y / dir.y;
      var pos = this.gp.camera.position.clone().add(dir.multiplyScalar(distance));
      pos.y = 0.02;
      if (this.hoverMouseDragging && this.hoverMouseDown !== null && typeof this.hoverMouseDown === "object") {
        // If dragging, set angle instead of position
        var distance = distanceBetween(
          { x: this.hoverMouseDown.z, y: this.hoverMouseDown.x },
          { x: pos.z, y: pos.x });
        this.gp.mouseTarget.position.copy(this.hoverMouseDown);
        if (distance >= 0.3) {
          var angle = angleFromOnePointToAnother(
            { x: this.hoverMouseDown.z, y: this.hoverMouseDown.x },
            { x: pos.z, y: pos.x });
          // angle = radMod(degToRad(360) - angle + degToRad(180 + 360));
          // if (angle > degToRad(180)) {
          // 	angle = radMod(angle - degToRad(360));
          // }
          if (!window.processAngle) {
            window.processAngle = function (angle) {
              angle = radMod(degToRad(360) - angle + degToRad(180));
              if (angle < degToRad(-180)) {
                angle = radMod(angle + degToRad(360));
              }
              if (angle > degToRad(180)) {
                angle = radMod(angle - degToRad(360));
              }
              return angle;
            };
          }
          angle = processAngle(angle);
          this.hoverMouseDown.angle = angle;
          this.gp.blueDotTriangle.rotation.z = angle;
          this.gp.blueDotTriangle.visible = remoteRobotSupports("targetAngle");
        } else {
          this.gp.blueDotTriangle.visible = false;
          if ("angle" in this.hoverMouseDown) {
            delete this.hoverMouseDown.angle;
          }
        }
      } else {
        this.gp.blueDotTriangle.visible = false;
        if (this.hoverMouseDown) {
          this.hoverMouseDown = pos;
          this.hoverMouseDragging = true;
        } else {
          this.hoverMouseDown = false;
          this.hoverMouseDragging = false;
        }
        if (this.hoverMouseDown !== null && typeof this.hoverMouseDown === "object" && "angle" in this.hoverMouseDown) {
          delete this.hoverMouseDown.angle;
        }
        this.gp.mouseTarget.position.copy(pos);
      }

      // Check for docks
      this.processDocks();
      if (!this.raycaster) {
        this.raycaster = new THREE.Raycaster();
      }
      this.raycaster.setFromCamera({ x: x, y: y }, this.gp.camera);
      var intersects = this.raycaster.intersectObjects([this.gp.scene], true);
      this.setHoverObject((intersects.length > 0) ? intersects[0].object : null);

      // Check for tags
      this.processTags();
      if (!this.raycaster) {
        this.raycaster = new THREE.Raycaster();
      }
      this.raycaster.setFromCamera({ x: x, y: y }, this.gp.camera);
      intersects = this.raycaster.intersectObjects([this.gp.scene], true);
      this.setHoverObject((intersects.length > 0) ? intersects[0].object : null);

      this.checkMouseTarget();
    };

    this.setHoverObject = (object) => {
      if (object && object.name && (object.name.indexOf("dock_") === 0 || object.name.indexOf("tag") === 0)) {
        this.hoverObject = object;
        this.hoverObject.material.opacity = Math.max(this.hoverObject.material.opacity, 0.4);
      } else {
        this.hoverObject = null;
      }
      if (this.dockMeshes) {
        for (var i = 0; i < this.dockMeshes.length; i++) {
          var d = this.dockMeshes[i];
          if (d != this.hoverObject) {
            d.material.opacity = 0;
          }
        }
      }
      if (this.tagMeshes) {
        for (var i = 0; i < this.tagMeshes.length; i++) {
          var d = this.tagMeshes[i];
          if (d != this.hoverObject) {
            d.material.opacity = 0;
          }
        }
      }
    };

    this.setHoverObjectMouseDown = () => {
      this.hoverObject.material.opacity = 0.8;
    };

    this.setHoverObjectMouseUp = () => {
      this.hoverObject.material.opacity = 0.4;
      if (this.hoverObject.name) {
        if (this.hoverObject.name.indexOf("dock_") === 0) {
          var id = parseInt(this.hoverObject.name.replace("dock_", ""));
          if (id && !isNaN(id)) {
            var params = { dockId: id };
            if (shiftKeyDown) {
              params.direction = "backward";
            }
            sendCommandWithData(kDRCommandTargetDrive, params);
          }
        } else if (this.hoverObject.name.indexOf("tag_") === 0) {
          processHit(this.hoverObject);
        }
      }
    };

    var onMouseMove = (event) => {
      // Update the mouse variable
      event.preventDefault();
      if (sidebarDragging) {
        return;
      }
      this.mouseHidden = false;
      this.updateMousePosition(event);
      this.calculateMouseIcon();
      this.gp.shouldRender = true;
    };
    var onMouseDown = (event) => {
      event.preventDefault();

      if ("which" in event && event.which === 3) {
        // right click
        rightClickDown = true;
        updateCtrlMenu();
        if (rightClickDownDate && Date.now() - rightClickDownDate < 500) {
          this.zoomIn(
            (event.offsetX / this.gp.size.width - 0.5) * 2,
            (event.offsetY / this.gp.size.height - 0.5) * 2);
        }
        rightClickDownDate = new Date();
        return;
      }

      this.updateMousePosition(event);

      this.clickPosition = {
        x: event.clientX,
        y: event.clientY
      };

      var position = this.mouseArrowPosition(this.mousePosition.x, this.mousePosition.y);
      switch (position) {
        case "bottomLeft":
        case "bottomRight":
        case "extremeLeft":
        case "extremeRight":
        case "extremeTop":
        case "extremeBottom": {
          if (this.clickHoldInterval) {
            window.clearInterval(this.clickHoldInterval);
          }
          this.clickHoldInterval = window.setInterval(() => {
            this.clickHoldTick();
          }, 67);
          this.clickHoldTick();
          this.clickArrow();
          sendPtz();
          break;
        }
      }

      if (this.hoverObject) {
        this.setHoverObjectMouseDown();
        this.gp.shouldRender = true;

      } else if (this.gp.mouseTarget.visible) {
        // Show the blue circle
        this.hoverMouseDown = true;
        this.hoverMouseDragging = false;
        this.gp.blueDot.visible = true;
        this.gp.shouldRender = true;
      }

    };
    var onMouseUp = (event) => {
      rightClickDown = false;
      updateCtrlMenu();

      ptzStates.left = false;
      ptzStates.right = false;
      ptzStates.up = false;
      ptzStates.down = false;
      if (this.clickHoldInterval) {
        window.clearInterval(this.clickHoldInterval);
        this.clickHoldInterval = null;
      }
      this.unclickArrow();

      var upPosition = {
        x: event.clientX,
        y: event.clientY
      };
      if ((this.clickPosition && this.clickPosition
        && (Math.abs(this.clickPosition.x - upPosition.x) < 20 || Math.abs(this.clickPosition.y - upPosition.y) < 20))
        || (this.hoverMouseDragging && this.hoverMouseDown)
      ) {
        // Clicked, but not dragged
        if (this.hoverObject) {
          this.setHoverObjectMouseUp();

        } else if (!this.arrowVisible() && this.mouseTargetAllowed && this.gp.mouseTarget.visible && !cKeyDown) {
          // Drive to tile
          if (this.latestPose && this.latestPose.base) {
            var point = {
              x: this.gp.mouseTarget.position.z - this.latestPose.base.x,
              y: this.gp.mouseTarget.position.x - this.latestPose.base.y
            };
            point = pointRotatedBy(point, -this.latestPose.base.yaw);

            var target = {
              x: point.x,
              y: point.y
            };
            if (this.hoverMouseDown !== null && typeof this.hoverMouseDown == "object"
              && !isNaN(parseFloat(this.hoverMouseDown.angle))
            ) {
              if (remoteRobotSupports("targetAngle")) {
                target.angle = degToRad(360) - parseFloat(this.hoverMouseDown.angle);
              }
              target.x = this.gp.mouseTarget.position.z;
              target.y = this.gp.mouseTarget.position.x;
              target.relative = false;
            }
            sendCommandWithData(kDRCommandTargetDrive, target);
            console.log("Drive to target: ", target);
            neutralDriveCommandsSent = 10;
            this.mouseHidden = true;
          }
        }
      }

      // Hide the blue circle
      this.hoverMouseDown = false;
      this.hoverMouseDragging = false;
      this.gp.blueDot.visible = false;
      this.gp.shouldRender = true;
    };
    this.gp.element.addEventListener("mouseenter", (event) => {
      this.checkMouseTarget();
    }, false);
    this.gp.element.addEventListener("mouseleave", (event) => {
      this.mouseHidden = true;
      this.hideArrow();
      this.checkMouseTarget();
      this.gp.blueDot.visible = false;
      this.gp.shouldRender = true;
    }, false);
    window.addEventListener("resize", () => {
      this.updateCanvasSize();
      this.hideArrow();
    }, false);

    if (isTouchDevice) {
      var hasMultipleTouches = false;
      var onTouchStart = (event) => {
        var touches = event.targetTouches;
        if (touches.length === 2) {
          hasMultipleTouches = true;
          updateCtrlMenu(null, event);
        } else {
          hasMultipleTouches = false;
        }
      };
      var onTouchMove = (event) => {
        var touches = event.targetTouches;
        if (touches.length === 2) {
          updateCtrlMenu(null, event);
          hasMultipleTouches = true;
        }
      };
      var onTouchCancel = (event) => {
        updateCtrlMenu();
      };
      var onTouchEnd = (event) => {
        updateCtrlMenu();
        var touches = event.changedTouches;
        if (touches.length == 0) {
          hasMultipleTouches = false;
        }
        if (!remoteRobotSupports("hitTest")) {
          return;
        }
        if (touches.length === 1 && !hasMultipleTouches) {
          var el = event.target.getBoundingClientRect();
          var x = touches[0].clientX - el.left;
          var y = touches[0].clientY - el.top;
          var xPercent = Math.min(1, Math.max(0, x / el.width));
          var yPercent = Math.min(1, Math.max(0, y / el.height));
          sendCommandWithData(kDRCommandHitTest, { x: xPercent, y: yPercent, highlight: true, dock: true, drive: true });
        }
      };
      this.gp.element.addEventListener("touchstart", onTouchStart, false);
      this.gp.element.addEventListener("touchmove", onTouchMove, false);
      this.gp.element.addEventListener("touchcancel", onTouchCancel, false);
      this.gp.element.addEventListener("touchend", onTouchEnd, false);
    } else {
      this.gp.element.addEventListener("mousedown", onMouseDown, false);
      this.gp.element.addEventListener("mousemove", onMouseMove, false);
      this.gp.element.addEventListener("mouseup", onMouseUp, false);
    }

    this.arrow = document.querySelector("#arrow");

    this.updateCanvasSize();
    this.hideHelper();
    this.gp.animate();
    this.resetCameraPosition();
  };

  this.mousePosition = { x: -1, y: -1, xPercent: -.01, yPercent: -.01 };
  this.updateMousePosition = (event) => {
    var elementPosition = $("#graphicsContainer .threeContainer canvas").offset();
    this.mousePosition = {
      x: event.clientX + document.body.scrollLeft - elementPosition.left,
      y: event.clientY + document.body.scrollTop - elementPosition.top,
      xPercent: ((event.clientX - elementPosition.left) / this.gp.size.width) * 2 - 1,
      yPercent: - ((event.clientY - elementPosition.top) / this.gp.size.height) * 2 + 1
    };
  };

  this.cancelPendingClickToDrive = () => {
    this.clickPosition = null;
    this.mouseHidden = true;

    // Hide the blue circle
    this.hoverMouseDown = false;
    this.hoverMouseDragging = false;
    this.gp.blueDot.visible = false;
    this.gp.shouldRender = true;
  };

  this.clickHoldTick = () => {
    ptzStates.left = false;
    ptzStates.right = false;
    ptzStates.up = false;
    ptzStates.down = false;
    if (this.mousePosition && this.mousePosition.x >= 0) {
      var position = this.mouseArrowPosition(this.mousePosition.x, this.mousePosition.y);
      switch (position) {
        case "bottomLeft":
        case "extremeLeft":
          ptzStates.left = true;
          break;
        case "bottomRight":
        case "extremeRight":
          ptzStates.right = true;
          break;
        case "extremeTop":
          // tilt up
          ptzStates.up = true;
          break;
        case "extremeBottom":
          // tilt down
          ptzStates.down = true;
          break;
        default:
          this.hideArrow();
          break;
      }
    }
  };

  this.mouseTargetAllowed = false;
  this.mouseHidden = false;
  this.checkMouseTarget = () => {
    var shouldBeVisible = (!this.arrowVisible() && !ctrlMenuVisible() && this.mouseTargetAllowed && !this.mouseHidden && !cKeyDown);

    if (shouldBeVisible) {
      if (this.hoverObject) {
        shouldBeVisible = true;
        this.gp.mouseTarget.visible = false;

      } else {
        this.processGlobalGridData();
        var normalizedX = this.gp.mouseTarget.position.x - this.globalGrid.offset.y;
        var normalizedY = this.gp.mouseTarget.position.z - this.globalGrid.offset.x;
        var index = this.indexFromPoint(this.globalGrid, normalizedX, normalizedY);
        if (this.globalGrid.buf && (index >= 0 && index < this.globalGrid.bufferLength) && this.globalGrid.buf[index] >= 2) {
          shouldBeVisible = true;
        } else {
          shouldBeVisible = false;
        }
        this.gp.mouseTarget.visible = shouldBeVisible;
      }
    }

    if (this.gp.renderer) {
      var el = this.gp.renderer.domElement;
      if (shouldBeVisible && el.style.visibility == "hidden") {
        el.style.visibility = "visible";
      } else if (!shouldBeVisible && el.style.visibility != "hidden") {
        el.style.visibility = "hidden";
      }
    }
  };

  this.processGlobalGrid = (data) => {
    // Save this raw and only process it if the mouse moves
    this.globalGrid.lastData = data;
    this.globalGrid.lastDataProcessed = false;
  };

  this.processGlobalGridData = () => {
    if (this.globalGrid.lastDataProcessed || !this.globalGrid.lastData) {
      return;
    }

    var data = this.globalGrid.lastData;
    this.globalGrid.lastDataProcessed = true;
    this.globalGrid.offset = data.offset;

    if (data.base64) {
      var strData = atob(data.base64);
      var charData = strData.split('').map(function (x) { return x.charCodeAt(0); });
      var binData = new Uint8Array(charData);
      var voteData = pako.inflate(binData);
      this.globalGrid.buf = Uint8Array.from(voteData);
    } else if (data.string) {
      // Decompress the data
      var len = data.string.length;

      // Parse deduped string (see DRGrid.js)
      var charCodeOffset = 48; // We start at the zero ASCII character.
      // Original: 0001123333
      // Compress: 02112033
      // Original: 000000000011111111233333333
      // Compress: 09172037

      var i = 0;
      for (var m = 0; m < len; m += 2) {
        var votesAscii = data.string[m];
        var votes = votesAscii.charCodeAt() - charCodeOffset;
        var repeats = data.string[m + 1].charCodeAt() - charCodeOffset;
        for (var k = 0; k < repeats + 1; k++) {
          if (i < this.globalGrid.bufferLength) {
            this.globalGrid.buf[i] = votes;
          } else {
            // console.log("Error: too many values for buffer");
          }
          i++;
        }
      }
    }
  };

  this.setDocks = (docks) => {
    this.lastDocks = docks;
  };

  this.processDocks = () => {
    if (!this.dockMeshes) {
      this.dockMeshes = [];
      for (var i = 0; i < 5; i++) {
        var m = new THREE.Mesh(
          new THREE.SphereGeometry(0.135, 24, 24),
          new THREE.MeshBasicMaterial({
            color: new THREE.Color("rgb(239, 147, 60)"),
            wireframe: false,
            side: THREE.FrontSide,
            transparent: true
          }
          )
        );
        m.material.opacity = 0;
        m.position.set(-999, 0.9, -999);
        m.scale.set(1.1, 1.1, 1.1);
        m.visible = true;
        this.dockMeshes.push(m);
        this.gp.scene.add(m);
      }
    }
    var docksUsed = 0;
    if (this.lastDocks && Array.isArray(this.lastDocks)) {
      for (var i = 0; i < this.lastDocks.length; i++) {
        var d = this.lastDocks[i];
        if (i < this.dockMeshes.length) {
          this.dockMeshes[i].position.x = d.y;
          this.dockMeshes[i].position.z = d.x;
          this.dockMeshes[i].name = "dock_" + d.id;
          docksUsed++;
        }
      }
    }
    for (var i = docksUsed; i < this.dockMeshes.length; i++) {
      this.dockMeshes[i].position.x = -999;
      this.dockMeshes[i].position.z = -999;
    }
  };

  this.setTags = (tags) => {
    this.lastTags = tags;
  };

  this.processTags = () => {
    if (!this.tagMeshes) {
      this.tagMeshes = [];
      for (var i = 0; i < 5; i++) {
        var m = new THREE.Mesh(
          new THREE.SphereGeometry(1, 24, 24),
          new THREE.MeshBasicMaterial({
            color: new THREE.Color(1, 1, 1),
            wireframe: false,
            side: THREE.FrontSide,
            transparent: true
          }
          )
        );
        m.material.opacity = 0;
        m.position.set(-999, 0.9, -999);
        m.visible = true;
        this.tagMeshes.push(m);
        this.gp.scene.add(m);
      }
    }
    var tagsUsed = 0;
    if (this.lastTags && Array.isArray(this.lastTags)) {
      for (var i = 0; i < this.lastTags.length; i++) {
        var d = this.lastTags[i];
        if (i < this.tagMeshes.length) {
          this.tagMeshes[i].position.x = d.world.x;
          this.tagMeshes[i].position.y = d.world.y;
          this.tagMeshes[i].position.z = d.world.z;
          this.tagMeshes[i].name = "tag_" + d.content;
          this.tagMeshes[i].material.color.setRGB(d.red, d.green, d.blue);
          var scale = d.world.radius * 1.1;
          this.tagMeshes[i].scale.set(scale, scale, scale);
          this.tagMeshes[i].content = d.content;
          this.tagMeshes[i].action = d.action;
          this.tagMeshes[i].visible = true;
          tagsUsed++;
        }
      }
    }
    for (var i = tagsUsed; i < this.tagMeshes.length; i++) {
      this.tagMeshes[i].position.x = -999;
      this.tagMeshes[i].position.z = -999;
      this.tagMeshes[i].visible = false;
    }
  };

  this.mouseArrowPosition = (x, y) => {
    // Check for bottom corners
    var video = document.querySelector("#graphicsContainer");
    var p = null;
    if (video) {
      // // if (y < video.clientTop + video.clientHeight && y > video.clientTop + video.clientHeight - (video.clientHeight * 0.2)) {
      // 	// Bottom 20% of the video
      // 	if (x < video.clientLeft + (video.clientWidth * 0.3)) {
      // 		p = "bottomLeft";
      // 	} else if (x >= video.clientLeft + video.clientWidth - (video.clientWidth * 0.3)) {
      // 		p = "bottomRight";
      // 	} else if (y >= video.clientTop + video.clientHeight - (video.clientHeight * 0.08)) {
      if (x < video.clientLeft + (video.clientWidth * 0.08)) {
        p = "extremeLeft";
      } else if (x >= video.clientLeft + video.clientWidth - (video.clientWidth * 0.08)) {
        p = "extremeRight";
      } else if (y >= video.clientTop + video.clientHeight - (video.clientHeight * 0.08)) {
        p = "extremeBottom";
      } else if (y < video.clientTop + (video.clientHeight * 0.08)) {
        p = "extremeTop";
      }
    }
    return p;
  };

  this.showArrow = (x, y, rotation) => {
    if (!this.arrow || ctrlMenuVisible()) { return; }
    this.arrow.style.left = x + "px";
    this.arrow.style.top = y + "px";
    this.arrow.style.transformOrigin = "0px 0px";
    this.arrow.style.transform = "rotate(" + rotation + "deg) translate(-20px, -24px)";
    this.arrow.style.display = "block";
  };
  this.hideArrow = () => {
    this.arrow.style.display = "none";
  };
  this.clickArrow = () => {
    this.arrow.style.backgroundPosition = "0px -53px";
    this.arrow.style.opacity = 1.0;
  };
  this.unclickArrow = () => {
    this.arrow.style.backgroundPosition = "0px 0px";
    this.arrow.style.opacity = 0.75;
  };

  this.showHelper = () => {
    this.gp.scene.add(this.gp.gridHelper);
    this.gp.shouldRender = true;
  };

  this.hideHelper = () => {
    this.gp.scene.remove(this.gp.gridHelper);
    this.gp.shouldRender = true;
  };

  this.arrowVisible = () => {
    return (this.arrow.style.display == "block");
  };

  this.resetCameraPosition = () => {
    var cameraPose = {
      position: {
        x: 0 * .0254,
        y: 0 * .0254, // distance to center of base along the wheel axels
        z: 47.625 * .0254
      },
      rotation: {
        roll: degToRad(0.0), //
        pitch: degToRad(10.0), // driving/wheel axis, was 14
        yaw: 0
      }
    };
    this.gp.camera.position.set(0, cameraPose.position.z, -cameraPose.position.x);
    this.gp.camera.rotation.set(degToRad(-180) + cameraPose.rotation.pitch, degToRad(0), degToRad(180));
    this.gp.shouldRender = true;
  };

  this.setPose = (data) => {
    if (data && data.wideCamera) {
      this.gp.camera.position.set(data.wideCamera.x, data.wideCamera.y, data.wideCamera.z);
      this.gp.camera.setRotationFromQuaternion(new THREE.Quaternion(
        data.wideCamera.quaternion.x,
        data.wideCamera.quaternion.y,
        data.wideCamera.quaternion.z,
        data.wideCamera.quaternion.w
      ));
      if (data.wideCamera.viewport) {
        // if (this.viewport &&
        // 	(data.wideCamera.viewport.x != this.viewport.x
        // 	|| data.wideCamera.viewport.y != this.viewport.y
        // 	|| data.wideCamera.viewport.zoom != this.viewport.zoom)
        // ) {
        // 	this.gp.shouldRender = true;
        // }
        this.viewport = data.wideCamera.viewport;
      }
      this.latestPose = data.wideCamera;
      this.gp.shouldRender = true;
    }
  };

  this.updateGridFullscreen = (fullscreen) => {
    this.gp.fullscreen = fullscreen;
    this.updateCanvasSize();
  };

  this.updateCanvasSize = () => {
    var ref = $("#graphicsContainer");
    if (this.gp.element && this.gp.renderer && ref) {
      this.gp.size = { width: ref.width(), height: ref.height() };
      this.gp.renderer.setSize(this.gp.size.width, this.gp.size.height);
      this.gp.element.style.width = this.gp.size.width + "px";
      this.gp.element.style.height = this.gp.size.height + "px";
      this.gp.needsUpdate = true;
    }
  };

  this.indexFromPoint = (grid, x, y) => {
    if (y < grid.origin.x || y >= grid.origin.x + grid.size.width
      || x < grid.origin.y || x >= grid.origin.y + grid.size.height) {
      return -1;
    }
    return Math.floor((y - grid.origin.x) / grid.step) * grid.cols + Math.floor((x - grid.origin.y) / grid.step);
    // return Math.floor((y - grid.origin.y) / grid.step) * grid.cols + Math.floor((x - grid.origin.x) / grid.step);
  };

  this.reduced = (grid, i) => {
    if (!grid) {
      return [0, 0];
    }
    return [
      grid.origin.x + (Math.floor(i / grid.cols) * grid.step),
      grid.origin.y + ((i % grid.cols) * grid.step)
    ];
  };

  this.gridCoordsFromIndex = (grid, index) => {
    var [x, y] = this.reduced(grid, index);
    return [
      Math.floor((x - grid.origin.x) / grid.step),
      Math.floor((y - grid.origin.y) / grid.step)
    ];
  };

  this.gridCoordsFromPoint = (grid, x, y) => {
    var index = this.indexFromPoint(grid, x, y);
    return this.gridCoordsFromIndex(grid, index);
  };

  this.indexIsDrivable = (grid, i) => {
    if (!grid) {
      return false;
    }
    // var z = grid.buf[i] * grid.zStep;
    var z = grid.buf[i];
    if (i > grid.bufferLength * 0.75) {
      // z *= 0.5;
      z *= 0.7;
    }
    return (z <= 0.1 && z >= -0.1); // These are now the slopes, with the new GPU process.
  };

  this.gpPlay = () => {
    this.gp.paused = false;
  };

  this.gpPause = () => {
    this.gp.paused = true;
  };

  this.pathToPoint = (grid, targetX, targetY) => {
    if (!grid) {
      return null;
    }
    if (targetX < grid.origin.x || targetX >= grid.origin.x + grid.size.width
      || targetY < grid.origin.y || targetY >= grid.origin.y + grid.size.height) {
      return [];
    }

    var all = [];
    for (var i = 0; i < grid.buf.length; i++) {
      all.push((this.indexIsDrivable(grid, i)) ? 1 : 0);
    }
    var g = [];
    for (var i = 0; i < grid.rows; i++) {
      g.push(all.slice(i * grid.cols, (i + 1) * grid.cols));
    }
    var graph = new Graph(g, { diagonal: true });
    var start = graph.grid[12][10];
    var [x, y] = this.gridCoordsFromPoint(grid, targetX, targetY);
    var end = graph.grid[x][y];
    var result = astar.search(graph, start, end, { heuristic: astar.heuristics.diagonal });
    return result;
  };

  this.setupWheelZoom = () => {
    var lastWheelDate = new Date();
    this.gp.element.addEventListener("wheel", (e) => {
      e.preventDefault();
      e.stopPropagation();

      var percent = {
        x: (e.offsetX / this.gp.size.width - 0.5) * 2,
        y: (e.offsetY / this.gp.size.height - 0.5) * 2
      };

      var direction = -Math.sign(e.deltaY);

      // Allow faster zooming out
      if ((direction > 0 && new Date() - lastWheelDate < 250)
        || (direction < 0 && new Date() - lastWheelDate < 50)) {
        return;
      }
      if (direction > 0) {
        this.zoomIn(percent.x, percent.y);
      } else if (direction < 0) {
        this.zoomOut();
      }

      lastWheelDate = new Date();
    });
  };

  this.zoomIn = (x, y) => {
    if (!x) { x = 0; }
    if (!y) { y = 0; }
    sendCommandWithData(kDRCommandPTZIn, { x: x, y: y });
  };

  this.zoomOut = () => {
    sendCommand(kDRCommandPTZOut);
  };

  this.endSession = () => {
    if (this.clickHoldInterval) {
      window.clearInterval(this.clickHoldInterval);
      this.clickHoldInterval = null;
    }
    // TODO teardown more stuff
  };

  // // Raw websocket
  // this.ws = null;
  // this.connectWebSocketTimeout = null;
  // this.connectWebSocket = () => {
  // 	if (this.ws) { this.ws.close(); }
  // 	if (this.connectWebSocketTimeout) {
  // 		window.clearTimeout(this.connectWebSocketTimeout);
  // 		this.connectWebSocketTimeout = null;
  // 	}
  //
  // 	this.ws = new WebSocket('wss://10.0.1.16:8443');
  // 	this.ws.onopen = (event) => {
  // 		console.log("WebSocket open");
  // 	};
  // 	this.ws.onclose = (event) => {
  // 		ws = null;
  // 		if (!this.connectWebSocketTimeout) {
  // 			this.connectWebSocketTimeout = window.setTimeout(this.connectWebSocket, 2000);
  // 		}
  // 	};
  // 	this.ws.onerror = (event) => {
  // 		if (this.ws) { this.ws.close(); }
  // 		this.ws = null;
  // 		if (!this.connectWebSocketTimeout) {
  // 			this.connectWebSocketTimeout = window.setTimeout(this.connectWebSocket, 2000);
  // 		}
  // 	};
  // 	this.ws.onmessage = (event) => {
  // 		// console.log(event.data);
  // 		var obj;
  // 		try {
  // 			obj = JSON.parse(event.data);
  // 		} catch (err) {
  //
  // 		}
  // 		if (obj) {
  // 			var unhandled = this.processMessage(obj.logs);
  // 			if (obj.level == "standard" && Array.isArray(unhandled) && unhandled.length > 0) {
  // 				console.log(unhandled);
  // 			}
  // 		}
  // 	};
  // }
  //
  // this.sendCommand = (command, data) => {
  // 	var out = {
  // 		c: command
  // 	};
  // 	if (data) {
  // 		out.d = data;
  // 	}
  // 	if (this.ws && this.ws.readyState === 1) {
  // 		this.ws.send(JSON.stringify(out));
  // 	}
  // }
  //
  // // Process Messages
  // this.processMessage = (message) => {
  // 	var arr = null;
  // 	if (Array.isArray(message)) {
  // 		arr = message;
  // 	} else {
  // 		arr = [message];
  // 	}
  //
  // 	var unhandled = [];
  // 	for (var i = 0; i < arr.length; i++) {
  // 		var message = arr[i];
  //
  // 		switch (message.key) {
  //
  // 			// DRRealSense
  // 			case "floorFrame": {
  // 				this.drawFrame(message.data);
  // 				break;
  // 			}
  // 			case "frontFrame": {
  // 				this.drawFrame(message.data);
  // 				break;
  // 			}
  //
  // 		}
  // 	}
  // 	return unhandled;
  // }

  this.init();
}

function pointRotatedBy(point, angleInRadians) {
  var s = Math.sin(angleInRadians);
  var c = Math.cos(angleInRadians);
  return {
    x: point.x * c - point.y * s,
    y: point.x * s + point.y * c
  };
}

/**
 * Draws a polygon with rounded corners
 * @param {CanvasRenderingContext2D} ctx The canvas context
 * @param {Array} points A list of `{x, y}` points
 * @radius {number} how much to round the corners
 */
function roundedPoly(ctx, points, radius) {
  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);

  const lerp = (a, b, x) => a + (b - a) * x;

  const lerp2D = (p1, p2, t) => ({
    x: lerp(p1.x, p2.x, t),
    y: lerp(p1.y, p2.y, t)
  });

  const numPoints = points.length;

  let corners = [];
  for (let i = 0; i < numPoints; i++) {
    let lastPoint = points[i];
    let thisPoint = points[(i + 1) % numPoints];
    let nextPoint = points[(i + 2) % numPoints];

    let lastEdgeLength = distance(lastPoint, thisPoint);
    let lastOffsetDistance = Math.min(lastEdgeLength / 2, radius);
    let start = lerp2D(
      thisPoint,
      lastPoint,
      lastOffsetDistance / lastEdgeLength
    );

    let nextEdgeLength = distance(nextPoint, thisPoint);
    let nextOffsetDistance = Math.min(nextEdgeLength / 2, radius);
    let end = lerp2D(
      thisPoint,
      nextPoint,
      nextOffsetDistance / nextEdgeLength
    );

    corners.push([start, thisPoint, end]);
  }

  ctx.moveTo(corners[0][0].x, corners[0][0].y);
  for (let [start, ctrl, end] of corners) {
    ctx.lineTo(start.x, start.y);
    ctx.quadraticCurveTo(ctrl.x, ctrl.y, end.x, end.y);
  }

  ctx.closePath();
}
// DRDrawMinimap

function DRDrawMinimap() {

  this.init = () => {
    this.renderer = new THREE.WebGLRenderer({
      antialias: true,	// to get smoother output
      preserveDrawingBuffer: true,	// to allow screenshot,
      alpha: true
    });
    this.renderer.setClearColor(0x222222, 1.0);
    this.hideableJqueryObject = $("#minimap");
    this.element = document.querySelector("#minimapThreeContainer");
    this.element.appendChild(this.renderer.domElement);
    this.size = { width: $(this.element).width(), height: $(this.element).height() };
    this.renderer.setSize(this.size.width, this.size.height);
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(35, 1.6, 0.01, 100);
    this.camera.position.set(0, 0.26, -0.4);
    this.camera.up = new THREE.Vector3(0, 1, 0);
    this.scene.add(this.camera);
    this.camera.lookAt(0, 0, 3);

    var color = 0x222222;
    this.scene.background = new THREE.Color(color);
    this.scene.fog = new THREE.Fog(color, 1, 2.5);

    this.shouldRender = true;
    this.paused = true;
    this.animate = () => {
      if (!this.paused) {
        requestAnimationFrame(this.animate);
        if (this.shouldRender && this.hideableJqueryObject.is(":visible")) {
          this.render();
          this.shouldRender = false;
        }
      }
    };
    this.render = () => {
      this.renderer.render(this.scene, this.camera);
    };

    this.createTargetIcon();

    this.ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    this.scene.add(this.ambientLight);

    this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
    this.directionalLight.target = this.targetContainer;
    this.scene.add(this.directionalLight);

    // Draw the grid starting at zero instead of -0.5
    this.grid = this.createGrid({
      origin: {
        x: -0.5,
        y: -1
      },
      size: {
        width: 2,
        height: 2.5
      },
      step: 0.05,
      zStep: 0.01
    }, -0.003);

    // move mouse object on hover
    var mouse = { x: 0, y: 0 };
    var onMouseMove = (event) => {
      event.preventDefault();
      this.updateMousePosition(event);
      this.updateCameraOrbit();
      this.shouldRender = true;
    };
    this.element.addEventListener('mousemove', onMouseMove, false);

    var onMouseOut = (event) => {
      event.preventDefault();
      this.mousePosition = null;
      this.updateCameraOrbit();
      this.shouldRender = true;
    };
    this.element.addEventListener('mouseout', onMouseOut, false);

    this.behindDistance = 0;

    this.animate();
  };

  this.updateMousePosition = (event) => {
    var elementPosition = $("#minimapThreeContainer canvas").offset();
    this.mousePosition = {
      x: event.clientX + document.body.scrollLeft - elementPosition.left,
      y: event.clientY + document.body.scrollTop - elementPosition.top,
      xPercent: ((event.clientX - elementPosition.left) / this.size.width) * 2 - 1,
      yPercent: - ((event.clientY - elementPosition.top) / this.size.height) * 2 + 1
    };
  };

  this.updateCameraOrbit = () => {
    if (this.mousePosition) {
      this.camera.position.set(this.mousePosition.xPercent * -0.15, this.mousePosition.yPercent * 0.15 + 0.26, -0.4);
    } else {
      this.camera.position.set(0, 0.26, -0.4);
    }
    this.camera.lookAt(0, 0, 3);
  };

  this.drawFrame = (data) => {
    if (data.detectors.hasOwnProperty("behind")) {
      this.behindDistance = parseFloat(data.detectors.behind.distance) || 0;
    }
    if (data.detectors.heightGrid) {
      var string = data.detectors.heightGrid.string;
      var config = this.grid.config;

      var maxValues = 78;
      var charCodeOffset = 48; // We start at the zero ASCII character.

      for (var i = 0; i < string.length; i++) {
        var gridIndex = i;
        var code = string.charCodeAt(gridIndex);
        var value = code - charCodeOffset - maxValues / 2;
        var y = value / (maxValues / 2);
        if (gridIndex < 560) { // hide from -0.5 through 0.2
          y = 0.0;
        }
        this.grid.offsetAttribute.setY(gridIndex, y);
      }
      this.grid.offsetAttribute.needsUpdate = true;
      this.shouldRender = true;
    }
  };

  this.createGrid = (gridConfig, z = 0.0) => {
    var out = {
      config: gridConfig
    };

    // grid
    out.cols = gridConfig.size.width / gridConfig.step;
    out.squares = out.cols * (gridConfig.size.height / gridConfig.step);

    var position = [];
    // var orientation = [];
    // var colors = [];

    var tempBox = new THREE.BoxBufferGeometry(gridConfig.step, 1.0, gridConfig.step, 1, 1, 1);
    out.bGeometry = new THREE.InstancedBufferGeometry();
    out.bGeometry.index = tempBox.index;
    out.bGeometry.attributes.position = tempBox.attributes.position;
    out.bGeometry.attributes.uv = tempBox.attributes.uv;

    for (var i = 0; i < out.squares; i++) {
      position.push(
        gridConfig.origin.y + ((i % out.cols) * gridConfig.step) + gridConfig.step / 2,
        z,
        gridConfig.origin.x + (Math.floor(i / out.cols) * gridConfig.step) + gridConfig.step / 2
      );
    }
    out.offsetAttribute = new THREE.InstancedBufferAttribute(new Float32Array(position), 3);
    out.bGeometry.addAttribute("offset", out.offsetAttribute);

    // material
    var material = new THREE.ShaderMaterial({
      uniforms: {
        "nearGrayValue": { value: 1.0 },
        "farGrayValue": { value: 0.2 },
        "nearDistance": { value: 0.2 },
        "farDistance": { value: 2.0 }
      },
      vertexShader: `
				varying float depthValue;
				varying float heightValue;
				attribute vec3 offset;
				varying vec3 vOffset;
				varying mat4 vPosition;
				void main() {

					float y = offset.y;

					// float distanceModifiedY = y * (1.0 - offset.z / 2.0 / 10.0);
					float distanceModifiedY = y;

					float yForScale = y;
					float yForTranslate = y / 2.0;
					if ((y <= 0.05 && y >= -0.05) || offset.z < 0.1 || (distanceModifiedY <= 0.05 && distanceModifiedY >= -0.5)) {
						y = 0.01;
						yForScale = y;
						yForTranslate = y / 2.0;
					}
					if (y < 0.0) {
						// y = 0.0;
						yForScale *= -1.0;
						yForTranslate *= 3.0;
					}

					heightValue = y;

					// Scale
					// mat4 scaleMatrix = mat4(
					// 	vec4(1.0,0.0,0.0,0.0), // x
					// 	vec4(0.0, y ,0.0,0.0), // y
					// 	vec4(0.0,0.0,1.0,0.0), // z
					// 	vec4(0.0,0.0,0.0,1.0));

					// vec3 offsetHalfY = vec3(offset.x, y / 2.0, offset.z);
					vec4 cs_position = modelViewMatrix * vec4(offset + position, 1.0);
					depthValue = -cs_position.z;
					// gl_Position = projectionMatrix * scaleMatrix * cs_position;


					vOffset = vec3(offset.x, 0.0, offset.z);

					float translationX = 0.0;
					float translationY = yForTranslate;
					float translationZ = 0.0;
					float scaleX = 1.0;
					float scaleY = yForScale;
					float scaleZ = 1.0;
					float rotationX = 0.0;
					float rotationY = 0.0;
					float rotationZ = 0.0;

					// Translate
					mat4 tPos = mat4(vec4(1.0,0.0,0.0,0.0),
					               vec4(0.0,1.0,0.0,0.0),
					               vec4(0.0,0.0,1.0,0.0),
					               vec4(translationX,translationY,translationZ,1.0));

					// Rotate
					mat4 rXPos = mat4(vec4(1.0,0.0,0.0,0.0),
					                vec4(0.0,cos(rotationX),-sin(rotationX),0.0),
					                vec4(0.0,sin(rotationX),cos(rotationX),0.0),
					                vec4(0.0,0.0,0.0,1.0));

					mat4 rYPos = mat4(vec4(cos(rotationY),0.0,sin(rotationY),0.0),
					                vec4(0.0,1.0,0.0,0.0),
					                vec4(-sin(rotationY),0.0,cos(rotationY),0.0),
					                vec4(0.0,0.0,0.0,1.0));

					mat4 rZPos = mat4(vec4(cos(rotationZ),-sin(rotationZ),0.0,0.0),
					                vec4(sin(rotationZ),cos(rotationZ),0.0,0.0),
					                vec4(0.0,0.0,1.0,0.0),
					                vec4(0.0,0.0,0.0,1.0));

					// Scale
					mat4 sPos = mat4(vec4(scaleX,0.0,0.0,0.0),
					                vec4(0.0,scaleY,0.0,0.0),
					                vec4(0.0,0.0,scaleZ,0.0),
					                vec4(0.0,0.0,0.0,1.0));

					vPosition =  tPos * rXPos * rZPos * rYPos * sPos;

					gl_Position = projectionMatrix * modelViewMatrix * vPosition * vec4(vOffset + position, 1.0);

				}
			`,
      fragmentShader: `
				#include <packing>
				uniform float nearGrayValue;
				uniform float farGrayValue;
				uniform float nearDistance;
				uniform float farDistance;
				varying float depthValue;
				varying float heightValue;
				varying vec3 vOffset;

				void main() {
					float depthPercent = max(0.0, min(1.0, (depthValue - nearDistance) / (farDistance - nearDistance)));
					float grayValue = (farGrayValue - nearGrayValue) * depthPercent + nearGrayValue;
					// float grayValue = max(0.0, min(1.0, depthValue / 2.0));
					if (heightValue >= -0.01 && heightValue <= 0.02) {
						// Green floor
						grayValue *= 0.8;
						gl_FragColor = vec4(grayValue * 0.3, grayValue * 0.9, grayValue * 0.3, 1.0);

					} else if (vOffset.x >= -0.15 && vOffset.x <= 0.15 && vOffset.z <= 0.6) {
						// Red center obstacles
						gl_FragColor = vec4(grayValue, grayValue * 0.4, grayValue * 0.4, 1.0);

					// } else if (vOffset.x >= -0.5 && vOffset.x <= 0.5 && vOffset.z <= 1.2) {
					// 	// Yellow sides obstacles
					// 	gl_FragColor = vec4(grayValue, grayValue, grayValue * 0.4, 1.0);

					} else {
						gl_FragColor = vec4(grayValue, grayValue, grayValue, 1.0);
					}
					// gl_FragColor = vec4(0.0, 0.8, 0.0, 1.0);
				}
			`,
      transparent: false
    });

    // material = new THREE.MeshLambertMaterial({ color: 0x77CC77, side: THREE.DoubleSide });

    out.bMesh = new THREE.Mesh(out.bGeometry, material);
    out.bMesh.position.set(0, 0, 0);
    out.bMesh.frustumCulled = false;

    this.scene.add(out.bMesh);

    return out;
  };

  this.enableMapControls = () => {
    // map-style controls
    this.controls = new THREE.MapControls(this.camera, this.element);
    this.controls.panSpeed = 1.0;
    this.controls.rotateSpeed = 0.25;
    this.controls.zoomSpeed = 0.5;
    this.controls.mouseButtons = { LEFT: THREE.MOUSE.LEFT, MIDDLE: null, RIGHT: THREE.MOUSE.RIGHT };
    this.controls.enableKeys = false;
    this.controls.target = new THREE.Vector3(0.4, 0, 0.75);
    this.controls.addEventListener("change", (event) => {
      this.shouldRender = true;
    });
    this.controls.update();
  };

  this.createTargetIcon = () => {
    var shape = new THREE.Shape();
    shape.moveTo(0, 0);
    shape.bezierCurveTo(-.06, 0, -.47, .70, 0, .72);
    shape.bezierCurveTo(.47, .70, .06, 0, 0, 0);

    var hole = new THREE.EllipseCurve(
      0, .499,            // ax, aY
      .14, .14,           // xRadius, yRadius
      0, 2 * Math.PI,  // aStartAngle, aEndAngle
      false,            // aClockwise
      0                 // aRotation
    );
    var holePath = new THREE.CurvePath();
    holePath.add(hole);
    holePath.closePath();
    var holeShape = new THREE.Shape(holePath.getPoints(20));
    holeShape.closePath();
    shape.holes = [
      holeShape
    ];

    var extrudeSettings = {
      curveSegments: 30,
      steps: 4,
      depth: .10,
      bevelEnabled: false,
      bevelThickness: 0,
      bevelSize: 0,
      bevelOffset: 0,
      bevelSegments: 0
    };

    var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    geometry.translate(0, 0, -.05);
    geometry.computeVertexNormals();
    for (var i = 0; i < geometry.faces.length; i++) {
      var face = geometry.faces[i];
      if (face.materialIndex == 1) {
        for (var j = 0; j < face.vertexNormals.length; j++) {
          face.vertexNormals[j].z = 0;
          face.vertexNormals[j].normalize();
        }
      }
    }

    var materials = [
      new THREE.MeshPhongMaterial({ color: 0x55FF00, flatShading: true }), // front
      new THREE.MeshPhongMaterial({ color: 0x55FF00, flatShading: false }) // side
    ];

    // Target icon
    this.targetMesh = new THREE.Mesh(
      new THREE.BufferGeometry().fromGeometry(geometry),
      new THREE.MultiMaterial(materials)
    );

    // Ring on floor
    var ringGeometry = new THREE.RingGeometry(0.2, 0.3, 32, 2);
    ringGeometry.rotateX(degToRad(-90));

    var filledRingGeometry = new THREE.RingGeometry(0.001, 0.3, 32, 2);
    filledRingGeometry.rotateX(degToRad(-90));
    ringGeometry.morphTargets.push({ name: "filled", vertices: filledRingGeometry.vertices });

    this.targetRingMesh = new THREE.Mesh(
      new THREE.BufferGeometry().fromGeometry(ringGeometry),
      new THREE.MeshPhongMaterial({ color: 0x55FF00, flatShading: true, morphTargets: true }),
    );
    this.targetRingMesh.position.set(0, 0.014, 0);
    this.targetMesh.visible = false;

    this.targetRingMesh.updateMorphTargets();

    this.targetContainer = new THREE.Object3D();

    // Add them to the scene
    this.targetContainer.add(this.targetRingMesh);
    this.targetContainer.add(this.targetMesh);
    this.targetContainer.scale.set(0.75, 0.75, 0.75);
    // this.targetContainer.position.set(-0.1, 0.0021, 1.9);
    // this.gp.scene.add(this.targetContainer);
  };

  this.showTargetIcon = (x, y) => {
    this.scene.add(this.targetContainer);
    this.targetContainer.position.set(-y, 0, x);
    this.targetEndPosition = null;
    if (!this.targetIconInterval) {
      this.targetIconInterval = window.setInterval(() => {
        this.targetMesh.rotation.y -= 0.010;
        this.tickTargetPosition();
        this.shouldRender = true;
      }, 1 / 30);
    }
    this.popTarget();
  };

  this.tickTargetPosition = () => {
    if (!this.targetEndPosition) { return; }
    if (!this.p) {
      this.p = 0.03;
    }
    var xDiff = this.targetEndPosition.x - this.targetContainer.position.x;
    var yDiff = this.targetEndPosition.y - this.targetContainer.position.z;
    if (Math.abs(xDiff) < 0.01 && Math.abs(yDiff) < 0.01) {
      this.targetEndPosition = null;
    } else {
      var x = this.targetContainer.position.x + xDiff * this.p;
      var y = this.targetContainer.position.z + yDiff * this.p;
      this.targetContainer.position.set(x, 0, y);
    }
  };

  this.moveTargetIcon = (x, y) => {
    this.targetEndPosition = { x: -y, y: x };
  };

  this.hideTargetIcon = () => {
    this.scene.remove(this.targetContainer);
    if (this.targetIconInterval) {
      window.clearInterval(this.targetIconInterval);
      this.targetIconInterval = null;
    }
  };

  this.targetArrived = () => {
    console.log("target arrived");
    this.targetArrivedInterval = window.setInterval(() => {
      this.targetRingMesh.morphTargetInfluences[0] += 1.0 / 9.0;
      if (this.targetRingMesh.morphTargetInfluences[0] >= 1.0) {
        this.hideTargetIcon();
        window.clearInterval(this.targetArrivedInterval);
        this.targetArrivedInterval = null;
      }
    }, 1000 / 30);
  };

  this.popTarget = () => {
    this.targetMesh.scale.set(0.1, 0.1, 0.1);
    this.targetRingMesh.scale.set(0.1, 0.1, 0.1);
    this.targetRingMesh.visible = true;
    this.targetMesh.visible = false;
    this.targetContainer.visible = true;
    this.targetMesh.rotation.y = degToRad(110);
    this.targetRingMesh.morphTargetInfluences[0] = 0;

    if (this.targetPopInterval) {
      window.clearInterval(this.targetPopInterval);
    }
    var increasing = true;
    var yMax = 1.2;
    var yRate = 0.02;
    this.targetPopInterval = window.setInterval(() => {
      this.targetMesh.rotation.y -= 0.02;

      if (this.targetRingMesh.scale.z < 1.0) {
        var newScale = this.targetRingMesh.scale.z * 1.14;
        this.targetRingMesh.scale.set(newScale, newScale, newScale);
        if (this.targetRingMesh.scale.z >= 1.0) {
          this.targetMesh.visible = false; // TODO: re-enable true;
        }

      } else if (this.targetMesh.scale.z < 1.0) {
        var newScale = this.targetMesh.scale.z * 1.1;
        this.targetMesh.scale.set(newScale, newScale, newScale);
        if (this.targetMesh.scale.z == 1.0) {
          this.targetMesh.scale.set(1, 1.001, 1);
        }

      } else if (increasing) {
        this.targetMesh.scale.set(this.targetMesh.scale.x - yRate, this.targetMesh.scale.y + yRate, 1);
        if (this.targetMesh.scale.y >= yMax) {
          increasing = false;
        }

      } else if (!increasing && this.targetMesh.scale.y > 1.0) {
        this.targetMesh.scale.set(this.targetMesh.scale.x + yRate, this.targetMesh.scale.y - yRate, 1);

      } else {
        this.targetMesh.scale.set(1, 1, 1);
        window.clearInterval(this.targetPopInterval);
        this.targetPopInterval = null;
      }
    }, 1 / 30);
  };

  this.setModifyDriveControls = (values) => {
    return; // TODO disabled for the video
    // {
    // 	"input": {
    // 		"throttle": 1,
    // 		"turn": 0,
    // 		"powerDrive": false
    // 	},
    // 	"output": {
    // 		"throttle": 0.40606060606060607,
    // 		"turn": -0.6,
    // 		"powerDrive": false
    // 	},
    // 	"level": 2,
    // 	"modified": true,
    // 	"modifiers": [
    // 		"approach",
    // 		"divert"
    // 	],
    // 	"diversion": {
    // 		"turn": "0.000"
    // 	}
    // }
    if (values.modified && values.modifiers && values.modifiers.indexOf("divert") >= 0) {
      var label = $("#minimapLabel");
      label.text("Diverting...");
      label.show();

      if (this.modifyDriveControlsLabelTimeout) {
        window.clearTimeout(this.modifyDriveControlsLabelTimeout);
      }
      this.modifyDriveControlsLabelTimeout = window.setTimeout(() => {
        this.clearModifyDriveControls();
        this.modifyDriveControlsLabelTimeout = null;
      }, 500);
    }
  };

  this.clearModifyDriveControls = () => {
    var label = $("#minimapLabel");
    label.text("");
    label.hide();
  };

  this.toggle = () => {
    if (this.hideableJqueryObject.is(":visible")) {
      this.hide();
    } else {
      this.show();
    }
  };

  this.hide = () => {
    this.hideableJqueryObject.hide();
    this.paused = true;
  };

  this.show = () => {
    this.hideableJqueryObject.show();
    this.paused = false;
    requestAnimationFrame(this.animate);
  };

  this.init();
}
'use strict';

// Last time updated: 2019-02-20 3:31:30 PM UTC

// _______________
// getStats v1.2.0

// Open-Sourced: https://github.com/muaz-khan/getStats

// --------------------------------------------------
// Muaz Khan     - www.MuazKhan.com
// MIT License   - www.WebRTC-Experiment.com/licence
// --------------------------------------------------

"use strict"; var getStats = function (mediaStreamTrack, callback, interval) { function getStatsLooper() { getStatsWrapper(function (results) { if (results && results.forEach) { results.forEach(function (result) { Object.keys(getStatsParser).forEach(function (key) { if ("function" == typeof getStatsParser[key]) try { getStatsParser[key](result); } catch (e) { console.error(e.message, e.stack, e); } }); }); try { peer.iceConnectionState.search(/failed|closed|disconnected/gi) !== -1 && (nomore = !0); } catch (e) { nomore = !0; } nomore === !0 && (getStatsResult.datachannel && (getStatsResult.datachannel.state = "close"), getStatsResult.ended = !0), getStatsResult.results = results, getStatsResult.audio && getStatsResult.video && (getStatsResult.bandwidth.speed = getStatsResult.audio.bytesSent - getStatsResult.bandwidth.helper.audioBytesSent + (getStatsResult.video.bytesSent - getStatsResult.bandwidth.helper.videoBytesSent), getStatsResult.bandwidth.helper.audioBytesSent = getStatsResult.audio.bytesSent, getStatsResult.bandwidth.helper.videoBytesSent = getStatsResult.video.bytesSent), callback(getStatsResult), nomore || void 0 != typeof interval && interval && setTimeout(getStatsLooper, interval || 1e3); } }); } function getStatsWrapper(cb) { "undefined" != typeof window.InstallTrigger || isSafari ? peer.getStats(window.mediaStreamTrack || null).then(function (res) { var items = []; res.forEach(function (r) { items.push(r); }), cb(items); })["catch"](cb) : peer.getStats(function (res) { var items = []; res.result().forEach(function (res) { var item = {}; res.names().forEach(function (name) { item[name] = res.stat(name); }), item.id = res.id, item.type = res.type, item.timestamp = res.timestamp, items.push(item); }), cb(items); }); } var browserFakeUserAgent = "Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45"; !function (that) { that && "undefined" == typeof window && "undefined" != typeof global && (global.navigator = { userAgent: browserFakeUserAgent, getUserMedia: function () { } }, global.console || (global.console = {}), "undefined" != typeof global.console.log && "undefined" != typeof global.console.error || (global.console.error = global.console.log = global.console.log || function () { console.log(arguments); }), "undefined" == typeof document && (that.document = { documentElement: { appendChild: function () { return ""; } } }, document.createElement = document.captureStream = document.mozCaptureStream = function () { var obj = { getContext: function () { return obj; }, play: function () { }, pause: function () { }, drawImage: function () { }, toDataURL: function () { return ""; } }; return obj; }, that.HTMLVideoElement = function () { }), "undefined" == typeof location && (that.location = { protocol: "file:", href: "", hash: "" }), "undefined" == typeof screen && (that.screen = { width: 0, height: 0 }), "undefined" == typeof URL && (that.URL = { createObjectURL: function () { return ""; }, revokeObjectURL: function () { return ""; } }), "undefined" == typeof MediaStreamTrack && (that.MediaStreamTrack = function () { }), "undefined" == typeof RTCPeerConnection && (that.RTCPeerConnection = function () { }), that.window = global); }("undefined" != typeof global ? global : null); var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection; "undefined" == typeof MediaStreamTrack && (MediaStreamTrack = {}); var systemNetworkType = ((navigator.connection || {}).type || "unknown").toString().toLowerCase(), getStatsResult = { encryption: "sha-256", audio: { send: { tracks: [], codecs: [], availableBandwidth: 0, streams: 0, framerateMean: 0, bitrateMean: 0 }, recv: { tracks: [], codecs: [], availableBandwidth: 0, streams: 0, framerateMean: 0, bitrateMean: 0 }, bytesSent: 0, bytesReceived: 0, latency: 0, packetsLost: 0 }, video: { send: { tracks: [], codecs: [], availableBandwidth: 0, streams: 0, framerateMean: 0, bitrateMean: 0 }, recv: { tracks: [], codecs: [], availableBandwidth: 0, streams: 0, framerateMean: 0, bitrateMean: 0 }, bytesSent: 0, bytesReceived: 0, latency: 0, packetsLost: 0 }, bandwidth: { systemBandwidth: 0, sentPerSecond: 0, encodedPerSecond: 0, helper: { audioBytesSent: 0, videoBytestSent: 0 }, speed: 0 }, results: {}, connectionType: { systemNetworkType: systemNetworkType, systemIpAddress: "192.168.1.2", local: { candidateType: [], transport: [], ipAddress: [], networkType: [] }, remote: { candidateType: [], transport: [], ipAddress: [], networkType: [] } }, resolutions: { send: { width: 0, height: 0 }, recv: { width: 0, height: 0 } }, internal: { audio: { send: {}, recv: {} }, video: { send: {}, recv: {} }, candidates: {} }, nomore: function () { nomore = !0; } }, getStatsParser = { checkIfOfferer: function (result) { "googLibjingleSession" === result.type && (getStatsResult.isOfferer = result.googInitiator); } }, isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), peer = this; if (!(arguments[0] instanceof RTCPeerConnection)) throw "1st argument is not instance of RTCPeerConnection."; peer = arguments[0], arguments[1] instanceof MediaStreamTrack && (mediaStreamTrack = arguments[1], callback = arguments[2], interval = arguments[3]); var nomore = !1; getStatsParser.datachannel = function (result) { "datachannel" === result.type && (getStatsResult.datachannel = { state: result.state }); }, getStatsParser.googCertificate = function (result) { "googCertificate" == result.type && (getStatsResult.encryption = result.googFingerprintAlgorithm), "certificate" == result.type && (getStatsResult.encryption = result.fingerprintAlgorithm); }, getStatsParser.checkAudioTracks = function (result) { if ("audio" === result.mediaType) { var sendrecvType = result.id.split("_").pop(); if (result.isRemote === !0 && (sendrecvType = "recv"), result.isRemote === !1 && (sendrecvType = "send"), sendrecvType) { if (getStatsResult.audio[sendrecvType].codecs.indexOf(result.googCodecName || "opus") === -1 && getStatsResult.audio[sendrecvType].codecs.push(result.googCodecName || "opus"), result.bytesSent) { var kilobytes = 0; getStatsResult.internal.audio[sendrecvType].prevBytesSent || (getStatsResult.internal.audio[sendrecvType].prevBytesSent = result.bytesSent); var bytes = result.bytesSent - getStatsResult.internal.audio[sendrecvType].prevBytesSent; getStatsResult.internal.audio[sendrecvType].prevBytesSent = result.bytesSent, kilobytes = bytes / 1024, getStatsResult.audio[sendrecvType].availableBandwidth = kilobytes.toFixed(1), getStatsResult.audio.bytesSent = kilobytes.toFixed(1); } if (result.bytesReceived) { var kilobytes = 0; getStatsResult.internal.audio[sendrecvType].prevBytesReceived || (getStatsResult.internal.audio[sendrecvType].prevBytesReceived = result.bytesReceived); var bytes = result.bytesReceived - getStatsResult.internal.audio[sendrecvType].prevBytesReceived; getStatsResult.internal.audio[sendrecvType].prevBytesReceived = result.bytesReceived, kilobytes = bytes / 1024, getStatsResult.audio.bytesReceived = kilobytes.toFixed(1); } if (result.googTrackId && getStatsResult.audio[sendrecvType].tracks.indexOf(result.googTrackId) === -1 && getStatsResult.audio[sendrecvType].tracks.push(result.googTrackId), result.googCurrentDelayMs) { var kilobytes = 0; getStatsResult.internal.audio.prevGoogCurrentDelayMs || (getStatsResult.internal.audio.prevGoogCurrentDelayMs = result.googCurrentDelayMs); var bytes = result.googCurrentDelayMs - getStatsResult.internal.audio.prevGoogCurrentDelayMs; getStatsResult.internal.audio.prevGoogCurrentDelayMs = result.googCurrentDelayMs, getStatsResult.audio.latency = bytes.toFixed(1), getStatsResult.audio.latency < 0 && (getStatsResult.audio.latency = 0); } if (result.packetsLost) { var kilobytes = 0; getStatsResult.internal.audio.prevPacketsLost || (getStatsResult.internal.audio.prevPacketsLost = result.packetsLost); var bytes = result.packetsLost - getStatsResult.internal.audio.prevPacketsLost; getStatsResult.internal.audio.prevPacketsLost = result.packetsLost, getStatsResult.audio.packetsLost = bytes.toFixed(1), getStatsResult.audio.packetsLost < 0 && (getStatsResult.audio.packetsLost = 0); } } } }, getStatsParser.checkVideoTracks = function (result) { if ("video" === result.mediaType) { var sendrecvType = result.id.split("_").pop(); if (result.isRemote === !0 && (sendrecvType = "recv"), result.isRemote === !1 && (sendrecvType = "send"), sendrecvType) { if (getStatsResult.video[sendrecvType].codecs.indexOf(result.googCodecName || "VP8") === -1 && getStatsResult.video[sendrecvType].codecs.push(result.googCodecName || "VP8"), result.bytesSent) { var kilobytes = 0; getStatsResult.internal.video[sendrecvType].prevBytesSent || (getStatsResult.internal.video[sendrecvType].prevBytesSent = result.bytesSent); var bytes = result.bytesSent - getStatsResult.internal.video[sendrecvType].prevBytesSent; getStatsResult.internal.video[sendrecvType].prevBytesSent = result.bytesSent, kilobytes = bytes / 1024, getStatsResult.video[sendrecvType].availableBandwidth = kilobytes.toFixed(1), getStatsResult.video.bytesSent = kilobytes.toFixed(1); } if (result.bytesReceived) { var kilobytes = 0; getStatsResult.internal.video[sendrecvType].prevBytesReceived || (getStatsResult.internal.video[sendrecvType].prevBytesReceived = result.bytesReceived); var bytes = result.bytesReceived - getStatsResult.internal.video[sendrecvType].prevBytesReceived; getStatsResult.internal.video[sendrecvType].prevBytesReceived = result.bytesReceived, kilobytes = bytes / 1024, getStatsResult.video.bytesReceived = kilobytes.toFixed(1); } if (result.googFrameHeightReceived && result.googFrameWidthReceived && (getStatsResult.resolutions[sendrecvType].width = result.googFrameWidthReceived, getStatsResult.resolutions[sendrecvType].height = result.googFrameHeightReceived), result.googFrameHeightSent && result.googFrameWidthSent && (getStatsResult.resolutions[sendrecvType].width = result.googFrameWidthSent, getStatsResult.resolutions[sendrecvType].height = result.googFrameHeightSent), result.googTrackId && getStatsResult.video[sendrecvType].tracks.indexOf(result.googTrackId) === -1 && getStatsResult.video[sendrecvType].tracks.push(result.googTrackId), result.framerateMean) { getStatsResult.bandwidth.framerateMean = result.framerateMean; var kilobytes = 0; getStatsResult.internal.video[sendrecvType].prevFramerateMean || (getStatsResult.internal.video[sendrecvType].prevFramerateMean = result.bitrateMean); var bytes = result.bytesSent - getStatsResult.internal.video[sendrecvType].prevFramerateMean; getStatsResult.internal.video[sendrecvType].prevFramerateMean = result.framerateMean, kilobytes = bytes / 1024, getStatsResult.video[sendrecvType].framerateMean = bytes.toFixed(1); } if (result.bitrateMean) { getStatsResult.bandwidth.bitrateMean = result.bitrateMean; var kilobytes = 0; getStatsResult.internal.video[sendrecvType].prevBitrateMean || (getStatsResult.internal.video[sendrecvType].prevBitrateMean = result.bitrateMean); var bytes = result.bytesSent - getStatsResult.internal.video[sendrecvType].prevBitrateMean; getStatsResult.internal.video[sendrecvType].prevBitrateMean = result.bitrateMean, kilobytes = bytes / 1024, getStatsResult.video[sendrecvType].bitrateMean = bytes.toFixed(1); } if (result.googCurrentDelayMs) { var kilobytes = 0; getStatsResult.internal.video.prevGoogCurrentDelayMs || (getStatsResult.internal.video.prevGoogCurrentDelayMs = result.googCurrentDelayMs); var bytes = result.googCurrentDelayMs - getStatsResult.internal.video.prevGoogCurrentDelayMs; getStatsResult.internal.video.prevGoogCurrentDelayMs = result.googCurrentDelayMs, getStatsResult.video.latency = bytes.toFixed(1), getStatsResult.video.latency < 0 && (getStatsResult.video.latency = 0); } if (result.packetsLost) { var kilobytes = 0; getStatsResult.internal.video.prevPacketsLost || (getStatsResult.internal.video.prevPacketsLost = result.packetsLost); var bytes = result.packetsLost - getStatsResult.internal.video.prevPacketsLost; getStatsResult.internal.video.prevPacketsLost = result.packetsLost, getStatsResult.video.packetsLost = bytes.toFixed(1), getStatsResult.video.packetsLost < 0 && (getStatsResult.video.packetsLost = 0); } } } }, getStatsParser.bweforvideo = function (result) { "VideoBwe" === result.type && (getStatsResult.bandwidth.availableSendBandwidth = result.googAvailableSendBandwidth, getStatsResult.bandwidth.googActualEncBitrate = result.googActualEncBitrate, getStatsResult.bandwidth.googAvailableSendBandwidth = result.googAvailableSendBandwidth, getStatsResult.bandwidth.googAvailableReceiveBandwidth = result.googAvailableReceiveBandwidth, getStatsResult.bandwidth.googRetransmitBitrate = result.googRetransmitBitrate, getStatsResult.bandwidth.googTargetEncBitrate = result.googTargetEncBitrate, getStatsResult.bandwidth.googBucketDelay = result.googBucketDelay, getStatsResult.bandwidth.googTransmitBitrate = result.googTransmitBitrate); }, getStatsParser.candidatePair = function (result) { if ("googCandidatePair" === result.type || "candidate-pair" === result.type || "local-candidate" === result.type || "remote-candidate" === result.type) { if ("true" == result.googActiveConnection) { Object.keys(getStatsResult.internal.candidates).forEach(function (cid) { var candidate = getStatsResult.internal.candidates[cid]; candidate.ipAddress.indexOf(result.googLocalAddress) !== -1 && (getStatsResult.connectionType.local.candidateType = candidate.candidateType, getStatsResult.connectionType.local.ipAddress = candidate.ipAddress, getStatsResult.connectionType.local.networkType = candidate.networkType, getStatsResult.connectionType.local.transport = candidate.transport), candidate.ipAddress.indexOf(result.googRemoteAddress) !== -1 && (getStatsResult.connectionType.remote.candidateType = candidate.candidateType, getStatsResult.connectionType.remote.ipAddress = candidate.ipAddress, getStatsResult.connectionType.remote.networkType = candidate.networkType, getStatsResult.connectionType.remote.transport = candidate.transport); }), getStatsResult.connectionType.transport = result.googTransportType; var localCandidate = getStatsResult.internal.candidates[result.localCandidateId]; localCandidate && localCandidate.ipAddress && (getStatsResult.connectionType.systemIpAddress = localCandidate.ipAddress); var remoteCandidate = getStatsResult.internal.candidates[result.remoteCandidateId]; remoteCandidate && remoteCandidate.ipAddress && (getStatsResult.connectionType.systemIpAddress = remoteCandidate.ipAddress); } if ("candidate-pair" === result.type && result.selected === !0 && result.nominated === !0 && "succeeded" === result.state) var localCandidate = getStatsResult.internal.candidates[result.remoteCandidateId], remoteCandidate = getStatsResult.internal.candidates[result.remoteCandidateId]; if ("local-candidate" === result.type && (getStatsResult.connectionType.local.candidateType = result.candidateType, getStatsResult.connectionType.local.ipAddress = result.ipAddress, getStatsResult.connectionType.local.networkType = result.networkType, getStatsResult.connectionType.local.transport = result.mozLocalTransport || result.transport), "remote-candidate" === result.type && (getStatsResult.connectionType.remote.candidateType = result.candidateType, getStatsResult.connectionType.remote.ipAddress = result.ipAddress, getStatsResult.connectionType.remote.networkType = result.networkType, getStatsResult.connectionType.remote.transport = result.mozRemoteTransport || result.transport), isSafari) { var sendrecvType = result.localCandidateId ? "send" : "recv"; if (!sendrecvType) return; if (result.bytesSent) { var kilobytes = 0; getStatsResult.internal.video[sendrecvType].prevBytesSent || (getStatsResult.internal.video[sendrecvType].prevBytesSent = result.bytesSent); var bytes = result.bytesSent - getStatsResult.internal.video[sendrecvType].prevBytesSent; getStatsResult.internal.video[sendrecvType].prevBytesSent = result.bytesSent, kilobytes = bytes / 1024, getStatsResult.video[sendrecvType].availableBandwidth = kilobytes.toFixed(1), getStatsResult.video.bytesSent = kilobytes.toFixed(1); } if (result.bytesReceived) { var kilobytes = 0; getStatsResult.internal.video[sendrecvType].prevBytesReceived || (getStatsResult.internal.video[sendrecvType].prevBytesReceived = result.bytesReceived); var bytes = result.bytesReceived - getStatsResult.internal.video[sendrecvType].prevBytesReceived; getStatsResult.internal.video[sendrecvType].prevBytesReceived = result.bytesReceived, kilobytes = bytes / 1024, getStatsResult.video.bytesReceived = kilobytes.toFixed(1); } if (result.availableOutgoingBitrate) { var kilobytes = 0; getStatsResult.internal.video[sendrecvType].prevAvailableOutgoingBitrate || (getStatsResult.internal.video[sendrecvType].prevAvailableOutgoingBitrate = result.availableOutgoingBitrate); var bytes = result.availableOutgoingBitrate - getStatsResult.internal.video[sendrecvType].prevAvailableOutgoingBitrate; getStatsResult.internal.video[sendrecvType].prevAvailableOutgoingBitrate = result.availableOutgoingBitrate, kilobytes = bytes / 1024, getStatsResult.video.availableOutgoingBitrate = kilobytes.toFixed(1); } if (result.availableIncomingBitrate) { var kilobytes = 0; getStatsResult.internal.video[sendrecvType].prevAvailableIncomingBitrate || (getStatsResult.internal.video[sendrecvType].prevAvailableIncomingBitrate = result.availableIncomingBitrate); var bytes = result.availableIncomingBitrate - getStatsResult.internal.video[sendrecvType].prevAvailableIncomingBitrate; getStatsResult.internal.video[sendrecvType].prevAvailableIncomingBitrate = result.availableIncomingBitrate, kilobytes = bytes / 1024, getStatsResult.video.availableIncomingBitrate = kilobytes.toFixed(1); } } } }; var LOCAL_candidateType = {}, LOCAL_transport = {}, LOCAL_ipAddress = {}, LOCAL_networkType = {}; getStatsParser.localcandidate = function (result) { "localcandidate" !== result.type && "local-candidate" !== result.type || result.id && (LOCAL_candidateType[result.id] || (LOCAL_candidateType[result.id] = []), LOCAL_transport[result.id] || (LOCAL_transport[result.id] = []), LOCAL_ipAddress[result.id] || (LOCAL_ipAddress[result.id] = []), LOCAL_networkType[result.id] || (LOCAL_networkType[result.id] = []), result.candidateType && LOCAL_candidateType[result.id].indexOf(result.candidateType) === -1 && LOCAL_candidateType[result.id].push(result.candidateType), result.transport && LOCAL_transport[result.id].indexOf(result.transport) === -1 && LOCAL_transport[result.id].push(result.transport), result.ipAddress && LOCAL_ipAddress[result.id].indexOf(result.ipAddress + ":" + result.portNumber) === -1 && LOCAL_ipAddress[result.id].push(result.ipAddress + ":" + result.portNumber), result.networkType && LOCAL_networkType[result.id].indexOf(result.networkType) === -1 && LOCAL_networkType[result.id].push(result.networkType), getStatsResult.internal.candidates[result.id] = { candidateType: LOCAL_candidateType[result.id], ipAddress: LOCAL_ipAddress[result.id], portNumber: result.portNumber, networkType: LOCAL_networkType[result.id], priority: result.priority, transport: LOCAL_transport[result.id], timestamp: result.timestamp, id: result.id, type: result.type }, getStatsResult.connectionType.local.candidateType = LOCAL_candidateType[result.id], getStatsResult.connectionType.local.ipAddress = LOCAL_ipAddress[result.id], getStatsResult.connectionType.local.networkType = LOCAL_networkType[result.id], getStatsResult.connectionType.local.transport = LOCAL_transport[result.id]); }; var REMOTE_candidateType = {}, REMOTE_transport = {}, REMOTE_ipAddress = {}, REMOTE_networkType = {}; getStatsParser.remotecandidate = function (result) { "remotecandidate" !== result.type && "remote-candidate" !== result.type || result.id && (REMOTE_candidateType[result.id] || (REMOTE_candidateType[result.id] = []), REMOTE_transport[result.id] || (REMOTE_transport[result.id] = []), REMOTE_ipAddress[result.id] || (REMOTE_ipAddress[result.id] = []), REMOTE_networkType[result.id] || (REMOTE_networkType[result.id] = []), result.candidateType && REMOTE_candidateType[result.id].indexOf(result.candidateType) === -1 && REMOTE_candidateType[result.id].push(result.candidateType), result.transport && REMOTE_transport[result.id].indexOf(result.transport) === -1 && REMOTE_transport[result.id].push(result.transport), result.ipAddress && REMOTE_ipAddress[result.id].indexOf(result.ipAddress + ":" + result.portNumber) === -1 && REMOTE_ipAddress[result.id].push(result.ipAddress + ":" + result.portNumber), result.networkType && REMOTE_networkType[result.id].indexOf(result.networkType) === -1 && REMOTE_networkType[result.id].push(result.networkType), getStatsResult.internal.candidates[result.id] = { candidateType: REMOTE_candidateType[result.id], ipAddress: REMOTE_ipAddress[result.id], portNumber: result.portNumber, networkType: REMOTE_networkType[result.id], priority: result.priority, transport: REMOTE_transport[result.id], timestamp: result.timestamp, id: result.id, type: result.type }, getStatsResult.connectionType.remote.candidateType = REMOTE_candidateType[result.id], getStatsResult.connectionType.remote.ipAddress = REMOTE_ipAddress[result.id], getStatsResult.connectionType.remote.networkType = REMOTE_networkType[result.id], getStatsResult.connectionType.remote.transport = REMOTE_transport[result.id]); }, getStatsParser.dataSentReceived = function (result) { !result.googCodecName || "video" !== result.mediaType && "audio" !== result.mediaType || (result.bytesSent && (getStatsResult[result.mediaType].bytesSent = parseInt(result.bytesSent)), result.bytesReceived && (getStatsResult[result.mediaType].bytesReceived = parseInt(result.bytesReceived))); }, getStatsParser.inboundrtp = function (result) { if (isSafari && "inbound-rtp" === result.type) { var mediaType = result.mediaType || "audio", sendrecvType = result.isRemote ? "recv" : "send"; if (sendrecvType) { if (result.bytesSent) { var kilobytes = 0; getStatsResult.internal[mediaType][sendrecvType].prevBytesSent || (getStatsResult.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent); var bytes = result.bytesSent - getStatsResult.internal[mediaType][sendrecvType].prevBytesSent; getStatsResult.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent, kilobytes = bytes / 1024, getStatsResult[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1), getStatsResult[mediaType].bytesSent = kilobytes.toFixed(1); } if (result.bytesReceived) { var kilobytes = 0; getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived || (getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived); var bytes = result.bytesReceived - getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived; getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived, kilobytes = bytes / 1024, getStatsResult[mediaType].bytesReceived = kilobytes.toFixed(1); } } } }, getStatsParser.outboundrtp = function (result) { if (isSafari && "outbound-rtp" === result.type) { var mediaType = result.mediaType || "audio", sendrecvType = result.isRemote ? "recv" : "send"; if (sendrecvType) { if (result.bytesSent) { var kilobytes = 0; getStatsResult.internal[mediaType][sendrecvType].prevBytesSent || (getStatsResult.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent); var bytes = result.bytesSent - getStatsResult.internal[mediaType][sendrecvType].prevBytesSent; getStatsResult.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent, kilobytes = bytes / 1024, getStatsResult[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1), getStatsResult[mediaType].bytesSent = kilobytes.toFixed(1); } if (result.bytesReceived) { var kilobytes = 0; getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived || (getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived); var bytes = result.bytesReceived - getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived; getStatsResult.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived, kilobytes = bytes / 1024, getStatsResult[mediaType].bytesReceived = kilobytes.toFixed(1); } } } }, getStatsParser.track = function (result) { if (isSafari && "track" === result.type) { var sendrecvType = result.remoteSource === !0 ? "send" : "recv"; result.frameWidth && result.frameHeight && (getStatsResult.resolutions[sendrecvType].width = result.frameWidth, getStatsResult.resolutions[sendrecvType].height = result.frameHeight); } }; var SSRC = { audio: { send: [], recv: [] }, video: { send: [], recv: [] } }; getStatsParser.ssrc = function (result) { if (result.googCodecName && ("video" === result.mediaType || "audio" === result.mediaType) && "ssrc" === result.type) { var sendrecvType = result.id.split("_").pop(); SSRC[result.mediaType][sendrecvType].indexOf(result.ssrc) === -1 && SSRC[result.mediaType][sendrecvType].push(result.ssrc), getStatsResult[result.mediaType][sendrecvType].streams = SSRC[result.mediaType][sendrecvType].length; } }, getStatsLooper(); }; "undefined" != typeof module && (module.exports = getStats), "function" == typeof define && define.amd && define("getStats", [], function () { return getStats; });/* mapbox.js 0.6.8-dev */
!function () {
  var define;  // Undefine define (require.js)
  /*!
    * bean.js - copyright Jacob Thornton 2011
    * https://github.com/fat/bean
    * MIT License
    * special thanks to:
    * dean edwards: http://dean.edwards.name/
    * dperini: https://github.com/dperini/nwevents
    * the entire mootools team: github.com/mootools/mootools-core
    */
  !function (name, context, definition) {
    if (typeof module !== 'undefined') module.exports = definition(name, context);
    else if (typeof define === 'function' && typeof define.amd === 'object') define(definition);
    else context[name] = definition(name, context);
  }('bean', this, function (name, context) {
    var win = window
      , old = context[name]
      , overOut = /over|out/
      , namespaceRegex = /[^\.]*(?=\..*)\.|.*/
      , nameRegex = /\..*/
      , addEvent = 'addEventListener'
      , attachEvent = 'attachEvent'
      , removeEvent = 'removeEventListener'
      , detachEvent = 'detachEvent'
      , ownerDocument = 'ownerDocument'
      , targetS = 'target'
      , qSA = 'querySelectorAll'
      , doc = document || {}
      , root = doc.documentElement || {}
      , W3C_MODEL = root[addEvent]
      , eventSupport = W3C_MODEL ? addEvent : attachEvent
      , slice = Array.prototype.slice
      , mouseTypeRegex = /click|mouse(?!(.*wheel|scroll))|menu|drag|drop/i
      , mouseWheelTypeRegex = /mouse.*(wheel|scroll)/i
      , textTypeRegex = /^text/i
      , touchTypeRegex = /^touch|^gesture/i
      , ONE = {} // singleton for quick matching making add() do one()

      , nativeEvents = (function (hash, events, i) {
        for (i = 0; i < events.length; i++)
          hash[events[i]] = 1;
        return hash;
      }({}, (
        'click dblclick mouseup mousedown contextmenu ' +                  // mouse buttons
        'mousewheel mousemultiwheel DOMMouseScroll ' +                     // mouse wheel
        'mouseover mouseout mousemove selectstart selectend ' +            // mouse movement
        'keydown keypress keyup ' +                                        // keyboard
        'orientationchange ' +                                             // mobile
        'focus blur change reset select submit ' +                         // form elements
        'load unload beforeunload resize move DOMContentLoaded ' +          // window
        'readystatechange message ' +                                      // window
        'error abort scroll ' +                                            // misc
        (W3C_MODEL ? // element.fireEvent('onXYZ'... is not forgiving if we try to fire an event
          // that doesn't actually exist, so make sure we only do these on newer browsers
          'show ' +                                                          // mouse buttons
          'input invalid ' +                                                 // form elements
          'touchstart touchmove touchend touchcancel ' +                     // touch
          'gesturestart gesturechange gestureend ' +                         // gesture
          'readystatechange pageshow pagehide popstate ' +                   // window
          'hashchange offline online ' +                                     // window
          'afterprint beforeprint ' +                                        // printing
          'dragstart dragenter dragover dragleave drag drop dragend ' +      // dnd
          'loadstart progress suspend emptied stalled loadmetadata ' +       // media
          'loadeddata canplay canplaythrough playing waiting seeking ' +     // media
          'seeked ended durationchange timeupdate play pause ratechange ' +  // media
          'volumechange cuechange ' +                                        // media
          'checking noupdate downloading cached updateready obsolete ' +     // appcache
          '' : '')
      ).split(' ')
      ))

      , customEvents = (function () {
        var cdp = 'compareDocumentPosition'
          , isAncestor = cdp in root
            ? function (element, container) {
              return container[cdp] && (container[cdp](element) & 16) === 16;
            }
            : 'contains' in root
              ? function (element, container) {
                container = container.nodeType === 9 || container === window ? root : container;
                return container !== element && container.contains(element);
              }
              : function (element, container) {
                while (element = element.parentNode) if (element === container) return 1;
                return 0;
              };

        function check(event) {
          var related = event.relatedTarget;
          return !related
            ? related === null
            : (related !== this && related.prefix !== 'xul' && !/document/.test(this.toString()) && !isAncestor(related, this));
        }

        return {
          mouseenter: { base: 'mouseover', condition: check }
          , mouseleave: { base: 'mouseout', condition: check }
          , mousewheel: { base: /Firefox/.test(navigator.userAgent) ? 'DOMMouseScroll' : 'mousewheel' }
        };
      }())

      , fixEvent = (function () {
        var commonProps = 'altKey attrChange attrName bubbles cancelable ctrlKey currentTarget detail eventPhase getModifierState isTrusted metaKey relatedNode relatedTarget shiftKey srcElement target timeStamp type view which'.split(' ')
          , mouseProps = commonProps.concat('button buttons clientX clientY dataTransfer fromElement offsetX offsetY pageX pageY screenX screenY toElement'.split(' '))
          , mouseWheelProps = mouseProps.concat('wheelDelta wheelDeltaX wheelDeltaY wheelDeltaZ axis'.split(' ')) // 'axis' is FF specific
          , keyProps = commonProps.concat('char charCode key keyCode keyIdentifier keyLocation'.split(' '))
          , textProps = commonProps.concat(['data'])
          , touchProps = commonProps.concat('touches targetTouches changedTouches scale rotation'.split(' '))
          , messageProps = commonProps.concat(['data', 'origin', 'source'])
          , preventDefault = 'preventDefault'
          , createPreventDefault = function (event) {
            return function () {
              if (event[preventDefault])
                event[preventDefault]();
              else
                event.returnValue = false;
            };
          }
          , stopPropagation = 'stopPropagation'
          , createStopPropagation = function (event) {
            return function () {
              if (event[stopPropagation])
                event[stopPropagation]();
              else
                event.cancelBubble = true;
            };
          }
          , createStop = function (synEvent) {
            return function () {
              synEvent[preventDefault]();
              synEvent[stopPropagation]();
              synEvent.stopped = true;
            };
          }
          , copyProps = function (event, result, props) {
            var i, p;
            for (i = props.length; i--;) {
              p = props[i];
              if (!(p in result) && p in event) result[p] = event[p];
            }
          };

        return function (event, isNative) {
          var result = { originalEvent: event, isNative: isNative };
          if (!event)
            return result;

          var props
            , type = event.type
            , target = event[targetS] || event.srcElement;

          result[preventDefault] = createPreventDefault(event);
          result[stopPropagation] = createStopPropagation(event);
          result.stop = createStop(result);
          result[targetS] = target && target.nodeType === 3 ? target.parentNode : target;

          if (isNative) { // we only need basic augmentation on custom events, the rest is too expensive
            if (type.indexOf('key') !== -1) {
              props = keyProps;
              result.keyCode = event.keyCode || event.which;
            } else if (mouseTypeRegex.test(type)) {
              props = mouseProps;
              result.rightClick = event.which === 3 || event.button === 2;
              result.pos = { x: 0, y: 0 };
              if (event.pageX || event.pageY) {
                result.clientX = event.pageX;
                result.clientY = event.pageY;
              } else if (event.clientX || event.clientY) {
                result.clientX = event.clientX + doc.body.scrollLeft + root.scrollLeft;
                result.clientY = event.clientY + doc.body.scrollTop + root.scrollTop;
              }
              if (overOut.test(type))
                result.relatedTarget = event.relatedTarget || event[(type === 'mouseover' ? 'from' : 'to') + 'Element'];
            } else if (touchTypeRegex.test(type)) {
              props = touchProps;
            } else if (mouseWheelTypeRegex.test(type)) {
              props = mouseWheelProps;
            } else if (textTypeRegex.test(type)) {
              props = textProps;
            } else if (type === 'message') {
              props = messageProps;
            }
            copyProps(event, result, props || commonProps);
          }
          return result;
        };
      }())

      // if we're in old IE we can't do onpropertychange on doc or win so we use doc.documentElement for both
      , targetElement = function (element, isNative) {
        return !W3C_MODEL && !isNative && (element === doc || element === win) ? root : element;
      }

      // we use one of these per listener, of any type
      , RegEntry = (function () {
        function entry(element, type, handler, original, namespaces) {
          var isNative = this.isNative = nativeEvents[type] && element[eventSupport];
          this.element = element;
          this.type = type;
          this.handler = handler;
          this.original = original;
          this.namespaces = namespaces;
          this.custom = customEvents[type];
          this.eventType = W3C_MODEL || isNative ? type : 'propertychange';
          this.customType = !W3C_MODEL && !isNative && type;
          this[targetS] = targetElement(element, isNative);
          this[eventSupport] = this[targetS][eventSupport];
        }

        entry.prototype = {
          // given a list of namespaces, is our entry in any of them?
          inNamespaces: function (checkNamespaces) {
            var i, j;
            if (!checkNamespaces)
              return true;
            if (!this.namespaces)
              return false;
            for (i = checkNamespaces.length; i--;) {
              for (j = this.namespaces.length; j--;) {
                if (checkNamespaces[i] === this.namespaces[j])
                  return true;
              }
            }
            return false;
          }

          // match by element, original fn (opt), handler fn (opt)
          , matches: function (checkElement, checkOriginal, checkHandler) {
            return this.element === checkElement &&
              (!checkOriginal || this.original === checkOriginal) &&
              (!checkHandler || this.handler === checkHandler);
          }
        };

        return entry;
      }())

      , registry = (function () {
        // our map stores arrays by event type, just because it's better than storing
        // everything in a single array. uses '$' as a prefix for the keys for safety
        var map = {}

          // generic functional search of our registry for matching listeners,
          // `fn` returns false to break out of the loop
          , forAll = function (element, type, original, handler, fn) {
            if (!type || type === '*') {
              // search the whole registry
              for (var t in map) {
                if (t.charAt(0) === '$')
                  forAll(element, t.substr(1), original, handler, fn);
              }
            } else {
              var i = 0, l, list = map['$' + type], all = element === '*';
              if (!list)
                return;
              for (l = list.length; i < l; i++) {
                if (all || list[i].matches(element, original, handler))
                  if (!fn(list[i], list, i, type))
                    return;
              }
            }
          }

          , has = function (element, type, original) {
            // we're not using forAll here simply because it's a bit slower and this
            // needs to be fast
            var i, list = map['$' + type];
            if (list) {
              for (i = list.length; i--;) {
                if (list[i].matches(element, original, null))
                  return true;
              }
            }
            return false;
          }

          , get = function (element, type, original) {
            var entries = [];
            forAll(element, type, original, null, function (entry) { return entries.push(entry); });
            return entries;
          }

          , put = function (entry) {
            (map['$' + entry.type] || (map['$' + entry.type] = [])).push(entry);
            return entry;
          }

          , del = function (entry) {
            forAll(entry.element, entry.type, null, entry.handler, function (entry, list, i) {
              list.splice(i, 1);
              if (list.length === 0)
                delete map['$' + entry.type];
              return false;
            });
          }

          // dump all entries, used for onunload
          , entries = function () {
            var t, entries = [];
            for (t in map) {
              if (t.charAt(0) === '$')
                entries = entries.concat(map[t]);
            }
            return entries;
          };

        return { has: has, get: get, put: put, del: del, entries: entries };
      }())

      , selectorEngine = doc[qSA]
        ? function (s, r) {
          return r[qSA](s);
        }
        : function () {
          throw new Error('Bean: No selector engine installed'); // eeek
        }

      , setSelectorEngine = function (e) {
        selectorEngine = e;
      }

      // add and remove listeners to DOM elements
      , listener = W3C_MODEL ? function (element, type, fn, add) {
        element[add ? addEvent : removeEvent](type, fn, false);
      } : function (element, type, fn, add, custom) {
        if (custom && add && element['_on' + custom] === null)
          element['_on' + custom] = 0;
        element[add ? attachEvent : detachEvent]('on' + type, fn);
      }

      , nativeHandler = function (element, fn, args) {
        var beanDel = fn.__beanDel
          , handler = function (event) {
            event = fixEvent(event || ((this[ownerDocument] || this.document || this).parentWindow || win).event, true);
            if (beanDel) // delegated event, fix the fix
              event.currentTarget = beanDel.ft(event[targetS], element);
            return fn.apply(element, [event].concat(args));
          };
        handler.__beanDel = beanDel;
        return handler;
      }

      , customHandler = function (element, fn, type, condition, args, isNative) {
        var beanDel = fn.__beanDel
          , handler = function (event) {
            var target = beanDel ? beanDel.ft(event[targetS], element) : this; // deleated event
            if (condition ? condition.apply(target, arguments) : W3C_MODEL ? true : event && event.propertyName === '_on' + type || !event) {
              if (event) {
                event = fixEvent(event || ((this[ownerDocument] || this.document || this).parentWindow || win).event, isNative);
                event.currentTarget = target;
              }
              fn.apply(element, event && (!args || args.length === 0) ? arguments : slice.call(arguments, event ? 0 : 1).concat(args));
            }
          };
        handler.__beanDel = beanDel;
        return handler;
      }

      , once = function (rm, element, type, fn, originalFn) {
        // wrap the handler in a handler that does a remove as well
        return function () {
          rm(element, type, originalFn);
          fn.apply(this, arguments);
        };
      }

      , removeListener = function (element, orgType, handler, namespaces) {
        var i, l, entry
          , type = (orgType && orgType.replace(nameRegex, ''))
          , handlers = registry.get(element, type, handler);

        for (i = 0, l = handlers.length; i < l; i++) {
          if (handlers[i].inNamespaces(namespaces)) {
            if ((entry = handlers[i])[eventSupport])
              listener(entry[targetS], entry.eventType, entry.handler, false, entry.type);
            // TODO: this is problematic, we have a registry.get() and registry.del() that
            // both do registry searches so we waste cycles doing this. Needs to be rolled into
            // a single registry.forAll(fn) that removes while finding, but the catch is that
            // we'll be splicing the arrays that we're iterating over. Needs extra tests to
            // make sure we don't screw it up. @rvagg
            registry.del(entry);
          }
        }
      }

      , addListener = function (element, orgType, fn, originalFn, args) {
        var entry
          , type = orgType.replace(nameRegex, '')
          , namespaces = orgType.replace(namespaceRegex, '').split('.');

        if (registry.has(element, type, fn))
          return element; // no dupe
        if (type === 'unload')
          fn = once(removeListener, element, type, fn, originalFn); // self clean-up
        if (customEvents[type]) {
          if (customEvents[type].condition)
            fn = customHandler(element, fn, type, customEvents[type].condition, args, true);
          type = customEvents[type].base || type;
        }
        entry = registry.put(new RegEntry(element, type, fn, originalFn, namespaces[0] && namespaces));
        entry.handler = entry.isNative ?
          nativeHandler(element, entry.handler, args) :
          customHandler(element, entry.handler, type, false, args, false);
        if (entry[eventSupport])
          listener(entry[targetS], entry.eventType, entry.handler, true, entry.customType);
      }

      , del = function (selector, fn, $) {
        //TODO: findTarget (therefore $) is called twice, once for match and once for
        // setting e.currentTarget, fix this so it's only needed once
        var findTarget = function (target, root) {
          var i, array = typeof selector === 'string' ? $(selector, root) : selector;
          for (; target && target !== root; target = target.parentNode) {
            for (i = array.length; i--;) {
              if (array[i] === target)
                return target;
            }
          }
        }
          , handler = function (e) {
            var match = findTarget(e[targetS], this);
            match && fn.apply(match, arguments);
          };

        handler.__beanDel = {
          ft: findTarget // attach it here for customEvents to use too
          , selector: selector
          , $: $
        };
        return handler;
      }

      , remove = function (element, typeSpec, fn) {
        var k, type, namespaces, i
          , rm = removeListener
          , isString = typeSpec && typeof typeSpec === 'string';

        if (isString && typeSpec.indexOf(' ') > 0) {
          // remove(el, 't1 t2 t3', fn) or remove(el, 't1 t2 t3')
          typeSpec = typeSpec.split(' ');
          for (i = typeSpec.length; i--;)
            remove(element, typeSpec[i], fn);
          return element;
        }
        type = isString && typeSpec.replace(nameRegex, '');
        if (type && customEvents[type])
          type = customEvents[type].type;
        if (!typeSpec || isString) {
          // remove(el) or remove(el, t1.ns) or remove(el, .ns) or remove(el, .ns1.ns2.ns3)
          if (namespaces = isString && typeSpec.replace(namespaceRegex, ''))
            namespaces = namespaces.split('.');
          rm(element, type, fn, namespaces);
        } else if (typeof typeSpec === 'function') {
          // remove(el, fn)
          rm(element, null, typeSpec);
        } else {
          // remove(el, { t1: fn1, t2, fn2 })
          for (k in typeSpec) {
            if (typeSpec.hasOwnProperty(k))
              remove(element, k, typeSpec[k]);
          }
        }
        return element;
      }

      // 5th argument, $=selector engine, is deprecated and will be removed
      , add = function (element, events, fn, delfn, $) {
        var type, types, i, args
          , originalFn = fn
          , isDel = fn && typeof fn === 'string';

        if (events && !fn && typeof events === 'object') {
          for (type in events) {
            if (events.hasOwnProperty(type))
              add.apply(this, [element, type, events[type]]);
          }
        } else {
          args = arguments.length > 3 ? slice.call(arguments, 3) : [];
          types = (isDel ? fn : events).split(' ');
          isDel && (fn = del(events, (originalFn = delfn), $ || selectorEngine)) && (args = slice.call(args, 1));
          // special case for one()
          this === ONE && (fn = once(remove, element, events, fn, originalFn));
          for (i = types.length; i--;) addListener(element, types[i], fn, originalFn, args);
        }
        return element;
      }

      , one = function () {
        return add.apply(ONE, arguments);
      }

      , fireListener = W3C_MODEL ? function (isNative, type, element) {
        var evt = doc.createEvent(isNative ? 'HTMLEvents' : 'UIEvents');
        evt[isNative ? 'initEvent' : 'initUIEvent'](type, true, true, win, 1);
        element.dispatchEvent(evt);
      } : function (isNative, type, element) {
        element = targetElement(element, isNative);
        // if not-native then we're using onpropertychange so we just increment a custom property
        isNative ? element.fireEvent('on' + type, doc.createEventObject()) : element['_on' + type]++;
      }

      , fire = function (element, type, args) {
        var i, j, l, names, handlers
          , types = type.split(' ');

        for (i = types.length; i--;) {
          type = types[i].replace(nameRegex, '');
          if (names = types[i].replace(namespaceRegex, ''))
            names = names.split('.');
          if (!names && !args && element[eventSupport]) {
            fireListener(nativeEvents[type], type, element);
          } else {
            // non-native event, either because of a namespace, arguments or a non DOM element
            // iterate over all listeners and manually 'fire'
            handlers = registry.get(element, type);
            args = [false].concat(args);
            for (j = 0, l = handlers.length; j < l; j++) {
              if (handlers[j].inNamespaces(names))
                handlers[j].handler.apply(element, args);
            }
          }
        }
        return element;
      }

      , clone = function (element, from, type) {
        var i = 0
          , handlers = registry.get(from, type)
          , l = handlers.length
          , args, beanDel;

        for (; i < l; i++) {
          if (handlers[i].original) {
            beanDel = handlers[i].handler.__beanDel;
            if (beanDel) {
              args = [element, beanDel.selector, handlers[i].type, handlers[i].original, beanDel.$];
            } else
              args = [element, handlers[i].type, handlers[i].original];
            add.apply(null, args);
          }
        }
        return element;
      }

      , bean = {
        add: add
        , one: one
        , remove: remove
        , clone: clone
        , fire: fire
        , setSelectorEngine: setSelectorEngine
        , noConflict: function () {
          context[name] = old;
          return this;
        }
      };

    if (win[attachEvent]) {
      // for IE, clean up on unload to avoid leaks
      var cleanup = function () {
        var i, entries = registry.entries();
        for (i in entries) {
          if (entries[i].type && entries[i].type !== 'unload')
            remove(entries[i].element, entries[i].type);
        }
        win[detachEvent]('onunload', cleanup);
        win.CollectGarbage && win.CollectGarbage();
      };
      win[attachEvent]('onunload', cleanup);
    }

    return bean;
  });
  /*!
    * Reqwest! A general purpose XHR connection manager
    * (c) Dustin Diaz 2012
    * https://github.com/ded/reqwest
    * license MIT
    */
  !function (name, definition) {
    if (typeof module != 'undefined') module.exports = definition();
    else if (typeof define == 'function' && define.amd) define(definition);
    else this[name] = definition();
  }('reqwest', function () {

    var win = window
      , doc = document
      , twoHundo = /^20\d$/
      , byTag = 'getElementsByTagName'
      , readyState = 'readyState'
      , contentType = 'Content-Type'
      , requestedWith = 'X-Requested-With'
      , head = doc[byTag]('head')[0]
      , uniqid = 0
      , callbackPrefix = 'reqwest_' + (+new Date())
      , lastValue // data stored by the most recent JSONP callback
      , xmlHttpRequest = 'XMLHttpRequest';

    var isArray = typeof Array.isArray == 'function' ? Array.isArray : function (a) {
      return a instanceof Array;
    };
    var defaultHeaders = {
      contentType: 'application/x-www-form-urlencoded'
      , requestedWith: xmlHttpRequest
      , accept: {
        '*': 'text/javascript, text/html, application/xml, text/xml, */*'
        , xml: 'application/xml, text/xml'
        , html: 'text/html'
        , text: 'text/plain'
        , json: 'application/json, text/javascript'
        , js: 'application/javascript, text/javascript'
      }
    };
    var xhr = win[xmlHttpRequest] ?
      function () {
        return new XMLHttpRequest();
      } :
      function () {
        return new ActiveXObject('Microsoft.XMLHTTP');
      };

    function handleReadyState(o, success, error) {
      return function () {
        if (o && o[readyState] == 4) {
          if (twoHundo.test(o.status)) {
            success(o);
          } else {
            error(o);
          }
        }
      };
    }

    function setHeaders(http, o) {
      var headers = o.headers || {}, h;
      headers.Accept = headers.Accept || defaultHeaders.accept[o.type] || defaultHeaders.accept['*'];
      // breaks cross-origin requests with legacy browsers
      if (!o.crossOrigin && !headers[requestedWith]) headers[requestedWith] = defaultHeaders.requestedWith;
      if (!headers[contentType]) headers[contentType] = o.contentType || defaultHeaders.contentType;
      for (h in headers) {
        headers.hasOwnProperty(h) && http.setRequestHeader(h, headers[h]);
      }
    }

    function setCredentials(http, o) {
      if (typeof o.withCredentials !== "undefined" && typeof http.withCredentials !== "undefined") {
        http.withCredentials = !!o.withCredentials;
      }
    }

    function generalCallback(data) {
      lastValue = data;
    }

    function urlappend(url, s) {
      return url + (/\?/.test(url) ? '&' : '?') + s;
    }

    function handleJsonp(o, fn, err, url) {
      var reqId = uniqid++
        , cbkey = o.jsonpCallback || 'callback' // the 'callback' key
        , cbval = o.jsonpCallbackName || reqwest.getcallbackPrefix(reqId)
        // , cbval = o.jsonpCallbackName || ('reqwest_' + reqId) // the 'callback' value
        , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
        , match = url.match(cbreg)
        , script = doc.createElement('script')
        , loaded = 0
        , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1;

      if (match) {
        if (match[3] === '?') {
          url = url.replace(cbreg, '$1=' + cbval); // wildcard callback func name
        } else {
          cbval = match[3]; // provided callback func name
        }
      } else {
        url = urlappend(url, cbkey + '=' + cbval); // no callback details, add 'em
      }

      win[cbval] = generalCallback;

      script.type = 'text/javascript';
      script.src = url;
      script.async = true;
      if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
        // need this for IE due to out-of-order onreadystatechange(), binding script
        // execution to an event listener gives us control over when the script
        // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
        //
        // if this hack is used in IE10 jsonp callback are never called
        script.event = 'onclick';
        script.htmlFor = script.id = '_reqwest_' + reqId;
      }

      script.onload = script.onreadystatechange = function () {
        if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
          return false;
        }
        script.onload = script.onreadystatechange = null;
        script.onclick && script.onclick();
        // Call the user callback with the last value stored and clean up values and scripts.
        o.success && o.success(lastValue);
        lastValue = undefined;
        head.removeChild(script);
        loaded = 1;
      };

      // Add the script to the DOM head
      head.appendChild(script);
    }

    function getRequest(o, fn, err) {
      var method = (o.method || 'GET').toUpperCase()
        , url = typeof o === 'string' ? o : o.url
        // convert non-string objects to query-string form unless o.processData is false
        , data = (o.processData !== false && o.data && typeof o.data !== 'string')
          ? reqwest.toQueryString(o.data)
          : (o.data || null)
        , http;

      // if we're working on a GET request and we have data then we should append
      // query string to end of URL and not post data
      if ((o.type == 'jsonp' || method == 'GET') && data) {
        url = urlappend(url, data);
        data = null;
      }

      if (o.type == 'jsonp') return handleJsonp(o, fn, err, url);

      http = xhr();
      http.open(method, url, true);
      setHeaders(http, o);
      setCredentials(http, o);
      http.onreadystatechange = handleReadyState(http, fn, err);
      o.before && o.before(http);
      http.send(data);
      return http;
    }

    function Reqwest(o, fn) {
      this.o = o;
      this.fn = fn;

      init.apply(this, arguments);
    }

    function setType(url) {
      var m = url.match(/\.(json|jsonp|html|xml)(\?|$)/);
      return m ? m[1] : 'js';
    }

    function init(o, fn) {

      this.url = typeof o == 'string' ? o : o.url;
      this.timeout = null;

      // whether request has been fulfilled for purpose
      // of tracking the Promises
      this._fulfilled = false;
      // success handlers
      this._fulfillmentHandlers = [];
      // error handlers
      this._errorHandlers = [];
      // complete (both success and fail) handlers
      this._completeHandlers = [];
      this._erred = false;
      this._responseArgs = {};

      var self = this
        , type = o.type || setType(this.url);

      fn = fn || function () { };

      if (o.timeout) {
        this.timeout = setTimeout(function () {
          self.abort();
        }, o.timeout);
      }

      if (o.success) {
        this._fulfillmentHandlers.push(function () {
          o.success.apply(o, arguments);
        });
      }

      if (o.error) {
        this._errorHandlers.push(function () {
          o.error.apply(o, arguments);
        });
      }

      if (o.complete) {
        this._completeHandlers.push(function () {
          o.complete.apply(o, arguments);
        });
      }

      function complete(resp) {
        o.timeout && clearTimeout(self.timeout);
        self.timeout = null;
        while (self._completeHandlers.length > 0) {
          self._completeHandlers.shift()(resp);
        }
      }

      function success(resp) {
        var r = resp.responseText;
        if (r) {
          switch (type) {
            case 'json':
              try {
                resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')');
              } catch (err) {
                return error(resp, 'Could not parse JSON in response', err);
              }
              break;
            case 'js':
              resp = eval(r);
              break;
            case 'html':
              resp = r;
              break;
            case 'xml':
              resp = resp.responseXML;
              break;
          }
        }

        self._responseArgs.resp = resp;
        self._fulfilled = true;
        fn(resp);
        while (self._fulfillmentHandlers.length > 0) {
          self._fulfillmentHandlers.shift()(resp);
        }

        complete(resp);
      }

      function error(resp, msg, t) {
        self._responseArgs.resp = resp;
        self._responseArgs.msg = msg;
        self._responseArgs.t = t;
        self._erred = true;
        while (self._errorHandlers.length > 0) {
          self._errorHandlers.shift()(resp, msg, t);
        }
        complete(resp);
      }

      this.request = getRequest(o, success, error);
    }

    Reqwest.prototype = {
      abort: function () {
        this.request.abort();
      }

      , retry: function () {
        init.call(this, this.o, this.fn);
      }

      /**
       * Small deviation from the Promises A CommonJs specification
       * http://wiki.commonjs.org/wiki/Promises/A
       */

      /**
       * `then` will execute upon successful requests
       */
      , then: function (success, fail) {
        if (this._fulfilled) {
          success(this._responseArgs.resp);
        } else if (this._erred) {
          fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t);
        } else {
          this._fulfillmentHandlers.push(success);
          this._errorHandlers.push(fail);
        }
        return this;
      }

      /**
       * `always` will execute whether the request succeeds or fails
       */
      , always: function (fn) {
        if (this._fulfilled || this._erred) {
          fn(this._responseArgs.resp);
        } else {
          this._completeHandlers.push(fn);
        }
        return this;
      }

      /**
       * `fail` will execute when the request fails
       */
      , fail: function (fn) {
        if (this._erred) {
          fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t);
        } else {
          this._errorHandlers.push(fn);
        }
        return this;
      }
    };

    function reqwest(o, fn) {
      return new Reqwest(o, fn);
    }

    // normalize newline variants according to spec -> CRLF
    function normalize(s) {
      return s ? s.replace(/\r?\n/g, '\r\n') : '';
    }

    function serial(el, cb) {
      var n = el.name
        , t = el.tagName.toLowerCase()
        , optCb = function (o) {
          // IE gives value="" even where there is no value attribute
          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
          if (o && !o.disabled)
            cb(n, normalize(o.attributes.value && o.attributes.value.specified ? o.value : o.text));
        };

      // don't serialize elements that are disabled or without a name
      if (el.disabled || !n) return;

      switch (t) {
        case 'input':
          if (!/reset|button|image|file/i.test(el.type)) {
            var ch = /checkbox/i.test(el.type)
              , ra = /radio/i.test(el.type)
              , val = el.value;
            // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
            (!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val));
          }
          break;
        case 'textarea':
          cb(n, normalize(el.value));
          break;
        case 'select':
          if (el.type.toLowerCase() === 'select-one') {
            optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null);
          } else {
            for (var i = 0; el.length && i < el.length; i++) {
              el.options[i].selected && optCb(el.options[i]);
            }
          }
          break;
      }
    }

    // collect up all form elements found from the passed argument elements all
    // the way down to child elements; pass a '<form>' or form fields.
    // called with 'this'=callback to use for serial() on each element
    function eachFormElement() {
      var cb = this
        , e, i, j
        , serializeSubtags = function (e, tags) {
          for (var i = 0; i < tags.length; i++) {
            var fa = e[byTag](tags[i]);
            for (j = 0; j < fa.length; j++) serial(fa[j], cb);
          }
        };

      for (i = 0; i < arguments.length; i++) {
        e = arguments[i];
        if (/input|select|textarea/i.test(e.tagName)) serial(e, cb);
        serializeSubtags(e, ['input', 'select', 'textarea']);
      }
    }

    // standard query string style serialization
    function serializeQueryString() {
      return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments));
    }

    // { 'name': 'value', ... } style serialization
    function serializeHash() {
      var hash = {};
      eachFormElement.apply(function (name, value) {
        if (name in hash) {
          hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]]);
          hash[name].push(value);
        } else hash[name] = value;
      }, arguments);
      return hash;
    }

    // [ { name: 'name', value: 'value' }, ... ] style serialization
    reqwest.serializeArray = function () {
      var arr = [];
      eachFormElement.apply(function (name, value) {
        arr.push({ name: name, value: value });
      }, arguments);
      return arr;
    };

    reqwest.serialize = function () {
      if (arguments.length === 0) return '';
      var opt, fn
        , args = Array.prototype.slice.call(arguments, 0);

      opt = args.pop();
      opt && opt.nodeType && args.push(opt) && (opt = null);
      opt && (opt = opt.type);

      if (opt == 'map') fn = serializeHash;
      else if (opt == 'array') fn = reqwest.serializeArray;
      else fn = serializeQueryString;

      return fn.apply(null, args);
    };

    reqwest.toQueryString = function (o) {
      var qs = '', i
        , enc = encodeURIComponent
        , push = function (k, v) {
          qs += enc(k) + '=' + enc(v) + '&';
        };

      if (isArray(o)) {
        for (i = 0; o && i < o.length; i++) push(o[i].name, o[i].value);
      } else {
        for (var k in o) {
          if (!Object.hasOwnProperty.call(o, k)) continue;
          var v = o[k];
          if (isArray(v)) {
            for (i = 0; i < v.length; i++) push(k, v[i]);
          } else push(k, o[k]);
        }
      }

      // spaces should be + according to spec
      return qs.replace(/&$/, '').replace(/%20/g, '+');
    };

    reqwest.getcallbackPrefix = function (reqId) {
      return callbackPrefix;
    };

    // jQuery and Zepto compatibility, differences can be remapped here so you can call
    // .ajax.compat(options, callback)
    reqwest.compat = function (o, fn) {
      if (o) {
        o.type && (o.method = o.type) && delete o.type;
        o.dataType && (o.type = o.dataType);
        o.jsonpCallback && (o.jsonpCallbackName = o.jsonpCallback) && delete o.jsonpCallback;
        o.jsonp && (o.jsonpCallback = o.jsonp);
      }
      return new Reqwest(o, fn);
    };

    return reqwest;
  });
}();
/*
 * CommonJS-compatible mustache.js module
 *
 * See http://github.com/janl/mustache.js for more info.
 */

/*
  mustache.js — Logic-less templates in JavaScript

  See http://mustache.github.com/ for more info.
*/

var Mustache = function () {
  var _toString = Object.prototype.toString;

  Array.isArray = Array.isArray || function (obj) {
    return _toString.call(obj) == "[object Array]";
  };

  var _trim = String.prototype.trim, trim;

  if (_trim) {
    trim = function (text) {
      return text == null ? "" : _trim.call(text);
    };
  } else {
    var trimLeft, trimRight;

    // IE doesn't match non-breaking spaces with \s.
    if ((/\S/).test("\xA0")) {
      trimLeft = /^[\s\xA0]+/;
      trimRight = /[\s\xA0]+$/;
    } else {
      trimLeft = /^\s+/;
      trimRight = /\s+$/;
    }

    trim = function (text) {
      return text == null ? "" :
        text.toString().replace(trimLeft, "").replace(trimRight, "");
    };
  }

  var escapeMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': '&quot;',
    "'": '&#39;'
  };

  function escapeHTML(string) {
    return String(string).replace(/&(?!\w+;)|[<>"']/g, function (s) {
      return escapeMap[s] || s;
    });
  }

  var regexCache = {};
  var Renderer = function () { };

  Renderer.prototype = {
    otag: "{{",
    ctag: "}}",
    pragmas: {},
    buffer: [],
    pragmas_implemented: {
      "IMPLICIT-ITERATOR": true
    },
    context: {},

    render: function (template, context, partials, in_recursion) {
      // reset buffer & set context
      if (!in_recursion) {
        this.context = context;
        this.buffer = []; // TODO: make this non-lazy
      }

      // fail fast
      if (!this.includes("", template)) {
        if (in_recursion) {
          return template;
        } else {
          this.send(template);
          return;
        }
      }

      // get the pragmas together
      template = this.render_pragmas(template);

      // render the template
      var html = this.render_section(template, context, partials);

      // render_section did not find any sections, we still need to render the tags
      if (html === false) {
        html = this.render_tags(template, context, partials, in_recursion);
      }

      if (in_recursion) {
        return html;
      } else {
        this.sendLines(html);
      }
    },

    /*
      Sends parsed lines
    */
    send: function (line) {
      if (line !== "") {
        this.buffer.push(line);
      }
    },

    sendLines: function (text) {
      if (text) {
        var lines = text.split("\n");
        for (var i = 0; i < lines.length; i++) {
          this.send(lines[i]);
        }
      }
    },

    /*
      Looks for %PRAGMAS
    */
    render_pragmas: function (template) {
      // no pragmas
      if (!this.includes("%", template)) {
        return template;
      }

      var that = this;
      var regex = this.getCachedRegex("render_pragmas", function (otag, ctag) {
        return new RegExp(otag + "%([\\w-]+) ?([\\w]+=[\\w]+)?" + ctag, "g");
      });

      return template.replace(regex, function (match, pragma, options) {
        if (!that.pragmas_implemented[pragma]) {
          throw ({
            message:
              "This implementation of mustache doesn't understand the '" +
              pragma + "' pragma"
          });
        }
        that.pragmas[pragma] = {};
        if (options) {
          var opts = options.split("=");
          that.pragmas[pragma][opts[0]] = opts[1];
        }
        return "";
        // ignore unknown pragmas silently
      });
    },

    /*
      Tries to find a partial in the curent scope and render it
    */
    render_partial: function (name, context, partials) {
      name = trim(name);
      if (!partials || partials[name] === undefined) {
        throw ({ message: "unknown_partial '" + name + "'" });
      }
      if (!context || typeof context[name] != "object") {
        return this.render(partials[name], context, partials, true);
      }
      return this.render(partials[name], context[name], partials, true);
    },

    /*
      Renders inverted (^) and normal (#) sections
    */
    render_section: function (template, context, partials) {
      if (!this.includes("#", template) && !this.includes("^", template)) {
        // did not render anything, there were no sections
        return false;
      }

      var that = this;

      var regex = this.getCachedRegex("render_section", function (otag, ctag) {
        // This regex matches _the first_ section ({{#foo}}{{/foo}}), and captures the remainder
        return new RegExp(
          "^([\\s\\S]*?)" +         // all the crap at the beginning that is not {{*}} ($1)

          otag +                    // {{
          "(\\^|\\#)\\s*(.+)\\s*" + //  #foo (# == $2, foo == $3)
          ctag +                    // }}

          "\n*([\\s\\S]*?)" +       // between the tag ($2). leading newlines are dropped

          otag +                    // {{
          "\\/\\s*\\3\\s*" +        //  /foo (backreference to the opening tag).
          ctag +                    // }}

          "\\s*([\\s\\S]*)$",       // everything else in the string ($4). leading whitespace is dropped.

          "g");
      });


      // for each {{#foo}}{{/foo}} section do...
      return template.replace(regex, function (match, before, type, name, content, after) {
        // before contains only tags, no sections
        var renderedBefore = before ? that.render_tags(before, context, partials, true) : "",

          // after may contain both sections and tags, so use full rendering function
          renderedAfter = after ? that.render(after, context, partials, true) : "",

          // will be computed below
          renderedContent,

          value = that.find(name, context);

        if (type === "^") { // inverted section
          if (!value || Array.isArray(value) && value.length === 0) {
            // false or empty list, render it
            renderedContent = that.render(content, context, partials, true);
          } else {
            renderedContent = "";
          }
        } else if (type === "#") { // normal section
          if (Array.isArray(value)) { // Enumerable, Let's loop!
            renderedContent = that.map(value, function (row) {
              return that.render(content, that.create_context(row), partials, true);
            }).join("");
          } else if (that.is_object(value)) { // Object, Use it as subcontext!
            renderedContent = that.render(content, that.create_context(value),
              partials, true);
          } else if (typeof value == "function") {
            // higher order section
            renderedContent = value.call(context, content, function (text) {
              return that.render(text, context, partials, true);
            });
          } else if (value) { // boolean section
            renderedContent = that.render(content, context, partials, true);
          } else {
            renderedContent = "";
          }
        }

        return renderedBefore + renderedContent + renderedAfter;
      });
    },

    /*
      Replace {{foo}} and friends with values from our view
    */
    render_tags: function (template, context, partials, in_recursion) {
      // tit for tat
      var that = this;

      var new_regex = function () {
        return that.getCachedRegex("render_tags", function (otag, ctag) {
          return new RegExp(otag + "(=|!|>|&|\\{|%)?([^#\\^]+?)\\1?" + ctag + "+", "g");
        });
      };

      var regex = new_regex();
      var tag_replace_callback = function (match, operator, name) {
        switch (operator) {
          case "!": // ignore comments
            return "";
          case "=": // set new delimiters, rebuild the replace regexp
            that.set_delimiters(name);
            regex = new_regex();
            return "";
          case ">": // render partial
            return that.render_partial(name, context, partials);
          case "{": // the triple mustache is unescaped
          case "&": // & operator is an alternative unescape method
            return that.find(name, context);
          default: // escape the value
            return escapeHTML(that.find(name, context));
        }
      };
      var lines = template.split("\n");
      for (var i = 0; i < lines.length; i++) {
        lines[i] = lines[i].replace(regex, tag_replace_callback, this);
        if (!in_recursion) {
          this.send(lines[i]);
        }
      }

      if (in_recursion) {
        return lines.join("\n");
      }
    },

    set_delimiters: function (delimiters) {
      var dels = delimiters.split(" ");
      this.otag = this.escape_regex(dels[0]);
      this.ctag = this.escape_regex(dels[1]);
    },

    escape_regex: function (text) {
      // thank you Simon Willison
      if (!arguments.callee.sRE) {
        var specials = [
          '/', '.', '*', '+', '?', '|',
          '(', ')', '[', ']', '{', '}', '\\'
        ];
        arguments.callee.sRE = new RegExp(
          '(\\' + specials.join('|\\') + ')', 'g'
        );
      }
      return text.replace(arguments.callee.sRE, '\\$1');
    },

    /*
      find `name` in current `context`. That is find me a value
      from the view object
    */
    find: function (name, context) {
      name = trim(name);

      // Checks whether a value is thruthy or false or 0
      function is_kinda_truthy(bool) {
        return bool === false || bool === 0 || bool;
      }

      var value;

      // check for dot notation eg. foo.bar
      if (name.match(/([a-z_]+)\./ig)) {
        var childValue = this.walk_context(name, context);
        if (is_kinda_truthy(childValue)) {
          value = childValue;
        }
      } else {
        if (is_kinda_truthy(context[name])) {
          value = context[name];
        } else if (is_kinda_truthy(this.context[name])) {
          value = this.context[name];
        }
      }

      if (typeof value == "function") {
        return value.apply(context);
      }
      if (value !== undefined) {
        return value;
      }
      // silently ignore unkown variables
      return "";
    },

    walk_context: function (name, context) {
      var path = name.split('.');
      // if the var doesn't exist in current context, check the top level context
      var value_context = (context[path[0]] != undefined) ? context : this.context;
      var value = value_context[path.shift()];
      while (value != undefined && path.length > 0) {
        value_context = value;
        value = value[path.shift()];
      }
      // if the value is a function, call it, binding the correct context
      if (typeof value == "function") {
        return value.apply(value_context);
      }
      return value;
    },

    // Utility methods

    /* includes tag */
    includes: function (needle, haystack) {
      return haystack.indexOf(this.otag + needle) != -1;
    },

    // by @langalex, support for arrays of strings
    create_context: function (_context) {
      if (this.is_object(_context)) {
        return _context;
      } else {
        var iterator = ".";
        if (this.pragmas["IMPLICIT-ITERATOR"]) {
          iterator = this.pragmas["IMPLICIT-ITERATOR"].iterator;
        }
        var ctx = {};
        ctx[iterator] = _context;
        return ctx;
      }
    },

    is_object: function (a) {
      return a && typeof a == "object";
    },

    /*
      Why, why, why? Because IE. Cry, cry cry.
    */
    map: function (array, fn) {
      if (typeof array.map == "function") {
        return array.map(fn);
      } else {
        var r = [];
        var l = array.length;
        for (var i = 0; i < l; i++) {
          r.push(fn(array[i]));
        }
        return r;
      }
    },

    getCachedRegex: function (name, generator) {
      var byOtag = regexCache[this.otag];
      if (!byOtag) {
        byOtag = regexCache[this.otag] = {};
      }

      var byCtag = byOtag[this.ctag];
      if (!byCtag) {
        byCtag = byOtag[this.ctag] = {};
      }

      var regex = byCtag[name];
      if (!regex) {
        regex = byCtag[name] = generator(this.otag, this.ctag);
      }

      return regex;
    }
  };

  return ({
    name: "mustache.js",
    version: "0.4.0",

    /*
      Turns a template and view into HTML
    */
    to_html: function (template, view, partials, send_fun) {
      var renderer = new Renderer();
      if (send_fun) {
        renderer.send = send_fun;
      }
      renderer.render(template, view || {}, partials);
      if (!send_fun) {
        return renderer.buffer.join("\n");
      }
    }
  });
}();
if (typeof module !== 'undefined' && module.exports) {
  exports.name = Mustache.name;
  exports.version = Mustache.version;

  exports.to_html = function () {
    return Mustache.to_html.apply(this, arguments);
  };
}
/*!
 * Modest Maps JS v3.3.6
 * http://modestmaps.com/
 *
 * Copyright (c) 2011 Stamen Design, All Rights Reserved.
 *
 * Open source under the BSD License.
 * http://creativecommons.org/licenses/BSD/
 *
 * Versioned using Semantic Versioning (v.major.minor.patch)
 * See CHANGELOG and http://semver.org/ for more details.
 *
 */

var previousMM = MM;

// namespacing for backwards-compatibility
if (!com) {
  var com = {};
  if (!com.modestmaps) com.modestmaps = {};
}

var MM = com.modestmaps = {
  noConflict: function () {
    MM = previousMM;
    return this;
  }
};

(function (MM) {
  // Make inheritance bearable: clone one level of properties
  MM.extend = function (child, parent) {
    for (var property in parent.prototype) {
      if (typeof child.prototype[property] == "undefined") {
        child.prototype[property] = parent.prototype[property];
      }
    }
    return child;
  };

  MM.getFrame = function () {
    // native animation frames
    // http://webstuff.nfshost.com/anim-timing/Overview.html
    // http://dev.chromium.org/developers/design-documents/requestanimationframe-implementation
    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    // can't apply these directly to MM because Chrome needs window
    // to own webkitRequestAnimationFrame (for example)
    // perhaps we should namespace an alias onto window instead?
    // e.g. window.mmRequestAnimationFrame?
    return function (callback) {
      (window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function (callback) {
          window.setTimeout(function () {
            callback(+new Date());
          }, 10);
        })(callback);
    };
  }();

  // Inspired by LeafletJS
  MM.transformProperty = (function (props) {
    if (!this.document) return; // node.js safety
    var style = document.documentElement.style;
    for (var i = 0; i < props.length; i++) {
      if (props[i] in style) {
        return props[i];
      }
    }
    return false;
  })(['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

  MM.matrixString = function (point) {
    // Make the result of point.scale * point.width a whole number.
    if (point.scale * point.width % 1) {
      point.scale += (1 - point.scale * point.width % 1) / point.width;
    }

    var scale = point.scale || 1;
    if (MM._browser.webkit3d) {
      return 'translate3d(' +
        point.x.toFixed(0) + 'px,' + point.y.toFixed(0) + 'px, 0px)' +
        'scale3d(' + scale + ',' + scale + ', 1)';
    } else {
      return 'translate(' +
        point.x.toFixed(6) + 'px,' + point.y.toFixed(6) + 'px)' +
        'scale(' + scale + ',' + scale + ')';
    }
  };

  MM._browser = (function (window) {
    return {
      webkit: ('WebKitCSSMatrix' in window),
      webkit3d: ('WebKitCSSMatrix' in window) && ('m11' in new WebKitCSSMatrix())
    };
  })(this); // use this for node.js global

  MM.moveElement = function (el, point) {
    if (MM.transformProperty) {
      // Optimize for identity transforms, where you don't actually
      // need to change this element's string. Browsers can optimize for
      // the .style.left case but not for this CSS case.
      if (!point.scale) point.scale = 1;
      if (!point.width) point.width = 0;
      if (!point.height) point.height = 0;
      var ms = MM.matrixString(point);
      if (el[MM.transformProperty] !== ms) {
        el.style[MM.transformProperty] =
          el[MM.transformProperty] = ms;
      }
    } else {
      el.style.left = point.x + 'px';
      el.style.top = point.y + 'px';
      // Don't set width unless asked to: this is performance-intensive
      // and not always necessary
      if (point.width && point.height && point.scale) {
        el.style.width = Math.ceil(point.width * point.scale) + 'px';
        el.style.height = Math.ceil(point.height * point.scale) + 'px';
      }
    }
  };

  // Events
  // Cancel an event: prevent it from bubbling
  MM.cancelEvent = function (e) {
    // there's more than one way to skin this cat
    if (e.target.nodeName.toLowerCase() == "li"
      || e.target.parentNode.nodeName.toLowerCase() == "li"
      || e.target.parentNode.parentNode.nodeName.toLowerCase() == "li"
      || e.target.parentNode.parentNode.parentNode.nodeName.toLowerCase() == "li"
      || e.target.parentNode.parentNode.parentNode.parentNode.nodeName.toLowerCase() == "li"
      || e.target.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName.toLowerCase() == "li"
    ) {
      // don't block
      // console.log("Don't block event");
    } else {
      e.cancelBubble = true;
      e.cancel = true;
      e.returnValue = false;
      if (e.stopPropagation) { e.stopPropagation(); }
      if (e.preventDefault) { e.preventDefault(); }
      return false;
    }
  };

  MM.coerceLayer = function (layerish) {
    if (typeof layerish == 'string') {
      // Probably a template string
      return new MM.Layer(new MM.TemplatedLayer(layerish));
    } else if ('draw' in layerish && typeof layerish.draw == 'function') {
      // good enough, though we should probably enforce .parent and .destroy() too
      return layerish;
    } else {
      // probably a MapProvider
      return new MM.Layer(layerish);
    }
  };

  // see http://ejohn.org/apps/jselect/event.html for the originals
  MM.addEvent = function (obj, type, fn) {
    if (obj.addEventListener) {
      obj.addEventListener(type, fn, false);
      if (type == 'mousewheel') {
        obj.addEventListener('DOMMouseScroll', fn, false);
      }
    } else if (obj.attachEvent) {
      obj['e' + type + fn] = fn;
      obj[type + fn] = function () { obj['e' + type + fn](window.event); };
      obj.attachEvent('on' + type, obj[type + fn]);
    }
  };

  MM.removeEvent = function (obj, type, fn) {
    if (obj.removeEventListener) {
      obj.removeEventListener(type, fn, false);
      if (type == 'mousewheel') {
        obj.removeEventListener('DOMMouseScroll', fn, false);
      }
    } else if (obj.detachEvent) {
      obj.detachEvent('on' + type, obj[type + fn]);
      obj[type + fn] = null;
    }
  };

  // Cross-browser function to get current element style property
  MM.getStyle = function (el, styleProp) {
    if (el.currentStyle)
      return el.currentStyle[styleProp];
    else if (window.getComputedStyle)
      return document.defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);
  };
  // Point
  MM.Point = function (x, y) {
    this.x = parseFloat(x);
    this.y = parseFloat(y);
  };

  MM.Point.prototype = {
    x: 0,
    y: 0,
    toString: function () {
      return "(" + this.x.toFixed(3) + ", " + this.y.toFixed(3) + ")";
    },
    copy: function () {
      return new MM.Point(this.x, this.y);
    }
  };

  // Get the euclidean distance between two points
  MM.Point.distance = function (p1, p2) {
    return Math.sqrt(
      Math.pow(p2.x - p1.x, 2) +
      Math.pow(p2.y - p1.y, 2));
  };

  // Get a point between two other points, biased by `t`.
  MM.Point.interpolate = function (p1, p2, t) {
    return new MM.Point(
      p1.x + (p2.x - p1.x) * t,
      p1.y + (p2.y - p1.y) * t);
  };
  // Coordinate
  // ----------
  // An object representing a tile position, at as specified zoom level.
  // This is not necessarily a precise tile - `row`, `column`, and
  // `zoom` can be floating-point numbers, and the `container()` function
  // can be used to find the actual tile that contains the point.
  MM.Coordinate = function (row, column, zoom) {
    this.row = row;
    this.column = column;
    this.zoom = zoom;
  };

  MM.Coordinate.prototype = {

    row: 0,
    column: 0,
    zoom: 0,

    toString: function () {
      return "(" + this.row.toFixed(3) +
        ", " + this.column.toFixed(3) +
        " @" + this.zoom.toFixed(3) + ")";
    },
    // Quickly generate a string representation of this coordinate to
    // index it in hashes.
    toKey: function () {
      // We've tried to use efficient hash functions here before but we took
      // them out. Contributions welcome but watch out for collisions when the
      // row or column are negative and check thoroughly (exhaustively) before
      // committing.
      return this.zoom + ',' + this.row + ',' + this.column;
    },
    // Clone this object.
    copy: function () {
      return new MM.Coordinate(this.row, this.column, this.zoom);
    },
    // Get the actual, rounded-number tile that contains this point.
    container: function () {
      // using floor here (not parseInt, ~~) because we want -0.56 --> -1
      return new MM.Coordinate(Math.floor(this.row),
        Math.floor(this.column),
        Math.floor(this.zoom));
    },
    // Recalculate this Coordinate at a different zoom level and return the
    // new object.
    zoomTo: function (destination) {
      var power = Math.pow(2, destination - this.zoom);
      return new MM.Coordinate(this.row * power,
        this.column * power,
        destination);
    },
    // Recalculate this Coordinate at a different relative zoom level and return the
    // new object.
    zoomBy: function (distance) {
      var power = Math.pow(2, distance);
      return new MM.Coordinate(this.row * power,
        this.column * power,
        this.zoom + distance);
    },
    // Move this coordinate up by `dist` coordinates
    up: function (dist) {
      if (dist === undefined) dist = 1;
      return new MM.Coordinate(this.row - dist, this.column, this.zoom);
    },
    // Move this coordinate right by `dist` coordinates
    right: function (dist) {
      if (dist === undefined) dist = 1;
      return new MM.Coordinate(this.row, this.column + dist, this.zoom);
    },
    // Move this coordinate down by `dist` coordinates
    down: function (dist) {
      if (dist === undefined) dist = 1;
      return new MM.Coordinate(this.row + dist, this.column, this.zoom);
    },
    // Move this coordinate left by `dist` coordinates
    left: function (dist) {
      if (dist === undefined) dist = 1;
      return new MM.Coordinate(this.row, this.column - dist, this.zoom);
    }
  };
  // Location
  // --------
  MM.Location = function (lat, lon) {
    this.lat = parseFloat(lat);
    this.lon = parseFloat(lon);
  };

  MM.Location.prototype = {
    lat: 0,
    lon: 0,
    toString: function () {
      return "(" + this.lat.toFixed(3) + ", " + this.lon.toFixed(3) + ")";
    },
    copy: function () {
      return new MM.Location(this.lat, this.lon);
    }
  };

  // returns approximate distance between start and end locations
  //
  // default unit is meters
  //
  // you can specify different units by optionally providing the
  // earth's radius in the units you desire
  //
  // Default is 6,378,000 metres, suggested values are:
  //
  // * 3963.1 statute miles
  // * 3443.9 nautical miles
  // * 6378 km
  //
  // see [Formula and code for calculating distance based on two lat/lon locations](http://jan.ucc.nau.edu/~cvm/latlon_formula.html)
  MM.Location.distance = function (l1, l2, r) {
    if (!r) {
      // default to meters
      r = 6378000;
    }
    var deg2rad = Math.PI / 180.0,
      a1 = l1.lat * deg2rad,
      b1 = l1.lon * deg2rad,
      a2 = l2.lat * deg2rad,
      b2 = l2.lon * deg2rad,
      c = Math.cos(a1) * Math.cos(b1) * Math.cos(a2) * Math.cos(b2),
      d = Math.cos(a1) * Math.sin(b1) * Math.cos(a2) * Math.sin(b2),
      e = Math.sin(a1) * Math.sin(a2);
    return Math.acos(c + d + e) * r;
  };

  // Interpolates along a great circle, f between 0 and 1
  //
  // * FIXME: could be heavily optimized (lots of trig calls to cache)
  // * FIXME: could be inmproved for calculating a full path
  MM.Location.interpolate = function (l1, l2, f) {
    if (l1.lat === l2.lat && l1.lon === l2.lon) {
      return new MM.Location(l1.lat, l1.lon);
    }
    var deg2rad = Math.PI / 180.0,
      lat1 = l1.lat * deg2rad,
      lon1 = l1.lon * deg2rad,
      lat2 = l2.lat * deg2rad,
      lon2 = l2.lon * deg2rad;

    var d = 2 * Math.asin(
      Math.sqrt(
        Math.pow(Math.sin((lat1 - lat2) / 2), 2) +
        Math.cos(lat1) * Math.cos(lat2) *
        Math.pow(Math.sin((lon1 - lon2) / 2), 2)));

    var A = Math.sin((1 - f) * d) / Math.sin(d);
    var B = Math.sin(f * d) / Math.sin(d);
    var x = A * Math.cos(lat1) * Math.cos(lon1) +
      B * Math.cos(lat2) * Math.cos(lon2);
    var y = A * Math.cos(lat1) * Math.sin(lon1) +
      B * Math.cos(lat2) * Math.sin(lon2);
    var z = A * Math.sin(lat1) + B * Math.sin(lat2);

    var latN = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
    var lonN = Math.atan2(y, x);

    return new MM.Location(latN / deg2rad, lonN / deg2rad);
  };

  // Returns bearing from one point to another
  //
  // * FIXME: bearing is not constant along significant great circle arcs.
  MM.Location.bearing = function (l1, l2) {
    var deg2rad = Math.PI / 180.0,
      lat1 = l1.lat * deg2rad,
      lon1 = l1.lon * deg2rad,
      lat2 = l2.lat * deg2rad,
      lon2 = l2.lon * deg2rad;
    var result = Math.atan2(
      Math.sin(lon1 - lon2) *
      Math.cos(lat2),
      Math.cos(lat1) *
      Math.sin(lat2) -
      Math.sin(lat1) *
      Math.cos(lat2) *
      Math.cos(lon1 - lon2)
    ) / -(Math.PI / 180);

    // map it into 0-360 range
    return (result < 0) ? result + 360 : result;
  };
  // Extent
  // ----------
  // An object representing a map's rectangular extent, defined by its north,
  // south, east and west bounds.

  MM.Extent = function (north, west, south, east) {
    if (north instanceof MM.Location &&
      west instanceof MM.Location) {
      var northwest = north,
        southeast = west;

      north = northwest.lat;
      west = northwest.lon;
      south = southeast.lat;
      east = southeast.lon;
    }
    if (isNaN(south)) south = north;
    if (isNaN(east)) east = west;
    this.north = Math.max(north, south);
    this.south = Math.min(north, south);
    this.east = Math.max(east, west);
    this.west = Math.min(east, west);
  };

  MM.Extent.prototype = {
    // boundary attributes
    north: 0,
    south: 0,
    east: 0,
    west: 0,

    copy: function () {
      return new MM.Extent(this.north, this.west, this.south, this.east);
    },

    toString: function (precision) {
      if (isNaN(precision)) precision = 3;
      return [
        this.north.toFixed(precision),
        this.west.toFixed(precision),
        this.south.toFixed(precision),
        this.east.toFixed(precision)
      ].join(", ");
    },

    // getters for the corner locations
    northWest: function () {
      return new MM.Location(this.north, this.west);
    },
    southEast: function () {
      return new MM.Location(this.south, this.east);
    },
    northEast: function () {
      return new MM.Location(this.north, this.east);
    },
    southWest: function () {
      return new MM.Location(this.south, this.west);
    },
    // getter for the center location
    center: function () {
      return new MM.Location(
        this.south + (this.north - this.south) / 2,
        this.east + (this.west - this.east) / 2
      );
    },

    // extend the bounds to include a location's latitude and longitude
    encloseLocation: function (loc) {
      if (loc.lat > this.north) this.north = loc.lat;
      if (loc.lat < this.south) this.south = loc.lat;
      if (loc.lon > this.east) this.east = loc.lon;
      if (loc.lon < this.west) this.west = loc.lon;
    },

    // extend the bounds to include multiple locations
    encloseLocations: function (locations) {
      var len = locations.length;
      for (var i = 0; i < len; i++) {
        this.encloseLocation(locations[i]);
      }
    },

    // reset bounds from a list of locations
    setFromLocations: function (locations) {
      var len = locations.length,
        first = locations[0];
      this.north = this.south = first.lat;
      this.east = this.west = first.lon;
      for (var i = 1; i < len; i++) {
        this.encloseLocation(locations[i]);
      }
    },

    // extend the bounds to include another extent
    encloseExtent: function (extent) {
      if (extent.north > this.north) this.north = extent.north;
      if (extent.south < this.south) this.south = extent.south;
      if (extent.east > this.east) this.east = extent.east;
      if (extent.west < this.west) this.west = extent.west;
    },

    // determine if a location is within this extent
    containsLocation: function (loc) {
      return loc.lat >= this.south &&
        loc.lat <= this.north &&
        loc.lon >= this.west &&
        loc.lon <= this.east;
    },

    // turn an extent into an array of locations containing its northwest
    // and southeast corners (used in MM.Map.setExtent())
    toArray: function () {
      return [this.northWest(), this.southEast()];
    }
  };

  MM.Extent.fromString = function (str) {
    var parts = str.split(/\s*,\s*/);
    if (parts.length != 4) {
      throw "Invalid extent string (expecting 4 comma-separated numbers)";
    }
    return new MM.Extent(
      parseFloat(parts[0]),
      parseFloat(parts[1]),
      parseFloat(parts[2]),
      parseFloat(parts[3])
    );
  };

  MM.Extent.fromArray = function (locations) {
    var extent = new MM.Extent();
    extent.setFromLocations(locations);
    return extent;
  };

  // Transformation
  // --------------
  MM.Transformation = function (ax, bx, cx, ay, by, cy) {
    this.ax = ax;
    this.bx = bx;
    this.cx = cx;
    this.ay = ay;
    this.by = by;
    this.cy = cy;
  };

  MM.Transformation.prototype = {

    ax: 0,
    bx: 0,
    cx: 0,
    ay: 0,
    by: 0,
    cy: 0,

    transform: function (point) {
      return new MM.Point(this.ax * point.x + this.bx * point.y + this.cx,
        this.ay * point.x + this.by * point.y + this.cy);
    },

    untransform: function (point) {
      return new MM.Point((point.x * this.by - point.y * this.bx -
        this.cx * this.by + this.cy * this.bx) /
        (this.ax * this.by - this.ay * this.bx),
        (point.x * this.ay - point.y * this.ax -
          this.cx * this.ay + this.cy * this.ax) /
        (this.bx * this.ay - this.by * this.ax));
    }

  };


  // Generates a transform based on three pairs of points,
  // a1 -> a2, b1 -> b2, c1 -> c2.
  MM.deriveTransformation = function (a1x, a1y, a2x, a2y,
    b1x, b1y, b2x, b2y,
    c1x, c1y, c2x, c2y) {
    var x = MM.linearSolution(a1x, a1y, a2x,
      b1x, b1y, b2x,
      c1x, c1y, c2x);
    var y = MM.linearSolution(a1x, a1y, a2y,
      b1x, b1y, b2y,
      c1x, c1y, c2y);
    return new MM.Transformation(x[0], x[1], x[2], y[0], y[1], y[2]);
  };

  // Solves a system of linear equations.
  //
  //     t1 = (a * r1) + (b + s1) + c
  //     t2 = (a * r2) + (b + s2) + c
  //     t3 = (a * r3) + (b + s3) + c
  //
  // r1 - t3 are the known values.
  // a, b, c are the unknowns to be solved.
  // returns the a, b, c coefficients.
  MM.linearSolution = function (r1, s1, t1, r2, s2, t2, r3, s3, t3) {
    // make them all floats
    r1 = parseFloat(r1);
    s1 = parseFloat(s1);
    t1 = parseFloat(t1);
    r2 = parseFloat(r2);
    s2 = parseFloat(s2);
    t2 = parseFloat(t2);
    r3 = parseFloat(r3);
    s3 = parseFloat(s3);
    t3 = parseFloat(t3);

    var a = (((t2 - t3) * (s1 - s2)) - ((t1 - t2) * (s2 - s3))) /
      (((r2 - r3) * (s1 - s2)) - ((r1 - r2) * (s2 - s3)));

    var b = (((t2 - t3) * (r1 - r2)) - ((t1 - t2) * (r2 - r3))) /
      (((s2 - s3) * (r1 - r2)) - ((s1 - s2) * (r2 - r3)));

    var c = t1 - (r1 * a) - (s1 * b);
    return [a, b, c];
  };
  // Projection
  // ----------

  // An abstract class / interface for projections
  MM.Projection = function (zoom, transformation) {
    if (!transformation) {
      transformation = new MM.Transformation(1, 0, 0, 0, 1, 0);
    }
    this.zoom = zoom;
    this.transformation = transformation;
  };

  MM.Projection.prototype = {

    zoom: 0,
    transformation: null,

    rawProject: function (point) {
      throw "Abstract method not implemented by subclass.";
    },

    rawUnproject: function (point) {
      throw "Abstract method not implemented by subclass.";
    },

    project: function (point) {
      point = this.rawProject(point);
      if (this.transformation) {
        point = this.transformation.transform(point);
      }
      return point;
    },

    unproject: function (point) {
      if (this.transformation) {
        point = this.transformation.untransform(point);
      }
      point = this.rawUnproject(point);
      return point;
    },

    locationCoordinate: function (location) {
      var point = new MM.Point(Math.PI * location.lon / 180.0,
        Math.PI * location.lat / 180.0);
      point = this.project(point);
      return new MM.Coordinate(point.y, point.x, this.zoom);
    },

    coordinateLocation: function (coordinate) {
      coordinate = coordinate.zoomTo(this.zoom);
      var point = new MM.Point(coordinate.column, coordinate.row);
      point = this.unproject(point);
      return new MM.Location(180.0 * point.y / Math.PI,
        180.0 * point.x / Math.PI);
    }
  };

  // A projection for equilateral maps, based on longitude and latitude
  MM.LinearProjection = function (zoom, transformation) {
    MM.Projection.call(this, zoom, transformation);
  };

  // The Linear projection doesn't reproject points
  MM.LinearProjection.prototype = {
    rawProject: function (point) {
      return new MM.Point(point.x, point.y);
    },
    rawUnproject: function (point) {
      return new MM.Point(point.x, point.y);
    }
  };

  MM.extend(MM.LinearProjection, MM.Projection);

  MM.MercatorProjection = function (zoom, transformation) {
    // super!
    MM.Projection.call(this, zoom, transformation);
  };

  // Project lon/lat points into meters required for Mercator
  MM.MercatorProjection.prototype = {
    rawProject: function (point) {
      return new MM.Point(point.x,
        Math.log(Math.tan(0.25 * Math.PI + 0.5 * point.y)));
    },

    rawUnproject: function (point) {
      return new MM.Point(point.x,
        2 * Math.atan(Math.pow(Math.E, point.y)) - 0.5 * Math.PI);
    }
  };

  MM.extend(MM.MercatorProjection, MM.Projection);
  // Providers
  // ---------
  // Providers provide tile URLs and possibly elements for layers.
  //
  // MapProvider ->
  //   Template
  //
  MM.MapProvider = function (getTile) {
    if (getTile) {
      this.getTile = getTile;
    }
  };

  MM.MapProvider.prototype = {

    // these are limits for available *tiles*
    // panning limits will be different (since you can wrap around columns)
    // but if you put Infinity in here it will screw up sourceCoordinate
    tileLimits: [
      new MM.Coordinate(0, 0, 0),             // top left outer
      new MM.Coordinate(1, 1, 0).zoomTo(18)   // bottom right inner
    ],

    getTileUrl: function (coordinate) {
      throw "Abstract method not implemented by subclass.";
    },

    getTile: function (coordinate) {
      throw "Abstract method not implemented by subclass.";
    },

    // releaseTile is not required
    releaseTile: function (element) { },

    // use this to tell MapProvider that tiles only exist between certain zoom levels.
    // should be set separately on Map to restrict interactive zoom/pan ranges
    setZoomRange: function (minZoom, maxZoom) {
      this.tileLimits[0] = this.tileLimits[0].zoomTo(minZoom);
      this.tileLimits[1] = this.tileLimits[1].zoomTo(maxZoom);
    },

    // wrap column around the world if necessary
    // return null if wrapped coordinate is outside of the tile limits
    sourceCoordinate: function (coord) {
      var TL = this.tileLimits[0].zoomTo(coord.zoom).container(),
        BR = this.tileLimits[1].zoomTo(coord.zoom),
        columnSize = Math.pow(2, coord.zoom),
        wrappedColumn;

      BR = new MM.Coordinate(Math.ceil(BR.row), Math.ceil(BR.column), Math.floor(BR.zoom));

      if (coord.column < 0) {
        wrappedColumn = ((coord.column % columnSize) + columnSize) % columnSize;
      } else {
        wrappedColumn = coord.column % columnSize;
      }

      if (coord.row < TL.row || coord.row >= BR.row) {
        return null;
      } else if (wrappedColumn < TL.column || wrappedColumn >= BR.column) {
        return null;
      } else {
        return new MM.Coordinate(coord.row, wrappedColumn, coord.zoom);
      }
    }
  };

  /**
   * FIXME: need a better explanation here! This is a pretty crucial part of
   * understanding how to use ModestMaps.
   *
   * TemplatedMapProvider is a tile provider that generates tile URLs from a
   * template string by replacing the following bits for each tile
   * coordinate:
   *
   * {Z}: the tile's zoom level (from 1 to ~20)
   * {X}: the tile's X, or column (from 0 to a very large number at higher
   * zooms)
   * {Y}: the tile's Y, or row (from 0 to a very large number at higher
   * zooms)
   *
   * E.g.:
   *
   * var osm = new MM.TemplatedMapProvider("http://tile.openstreetmap.org/{Z}/{X}/{Y}.png");
   *
   * Or:
   *
   * var placeholder = new MM.TemplatedMapProvider("http://placehold.it/256/f0f/fff.png&text={Z}/{X}/{Y}");
   *
   */
  MM.Template = function (template, subdomains) {
    var isQuadKey = template.match(/{(Q|quadkey)}/);
    // replace Microsoft style substitution strings
    if (isQuadKey) template = template
      .replace('{subdomains}', '{S}')
      .replace('{zoom}', '{Z}')
      .replace('{quadkey}', '{Q}');

    var hasSubdomains = (subdomains &&
      subdomains.length && template.indexOf("{S}") >= 0);

    function quadKey(row, column, zoom) {
      var key = '';
      for (var i = 1; i <= zoom; i++) {
        key += (((row >> zoom - i) & 1) << 1) | ((column >> zoom - i) & 1);
      }
      return key || '0';
    }

    var getTileUrl = function (coordinate) {
      var coord = this.sourceCoordinate(coordinate);
      if (!coord) {
        return null;
      }
      var base = template;
      if (hasSubdomains) {
        var index = parseInt(coord.zoom + coord.row + coord.column, 10) %
          subdomains.length;
        base = base.replace('{S}', subdomains[index]);
      }
      if (isQuadKey) {
        return base
          .replace('{Z}', coord.zoom.toFixed(0))
          .replace('{Q}', quadKey(coord.row,
            coord.column,
            coord.zoom));
      } else {
        return base
          .replace('{Z}', coord.zoom.toFixed(0))
          .replace('{X}', coord.column.toFixed(0))
          .replace('{Y}', coord.row.toFixed(0));
      }
    };

    MM.MapProvider.call(this, getTileUrl);
  };

  MM.Template.prototype = {
    // quadKey generator
    getTile: function (coord) {
      return this.getTileUrl(coord);
    }
  };

  MM.extend(MM.Template, MM.MapProvider);

  MM.TemplatedLayer = function (template, subdomains, name) {
    return new MM.Layer(new MM.Template(template, subdomains), null, name);
  };
  // Event Handlers
  // --------------

  // A utility function for finding the offset of the
  // mouse from the top-left of the page
  MM.getMousePoint = function (e, map) {
    // start with just the mouse (x, y)
    var point = new MM.Point(e.clientX, e.clientY);

    // correct for scrolled document
    point.x += document.body.scrollLeft + document.documentElement.scrollLeft;
    point.y += document.body.scrollTop + document.documentElement.scrollTop;

    // correct for nested offsets in DOM
    for (var node = map.parent; node; node = node.offsetParent) {
      point.x -= node.offsetLeft;
      point.y -= node.offsetTop;
    }
    return point;
  };

  MM.MouseWheelHandler = function () {
    var handler = {},
      map,
      _zoomDiv,
      prevTime,
      precise = false;

    function mouseWheel(e) {
      var delta = 0;
      prevTime = prevTime || new Date().getTime();

      try {
        _zoomDiv.scrollTop = 1000;
        _zoomDiv.dispatchEvent(e);
        delta = 1000 - _zoomDiv.scrollTop;
      } catch (error) {
        delta = e.wheelDelta || (-e.detail * 5);
      }

      // limit mousewheeling to once every 200ms
      var timeSince = new Date().getTime() - prevTime;
      var point = MM.getMousePoint(e, map);

      if (Math.abs(delta) > 0 && (timeSince > 200) && !precise) {
        map.zoomByAbout(delta > 0 ? 1 : -1, point);
        prevTime = new Date().getTime();
      } else if (precise) {
        map.zoomByAbout(delta * 0.001, point);
      }

      // Cancel the event so that the page doesn't scroll
      return MM.cancelEvent(e);
    }

    handler.init = function (x) {
      map = x;
      _zoomDiv = document.body.appendChild(document.createElement('div'));
      _zoomDiv.style.cssText = 'visibility:hidden;top:0;height:0;width:0;overflow-y:scroll';
      var innerDiv = _zoomDiv.appendChild(document.createElement('div'));
      innerDiv.style.height = '2000px';
      MM.addEvent(map.parent, 'mousewheel', mouseWheel);
      return handler;
    };

    handler.precise = function (x) {
      if (!arguments.length) return precise;
      precise = x;
      return handler;
    };

    handler.remove = function () {
      MM.removeEvent(map.parent, 'mousewheel', mouseWheel);
      _zoomDiv.parentNode.removeChild(_zoomDiv);
    };

    return handler;
  };

  MM.DoubleClickHandler = function () {
    var handler = {},
      map;

    function doubleClick(e) {
      // Ensure that this handler is attached once.
      // Get the point on the map that was double-clicked
      var point = MM.getMousePoint(e, map);
      // use shift-double-click to zoom out
      map.zoomByAbout(e.shiftKey ? -1 : 1, point);
      return MM.cancelEvent(e);
    }

    handler.init = function (x) {
      map = x;
      MM.addEvent(map.parent, 'dblclick', doubleClick);
      return handler;
    };

    handler.remove = function () {
      MM.removeEvent(map.parent, 'dblclick', doubleClick);
    };

    return handler;
  };

  // Handle the use of mouse dragging to pan the map.
  MM.DragHandler = function () {
    var handler = {},
      prevMouse,
      map;

    function mouseDown(e) {
      if (e.shiftKey || e.button == 2) return;
      MM.addEvent(document, 'mouseup', mouseUp);
      MM.addEvent(document, 'mousemove', mouseMove);

      prevMouse = new MM.Point(e.clientX, e.clientY);
      map.parent.style.cursor = 'move';

      return MM.cancelEvent(e);
    }

    function mouseUp(e) {
      MM.removeEvent(document, 'mouseup', mouseUp);
      MM.removeEvent(document, 'mousemove', mouseMove);

      prevMouse = null;
      map.parent.style.cursor = '';

      return MM.cancelEvent(e);
    }

    function mouseMove(e) {
      if (prevMouse) {
        map.panBy(
          e.clientX - prevMouse.x,
          e.clientY - prevMouse.y);
        prevMouse.x = e.clientX;
        prevMouse.y = e.clientY;
        prevMouse.t = +new Date();
      }

      return MM.cancelEvent(e);
    }

    handler.init = function (x) {
      map = x;
      MM.addEvent(map.parent, 'mousedown', mouseDown);
      return handler;
    };

    handler.remove = function () {
      MM.removeEvent(map.parent, 'mousedown', mouseDown);
    };

    return handler;
  };

  MM.MouseHandler = function () {
    var handler = {},
      map,
      handlers;

    handler.init = function (x) {
      map = x;
      handlers = [
        MM.DragHandler().init(map),
        MM.DoubleClickHandler().init(map),
        MM.MouseWheelHandler().init(map)
      ];
      return handler;
    };

    handler.remove = function () {
      for (var i = 0; i < handlers.length; i++) {
        handlers[i].remove();
      }
      return handler;
    };

    return handler;
  };
  MM.TouchHandler = function () {
    var handler = {},
      map,
      maxTapTime = 250,
      maxTapDistance = 30,
      maxDoubleTapDelay = 350,
      locations = {},
      taps = [],
      snapToZoom = true,
      wasPinching = false,
      lastPinchCenter = null;

    function isTouchable() {
      var el = document.createElement('div');
      el.setAttribute('ongesturestart', 'return;');
      return (typeof el.ongesturestart === 'function');
    }

    function updateTouches(e) {
      for (var i = 0; i < e.touches.length; i += 1) {
        var t = e.touches[i];
        if (t.identifier in locations) {
          var l = locations[t.identifier];
          l.x = t.clientX;
          l.y = t.clientY;
          l.scale = e.scale;
        }
        else {
          locations[t.identifier] = {
            scale: e.scale,
            startPos: { x: t.clientX, y: t.clientY },
            x: t.clientX,
            y: t.clientY,
            time: new Date().getTime()
          };
        }
      }
    }

    // Test whether touches are from the same source -
    // whether this is the same touchmove event.
    function sameTouch(event, touch) {
      return (event && event.touch) &&
        (touch.identifier == event.touch.identifier);
    }

    function touchStart(e) {
      updateTouches(e);
    }

    function touchMove(e) {
      switch (e.touches.length) {
        case 1:
          onPanning(e.touches[0]);
          break;
        case 2:
          onPinching(e);
          break;
      }
      updateTouches(e);
      return MM.cancelEvent(e);
    }

    function touchEnd(e) {
      var now = new Date().getTime();
      // round zoom if we're done pinching
      if (e.touches.length === 0 && wasPinching) {
        onPinched(lastPinchCenter);
      }

      // Look at each changed touch in turn.
      for (var i = 0; i < e.changedTouches.length; i += 1) {
        var t = e.changedTouches[i],
          loc = locations[t.identifier];
        // if we didn't see this one (bug?)
        // or if it was consumed by pinching already
        // just skip to the next one
        if (!loc || loc.wasPinch) {
          continue;
        }

        // we now know we have an event object and a
        // matching touch that's just ended. Let's see
        // what kind of event it is based on how long it
        // lasted and how far it moved.
        var pos = { x: t.clientX, y: t.clientY },
          time = now - loc.time,
          travel = MM.Point.distance(pos, loc.startPos);
        if (travel > maxTapDistance) {
          // we will to assume that the drag has been handled separately
        } else if (time > maxTapTime) {
          // close in space, but not in time: a hold
          pos.end = now;
          pos.duration = time;
          onHold(pos);
        } else {
          // close in both time and space: a tap
          pos.time = now;
          onTap(pos);
        }
      }

      // Weird, sometimes an end event doesn't get thrown
      // for a touch that nevertheless has disappeared.
      // Still, this will eventually catch those ids:

      var validTouchIds = {};
      for (var j = 0; j < e.touches.length; j++) {
        validTouchIds[e.touches[j].identifier] = true;
      }
      for (var id in locations) {
        if (!(id in validTouchIds)) {
          delete validTouchIds[id];
        }
      }

      return MM.cancelEvent(e);
    }

    function onHold(hold) {
      // TODO
    }

    // Handle a tap event - mainly watch for a doubleTap
    function onTap(tap) {
      if (taps.length &&
        (tap.time - taps[0].time) < maxDoubleTapDelay) {
        onDoubleTap(tap);
        taps = [];
        return;
      }
      taps = [tap];
    }

    // Handle a double tap by zooming in a single zoom level to a
    // round zoom.
    function onDoubleTap(tap) {
      var z = map.getZoom(), // current zoom
        tz = Math.round(z) + 1, // target zoom
        dz = tz - z;            // desired delate

      // zoom in to a round number
      var p = new MM.Point(tap.x, tap.y);
      map.zoomByAbout(dz, p);
    }

    // Re-transform the actual map parent's CSS transformation
    function onPanning(touch) {
      var pos = { x: touch.clientX, y: touch.clientY },
        prev = locations[touch.identifier];
      map.panBy(pos.x - prev.x, pos.y - prev.y);
    }

    function onPinching(e) {
      // use the first two touches and their previous positions
      var t0 = e.touches[0],
        t1 = e.touches[1],
        p0 = new MM.Point(t0.clientX, t0.clientY),
        p1 = new MM.Point(t1.clientX, t1.clientY),
        l0 = locations[t0.identifier],
        l1 = locations[t1.identifier];

      // mark these touches so they aren't used as taps/holds
      l0.wasPinch = true;
      l1.wasPinch = true;

      // scale about the center of these touches
      var center = MM.Point.interpolate(p0, p1, 0.5);

      map.zoomByAbout(
        Math.log(e.scale) / Math.LN2 -
        Math.log(l0.scale) / Math.LN2,
        center);

      // pan from the previous center of these touches
      var prevCenter = MM.Point.interpolate(l0, l1, 0.5);

      map.panBy(center.x - prevCenter.x,
        center.y - prevCenter.y);
      wasPinching = true;
      lastPinchCenter = center;
    }

    // When a pinch event ends, round the zoom of the map.
    function onPinched(p) {
      // TODO: easing
      if (snapToZoom) {
        var z = map.getZoom(), // current zoom
          tz = Math.round(z);     // target zoom
        map.zoomByAbout(tz - z, p);
      }
      wasPinching = false;
    }

    handler.init = function (x) {
      map = x;

      // Fail early if this isn't a touch device.
      if (!isTouchable()) return handler;

      MM.addEvent(map.parent, 'touchstart', touchStart);
      MM.addEvent(map.parent, 'touchmove', touchMove);
      MM.addEvent(map.parent, 'touchend', touchEnd);
      return handler;
    };

    handler.remove = function () {
      // Fail early if this isn't a touch device.
      if (!isTouchable()) return handler;

      MM.removeEvent(map.parent, 'touchstart', touchStart);
      MM.removeEvent(map.parent, 'touchmove', touchMove);
      MM.removeEvent(map.parent, 'touchend', touchEnd);
      return handler;
    };

    return handler;
  };
  // CallbackManager
  // ---------------
  // A general-purpose event binding manager used by `Map`
  // and `RequestManager`

  // Construct a new CallbackManager, with an list of
  // supported events.
  MM.CallbackManager = function (owner, events) {
    this.owner = owner;
    this.callbacks = {};
    for (var i = 0; i < events.length; i++) {
      this.callbacks[events[i]] = [];
    }
  };

  // CallbackManager does simple event management for modestmaps
  MM.CallbackManager.prototype = {
    // The element on which callbacks will be triggered.
    owner: null,

    // An object of callbacks in the form
    //
    //     { event: function }
    callbacks: null,

    // Add a callback to this object - where the `event` is a string of
    // the event name and `callback` is a function.
    addCallback: function (event, callback) {
      if (typeof (callback) == 'function' && this.callbacks[event]) {
        this.callbacks[event].push(callback);
      }
    },

    // Remove a callback. The given function needs to be equal (`===`) to
    // the callback added in `addCallback`, so named functions should be
    // used as callbacks.
    removeCallback: function (event, callback) {
      if (typeof (callback) == 'function' && this.callbacks[event]) {
        var cbs = this.callbacks[event],
          len = cbs.length;
        for (var i = 0; i < len; i++) {
          if (cbs[i] === callback) {
            cbs.splice(i, 1);
            break;
          }
        }
      }
    },

    // Trigger a callback, passing it an object or string from the second
    // argument.
    dispatchCallback: function (event, message) {
      if (this.callbacks[event]) {
        for (var i = 0; i < this.callbacks[event].length; i += 1) {
          try {
            this.callbacks[event][i](this.owner, message);
          } catch (e) {
            //console.log(e);
            // meh
          }
        }
      }
    }
  };
  // RequestManager
  // --------------
  // an image loading queue
  MM.RequestManager = function () {

    // The loading bay is a document fragment to optimize appending, since
    // the elements within are invisible. See
    //  [this blog post](http://ejohn.org/blog/dom-documentfragments/).
    this.loadingBay = document.createDocumentFragment();

    this.requestsById = {};
    this.openRequestCount = 0;

    this.maxOpenRequests = 4;
    this.requestQueue = [];

    this.callbackManager = new MM.CallbackManager(this, [
      'requestcomplete', 'requesterror']);
  };

  MM.RequestManager.prototype = {

    // DOM element, hidden, for making sure images dispatch complete events
    loadingBay: null,

    // all known requests, by ID
    requestsById: null,

    // current pending requests
    requestQueue: null,

    // current open requests (children of loadingBay)
    openRequestCount: null,

    // the number of open requests permitted at one time, clamped down
    // because of domain-connection limits.
    maxOpenRequests: null,

    // for dispatching 'requestcomplete'
    callbackManager: null,

    addCallback: function (event, callback) {
      this.callbackManager.addCallback(event, callback);
    },

    removeCallback: function (event, callback) {
      this.callbackManager.removeCallback(event, callback);
    },

    dispatchCallback: function (event, message) {
      this.callbackManager.dispatchCallback(event, message);
    },

    // Clear everything in the queue by excluding nothing
    clear: function () {
      this.clearExcept({});
    },

    clearRequest: function (id) {
      if (id in this.requestsById) {
        delete this.requestsById[id];
      }

      for (var i = 0; i < this.requestQueue.length; i++) {
        var request = this.requestQueue[i];
        if (request && request.id == id) {
          this.requestQueue[i] = null;
        }
      }
    },

    // Clear everything in the queue except for certain keys, specified
    // by an object of the form
    //
    //     { key: throwawayvalue }
    clearExcept: function (validIds) {

      // clear things from the queue first...
      for (var i = 0; i < this.requestQueue.length; i++) {
        var request = this.requestQueue[i];
        if (request && !(request.id in validIds)) {
          this.requestQueue[i] = null;
        }
      }

      // then check the loadingBay...
      var openRequests = this.loadingBay.childNodes;
      for (var j = openRequests.length - 1; j >= 0; j--) {
        var img = openRequests[j];
        if (!(img.id in validIds)) {
          this.loadingBay.removeChild(img);
          this.openRequestCount--;
          /* console.log(this.openRequestCount + " open requests"); */
          img.src = img.coord = img.onload = img.onerror = null;
        }
      }

      // hasOwnProperty protects against prototype additions
      // > "The standard describes an augmentable Object.prototype.
      //  Ignore standards at your own peril."
      // -- http://www.yuiblog.com/blog/2006/09/26/for-in-intrigue/
      for (var id in this.requestsById) {
        if (!(id in validIds)) {
          if (this.requestsById.hasOwnProperty(id)) {
            var requestToRemove = this.requestsById[id];
            // whether we've done the request or not...
            delete this.requestsById[id];
            if (requestToRemove !== null) {
              requestToRemove =
                requestToRemove.id =
                requestToRemove.coord =
                requestToRemove.url = null;
            }
          }
        }
      }
    },

    // Given a tile id, check whether the RequestManager is currently
    // requesting it and waiting for the result.
    hasRequest: function (id) {
      return (id in this.requestsById);
    },

    // * TODO: remove dependency on coord (it's for sorting, maybe call it data?)
    // * TODO: rename to requestImage once it's not tile specific
    requestTile: function (id, coord, url) {
      if (!(id in this.requestsById)) {
        var request = { id: id, coord: coord.copy(), url: url };
        // if there's no url just make sure we don't request this image again
        this.requestsById[id] = request;
        if (url) {
          this.requestQueue.push(request);
          /* console.log(this.requestQueue.length + ' pending requests'); */
        }
      }
    },

    getProcessQueue: function () {
      // let's only create this closure once...
      if (!this._processQueue) {
        var theManager = this;
        this._processQueue = function () {
          theManager.processQueue();
        };
      }
      return this._processQueue;
    },

    // Select images from the `requestQueue` and create image elements for
    // them, attaching their load events to the function returned by
    // `this.getLoadComplete()` so that they can be added to the map.
    processQueue: function (sortFunc) {
      // When the request queue fills up beyond 8, start sorting the
      // requests so that spiral-loading or another pattern can be used.
      if (sortFunc && this.requestQueue.length > 8) {
        this.requestQueue.sort(sortFunc);
      }
      while (this.openRequestCount < this.maxOpenRequests && this.requestQueue.length > 0) {
        var request = this.requestQueue.pop();
        if (request) {
          this.openRequestCount++;
          /* console.log(this.openRequestCount + ' open requests'); */

          // JSLitmus benchmark shows createElement is a little faster than
          // new Image() in Firefox and roughly the same in Safari:
          // http://tinyurl.com/y9wz2jj http://tinyurl.com/yes6rrt
          var img = document.createElement('img');

          // FIXME: id is technically not unique in document if there
          // are two Maps but toKey is supposed to be fast so we're trying
          // to avoid a prefix ... hence we can't use any calls to
          // `document.getElementById()` to retrieve images
          img.id = request.id;
          img.style.position = 'absolute';
          // * FIXME: store this elsewhere to avoid scary memory leaks?
          // * FIXME: call this 'data' not 'coord' so that RequestManager is less Tile-centric?
          img.coord = request.coord;
          // add it to the DOM in a hidden layer, this is a bit of a hack, but it's
          // so that the event we get in image.onload has srcElement assigned in IE6
          this.loadingBay.appendChild(img);
          // set these before img.src to avoid missing an img that's already cached
          img.onload = img.onerror = this.getLoadComplete();
          img.src = request.url;

          // keep things tidy
          request = request.id = request.coord = request.url = null;
        }
      }
    },

    _loadComplete: null,

    // Get the singleton `_loadComplete` function that is called on image
    // load events, either removing them from the queue and dispatching an
    // event to add them to the map, or deleting them if the image failed
    // to load.
    getLoadComplete: function () {
      // let's only create this closure once...
      if (!this._loadComplete) {
        var theManager = this;
        this._loadComplete = function (e) {
          // this is needed because we don't use MM.addEvent for images
          e = e || window.event;

          // srcElement for IE, target for FF, Safari etc.
          var img = e.srcElement || e.target;

          // unset these straight away so we don't call this twice
          img.onload = img.onerror = null;

          // pull it back out of the (hidden) DOM
          // so that draw will add it correctly later
          theManager.loadingBay.removeChild(img);
          theManager.openRequestCount--;
          delete theManager.requestsById[img.id];

          /* console.log(theManager.openRequestCount + ' open requests'); */

          // NB:- complete is also true onerror if we got a 404
          if (e.type === 'load' && (img.complete ||
            (img.readyState && img.readyState == 'complete'))) {
            theManager.dispatchCallback('requestcomplete', img);
          } else {
            // if it didn't finish clear its src to make sure it
            // really stops loading
            // FIXME: we'll never retry because this id is still
            // in requestsById - is that right?
            theManager.dispatchCallback('requesterror', {
              element: img,
              url: ('' + img.src)
            });
            img.src = null;
          }

          // keep going in the same order
          // use `setTimeout()` to avoid the IE recursion limit, see
          // http://cappuccino.org/discuss/2010/03/01/internet-explorer-global-variables-and-stack-overflows/
          // and https://github.com/stamen/modestmaps-js/issues/12
          setTimeout(theManager.getProcessQueue(), 0);

        };
      }
      return this._loadComplete;
    }

  };

  // Layer
  MM.Layer = function (provider, parent, name) {
    this.parent = parent || document.createElement('div');
    this.parent.style.cssText = 'position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; margin: 0; padding: 0; z-index: 0';
    this.name = name;
    this.levels = {};
    this.requestManager = new MM.RequestManager();
    this.requestManager.addCallback('requestcomplete', this.getTileComplete());
    this.requestManager.addCallback('requesterror', this.getTileError());
    if (provider) this.setProvider(provider);
  };

  MM.Layer.prototype = {

    map: null, // TODO: remove
    parent: null,
    name: null,
    enabled: true,
    tiles: null,
    levels: null,
    requestManager: null,
    provider: null,
    _tileComplete: null,

    getTileComplete: function () {
      if (!this._tileComplete) {
        var theLayer = this;
        this._tileComplete = function (manager, tile) {
          theLayer.tiles[tile.id] = tile;
          theLayer.positionTile(tile);
          // Support style transition if available.
          tile.style.visibility = 'inherit';
          tile.className = 'map-tile-loaded';
        };
      }
      return this._tileComplete;
    },

    getTileError: function () {
      if (!this._tileError) {
        var theLayer = this;
        this._tileError = function (manager, tile) {
          tile.onload = tile.onerror = null;
          theLayer.tiles[tile.element.id] = tile.element;
          theLayer.positionTile(tile.element);
          tile.element.style.visibility = 'hidden';
        };
      }
      return this._tileError;
    },

    draw: function () {
      if (!this.enabled || !this.map) return;
      // compares manhattan distance from center of
      // requested tiles to current map center
      // NB:- requested tiles are *popped* from queue, so we do a descending sort
      var theCoord = this.map.coordinate.zoomTo(Math.round(this.map.coordinate.zoom));

      function centerDistanceCompare(r1, r2) {
        if (r1 && r2) {
          var c1 = r1.coord;
          var c2 = r2.coord;
          if (c1.zoom == c2.zoom) {
            var ds1 = Math.abs(theCoord.row - c1.row - 0.5) +
              Math.abs(theCoord.column - c1.column - 0.5);
            var ds2 = Math.abs(theCoord.row - c2.row - 0.5) +
              Math.abs(theCoord.column - c2.column - 0.5);
            return ds1 < ds2 ? 1 : ds1 > ds2 ? -1 : 0;
          } else {
            return c1.zoom < c2.zoom ? 1 : c1.zoom > c2.zoom ? -1 : 0;
          }
        }
        return r1 ? 1 : r2 ? -1 : 0;
      }

      // if we're in between zoom levels, we need to choose the nearest:
      var baseZoom = Math.round(this.map.coordinate.zoom);

      // these are the top left and bottom right tile coordinates
      // we'll be loading everything in between:
      var startCoord = this.map.pointCoordinate(new MM.Point(0, 0))
        .zoomTo(baseZoom).container();
      var endCoord = this.map.pointCoordinate(this.map.dimensions)
        .zoomTo(baseZoom).container().right().down();

      // tiles with invalid keys will be removed from visible levels
      // requests for tiles with invalid keys will be canceled
      // (this object maps from a tile key to a boolean)
      var validTileKeys = {};

      // make sure we have a container for tiles in the current level
      var levelElement = this.createOrGetLevel(startCoord.zoom);

      // use this coordinate for generating keys, parents and children:
      var tileCoord = startCoord.copy();

      for (tileCoord.column = startCoord.column;
        tileCoord.column <= endCoord.column; tileCoord.column++) {
        for (tileCoord.row = startCoord.row;
          tileCoord.row <= endCoord.row; tileCoord.row++) {
          var validKeys = this.inventoryVisibleTile(levelElement, tileCoord);

          while (validKeys.length) {
            validTileKeys[validKeys.pop()] = true;
          }
        }
      }

      // i from i to zoom-5 are levels that would be scaled too big,
      // i from zoom + 2 to levels. length are levels that would be
      // scaled too small (and tiles would be too numerous)
      for (var name in this.levels) {
        if (this.levels.hasOwnProperty(name)) {
          var zoom = parseInt(name, 10);

          if (zoom >= startCoord.zoom - 5 && zoom < startCoord.zoom + 2) {
            continue;
          }

          var level = this.levels[name];
          level.style.display = 'none';
          var visibleTiles = this.tileElementsInLevel(level);

          while (visibleTiles.length) {
            this.provider.releaseTile(visibleTiles[0].coord);
            this.requestManager.clearRequest(visibleTiles[0].coord.toKey());
            level.removeChild(visibleTiles[0]);
            visibleTiles.shift();
          }
        }
      }

      // levels we want to see, if they have tiles in validTileKeys
      var minLevel = startCoord.zoom - 5;
      var maxLevel = startCoord.zoom + 2;

      for (var z = minLevel; z < maxLevel; z++) {
        this.adjustVisibleLevel(this.levels[z], z, validTileKeys);
      }

      // cancel requests that aren't visible:
      this.requestManager.clearExcept(validTileKeys);

      // get newly requested tiles, sort according to current view:
      this.requestManager.processQueue(centerDistanceCompare);
    },

    // For a given tile coordinate in a given level element, ensure that it's
    // correctly represented in the DOM including potentially-overlapping
    // parent and child tiles for pyramid loading.
    //
    // Return a list of valid (i.e. loadable?) tile keys.
    inventoryVisibleTile: function (layer_element, tile_coord) {
      var tile_key = tile_coord.toKey(),
        valid_tile_keys = [tile_key];

      // Check that the needed tile already exists someplace - add it to the DOM if it does.
      if (tile_key in this.tiles) {
        var tile = this.tiles[tile_key];

        // ensure it's in the DOM:
        if (tile.parentNode != layer_element) {
          layer_element.appendChild(tile);
          // if the provider implements reAddTile(), call it
          if ("reAddTile" in this.provider) {
            this.provider.reAddTile(tile_key, tile_coord, tile);
          }
        }

        return valid_tile_keys;
      }

      // Check that the needed tile has even been requested at all.
      if (!this.requestManager.hasRequest(tile_key)) {
        var tileToRequest = this.provider.getTile(tile_coord);
        if (typeof tileToRequest == 'string') {
          this.addTileImage(tile_key, tile_coord, tileToRequest);
          // tile must be truish
        } else if (tileToRequest) {
          this.addTileElement(tile_key, tile_coord, tileToRequest);
        }
      }

      // look for a parent tile in our image cache
      var tileCovered = false;
      var maxStepsOut = tile_coord.zoom;

      for (var pz = 1; pz <= maxStepsOut; pz++) {
        var parent_coord = tile_coord.zoomBy(-pz).container();
        var parent_key = parent_coord.toKey();

        // only mark it valid if we have it already
        if (parent_key in this.tiles) {
          valid_tile_keys.push(parent_key);
          tileCovered = true;
          break;
        }
      }

      // if we didn't find a parent, look at the children:
      if (!tileCovered) {
        var child_coord = tile_coord.zoomBy(1);

        // mark everything valid whether or not we have it:
        valid_tile_keys.push(child_coord.toKey());
        child_coord.column += 1;
        valid_tile_keys.push(child_coord.toKey());
        child_coord.row += 1;
        valid_tile_keys.push(child_coord.toKey());
        child_coord.column -= 1;
        valid_tile_keys.push(child_coord.toKey());
      }

      return valid_tile_keys;
    },

    tileElementsInLevel: function (level) {
      // this is somewhat future proof, we're looking for DOM elements
      // not necessarily <img> elements
      var tiles = [];
      for (var tile = level.firstChild; tile; tile = tile.nextSibling) {
        if (tile.nodeType == 1) {
          tiles.push(tile);
        }
      }
      return tiles;
    },

    /**
     * For a given level, adjust visibility as a whole and discard individual
     * tiles based on values in valid_tile_keys from inventoryVisibleTile().
     */
    adjustVisibleLevel: function (level, zoom, valid_tile_keys) {
      // no tiles for this level yet
      if (!level) return;

      var scale = 1;
      var theCoord = this.map.coordinate.copy();

      if (level.childNodes.length > 0) {
        level.style.display = 'block';
        scale = Math.pow(2, this.map.coordinate.zoom - zoom);
        theCoord = theCoord.zoomTo(zoom);
      } else {
        level.style.display = 'none';
        return false;
      }

      var tileWidth = this.map.tileSize.x * scale;
      var tileHeight = this.map.tileSize.y * scale;
      var center = new MM.Point(this.map.dimensions.x / 2, this.map.dimensions.y / 2);
      var tiles = this.tileElementsInLevel(level);

      while (tiles.length) {
        var tile = tiles.pop();

        if (!valid_tile_keys[tile.id]) {
          this.provider.releaseTile(tile.coord);
          this.requestManager.clearRequest(tile.coord.toKey());
          level.removeChild(tile);
        } else {
          // position tiles
          MM.moveElement(tile, {
            x: Math.round(center.x +
              (tile.coord.column - theCoord.column) * tileWidth),
            y: Math.round(center.y +
              (tile.coord.row - theCoord.row) * tileHeight),
            scale: scale,
            // TODO: pass only scale or only w/h
            width: this.map.tileSize.x,
            height: this.map.tileSize.y
          });
        }
      }
    },

    createOrGetLevel: function (zoom) {
      if (zoom in this.levels) {
        return this.levels[zoom];
      }

      var level = document.createElement('div');
      level.id = this.parent.id + '-zoom-' + zoom;
      level.style.cssText = 'position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; margin: 0; padding: 0;';
      level.style.zIndex = zoom;

      this.parent.appendChild(level);
      this.levels[zoom] = level;

      return level;
    },

    addTileImage: function (key, coord, url) {
      this.requestManager.requestTile(key, coord, url);
    },

    addTileElement: function (key, coordinate, element) {
      // Expected in draw()
      element.id = key;
      element.coord = coordinate.copy();
      this.positionTile(element);
    },

    positionTile: function (tile) {
      // position this tile (avoids a full draw() call):
      var theCoord = this.map.coordinate.zoomTo(tile.coord.zoom);

      // Start tile positioning and prevent drag for modern browsers
      tile.style.cssText = 'position:absolute;-webkit-user-select:none;' +
        '-webkit-user-drag:none;-moz-user-drag:none;-webkit-transform-origin:0 0;' +
        '-moz-transform-origin:0 0;-o-transform-origin:0 0;-ms-transform-origin:0 0;' +
        'width:' + this.map.tileSize.x + 'px; height: ' + this.map.tileSize.y + 'px;';

      // Prevent drag for IE
      tile.ondragstart = function () { return false; };

      var scale = Math.pow(2, this.map.coordinate.zoom - tile.coord.zoom);

      MM.moveElement(tile, {
        x: Math.round((this.map.dimensions.x / 2) +
          (tile.coord.column - theCoord.column) * this.map.tileSize.x),
        y: Math.round((this.map.dimensions.y / 2) +
          (tile.coord.row - theCoord.row) * this.map.tileSize.y),
        scale: scale,
        // TODO: pass only scale or only w/h
        width: this.map.tileSize.x,
        height: this.map.tileSize.y
      });

      // add tile to its level
      var theLevel = this.levels[tile.coord.zoom];
      theLevel.appendChild(tile);


      // ensure the level is visible if it's still the current level
      if (Math.round(this.map.coordinate.zoom) == tile.coord.zoom) {
        theLevel.style.display = 'block';
      }

      // request a lazy redraw of all levels
      // this will remove tiles that were only visible
      // to cover this tile while it loaded:
      this.requestRedraw();
    },

    _redrawTimer: undefined,

    requestRedraw: function () {
      // we'll always draw within 1 second of this request,
      // sometimes faster if there's already a pending redraw
      // this is used when a new tile arrives so that we clear
      // any parent/child tiles that were only being displayed
      // until the tile loads at the right zoom level
      if (!this._redrawTimer) {
        this._redrawTimer = setTimeout(this.getRedraw(), 1000);
      }
    },

    _redraw: null,

    getRedraw: function () {
      // let's only create this closure once...
      if (!this._redraw) {
        var theLayer = this;
        this._redraw = function () {
          theLayer.draw();
          theLayer._redrawTimer = 0;
        };
      }
      return this._redraw;
    },

    setProvider: function (newProvider) {
      var firstProvider = (this.provider === null);

      // if we already have a provider the we'll need to
      // clear the DOM, cancel requests and redraw
      if (!firstProvider) {
        this.requestManager.clear();

        for (var name in this.levels) {
          if (this.levels.hasOwnProperty(name)) {
            var level = this.levels[name];

            while (level.firstChild) {
              this.provider.releaseTile(level.firstChild.coord);
              level.removeChild(level.firstChild);
            }
          }
        }
      }

      // first provider or not we'll init/reset some values...
      this.tiles = {};

      // for later: check geometry of old provider and set a new coordinate center
      // if needed (now? or when?)
      this.provider = newProvider;

      if (!firstProvider) {
        this.draw();
      }
    },

    // Enable a layer and show its dom element
    enable: function () {
      this.enabled = true;
      this.parent.style.display = '';
      this.draw();
      return this;
    },

    // Disable a layer, don't display in DOM, clear all requests
    disable: function () {
      this.enabled = false;
      this.requestManager.clear();
      this.parent.style.display = 'none';
      return this;
    },

    // Remove this layer from the DOM, cancel all of its requests
    // and unbind any callbacks that are bound to it.
    destroy: function () {
      this.requestManager.clear();
      this.requestManager.removeCallback('requestcomplete', this.getTileComplete());
      this.requestManager.removeCallback('requesterror', this.getTileError());
      // TODO: does requestManager need a destroy function too?
      this.provider = null;
      // If this layer was ever attached to the DOM, detach it.
      if (this.parent.parentNode) {
        this.parent.parentNode.removeChild(this.parent);
      }
      this.map = null;
    }
  };

  // Map

  // Instance of a map intended for drawing to a div.
  //
  //  * `parent` (required DOM element)
  //      Can also be an ID of a DOM element
  //  * `layerOrLayers` (required MM.Layer or Array of MM.Layers)
  //      each one must implement draw(), destroy(), have a .parent DOM element and a .map property
  //      (an array of URL templates or MM.MapProviders is also acceptable)
  //  * `dimensions` (optional Point)
  //      Size of map to create
  //  * `eventHandlers` (optional Array)
  //      If empty or null MouseHandler will be used
  //      Otherwise, each handler will be called with init(map)
  MM.Map = function (parent, layerOrLayers, dimensions, eventHandlers) {

    if (typeof parent == 'string') {
      parent = document.getElementById(parent);
      if (!parent) {
        throw 'The ID provided to modest maps could not be found.';
      }
    }
    this.parent = parent;

    // we're no longer adding width and height to parent.style but we still
    // need to enforce padding, overflow and position otherwise everything screws up
    // TODO: maybe console.warn if the current values are bad?
    this.parent.style.padding = '0';
    this.parent.style.overflow = 'hidden';

    var position = MM.getStyle(this.parent, 'position');
    if (position != 'relative' && position != 'absolute') {
      this.parent.style.position = 'relative';
    }

    this.layers = [];

    if (!layerOrLayers) {
      layerOrLayers = [];
    }

    if (!(layerOrLayers instanceof Array)) {
      layerOrLayers = [layerOrLayers];
    }

    for (var i = 0; i < layerOrLayers.length; i++) {
      this.addLayer(layerOrLayers[i]);
    }

    // default to Google-y Mercator style maps
    this.projection = new MM.MercatorProjection(0,
      MM.deriveTransformation(-Math.PI, Math.PI, 0, 0,
        Math.PI, Math.PI, 1, 0,
        -Math.PI, -Math.PI, 0, 1));
    this.tileSize = new MM.Point(256, 256);

    // default 0-18 zoom level
    // with infinite horizontal pan and clamped vertical pan
    this.coordLimits = [
      new MM.Coordinate(0, -Infinity, 0),           // top left outer
      new MM.Coordinate(1, Infinity, 0).zoomTo(18) // bottom right inner
    ];

    // eyes towards null island
    this.coordinate = new MM.Coordinate(0.5, 0.5, 0);

    // if you don't specify dimensions we assume you want to fill the parent
    // unless the parent has no w/h, in which case we'll still use a default
    if (!dimensions) {
      dimensions = new MM.Point(this.parent.offsetWidth,
        this.parent.offsetHeight);
      this.autoSize = true;
      // use destroy to get rid of this handler from the DOM
      MM.addEvent(window, 'resize', this.windowResize());
    } else {
      this.autoSize = false;
      // don't call setSize here because it calls draw()
      this.parent.style.width = Math.round(dimensions.x) + 'px';
      this.parent.style.height = Math.round(dimensions.y) + 'px';
    }
    this.dimensions = dimensions;

    this.callbackManager = new MM.CallbackManager(this, [
      'zoomed',
      'panned',
      'centered',
      'extentset',
      'resized',
      'drawn'
    ]);

    // set up handlers last so that all required attributes/functions are in place if needed
    if (eventHandlers === undefined) {
      this.eventHandlers = [
        MM.MouseHandler().init(this),
        MM.TouchHandler().init(this)
      ];
    } else {
      this.eventHandlers = eventHandlers;
      if (eventHandlers instanceof Array) {
        for (var j = 0; j < eventHandlers.length; j++) {
          eventHandlers[j].init(this);
        }
      }
    }

  };

  MM.Map.prototype = {

    parent: null,          // DOM Element
    dimensions: null,      // MM.Point with x/y size of parent element

    projection: null,      // MM.Projection of first known layer
    coordinate: null,      // Center of map MM.Coordinate with row/column/zoom
    tileSize: null,        // MM.Point with x/y size of tiles

    coordLimits: null,     // Array of [ topLeftOuter, bottomLeftInner ] MM.Coordinates

    layers: null,          // Array of MM.Layer (interface = .draw(), .destroy(), .parent and .map)

    callbackManager: null, // MM.CallbackManager, handles map events

    eventHandlers: null,   // Array of interaction handlers, just a MM.MouseHandler by default

    autoSize: null,        // Boolean, true if we have a window resize listener

    toString: function () {
      return 'Map(#' + this.parent.id + ')';
    },

    // callbacks...

    addCallback: function (event, callback) {
      this.callbackManager.addCallback(event, callback);
      return this;
    },

    removeCallback: function (event, callback) {
      this.callbackManager.removeCallback(event, callback);
      return this;
    },

    dispatchCallback: function (event, message) {
      this.callbackManager.dispatchCallback(event, message);
      return this;
    },

    windowResize: function () {
      if (!this._windowResize) {
        var theMap = this;
        this._windowResize = function (event) {
          // don't call setSize here because it sets parent.style.width/height
          // and setting the height breaks percentages and default styles
          theMap.dimensions = new MM.Point(theMap.parent.offsetWidth, theMap.parent.offsetHeight);
          theMap.draw();
          theMap.dispatchCallback('resized', [theMap.dimensions]);
        };
      }
      return this._windowResize;
    },

    // A convenience function to restrict interactive zoom ranges.
    // (you should also adjust map provider to restrict which tiles get loaded,
    // or modify map.coordLimits and provider.tileLimits for finer control)
    setZoomRange: function (minZoom, maxZoom) {
      this.coordLimits[0] = this.coordLimits[0].zoomTo(minZoom);
      this.coordLimits[1] = this.coordLimits[1].zoomTo(maxZoom);
      return this;
    },

    // zooming
    zoomBy: function (zoomOffset) {
      this.coordinate = this.enforceLimits(this.coordinate.zoomBy(zoomOffset));
      MM.getFrame(this.getRedraw());
      this.dispatchCallback('zoomed', zoomOffset);
      return this;
    },

    zoomIn: function () { return this.zoomBy(1); },
    zoomOut: function () { return this.zoomBy(-1); },
    setZoom: function (z) { return this.zoomBy(z - this.coordinate.zoom); },

    zoomByAbout: function (zoomOffset, point) {
      var location = this.pointLocation(point);

      this.coordinate = this.enforceLimits(this.coordinate.zoomBy(zoomOffset));
      var newPoint = this.locationPoint(location);

      this.dispatchCallback('zoomed', zoomOffset);
      return this.panBy(point.x - newPoint.x, point.y - newPoint.y);
    },

    // panning
    panBy: function (dx, dy) {
      // if (window.devicePixelRatio && window.devicePixelRatio > 1) {
      // 	dx /= window.devicePixelRatio;
      // 	dy /= window.devicePixelRatio;
      // }

      this.coordinate.column -= dx / this.tileSize.x;
      this.coordinate.row -= dy / this.tileSize.y;

      this.coordinate = this.enforceLimits(this.coordinate);

      // Defer until the browser is ready to draw.
      MM.getFrame(this.getRedraw());
      this.dispatchCallback('panned', [dx, dy]);
      return this;
    },

    panLeft: function () { return this.panBy(100, 0); },
    panRight: function () { return this.panBy(-100, 0); },
    panDown: function () { return this.panBy(0, -100); },
    panUp: function () { return this.panBy(0, 100); },

    // positioning
    setCenter: function (location) {
      return this.setCenterZoom(location, this.coordinate.zoom);
    },

    setCenterZoom: function (location, zoom) {
      this.coordinate = this.projection.locationCoordinate(location).zoomTo(parseFloat(zoom) || 0);
      this.coordinate = this.enforceLimits(this.coordinate);
      MM.getFrame(this.getRedraw());
      this.dispatchCallback('centered', [location, zoom]);
      return this;
    },

    extentCoordinate: function (locations, precise) {
      // coerce locations to an array if it's a Extent instance
      if (locations instanceof MM.Extent) {
        locations = locations.toArray();
      }

      var TL, BR;
      for (var i = 0; i < locations.length; i++) {
        var coordinate = this.projection.locationCoordinate(locations[i]);
        if (TL) {
          TL.row = Math.min(TL.row, coordinate.row);
          TL.column = Math.min(TL.column, coordinate.column);
          TL.zoom = Math.min(TL.zoom, coordinate.zoom);
          BR.row = Math.max(BR.row, coordinate.row);
          BR.column = Math.max(BR.column, coordinate.column);
          BR.zoom = Math.max(BR.zoom, coordinate.zoom);
        }
        else {
          TL = coordinate.copy();
          BR = coordinate.copy();
        }
      }

      var width = this.dimensions.x + 1;
      var height = this.dimensions.y + 1;

      // multiplication factor between horizontal span and map width
      var hFactor = (BR.column - TL.column) / (width / this.tileSize.x);

      // multiplication factor expressed as base-2 logarithm, for zoom difference
      var hZoomDiff = Math.log(hFactor) / Math.log(2);

      // possible horizontal zoom to fit geographical extent in map width
      var hPossibleZoom = TL.zoom - (precise ? hZoomDiff : Math.ceil(hZoomDiff));

      // multiplication factor between vertical span and map height
      var vFactor = (BR.row - TL.row) / (height / this.tileSize.y);

      // multiplication factor expressed as base-2 logarithm, for zoom difference
      var vZoomDiff = Math.log(vFactor) / Math.log(2);

      // possible vertical zoom to fit geographical extent in map height
      var vPossibleZoom = TL.zoom - (precise ? vZoomDiff : Math.ceil(vZoomDiff));

      // initial zoom to fit extent vertically and horizontally
      var initZoom = Math.min(hPossibleZoom, vPossibleZoom);

      // additionally, make sure it's not outside the boundaries set by map limits
      initZoom = Math.min(initZoom, this.coordLimits[1].zoom);
      initZoom = Math.max(initZoom, this.coordLimits[0].zoom);

      // coordinate of extent center
      var centerRow = (TL.row + BR.row) / 2;
      var centerColumn = (TL.column + BR.column) / 2;
      var centerZoom = TL.zoom;
      return new MM.Coordinate(centerRow, centerColumn, centerZoom).zoomTo(initZoom);
    },

    setExtent: function (locations, precise) {
      this.coordinate = this.extentCoordinate(locations, precise);
      this.coordinate = this.enforceLimits(this.coordinate);
      MM.getFrame(this.getRedraw());

      this.dispatchCallback('extentset', locations);
      return this;
    },

    // Resize the map's container `<div>`, redrawing the map and triggering
    // `resized` to make sure that the map's presentation is still correct.
    setSize: function (dimensions) {
      // Ensure that, whether a raw object or a Point object is passed,
      // this.dimensions will be a Point.
      this.dimensions = new MM.Point(dimensions.x, dimensions.y);
      this.parent.style.width = Math.round(this.dimensions.x) + 'px';
      this.parent.style.height = Math.round(this.dimensions.y) + 'px';
      if (this.autoSize) {
        MM.removeEvent(window, 'resize', this.windowResize());
        this.autoSize = false;
      }
      this.draw(); // draw calls enforceLimits
      // (if you switch to getFrame, call enforceLimits first)
      this.dispatchCallback('resized', this.dimensions);
      return this;
    },

    // projecting points on and off screen
    coordinatePoint: function (coord) {
      // Return an x, y point on the map image for a given coordinate.
      if (coord.zoom != this.coordinate.zoom) {
        coord = coord.zoomTo(this.coordinate.zoom);
      }

      // distance from the center of the map
      var point = new MM.Point(this.dimensions.x / 2, this.dimensions.y / 2);
      point.x += this.tileSize.x * (coord.column - this.coordinate.column);
      point.y += this.tileSize.y * (coord.row - this.coordinate.row);

      return point;
    },

    // Get a `MM.Coordinate` from an `MM.Point` - returns a new tile-like object
    // from a screen point.
    pointCoordinate: function (point) {
      // new point coordinate reflecting distance from map center, in tile widths
      var coord = this.coordinate.copy();
      coord.column += (point.x - this.dimensions.x / 2) / this.tileSize.x;
      coord.row += (point.y - this.dimensions.y / 2) / this.tileSize.y;

      return coord;
    },

    // Return an MM.Coordinate (row,col,zoom) for an MM.Location (lat,lon).
    locationCoordinate: function (location) {
      return this.projection.locationCoordinate(location);
    },

    // Return an MM.Location (lat,lon) for an MM.Coordinate (row,col,zoom).
    coordinateLocation: function (coordinate) {
      return this.projection.coordinateLocation(coordinate);
    },

    // Return an x, y point on the map image for a given geographical location.
    locationPoint: function (location) {
      return this.coordinatePoint(this.locationCoordinate(location));
    },

    // Return a geographical location on the map image for a given x, y point.
    pointLocation: function (point) {
      return this.coordinateLocation(this.pointCoordinate(point));
    },

    // inspecting
    getExtent: function () {
      return new MM.Extent(
        this.pointLocation(new MM.Point(0, 0)),
        this.pointLocation(this.dimensions)
      );
    },

    extent: function (locations, precise) {
      if (locations) {
        return this.setExtent(locations, precise);
      } else {
        return this.getExtent();
      }
    },

    // Get the current centerpoint of the map, returning a `Location`
    getCenter: function () {
      return this.projection.coordinateLocation(this.coordinate);
    },

    center: function (location) {
      if (location) {
        return this.setCenter(location);
      } else {
        return this.getCenter();
      }
    },

    // Get the current zoom level of the map, returning a number
    getZoom: function () {
      return this.coordinate.zoom;
    },

    zoom: function (zoom) {
      if (zoom !== undefined) {
        return this.setZoom(zoom);
      } else {
        return this.getZoom();
      }
    },

    // return a copy of the layers array
    getLayers: function () {
      return this.layers.slice();
    },

    // return the first layer with given name
    getLayer: function (name) {
      for (var i = 0; i < this.layers.length; i++) {
        if (name == this.layers[i].name)
          return this.layers[i];
      }
    },

    // return the layer at the given index
    getLayerAt: function (index) {
      return this.layers[index];
    },

    // put the given layer on top of all the others
    // Since this is called for the first layer, which is by definition
    // added before the map has a valid `coordinate`, we request
    // a redraw only if the map has a center coordinate.
    addLayer: function (layer) {
      this.layers.push(layer);
      this.parent.appendChild(layer.parent);
      layer.map = this; // TODO: remove map property from MM.Layer?
      if (this.coordinate) {
        MM.getFrame(this.getRedraw());
      }
      return this;
    },

    // find the given layer and remove it
    removeLayer: function (layer) {
      for (var i = 0; i < this.layers.length; i++) {
        if (layer == this.layers[i] || layer == this.layers[i].name) {
          this.removeLayerAt(i);
          break;
        }
      }
      return this;
    },

    // replace the current layer at the given index with the given layer
    setLayerAt: function (index, layer) {

      if (index < 0 || index >= this.layers.length) {
        throw new Error('invalid index in setLayerAt(): ' + index);
      }

      if (this.layers[index] != layer) {

        // clear existing layer at this index
        if (index < this.layers.length) {
          var other = this.layers[index];
          this.parent.insertBefore(layer.parent, other.parent);
          other.destroy();
        } else {
          // Or if this will be the last layer, it can be simply appended
          this.parent.appendChild(layer.parent);
        }

        this.layers[index] = layer;
        layer.map = this; // TODO: remove map property from MM.Layer

        MM.getFrame(this.getRedraw());
      }

      return this;
    },

    // put the given layer at the given index, moving others if necessary
    insertLayerAt: function (index, layer) {

      if (index < 0 || index > this.layers.length) {
        throw new Error('invalid index in insertLayerAt(): ' + index);
      }

      if (index == this.layers.length) {
        // it just gets tacked on to the end
        this.layers.push(layer);
        this.parent.appendChild(layer.parent);
      } else {
        // it needs to get slipped in amongst the others
        var other = this.layers[index];
        this.parent.insertBefore(layer.parent, other.parent);
        this.layers.splice(index, 0, layer);
      }

      layer.map = this; // TODO: remove map property from MM.Layer

      MM.getFrame(this.getRedraw());

      return this;
    },

    // remove the layer at the given index, call .destroy() on the layer
    removeLayerAt: function (index) {
      if (index < 0 || index >= this.layers.length) {
        throw new Error('invalid index in removeLayer(): ' + index);
      }

      // gone baby gone.
      var old = this.layers[index];
      this.layers.splice(index, 1);
      old.destroy();

      return this;
    },

    // switch the stacking order of two layers, by index
    swapLayersAt: function (i, j) {

      if (i < 0 || i >= this.layers.length || j < 0 || j >= this.layers.length) {
        throw new Error('invalid index in swapLayersAt(): ' + index);
      }

      var layer1 = this.layers[i],
        layer2 = this.layers[j],
        dummy = document.createElement('div');

      // kick layer2 out, replace it with the dummy.
      this.parent.replaceChild(dummy, layer2.parent);

      // put layer2 back in and kick layer1 out
      this.parent.replaceChild(layer2.parent, layer1.parent);

      // put layer1 back in and ditch the dummy
      this.parent.replaceChild(layer1.parent, dummy);

      // now do it to the layers array
      this.layers[i] = layer2;
      this.layers[j] = layer1;

      return this;
    },

    // Enable and disable layers.
    // Disabled layers are not displayed, are not drawn, and do not request
    // tiles. They do maintain their layer index on the map.
    enableLayer: function (name) {
      var l = this.getLayer(name);
      if (l) l.enable();
      return this;
    },

    enableLayerAt: function (index) {
      var l = this.getLayerAt(index);
      if (l) l.enable();
      return this;
    },

    disableLayer: function (name) {
      var l = this.getLayer(name);
      if (l) l.disable();
      return this;
    },

    disableLayerAt: function (index) {
      var l = this.getLayerAt(index);
      if (l) l.disable();
      return this;
    },


    // limits

    enforceZoomLimits: function (coord) {
      var limits = this.coordLimits;
      if (limits) {
        // clamp zoom level:
        var minZoom = limits[0].zoom;
        var maxZoom = limits[1].zoom;
        if (coord.zoom < minZoom) {
          coord = coord.zoomTo(minZoom);
        }
        else if (coord.zoom > maxZoom) {
          coord = coord.zoomTo(maxZoom);
        }
      }
      return coord;
    },

    enforcePanLimits: function (coord) {

      if (this.coordLimits) {

        coord = coord.copy();

        // clamp pan:
        var topLeftLimit = this.coordLimits[0].zoomTo(coord.zoom);
        var bottomRightLimit = this.coordLimits[1].zoomTo(coord.zoom);
        var currentTopLeft = this.pointCoordinate(new MM.Point(0, 0))
          .zoomTo(coord.zoom);
        var currentBottomRight = this.pointCoordinate(this.dimensions)
          .zoomTo(coord.zoom);

        // this handles infinite limits:
        // (Infinity - Infinity) is Nan
        // NaN is never less than anything
        if (bottomRightLimit.row - topLeftLimit.row <
          currentBottomRight.row - currentTopLeft.row) {
          // if the limit is smaller than the current view center it
          coord.row = (bottomRightLimit.row + topLeftLimit.row) / 2;
        } else {
          if (currentTopLeft.row < topLeftLimit.row) {
            coord.row += topLeftLimit.row - currentTopLeft.row;
          } else if (currentBottomRight.row > bottomRightLimit.row) {
            coord.row -= currentBottomRight.row - bottomRightLimit.row;
          }
        }
        if (bottomRightLimit.column - topLeftLimit.column <
          currentBottomRight.column - currentTopLeft.column) {
          // if the limit is smaller than the current view, center it
          coord.column = (bottomRightLimit.column + topLeftLimit.column) / 2;
        } else {
          if (currentTopLeft.column < topLeftLimit.column) {
            coord.column += topLeftLimit.column - currentTopLeft.column;
          } else if (currentBottomRight.column > bottomRightLimit.column) {
            coord.column -= currentBottomRight.column - bottomRightLimit.column;
          }
        }
      }

      return coord;
    },

    // Prevent accidentally navigating outside the `coordLimits` of the map.
    enforceLimits: function (coord) {
      return this.enforcePanLimits(this.enforceZoomLimits(coord));
    },

    // rendering

    // Redraw the tiles on the map, reusing existing tiles.
    draw: function () {
      // make sure we're not too far in or out:
      this.coordinate = this.enforceLimits(this.coordinate);

      // if we don't have dimensions, check the parent size
      if (this.dimensions.x <= 0 || this.dimensions.y <= 0) {
        if (this.autoSize) {
          // maybe the parent size has changed?
          var w = this.parent.offsetWidth,
            h = this.parent.offsetHeight;
          this.dimensions = new MM.Point(w, h);
          if (w <= 0 || h <= 0) {
            return;
          }
        } else {
          // the issue can only be corrected with setSize
          return;
        }
      }

      // draw layers one by one
      for (var i = 0; i < this.layers.length; i++) {
        this.layers[i].draw();
      }

      this.dispatchCallback('drawn');
    },

    _redrawTimer: undefined,

    requestRedraw: function () {
      // we'll always draw within 1 second of this request,
      // sometimes faster if there's already a pending redraw
      // this is used when a new tile arrives so that we clear
      // any parent/child tiles that were only being displayed
      // until the tile loads at the right zoom level
      if (!this._redrawTimer) {
        this._redrawTimer = setTimeout(this.getRedraw(), 1000);
      }
    },

    _redraw: null,

    getRedraw: function () {
      // let's only create this closure once...
      if (!this._redraw) {
        var theMap = this;
        this._redraw = function () {
          theMap.draw();
          theMap._redrawTimer = 0;
        };
      }
      return this._redraw;
    },

    // Attempts to destroy all attachment a map has to a page
    // and clear its memory usage.
    destroy: function () {
      for (var j = 0; j < this.layers.length; j++) {
        this.layers[j].destroy();
      }
      this.layers = [];
      this.projection = null;
      for (var i = 0; i < this.eventHandlers.length; i++) {
        this.eventHandlers[i].remove();
      }
      if (this.autoSize) {
        MM.removeEvent(window, 'resize', this.windowResize());
      }
    }
  };
  // Instance of a map intended for drawing to a div.
  //
  //  * `parent` (required DOM element)
  //      Can also be an ID of a DOM element
  //  * `provider` (required MM.MapProvider or URL template)
  //  * `location` (required MM.Location)
  //      Location for map to show
  //  * `zoom` (required number)
  MM.mapByCenterZoom = function (parent, layerish, location, zoom) {
    var layer = MM.coerceLayer(layerish),
      map = new MM.Map(parent, layer, false);
    map.setCenterZoom(location, zoom).draw();
    return map;
  };

  // Instance of a map intended for drawing to a div.
  //
  //  * `parent` (required DOM element)
  //      Can also be an ID of a DOM element
  //  * `provider` (required MM.MapProvider or URL template)
  //  * `locationA` (required MM.Location)
  //      Location of one map corner
  //  * `locationB` (required MM.Location)
  //      Location of other map corner
  MM.mapByExtent = function (parent, layerish, locationA, locationB) {
    var layer = MM.coerceLayer(layerish),
      map = new MM.Map(parent, layer, false);
    map.setExtent([locationA, locationB]).draw();
    return map;
  };
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
      Point: MM.Point,
      Projection: MM.Projection,
      MercatorProjection: MM.MercatorProjection,
      LinearProjection: MM.LinearProjection,
      Transformation: MM.Transformation,
      Location: MM.Location,
      MapProvider: MM.MapProvider,
      Template: MM.Template,
      Coordinate: MM.Coordinate,
      deriveTransformation: MM.deriveTransformation
    };
  }
})(MM);
// Copyright Google Inc.
// Licensed under the Apache Licence Version 2.0
// Autogenerated at Tue Oct 11 13:36:46 EDT 2011
// @provides html4
var html4 = {};
html4.atype = {
  NONE: 0,
  URI: 1,
  URI_FRAGMENT: 11,
  SCRIPT: 2,
  STYLE: 3,
  ID: 4,
  IDREF: 5,
  IDREFS: 6,
  GLOBAL_NAME: 7,
  LOCAL_NAME: 8,
  CLASSES: 9,
  FRAME_TARGET: 10
};
html4.ATTRIBS = {
  '*::class': 9,
  '*::dir': 0,
  '*::id': 4,
  '*::lang': 0,
  '*::onclick': 2,
  '*::ondblclick': 2,
  '*::onkeydown': 2,
  '*::onkeypress': 2,
  '*::onkeyup': 2,
  '*::onload': 2,
  '*::onmousedown': 2,
  '*::onmousemove': 2,
  '*::onmouseout': 2,
  '*::onmouseover': 2,
  '*::onmouseup': 2,
  '*::style': 3,
  '*::title': 0,
  'a::accesskey': 0,
  'a::coords': 0,
  'a::href': 1,
  'a::hreflang': 0,
  'a::name': 7,
  'a::onblur': 2,
  'a::onfocus': 2,
  'a::rel': 0,
  'a::rev': 0,
  'a::shape': 0,
  'a::tabindex': 0,
  'a::target': 10,
  'a::type': 0,
  'area::accesskey': 0,
  'area::alt': 0,
  'area::coords': 0,
  'area::href': 1,
  'area::nohref': 0,
  'area::onblur': 2,
  'area::onfocus': 2,
  'area::shape': 0,
  'area::tabindex': 0,
  'area::target': 10,
  'bdo::dir': 0,
  'blockquote::cite': 1,
  'br::clear': 0,
  'button::accesskey': 0,
  'button::disabled': 0,
  'button::name': 8,
  'button::onblur': 2,
  'button::onfocus': 2,
  'button::tabindex': 0,
  'button::type': 0,
  'button::value': 0,
  'canvas::height': 0,
  'canvas::width': 0,
  'caption::align': 0,
  'col::align': 0,
  'col::char': 0,
  'col::charoff': 0,
  'col::span': 0,
  'col::valign': 0,
  'col::width': 0,
  'colgroup::align': 0,
  'colgroup::char': 0,
  'colgroup::charoff': 0,
  'colgroup::span': 0,
  'colgroup::valign': 0,
  'colgroup::width': 0,
  'del::cite': 1,
  'del::datetime': 0,
  'dir::compact': 0,
  'div::align': 0,
  'dl::compact': 0,
  'font::color': 0,
  'font::face': 0,
  'font::size': 0,
  'form::accept': 0,
  'form::action': 1,
  'form::autocomplete': 0,
  'form::enctype': 0,
  'form::method': 0,
  'form::name': 7,
  'form::onreset': 2,
  'form::onsubmit': 2,
  'form::target': 10,
  'h1::align': 0,
  'h2::align': 0,
  'h3::align': 0,
  'h4::align': 0,
  'h5::align': 0,
  'h6::align': 0,
  'hr::align': 0,
  'hr::noshade': 0,
  'hr::size': 0,
  'hr::width': 0,
  'iframe::align': 0,
  'iframe::frameborder': 0,
  'iframe::height': 0,
  'iframe::marginheight': 0,
  'iframe::marginwidth': 0,
  'iframe::width': 0,
  'img::align': 0,
  'img::alt': 0,
  'img::border': 0,
  'img::height': 0,
  'img::hspace': 0,
  'img::ismap': 0,
  'img::name': 7,
  'img::src': 1,
  'img::usemap': 11,
  'img::vspace': 0,
  'img::width': 0,
  'input::accept': 0,
  'input::accesskey': 0,
  'input::align': 0,
  'input::alt': 0,
  'input::autocomplete': 0,
  'input::checked': 0,
  'input::disabled': 0,
  'input::ismap': 0,
  'input::maxlength': 0,
  'input::name': 8,
  'input::onblur': 2,
  'input::onchange': 2,
  'input::onfocus': 2,
  'input::onselect': 2,
  'input::readonly': 0,
  'input::size': 0,
  'input::src': 1,
  'input::tabindex': 0,
  'input::type': 0,
  'input::usemap': 11,
  'input::value': 0,
  'ins::cite': 1,
  'ins::datetime': 0,
  'label::accesskey': 0,
  'label::for': 5,
  'label::onblur': 2,
  'label::onfocus': 2,
  'legend::accesskey': 0,
  'legend::align': 0,
  'li::type': 0,
  'li::value': 0,
  'map::name': 7,
  'menu::compact': 0,
  'ol::compact': 0,
  'ol::start': 0,
  'ol::type': 0,
  'optgroup::disabled': 0,
  'optgroup::label': 0,
  'option::disabled': 0,
  'option::label': 0,
  'option::selected': 0,
  'option::value': 0,
  'p::align': 0,
  'pre::width': 0,
  'q::cite': 1,
  'select::disabled': 0,
  'select::multiple': 0,
  'select::name': 8,
  'select::onblur': 2,
  'select::onchange': 2,
  'select::onfocus': 2,
  'select::size': 0,
  'select::tabindex': 0,
  'table::align': 0,
  'table::bgcolor': 0,
  'table::border': 0,
  'table::cellpadding': 0,
  'table::cellspacing': 0,
  'table::frame': 0,
  'table::rules': 0,
  'table::summary': 0,
  'table::width': 0,
  'tbody::align': 0,
  'tbody::char': 0,
  'tbody::charoff': 0,
  'tbody::valign': 0,
  'td::abbr': 0,
  'td::align': 0,
  'td::axis': 0,
  'td::bgcolor': 0,
  'td::char': 0,
  'td::charoff': 0,
  'td::colspan': 0,
  'td::headers': 6,
  'td::height': 0,
  'td::nowrap': 0,
  'td::rowspan': 0,
  'td::scope': 0,
  'td::valign': 0,
  'td::width': 0,
  'textarea::accesskey': 0,
  'textarea::cols': 0,
  'textarea::disabled': 0,
  'textarea::name': 8,
  'textarea::onblur': 2,
  'textarea::onchange': 2,
  'textarea::onfocus': 2,
  'textarea::onselect': 2,
  'textarea::readonly': 0,
  'textarea::rows': 0,
  'textarea::tabindex': 0,
  'tfoot::align': 0,
  'tfoot::char': 0,
  'tfoot::charoff': 0,
  'tfoot::valign': 0,
  'th::abbr': 0,
  'th::align': 0,
  'th::axis': 0,
  'th::bgcolor': 0,
  'th::char': 0,
  'th::charoff': 0,
  'th::colspan': 0,
  'th::headers': 6,
  'th::height': 0,
  'th::nowrap': 0,
  'th::rowspan': 0,
  'th::scope': 0,
  'th::valign': 0,
  'th::width': 0,
  'thead::align': 0,
  'thead::char': 0,
  'thead::charoff': 0,
  'thead::valign': 0,
  'tr::align': 0,
  'tr::bgcolor': 0,
  'tr::char': 0,
  'tr::charoff': 0,
  'tr::valign': 0,
  'ul::compact': 0,
  'ul::type': 0
};
html4.eflags = {
  OPTIONAL_ENDTAG: 1,
  EMPTY: 2,
  CDATA: 4,
  RCDATA: 8,
  UNSAFE: 16,
  FOLDABLE: 32,
  SCRIPT: 64,
  STYLE: 128
};
html4.ELEMENTS = {
  'a': 0,
  'abbr': 0,
  'acronym': 0,
  'address': 0,
  'applet': 16,
  'area': 2,
  'b': 0,
  'base': 18,
  'basefont': 18,
  'bdo': 0,
  'big': 0,
  'blockquote': 0,
  'body': 49,
  'br': 2,
  'button': 0,
  'canvas': 0,
  'caption': 0,
  'center': 0,
  'cite': 0,
  'code': 0,
  'col': 2,
  'colgroup': 1,
  'dd': 1,
  'del': 0,
  'dfn': 0,
  'dir': 0,
  'div': 0,
  'dl': 0,
  'dt': 1,
  'em': 0,
  'fieldset': 0,
  'font': 0,
  'form': 0,
  'frame': 18,
  'frameset': 16,
  'h1': 0,
  'h2': 0,
  'h3': 0,
  'h4': 0,
  'h5': 0,
  'h6': 0,
  'head': 49,
  'hr': 2,
  'html': 49,
  'i': 0,
  'iframe': 4,
  'img': 2,
  'input': 2,
  'ins': 0,
  'isindex': 18,
  'kbd': 0,
  'label': 0,
  'legend': 0,
  'li': 1,
  'link': 18,
  'map': 0,
  'menu': 0,
  'meta': 18,
  'nobr': 0,
  'noembed': 4,
  'noframes': 20,
  'noscript': 20,
  'object': 16,
  'ol': 0,
  'optgroup': 0,
  'option': 1,
  'p': 1,
  'param': 18,
  'pre': 0,
  'q': 0,
  's': 0,
  'samp': 0,
  'script': 84,
  'select': 0,
  'small': 0,
  'span': 0,
  'strike': 0,
  'strong': 0,
  'style': 148,
  'sub': 0,
  'sup': 0,
  'table': 0,
  'tbody': 1,
  'td': 1,
  'textarea': 8,
  'tfoot': 1,
  'th': 1,
  'thead': 1,
  'title': 24,
  'tr': 1,
  'tt': 0,
  'u': 0,
  'ul': 0,
  'var': 0
};
html4.ueffects = {
  NOT_LOADED: 0,
  SAME_DOCUMENT: 1,
  NEW_DOCUMENT: 2
};
html4.URIEFFECTS = {
  'a::href': 2,
  'area::href': 2,
  'blockquote::cite': 0,
  'body::background': 1,
  'del::cite': 0,
  'form::action': 2,
  'img::src': 1,
  'input::src': 1,
  'ins::cite': 0,
  'q::cite': 0
};
html4.ltypes = {
  UNSANDBOXED: 2,
  SANDBOXED: 1,
  DATA: 0
};
html4.LOADERTYPES = {
  'a::href': 2,
  'area::href': 2,
  'blockquote::cite': 2,
  'body::background': 1,
  'del::cite': 2,
  'form::action': 2,
  'img::src': 1,
  'input::src': 1,
  'ins::cite': 2,
  'q::cite': 2
};;
// Copyright (C) 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview
 * An HTML sanitizer that can satisfy a variety of security policies.
 *
 * <p>
 * The HTML sanitizer is built around a SAX parser and HTML element and
 * attributes schemas.
 *
 * @author mikesamuel@gmail.com
 * @requires html4
 * @overrides window
 * @provides html, html_sanitize
 */

/**
 * @namespace
 */
var html = (function (html4) {
  var lcase;
  // The below may not be true on browsers in the Turkish locale.
  if ('script' === 'SCRIPT'.toLowerCase()) {
    lcase = function (s) { return s.toLowerCase(); };
  } else {
    /**
     * {@updoc
     * $ lcase('SCRIPT')
     * # 'script'
     * $ lcase('script')
     * # 'script'
     * }
     */
    lcase = function (s) {
      return s.replace(
        /[A-Z]/g,
        function (ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        });
    };
  }

  var ENTITIES = {
    lt: '<',
    gt: '>',
    amp: '&',
    nbsp: '\240',
    quot: '"',
    apos: '\''
  };

  // Schemes on which to defer to uripolicy. Urls with other schemes are denied
  var WHITELISTED_SCHEMES = /^(?:https?|mailto|data)$/i;

  var decimalEscapeRe = /^#(\d+)$/;
  var hexEscapeRe = /^#x([0-9A-Fa-f]+)$/;
  /**
   * Decodes an HTML entity.
   *
   * {@updoc
   * $ lookupEntity('lt')
   * # '<'
   * $ lookupEntity('GT')
   * # '>'
   * $ lookupEntity('amp')
   * # '&'
   * $ lookupEntity('nbsp')
   * # '\xA0'
   * $ lookupEntity('apos')
   * # "'"
   * $ lookupEntity('quot')
   * # '"'
   * $ lookupEntity('#xa')
   * # '\n'
   * $ lookupEntity('#10')
   * # '\n'
   * $ lookupEntity('#x0a')
   * # '\n'
   * $ lookupEntity('#010')
   * # '\n'
   * $ lookupEntity('#x00A')
   * # '\n'
   * $ lookupEntity('Pi')      // Known failure
   * # '\u03A0'
   * $ lookupEntity('pi')      // Known failure
   * # '\u03C0'
   * }
   *
   * @param name the content between the '&' and the ';'.
   * @return a single unicode code-point as a string.
   */
  function lookupEntity(name) {
    name = lcase(name);  // TODO: &pi; is different from &Pi;
    if (ENTITIES.hasOwnProperty(name)) { return ENTITIES[name]; }
    var m = name.match(decimalEscapeRe);
    if (m) {
      return String.fromCharCode(parseInt(m[1], 10));
    } else if (!!(m = name.match(hexEscapeRe))) {
      return String.fromCharCode(parseInt(m[1], 16));
    }
    return '';
  }

  function decodeOneEntity(_, name) {
    return lookupEntity(name);
  }

  var nulRe = /\0/g;
  function stripNULs(s) {
    return s.replace(nulRe, '');
  }

  var entityRe = /&(#\d+|#x[0-9A-Fa-f]+|\w+);/g;
  /**
   * The plain text of a chunk of HTML CDATA which possibly containing.
   *
   * {@updoc
   * $ unescapeEntities('')
   * # ''
   * $ unescapeEntities('hello World!')
   * # 'hello World!'
   * $ unescapeEntities('1 &lt; 2 &amp;&AMP; 4 &gt; 3&#10;')
   * # '1 < 2 && 4 > 3\n'
   * $ unescapeEntities('&lt;&lt <- unfinished entity&gt;')
   * # '<&lt <- unfinished entity>'
   * $ unescapeEntities('/foo?bar=baz&copy=true')  // & often unescaped in URLS
   * # '/foo?bar=baz&copy=true'
   * $ unescapeEntities('pi=&pi;&#x3c0;, Pi=&Pi;\u03A0') // FIXME: known failure
   * # 'pi=\u03C0\u03c0, Pi=\u03A0\u03A0'
   * }
   *
   * @param s a chunk of HTML CDATA.  It must not start or end inside an HTML
   *   entity.
   */
  function unescapeEntities(s) {
    return s.replace(entityRe, decodeOneEntity);
  }

  var ampRe = /&/g;
  var looseAmpRe = /&([^a-z#]|#(?:[^0-9x]|x(?:[^0-9a-f]|$)|$)|$)/gi;
  var ltRe = /</g;
  var gtRe = />/g;
  var quotRe = /\"/g;
  var eqRe = /\=/g;  // Backslash required on JScript.net

  /**
   * Escapes HTML special characters in attribute values as HTML entities.
   *
   * {@updoc
   * $ escapeAttrib('')
   * # ''
   * $ escapeAttrib('"<<&==&>>"')  // Do not just escape the first occurrence.
   * # '&#34;&lt;&lt;&amp;&#61;&#61;&amp;&gt;&gt;&#34;'
   * $ escapeAttrib('Hello <World>!')
   * # 'Hello &lt;World&gt;!'
   * }
   */
  function escapeAttrib(s) {
    // Escaping '=' defangs many UTF-7 and SGML short-tag attacks.
    return s.replace(ampRe, '&amp;').replace(ltRe, '&lt;').replace(gtRe, '&gt;')
      .replace(quotRe, '&#34;').replace(eqRe, '&#61;');
  }

  /**
   * Escape entities in RCDATA that can be escaped without changing the meaning.
   * {@updoc
   * $ normalizeRCData('1 < 2 &&amp; 3 > 4 &amp;& 5 &lt; 7&8')
   * # '1 &lt; 2 &amp;&amp; 3 &gt; 4 &amp;&amp; 5 &lt; 7&amp;8'
   * }
   */
  function normalizeRCData(rcdata) {
    return rcdata
      .replace(looseAmpRe, '&amp;$1')
      .replace(ltRe, '&lt;')
      .replace(gtRe, '&gt;');
  }


  // TODO(mikesamuel): validate sanitizer regexs against the HTML5 grammar at
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html

  /** token definitions. */
  var INSIDE_TAG_TOKEN = new RegExp(
    // Don't capture space.
    '^\\s*(?:'
    // Capture an attribute name in group 1, and value in group 3.
    // We capture the fact that there was an attribute in group 2, since
    // interpreters are inconsistent in whether a group that matches nothing
    // is null, undefined, or the empty string.
    + ('(?:'
      + '([a-z][a-z-]*)'                    // attribute name
      + ('('                                // optionally followed
        + '\\s*=\\s*'
        + ('('
          // A double quoted string.
          + '\"[^\"]*\"'
          // A single quoted string.
          + '|\'[^\']*\''
          // The positive lookahead is used to make sure that in
          // <foo bar= baz=boo>, the value for bar is blank, not "baz=boo".
          + '|(?=[a-z][a-z-]*\\s*=)'
          // An unquoted value that is not an attribute name.
          // We know it is not an attribute name because the previous
          // zero-width match would've eliminated that possibility.
          + '|[^>\"\'\\s]*'
          + ')'
        )
        + ')'
      ) + '?'
      + ')'
    )
    // End of tag captured in group 3.
    + '|(\/?>)'
    // Don't capture cruft
    + '|[\\s\\S][^a-z\\s>]*)',
    'i');

  var OUTSIDE_TAG_TOKEN = new RegExp(
    '^(?:'
    // Entity captured in group 1.
    + '&(\\#[0-9]+|\\#[x][0-9a-f]+|\\w+);'
    // Comment, doctypes, and processing instructions not captured.
    + '|<\!--[\\s\\S]*?--\>|<!\\w[^>]*>|<\\?[^>*]*>'
    // '/' captured in group 2 for close tags, and name captured in group 3.
    + '|<(\/)?([a-z][a-z0-9]*)'
    // Text captured in group 4.
    + '|([^<&>]+)'
    // Cruft captured in group 5.
    + '|([<&>]))',
    'i');

  /**
   * Given a SAX-like event handler, produce a function that feeds those
   * events and a parameter to the event handler.
   *
   * The event handler has the form:{@code
   * {
   *   // Name is an upper-case HTML tag name.  Attribs is an array of
   *   // alternating upper-case attribute names, and attribute values.  The
   *   // attribs array is reused by the parser.  Param is the value passed to
   *   // the saxParser.
   *   startTag: function (name, attribs, param) { ... },
   *   endTag:   function (name, param) { ... },
   *   pcdata:   function (text, param) { ... },
   *   rcdata:   function (text, param) { ... },
   *   cdata:    function (text, param) { ... },
   *   startDoc: function (param) { ... },
   *   endDoc:   function (param) { ... }
   * }}
   *
   * @param {Object} handler a record containing event handlers.
   * @return {Function} that takes a chunk of html and a parameter.
   *   The parameter is passed on to the handler methods.
   */
  function makeSaxParser(handler) {
    return function parse(htmlText, param) {
      htmlText = String(htmlText);
      var htmlLower = null;

      var inTag = false;  // True iff we're currently processing a tag.
      var attribs = [];  // Accumulates attribute names and values.
      var tagName = void 0;  // The name of the tag currently being processed.
      var eflags = void 0;  // The element flags for the current tag.
      var openTag = void 0;  // True if the current tag is an open tag.

      if (handler.startDoc) { handler.startDoc(param); }

      while (htmlText) {
        var m = htmlText.match(inTag ? INSIDE_TAG_TOKEN : OUTSIDE_TAG_TOKEN);
        htmlText = htmlText.substring(m[0].length);

        if (inTag) {
          if (m[1]) { // attribute
            // setAttribute with uppercase names doesn't work on IE6.
            var attribName = lcase(m[1]);
            var decodedValue;
            if (m[2]) {
              var encodedValue = m[3];
              switch (encodedValue.charCodeAt(0)) {  // Strip quotes
                case 34: case 39:
                  encodedValue = encodedValue.substring(
                    1, encodedValue.length - 1);
                  break;
              }
              decodedValue = unescapeEntities(stripNULs(encodedValue));
            } else {
              // Use name as value for valueless attribs, so
              //   <input type=checkbox checked>
              // gets attributes ['type', 'checkbox', 'checked', 'checked']
              decodedValue = attribName;
            }
            attribs.push(attribName, decodedValue);
          } else if (m[4]) {
            if (eflags !== void 0) {  // False if not in whitelist.
              if (openTag) {
                if (handler.startTag) {
                  handler.startTag(tagName, attribs, param);
                }
              } else {
                if (handler.endTag) {
                  handler.endTag(tagName, param);
                }
              }
            }

            if (openTag
              && (eflags & (html4.eflags.CDATA | html4.eflags.RCDATA))) {
              if (htmlLower === null) {
                htmlLower = lcase(htmlText);
              } else {
                htmlLower = htmlLower.substring(
                  htmlLower.length - htmlText.length);
              }
              var dataEnd = htmlLower.indexOf('</' + tagName);
              if (dataEnd < 0) { dataEnd = htmlText.length; }
              if (dataEnd) {
                if (eflags & html4.eflags.CDATA) {
                  if (handler.cdata) {
                    handler.cdata(htmlText.substring(0, dataEnd), param);
                  }
                } else if (handler.rcdata) {
                  handler.rcdata(
                    normalizeRCData(htmlText.substring(0, dataEnd)), param);
                }
                htmlText = htmlText.substring(dataEnd);
              }
            }

            tagName = eflags = openTag = void 0;
            attribs.length = 0;
            inTag = false;
          }
        } else {
          if (m[1]) {  // Entity
            if (handler.pcdata) { handler.pcdata(m[0], param); }
          } else if (m[3]) {  // Tag
            openTag = !m[2];
            inTag = true;
            tagName = lcase(m[3]);
            eflags = html4.ELEMENTS.hasOwnProperty(tagName)
              ? html4.ELEMENTS[tagName] : void 0;
          } else if (m[4]) {  // Text
            if (handler.pcdata) { handler.pcdata(m[4], param); }
          } else if (m[5]) {  // Cruft
            if (handler.pcdata) {
              var ch = m[5];
              handler.pcdata(
                ch === '<' ? '&lt;' : ch === '>' ? '&gt;' : '&amp;',
                param);
            }
          }
        }
      }

      if (handler.endDoc) { handler.endDoc(param); }
    };
  }

  /**
   * Returns a function that strips unsafe tags and attributes from html.
   * @param {Function} sanitizeAttributes
   *     maps from (tagName, attribs[]) to null or a sanitized attribute array.
   *     The attribs array can be arbitrarily modified, but the same array
   *     instance is reused, so should not be held.
   * @return {Function} from html to sanitized html
   */
  function makeHtmlSanitizer(sanitizeAttributes) {
    var stack;
    var ignoring;
    return makeSaxParser({
      startDoc: function (_) {
        stack = [];
        ignoring = false;
      },
      startTag: function (tagName, attribs, out) {
        if (ignoring) { return; }
        if (!html4.ELEMENTS.hasOwnProperty(tagName)) { return; }
        var eflags = html4.ELEMENTS[tagName];
        if (eflags & html4.eflags.FOLDABLE) {
          return;
        } else if (eflags & html4.eflags.UNSAFE) {
          ignoring = !(eflags & html4.eflags.EMPTY);
          return;
        }
        attribs = sanitizeAttributes(tagName, attribs);
        // TODO(mikesamuel): relying on sanitizeAttributes not to
        // insert unsafe attribute names.
        if (attribs) {
          if (!(eflags & html4.eflags.EMPTY)) {
            stack.push(tagName);
          }

          out.push('<', tagName);
          for (var i = 0, n = attribs.length; i < n; i += 2) {
            var attribName = attribs[i],
              value = attribs[i + 1];
            if (value !== null && value !== void 0) {
              out.push(' ', attribName, '="', escapeAttrib(value), '"');
            }
          }
          out.push('>');
        }
      },
      endTag: function (tagName, out) {
        if (ignoring) {
          ignoring = false;
          return;
        }
        if (!html4.ELEMENTS.hasOwnProperty(tagName)) { return; }
        var eflags = html4.ELEMENTS[tagName];
        if (!(eflags & (html4.eflags.UNSAFE | html4.eflags.EMPTY
          | html4.eflags.FOLDABLE))) {
          var index;
          if (eflags & html4.eflags.OPTIONAL_ENDTAG) {
            for (index = stack.length; --index >= 0;) {
              var stackEl = stack[index];
              if (stackEl === tagName) { break; }
              if (!(html4.ELEMENTS[stackEl]
                & html4.eflags.OPTIONAL_ENDTAG)) {
                // Don't pop non optional end tags looking for a match.
                return;
              }
            }
          } else {
            for (index = stack.length; --index >= 0;) {
              if (stack[index] === tagName) { break; }
            }
          }
          if (index < 0) { return; }  // Not opened.
          for (var i = stack.length; --i > index;) {
            var stackEl = stack[i];
            if (!(html4.ELEMENTS[stackEl]
              & html4.eflags.OPTIONAL_ENDTAG)) {
              out.push('</', stackEl, '>');
            }
          }
          stack.length = index;
          out.push('</', tagName, '>');
        }
      },
      pcdata: function (text, out) {
        if (!ignoring) { out.push(text); }
      },
      rcdata: function (text, out) {
        if (!ignoring) { out.push(text); }
      },
      cdata: function (text, out) {
        if (!ignoring) { out.push(text); }
      },
      endDoc: function (out) {
        for (var i = stack.length; --i >= 0;) {
          out.push('</', stack[i], '>');
        }
        stack.length = 0;
      }
    });
  }

  // From RFC3986
  var URI_SCHEME_RE = new RegExp(
    "^" +
    "(?:" +
    "([^:\/?#]+)" +         // scheme
    ":)?"
  );

  /**
   * Strips unsafe tags and attributes from html.
   * @param {string} htmlText to sanitize
   * @param {Function} opt_uriPolicy -- a transform to apply to uri/url
   *     attribute values.  If no opt_uriPolicy is provided, no uris
   *     are allowed ie. the default uriPolicy rewrites all uris to null
   * @param {Function} opt_nmTokenPolicy : string -> string? -- a transform to
   *     apply to names, ids, and classes. If no opt_nmTokenPolicy is provided,
   *     all names, ids and classes are passed through ie. the default
   *     nmTokenPolicy is an identity transform
   * @return {string} html
   */
  function sanitize(htmlText, opt_uriPolicy, opt_nmTokenPolicy) {
    var out = [];
    makeHtmlSanitizer(
      function sanitizeAttribs(tagName, attribs) {
        for (var i = 0; i < attribs.length; i += 2) {
          var attribName = attribs[i];
          var value = attribs[i + 1];
          var atype = null, attribKey;
          if ((attribKey = tagName + '::' + attribName,
            html4.ATTRIBS.hasOwnProperty(attribKey))
            || (attribKey = '*::' + attribName,
              html4.ATTRIBS.hasOwnProperty(attribKey))) {
            atype = html4.ATTRIBS[attribKey];
          }
          if (atype !== null) {
            switch (atype) {
              case html4.atype.NONE: break;
              case html4.atype.SCRIPT:
              case html4.atype.STYLE:
                value = null;
                break;
              case html4.atype.ID:
              case html4.atype.IDREF:
              case html4.atype.IDREFS:
              case html4.atype.GLOBAL_NAME:
              case html4.atype.LOCAL_NAME:
              case html4.atype.CLASSES:
                value = opt_nmTokenPolicy ? opt_nmTokenPolicy(value) : value;
                break;
              case html4.atype.URI:
                var parsedUri = ('' + value).match(URI_SCHEME_RE);
                if (!parsedUri) {
                  value = null;
                } else if (!parsedUri[1] ||
                  WHITELISTED_SCHEMES.test(parsedUri[1])) {
                  value = opt_uriPolicy && opt_uriPolicy(value);
                } else {
                  value = null;
                }
                break;
              case html4.atype.URI_FRAGMENT:
                if (value && '#' === value.charAt(0)) {
                  value = opt_nmTokenPolicy ? opt_nmTokenPolicy(value) : value;
                  if (value) { value = '#' + value; }
                } else {
                  value = null;
                }
                break;
              default:
                value = null;
                break;
            }
          } else {
            value = null;
          }
          attribs[i + 1] = value;
        }
        return attribs;
      })(htmlText, out);
    return out.join('');
  }

  return {
    escapeAttrib: escapeAttrib,
    makeHtmlSanitizer: makeHtmlSanitizer,
    makeSaxParser: makeSaxParser,
    normalizeRCData: normalizeRCData,
    sanitize: sanitize,
    unescapeEntities: unescapeEntities
  };
})(html4);

var html_sanitize = html.sanitize;

// Exports for closure compiler.  Note this file is also cajoled
// for domado and run in an environment without 'window'
if (typeof window !== 'undefined') {
  window['html'] = html;
  window['html_sanitize'] = html_sanitize;
}
// Loosen restrictions of Caja's
// html-sanitizer to allow for styling
html4.ATTRIBS['*::style'] = 0;
html4.ELEMENTS['style'] = 0;

html4.ATTRIBS['a::target'] = 0;

html4.ELEMENTS['video'] = 0;
html4.ATTRIBS['video::src'] = 0;
html4.ATTRIBS['video::poster'] = 0;
html4.ATTRIBS['video::controls'] = 0;

html4.ELEMENTS['audio'] = 0;
html4.ATTRIBS['audio::src'] = 0;
html4.ATTRIBS['video::autoplay'] = 0;
html4.ATTRIBS['video::controls'] = 0;
; wax = wax || {};

// Attribution
// -----------
wax.attribution = function () {
  var a = {};

  var container = document.createElement('div');
  container.className = 'map-attribution';

  a.content = function (x) {
    if (typeof x === 'undefined') return container.innerHTML;
    container.innerHTML = wax.u.sanitize(x);
    return this;
  };

  a.element = function () {
    return container;
  };

  a.init = function () {
    return this;
  };

  return a;
};
wax = wax || {};

// Attribution
// -----------
wax.bwdetect = function (options, callback) {
  var detector = {},
    threshold = options.threshold || 400,
    // test image: 30.29KB
    testImage = 'http://a.tiles.mapbox.com/mapbox/1.0.0/blue-marble-topo-bathy-jul/0/0/0.png?preventcache=' + (+new Date()),
    // High-bandwidth assumed
    // 1: high bandwidth (.png, .jpg)
    // 0: low bandwidth (.png128, .jpg70)
    bw = 1,
    // Alternative versions
    auto = options.auto === undefined ? true : options.auto;

  function bwTest() {
    wax.bw = -1;
    var im = new Image();
    im.src = testImage;
    var first = true;
    var timeout = setTimeout(function () {
      if (first && wax.bw == -1) {
        detector.bw(0);
        first = false;
      }
    }, threshold);
    im.onload = function () {
      if (first && wax.bw == -1) {
        clearTimeout(timeout);
        detector.bw(1);
        first = false;
      }
    };
  }

  detector.bw = function (x) {
    if (!arguments.length) return bw;
    var oldBw = bw;
    if (wax.bwlisteners && wax.bwlisteners.length) (function () {
      listeners = wax.bwlisteners;
      wax.bwlisteners = [];
      for (i = 0; i < listeners; i++) {
        listeners[i](x);
      }
    })();
    wax.bw = x;

    if (bw != (bw = x)) callback(x);
  };

  detector.add = function () {
    if (auto) bwTest();
    return this;
  };

  if (wax.bw == -1) {
    wax.bwlisteners = wax.bwlisteners || [];
    wax.bwlisteners.push(detector.bw);
  } else if (wax.bw !== undefined) {
    detector.bw(wax.bw);
  } else {
    detector.add();
  }
  return detector;
};
// Formatter
// ---------
//
// This code is no longer the recommended code path for Wax -
// see `template.js`, a safe implementation of Mustache templates.
wax.formatter = function (x) {
  var formatter = {},
    f;

  // Prevent against just any input being used.
  if (x && typeof x === 'string') {
    try {
      // Ugly, dangerous use of eval.
      eval('f = ' + x);
    } catch (e) {
      if (console) console.log(e);
    }
  } else if (x && typeof x === 'function') {
    f = x;
  } else {
    f = function () { };
  }

  // Wrap the given formatter function in order to
  // catch exceptions that it may throw.
  formatter.format = function (options, data) {
    try {
      return wax.u.sanitize(f(options, data));
    } catch (e) {
      if (console) console.log(e);
    }
  };

  return formatter;
};
// GridInstance
// ------------
// GridInstances are queryable, fully-formed
// objects for acquiring features from events.
//
// This code ignores format of 1.1-1.2
wax.gi = function (grid_tile, options) {
  options = options || {};
  // resolution is the grid-elements-per-pixel ratio of gridded data.
  // The size of a tile element. For now we expect tiles to be squares.
  var instance = {},
    resolution = options.resolution || 4,
    tileSize = options.tileSize || 256;

  // Resolve the UTF-8 encoding stored in grids to simple
  // number values.
  // See the [utfgrid spec](https://github.com/mapbox/utfgrid-spec)
  // for details.
  function resolveCode(key) {
    if (key >= 93) key--;
    if (key >= 35) key--;
    key -= 32;
    return key;
  }

  instance.grid_tile = function () {
    return grid_tile;
  };

  instance.getKey = function (x, y) {
    if (!(grid_tile && grid_tile.grid)) return;
    if ((y < 0) || (x < 0)) return;
    if ((Math.floor(y) >= tileSize) ||
      (Math.floor(x) >= tileSize)) return;
    // Find the key in the grid. The above calls should ensure that
    // the grid's array is large enough to make this work.
    return resolveCode(grid_tile.grid[
      Math.floor((y) / resolution)
    ].charCodeAt(
      Math.floor((x) / resolution)
    ));
  };

  // Lower-level than tileFeature - has nothing to do
  // with the DOM. Takes a px offset from 0, 0 of a grid.
  instance.gridFeature = function (x, y) {
    // Find the key in the grid. The above calls should ensure that
    // the grid's array is large enough to make this work.
    var key = this.getKey(x, y),
      keys = grid_tile.keys;

    if (keys &&
      keys[key] &&
      grid_tile.data[keys[key]]) {
      return grid_tile.data[keys[key]];
    }
  };

  // Get a feature:
  // * `x` and `y`: the screen coordinates of an event
  // * `tile_element`: a DOM element of a tile, from which we can get an offset.
  instance.tileFeature = function (x, y, tile_element) {
    if (!grid_tile) return;
    // IE problem here - though recoverable, for whatever reason
    var offset = wax.u.offset(tile_element);
    feature = this.gridFeature(x - offset.left, y - offset.top);
    return feature;
  };

  return instance;
};
// GridManager
// -----------
// Generally one GridManager will be used per map.
//
// It takes one options object, which current accepts a single option:
// `resolution` determines the number of pixels per grid element in the grid.
// The default is 4.
wax.gm = function () {

  var resolution = 4,
    grid_tiles = {},
    manager = {},
    tilejson,
    formatter;

  var gridUrl = function (url) {
    if (url) {
      return url.replace(/(\.png|\.jpg|\.jpeg)(\d*)/, '.grid.json');
    }
  };

  function templatedGridUrl(template) {
    if (typeof template === 'string') template = [template];
    return function templatedGridFinder(url) {
      if (!url) return;
      var rx = new RegExp('/(\\d+)\\/(\\d+)\\/(\\d+)\\.[\\w\\._]+');
      var xyz = rx.exec(url);
      if (!xyz) return;
      return template[parseInt(xyz[2], 10) % template.length]
        .replace(/\{z\}/g, xyz[1])
        .replace(/\{x\}/g, xyz[2])
        .replace(/\{y\}/g, xyz[3]);
    };
  }

  manager.formatter = function (x) {
    if (!arguments.length) return formatter;
    formatter = wax.formatter(x);
    return manager;
  };

  manager.template = function (x) {
    if (!arguments.length) return formatter;
    formatter = wax.template(x);
    return manager;
  };

  manager.gridUrl = function (x) {
    // Getter-setter
    if (!arguments.length) return gridUrl;

    // Handle tilesets that don't support grids
    if (!x) {
      gridUrl = function () { return null; };
    } else {
      gridUrl = typeof x === 'function' ?
        x : templatedGridUrl(x);
    }
    return manager;
  };

  manager.getGrid = function (url, callback) {
    var gurl = gridUrl(url);
    if (!formatter || !gurl) return callback(null, null);

    wax.request.get(gurl, function (err, t) {
      if (err) return callback(err, null);
      callback(null, wax.gi(t, {
        formatter: formatter,
        resolution: resolution
      }));
    });
    return manager;
  };

  manager.tilejson = function (x) {
    if (!arguments.length) return tilejson;
    // prefer templates over formatters
    if (x.template) {
      manager.template(x.template);
    } else if (x.formatter) {
      manager.formatter(x.formatter);
    } else {
      // In this case, we cannot support grids
      formatter = undefined;
    }
    manager.gridUrl(x.grids);
    if (x.resolution) resolution = x.resolution;
    tilejson = x;
    return manager;
  };

  return manager;
};
wax = wax || {};

// Hash
// ----
wax.hash = function (options) {
  options = options || {};

  var s0, // old hash
    hash = {},
    lat = 90 - 1e-8;  // allowable latitude range

  function getState() {
    return location.hash.substring(1);
  }

  function pushState(state) {
    var l = window.location;
    l.replace(l.toString().replace((l.hash || /$/), '#' + state));
  }

  function parseHash(s) {
    var args = s.split('/');
    for (var i = 0; i < args.length; i++) {
      args[i] = Number(args[i]);
      if (isNaN(args[i])) return true;
    }
    if (args.length < 3) {
      // replace bogus hash
      return true;
    } else if (args.length == 3) {
      options.setCenterZoom(args);
    }
  }

  function move() {
    var s1 = options.getCenterZoom();
    if (s0 !== s1) {
      s0 = s1;
      // don't recenter the map!
      pushState(s0);
    }
  }

  function stateChange(state) {
    // ignore spurious hashchange events
    if (state === s0) return;
    if (parseHash(s0 = state)) {
      // replace bogus hash
      move();
    }
  }

  var _move = wax.u.throttle(move, 500);

  hash.add = function () {
    stateChange(getState());
    options.bindChange(_move);
    return hash;
  };

  hash.remove = function () {
    options.unbindChange(_move);
    return hash;
  };

  return hash;
};
wax = wax || {};

wax.interaction = function () {
  var gm = wax.gm(),
    interaction = {},
    _downLock = false,
    _clickTimeout = null,
    // Active feature
    // Down event
    _d,
    // Touch tolerance
    tol = 4,
    grid,
    attach,
    detach,
    parent,
    map,
    tileGrid;

  var defaultEvents = {
    mousemove: onMove,
    touchstart: onDown,
    mousedown: onDown
  };

  var touchEnds = {
    touchend: onUp,
    touchmove: onUp,
    touchcancel: touchCancel
  };

  // Abstract getTile method. Depends on a tilegrid with
  // grid[ [x, y, tile] ] structure.
  function getTile(e) {
    var g = grid();
    for (var i = 0; i < g.length; i++) {
      if ((g[i][0] < e.y) &&
        ((g[i][0] + 256) > e.y) &&
        (g[i][1] < e.x) &&
        ((g[i][1] + 256) > e.x)) return g[i][2];
    }
    return false;
  }

  // Clear the double-click timeout to prevent double-clicks from
  // triggering popups.
  function killTimeout() {
    if (_clickTimeout) {
      window.clearTimeout(_clickTimeout);
      _clickTimeout = null;
      return true;
    } else {
      return false;
    }
  }

  function onMove(e) {
    // If the user is actually dragging the map, exit early
    // to avoid performance hits.
    if (_downLock) return;

    var pos = wax.u.eventoffset(e);

    interaction.screen_feature(pos, function (feature) {
      if (feature) {
        bean.fire(interaction, 'on', {
          parent: parent(),
          data: feature,
          formatter: gm.formatter().format,
          e: e
        });
      } else {
        bean.fire(interaction, 'off');
      }
    });
  }

  function dragEnd() {
    _downLock = false;
  }

  // A handler for 'down' events - which means `mousedown` and `touchstart`
  function onDown(e) {

    // Prevent interaction offset calculations happening while
    // the user is dragging the map.
    //
    // Store this event so that we can compare it to the
    // up event
    _downLock = true;
    _d = wax.u.eventoffset(e);
    if (e.type === 'mousedown') {
      bean.add(document.body, 'click', onUp);
      // track mouse up to remove lockDown when the drags end
      bean.add(document.body, 'mouseup', dragEnd);

      // Only track single-touches. Double-touches will not affect this
      // control
    } else if (e.type === 'touchstart' && e.touches.length === 1) {
      // Don't make the user click close if they hit another tooltip
      bean.fire(interaction, 'off');
      // Touch moves invalidate touches
      bean.add(e.srcElement, touchEnds);
    }
  }

  function touchCancel(e) {
    bean.remove(e.srcElement, touchEnds);
    _downLock = false;
  }

  function onUp(e) {
    var evt = {},
      pos = wax.u.eventoffset(e);
    _downLock = false;

    // TODO: refine
    for (var key in e) {
      evt[key] = e[key];
    }

    bean.remove(document.body, 'mouseup', onUp);
    bean.remove(e.srcElement, touchEnds);

    if (e.type === 'touchend') {
      // If this was a touch and it survived, there's no need to avoid a double-tap
      // but also wax.u.eventoffset will have failed, since this touch
      // event doesn't have coordinates
      interaction.click(e, _d);
    } else if (pos && _d && Math.round(pos.y / tol) === Math.round(_d.y / tol) &&
      Math.round(pos.x / tol) === Math.round(_d.x / tol)) {
      // Contain the event data in a closure.
      // Ignore double-clicks by ignoring clicks within 300ms of
      // each other.
      if (!_clickTimeout) {
        _clickTimeout = window.setTimeout(function () {
          _clickTimeout = null;
          interaction.click(evt, pos);
        }, 300);
      } else {
        killTimeout();
      }
    }
    return onUp;
  }

  // Handle a click event. Takes a second
  interaction.click = function (e, pos) {
    interaction.screen_feature(pos, function (feature) {
      if (feature) bean.fire(interaction, 'on', {
        parent: parent(),
        data: feature,
        formatter: gm.formatter().format,
        e: e
      });
    });
  };

  interaction.screen_feature = function (pos, callback) {
    var tile = getTile(pos);
    if (!tile) callback(null);
    gm.getGrid(tile.src, function (err, g) {
      if (err || !g) return callback(null);
      var feature = g.tileFeature(pos.x, pos.y, tile);
      callback(feature);
    });
  };

  // set an attach function that should be
  // called when maps are set
  interaction.attach = function (x) {
    if (!arguments.length) return attach;
    attach = x;
    return interaction;
  };

  interaction.detach = function (x) {
    if (!arguments.length) return detach;
    detach = x;
    return interaction;
  };

  // Attach listeners to the map
  interaction.map = function (x) {
    if (!arguments.length) return map;
    map = x;
    if (attach) attach(map);
    bean.add(parent(), defaultEvents);
    bean.add(parent(), 'touchstart', onDown);
    return interaction;
  };

  // set a grid getter for this control
  interaction.grid = function (x) {
    if (!arguments.length) return grid;
    grid = x;
    return interaction;
  };

  // detach this and its events from the map cleanly
  interaction.remove = function (x) {
    if (detach) detach(map);
    bean.remove(parent(), defaultEvents);
    bean.fire(interaction, 'remove');
    return interaction;
  };

  // get or set a tilejson chunk of json
  interaction.tilejson = function (x) {
    if (!arguments.length) return gm.tilejson();
    gm.tilejson(x);
    return interaction;
  };

  // return the formatter, which has an exposed .format
  // function
  interaction.formatter = function () {
    return gm.formatter();
  };

  // ev can be 'on', 'off', fn is the handler
  interaction.on = function (ev, fn) {
    bean.add(interaction, ev, fn);
    return interaction;
  };

  // ev can be 'on', 'off', fn is the handler
  interaction.off = function (ev, fn) {
    bean.remove(interaction, ev, fn);
    return interaction;
  };

  // Return or set the gridmanager implementation
  interaction.gridmanager = function (x) {
    if (!arguments.length) return gm;
    gm = x;
    return interaction;
  };

  // parent should be a function that returns
  // the parent element of the map
  interaction.parent = function (x) {
    parent = x;
    return interaction;
  };

  return interaction;
};
// Wax Legend
// ----------

// Wax header
var wax = wax || {};

wax.legend = function () {
  var element,
    legend = {},
    container;

  legend.element = function () {
    return container;
  };

  legend.content = function (content) {
    if (!arguments.length) return element.innerHTML;

    element.innerHTML = wax.u.sanitize(content);
    element.style.display = 'block';
    if (element.innerHTML === '') {
      element.style.display = 'none';
    }

    return legend;
  };

  legend.add = function () {
    container = document.createElement('div');
    container.className = 'map-legends wax-legends';

    element = container.appendChild(document.createElement('div'));
    element.className = 'map-legend wax-legend';
    element.style.display = 'none';
    return legend;
  };

  return legend.add();
};
var wax = wax || {};

wax.location = function () {

  var t = {};

  function on(o) {
    if ((o.e.type === 'mousemove' || !o.e.type)) {
      return;
    } else {
      var loc = o.formatter({ format: 'location' }, o.data);
      if (loc) {
        window.top.location.href = loc;
      }
    }
  }

  t.events = function () {
    return {
      on: on
    };
  };

  return t;

};
var wax = wax || {};
wax.movetip = {};

wax.movetip = function () {
  var popped = false,
    t = {},
    _tooltipOffset,
    _contextOffset,
    tooltip,
    parent;

  function moveTooltip(e) {
    var eo = wax.u.eventoffset(e);
    // faux-positioning
    if ((_tooltipOffset.height + eo.y) >
      (_contextOffset.top + _contextOffset.height) &&
      (_contextOffset.height > _tooltipOffset.height)) {
      eo.y -= _tooltipOffset.height;
      tooltip.className += ' flip-y';
    }

    // faux-positioning
    if ((_tooltipOffset.width + eo.x) >
      (_contextOffset.left + _contextOffset.width)) {
      eo.x -= _tooltipOffset.width;
      tooltip.className += ' flip-x';
    }

    tooltip.style.left = eo.x + 'px';
    tooltip.style.top = eo.y + 'px';
  }

  // Get the active tooltip for a layer or create a new one if no tooltip exists.
  // Hide any tooltips on layers underneath this one.
  function getTooltip(feature) {
    var tooltip = document.createElement('div');
    tooltip.className = 'map-tooltip map-tooltip-0';
    tooltip.innerHTML = feature;
    return tooltip;
  }

  // Hide a given tooltip.
  function hide() {
    if (tooltip) {
      tooltip.parentNode.removeChild(tooltip);
      tooltip = null;
    }
  }

  function on(o) {
    var content;
    if (popped) return;
    if ((o.e.type === 'mousemove' || !o.e.type)) {
      content = o.formatter({ format: 'teaser' }, o.data);
      if (!content) return;
      hide();
      parent.style.cursor = 'pointer';
      tooltip = document.body.appendChild(getTooltip(content));
    } else {
      content = o.formatter({ format: 'teaser' }, o.data);
      if (!content) return;
      hide();
      var tt = document.body.appendChild(getTooltip(content));
      tt.className += ' map-popup';

      var close = tt.appendChild(document.createElement('a'));
      close.href = '#close';
      close.className = 'close';
      close.innerHTML = 'Close';

      popped = true;

      tooltip = tt;

      _tooltipOffset = wax.u.offset(tooltip);
      _contextOffset = wax.u.offset(parent);
      moveTooltip(o.e);

      bean.add(close, 'click touchend', function closeClick(e) {
        e.stop();
        hide();
        popped = false;
      });
    }
    if (tooltip) {
      _tooltipOffset = wax.u.offset(tooltip);
      _contextOffset = wax.u.offset(parent);
      moveTooltip(o.e);
    }

  }

  function off() {
    parent.style.cursor = 'default';
    if (!popped) hide();
  }

  t.parent = function (x) {
    if (!arguments.length) return parent;
    parent = x;
    return t;
  };

  t.events = function () {
    return {
      on: on,
      off: off
    };
  };

  return t;
};

// Wax GridUtil
// ------------

// Wax header
var wax = wax || {};

// Request
// -------
// Request data cache. `callback(data)` where `data` is the response data.
wax.request = {
  cache: {},
  locks: {},
  promises: {},
  get: function (url, callback) {
    // Cache hit.
    if (this.cache[url]) {
      return callback(this.cache[url][0], this.cache[url][1]);
      // Cache miss.
    } else {
      this.promises[url] = this.promises[url] || [];
      this.promises[url].push(callback);
      // Lock hit.
      if (this.locks[url]) return;
      // Request.
      var that = this;
      this.locks[url] = true;
      reqwest({
        url: url + (~url.indexOf('?') ? '&' : '?') + 'callback=?',
        type: 'jsonp',
        success: function (data) {
          that.locks[url] = false;
          that.cache[url] = [null, data];
          for (var i = 0; i < that.promises[url].length; i++) {
            that.promises[url][i](that.cache[url][0], that.cache[url][1]);
          }
        },
        error: function (err) {
          that.locks[url] = false;
          that.cache[url] = [err, null];
          for (var i = 0; i < that.promises[url].length; i++) {
            that.promises[url][i](that.cache[url][0], that.cache[url][1]);
          }
        }
      });
    }
  }
};
// Templating
// ---------
wax.template = function (x) {
  var template = {};

  // Clone the data object such that the '__[format]__' key is only
  // set for this instance of templating.
  template.format = function (options, data) {
    var clone = {};
    for (var key in data) {
      clone[key] = data[key];
    }
    if (options.format) {
      clone['__' + options.format + '__'] = true;
    }
    return wax.u.sanitize(Mustache.to_html(x, clone));
  };

  return template;
};
if (!wax) var wax = {};

// A wrapper for reqwest jsonp to easily load TileJSON from a URL.
wax.tilejson = function (url, callback) {
  reqwest({
    url: url + (~url.indexOf('?') ? '&' : '?') + 'callback=?',
    type: 'jsonp',
    success: callback,
    error: callback
  });
};
var wax = wax || {};
wax.tooltip = {};

wax.tooltip = function () {
  var popped = false,
    animate = false,
    t = {},
    tooltips = [],
    _currentContent,
    transitionEvent,
    parent;

  if (document.body.style['-webkit-transition'] !== undefined) {
    transitionEvent = 'webkitTransitionEnd';
  } else if (document.body.style.MozTransition !== undefined) {
    transitionEvent = 'transitionend';
  }

  // Get the active tooltip for a layer or create a new one if no tooltip exists.
  // Hide any tooltips on layers underneath this one.
  function getTooltip(feature) {
    var tooltip = document.createElement('div');
    tooltip.className = 'map-tooltip map-tooltip-0 wax-tooltip';
    tooltip.innerHTML = feature;
    return tooltip;
  }

  function remove() {
    if (this.parentNode) this.parentNode.removeChild(this);
  }

  // Hide a given tooltip.
  function hide() {
    var _ct;
    while (_ct = tooltips.pop()) {
      if (animate && transitionEvent) {
        // This code assumes that transform-supporting browsers
        // also support proper events. IE9 does both.
        bean.add(_ct, transitionEvent, remove);
        _ct.className += ' map-fade';
      } else {
        if (_ct.parentNode) _ct.parentNode.removeChild(_ct);
      }
    }
  }

  function on(o) {
    var content;
    if (o.e.type === 'mousemove' || !o.e.type) {
      if (!popped) {
        content = o.content || o.formatter({ format: 'teaser' }, o.data);
        if (!content || content == _currentContent) return;
        hide();
        parent.style.cursor = 'pointer';
        tooltips.push(parent.appendChild(getTooltip(content)));
        _currentContent = content;
      }
    } else {
      content = o.content || o.formatter({ format: 'full' }, o.data);
      if (!content) {
        if (o.e.type && o.e.type.match(/touch/)) {
          // fallback possible
          content = o.content || o.formatter({ format: 'teaser' }, o.data);
        }
        // but if that fails, return just the same.
        if (!content) return;
      }
      hide();
      parent.style.cursor = 'pointer';
      var tt = parent.appendChild(getTooltip(content));
      tt.className += ' map-popup wax-popup';

      var close = tt.appendChild(document.createElement('a'));
      close.href = '#close';
      close.className = 'close';
      close.innerHTML = 'Close';
      popped = true;

      tooltips.push(tt);

      bean.add(close, 'touchstart mousedown', function (e) {
        e.stop();
      });

      bean.add(close, 'click touchend', function closeClick(e) {
        e.stop();
        hide();
        popped = false;
      });
    }
  }

  function off() {
    parent.style.cursor = 'default';
    _currentContent = null;
    if (!popped) hide();
  }

  t.parent = function (x) {
    if (!arguments.length) return parent;
    parent = x;
    return t;
  };

  t.animate = function (x) {
    if (!arguments.length) return animate;
    animate = x;
    return t;
  };

  t.events = function () {
    return {
      on: on,
      off: off
    };
  };

  return t;
};
var wax = wax || {};

// Utils are extracted from other libraries or
// written from scratch to plug holes in browser compatibility.
wax.u = {
  // From Bonzo
  offset: function (el) {
    // TODO: window margins
    //
    // Okay, so fall back to styles if offsetWidth and height are botched
    // by Firefox.
    var width = el.offsetWidth || parseInt(el.style.width, 10),
      height = el.offsetHeight || parseInt(el.style.height, 10),
      doc_body = document.body,
      top = 0,
      left = 0;

    var calculateOffset = function (el) {
      if (el === doc_body || el === document.documentElement) return;
      top += el.offsetTop;
      left += el.offsetLeft;

      var style = el.style.transform ||
        el.style.WebkitTransform ||
        el.style.OTransform ||
        el.style.MozTransform ||
        el.style.msTransform;

      if (style) {
        var match;
        if (match = style.match(/translate\((.+)[px]?, (.+)[px]?\)/)) {
          top += parseInt(match[2], 10);
          left += parseInt(match[1], 10);
        } else if (match = style.match(/translate3d\((.+)[px]?, (.+)[px]?, (.+)[px]?\)/)) {
          top += parseInt(match[2], 10);
          left += parseInt(match[1], 10);
        } else if (match = style.match(/matrix3d\(([\-\d,\s]+)\)/)) {
          var pts = match[1].split(',');
          top += parseInt(pts[13], 10);
          left += parseInt(pts[12], 10);
        } else if (match = style.match(/matrix\(.+, .+, .+, .+, (.+), (.+)\)/)) {
          top += parseInt(match[2], 10);
          left += parseInt(match[1], 10);
        }
      }
    };

    // from jquery, offset.js
    if (typeof el.getBoundingClientRect !== "undefined") {
      var body = document.body;
      var doc = el.ownerDocument.documentElement;
      var clientTop = document.clientTop || body.clientTop || 0;
      var clientLeft = document.clientLeft || body.clientLeft || 0;
      var scrollTop = window.pageYOffset || doc.scrollTop;
      var scrollLeft = window.pageXOffset || doc.scrollLeft;

      var box = el.getBoundingClientRect();
      top = box.top + scrollTop - clientTop;
      left = box.left + scrollLeft - clientLeft;

    } else {
      calculateOffset(el);
      try {
        while (el = el.offsetParent) { calculateOffset(el); }
      } catch (e) {
        // Hello, internet explorer.
      }
    }

    // Offsets from the body
    top += doc_body.offsetTop;
    left += doc_body.offsetLeft;
    // Offsets from the HTML element
    top += doc_body.parentNode.offsetTop;
    left += doc_body.parentNode.offsetLeft;

    // Firefox and other weirdos. Similar technique to jQuery's
    // `doesNotIncludeMarginInBodyOffset`.
    var htmlComputed = document.defaultView ?
      window.getComputedStyle(doc_body.parentNode, null) :
      doc_body.parentNode.currentStyle;
    if (doc_body.parentNode.offsetTop !==
      parseInt(htmlComputed.marginTop, 10) &&
      !isNaN(parseInt(htmlComputed.marginTop, 10))) {
      top += parseInt(htmlComputed.marginTop, 10);
      left += parseInt(htmlComputed.marginLeft, 10);
    }

    return {
      top: top,
      left: left,
      height: height,
      width: width
    };
  },

  '$': function (x) {
    return (typeof x === 'string') ?
      document.getElementById(x) :
      x;
  },

  // From quirksmode: normalize the offset of an event from the top-left
  // of the page.
  eventoffset: function (e) {
    var posx = 0;
    var posy = 0;
    if (!e) { e = window.event; }
    if (e.pageX || e.pageY) {
      // Good browsers
      return {
        x: e.pageX,
        y: e.pageY
      };
    } else if (e.clientX || e.clientY) {
      // Internet Explorer
      return {
        x: e.clientX,
        y: e.clientY
      };
    } else if (e.touches && e.touches.length === 1) {
      // Touch browsers
      return {
        x: e.touches[0].pageX,
        y: e.touches[0].pageY
      };
    }
  },

  // Ripped from underscore.js
  // Internal function used to implement `_.throttle` and `_.debounce`.
  limit: function (func, wait, debounce) {
    var timeout;
    return function () {
      var context = this, args = arguments;
      var throttler = function () {
        timeout = null;
        func.apply(context, args);
      };
      if (debounce) clearTimeout(timeout);
      if (debounce || !timeout) timeout = setTimeout(throttler, wait);
    };
  },

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  throttle: function (func, wait) {
    return this.limit(func, wait, false);
  },

  sanitize: function (content) {
    if (!content) return '';

    function urlX(url) {
      // Data URIs are subject to a bug in Firefox
      // https://bugzilla.mozilla.org/show_bug.cgi?id=255107
      // which let them be a vector. But WebKit does 'the right thing'
      // or at least 'something' about this situation, so we'll tolerate
      // them.
      if (/^(https?:\/\/|data:image)/.test(url)) {
        return url;
      }
    }

    function idX(id) { return id; }

    return html_sanitize(content, urlX, idX);
  }
};
wax = wax || {};
wax.mm = wax.mm || {};

wax.mm.attribution = function () {
  var map,
    a = {},
    container = document.createElement('div');

  container.className = 'map-attribution map-mm';

  a.content = function (x) {
    if (typeof x === 'undefined') return container.innerHTML;
    container.innerHTML = wax.u.sanitize(x);
    return a;
  };

  a.element = function () {
    return container;
  };

  a.map = function (x) {
    if (!arguments.length) return map;
    map = x;
    return a;
  };

  a.add = function () {
    if (!map) return false;
    map.parent.appendChild(container);
    return a;
  };

  a.remove = function () {
    if (!map) return false;
    if (container.parentNode) container.parentNode.removeChild(container);
    return a;
  };

  a.appendTo = function (elem) {
    wax.u.$(elem).appendChild(container);
    return a;
  };

  return a;
};
wax = wax || {};
wax.mm = wax.mm || {};

wax.mm.boxselector = function () {
  var corner,
    nearCorner,
    boxDiv,
    style,
    borderWidth = 0,
    horizontal = false,  // Whether the resize is horizontal
    vertical = false,
    edge = 5,  // Distance from border sensitive to resizing
    addEvent = MM.addEvent,
    removeEvent = MM.removeEvent,
    box,
    boxselector = {},
    map,
    callbackManager = new MM.CallbackManager(boxselector, ['change']);

  function getMousePoint(e) {
    // start with just the mouse (x, y)
    var point = new MM.Point(e.clientX, e.clientY);
    // correct for scrolled document
    point.x += document.body.scrollLeft +
      document.documentElement.scrollLeft;
    point.y += document.body.scrollTop +
      document.documentElement.scrollTop;

    // correct for nested offsets in DOM
    for (var node = map.parent; node; node = node.offsetParent) {
      point.x -= node.offsetLeft;
      point.y -= node.offsetTop;
    }
    return point;
  }

  function mouseDown(e) {
    if (!e.shiftKey) return;

    corner = nearCorner = getMousePoint(e);
    horizontal = vertical = true;

    style.left = corner.x + 'px';
    style.top = corner.y + 'px';
    style.width = style.height = 0;

    addEvent(document, 'mousemove', mouseMove);
    addEvent(document, 'mouseup', mouseUp);

    map.parent.style.cursor = 'crosshair';
    return MM.cancelEvent(e);
  }

  // Resize existing box
  function mouseDownResize(e) {
    var point = getMousePoint(e),
      TL = {
        x: parseInt(boxDiv.offsetLeft, 10),
        y: parseInt(boxDiv.offsetTop, 10)
      },
      BR = {
        x: TL.x + parseInt(boxDiv.offsetWidth, 10),
        y: TL.y + parseInt(boxDiv.offsetHeight, 10)
      };

    // Determine whether resize is horizontal, vertical or both
    horizontal = point.x - TL.x <= edge || BR.x - point.x <= edge;
    vertical = point.y - TL.y <= edge || BR.y - point.y <= edge;

    if (vertical || horizontal) {
      corner = {
        x: (point.x - TL.x < BR.x - point.x) ? BR.x : TL.x,
        y: (point.y - TL.y < BR.y - point.y) ? BR.y : TL.y
      };
      nearCorner = {
        x: (point.x - TL.x < BR.x - point.x) ? TL.x : BR.x,
        y: (point.y - TL.y < BR.y - point.y) ? TL.y : BR.y
      };
      addEvent(document, 'mousemove', mouseMove);
      addEvent(document, 'mouseup', mouseUp);
      return MM.cancelEvent(e);
    }
  }

  function mouseMove(e) {
    var point = getMousePoint(e);
    style.display = 'block';
    if (horizontal) {
      style.left = (point.x < corner.x ? point.x : corner.x) + 'px';
      style.width = Math.abs(point.x - corner.x) - 2 * borderWidth + 'px';
    }
    if (vertical) {
      style.top = (point.y < corner.y ? point.y : corner.y) + 'px';
      style.height = Math.abs(point.y - corner.y) - 2 * borderWidth + 'px';
    }
    changeCursor(point, map.parent);
    return MM.cancelEvent(e);
  }

  function mouseUp(e) {
    var point = getMousePoint(e),
      l1 = map.pointLocation(new MM.Point(
        horizontal ? point.x : nearCorner.x,
        vertical ? point.y : nearCorner.y
      ));
    l2 = map.pointLocation(corner);

    // Format coordinates like mm.map.getExtent().
    boxselector.extent([
      new MM.Location(
        Math.max(l1.lat, l2.lat),
        Math.min(l1.lon, l2.lon)),
      new MM.Location(
        Math.min(l1.lat, l2.lat),
        Math.max(l1.lon, l2.lon))
    ]);

    removeEvent(document, 'mousemove', mouseMove);
    removeEvent(document, 'mouseup', mouseUp);

    map.parent.style.cursor = 'auto';
  }

  function mouseMoveCursor(e) {
    changeCursor(getMousePoint(e), boxDiv);
  }

  // Set resize cursor if mouse is on edge
  function changeCursor(point, elem) {
    var TL = {
      x: parseInt(boxDiv.offsetLeft, 10),
      y: parseInt(boxDiv.offsetTop, 10)
    },
      BR = {
        x: TL.x + parseInt(boxDiv.offsetWidth, 10),
        y: TL.y + parseInt(boxDiv.offsetHeight, 10)
      };
    // Build cursor style string
    var prefix = '';
    if (point.y - TL.y <= edge) prefix = 'n';
    else if (BR.y - point.y <= edge) prefix = 's';
    if (point.x - TL.x <= edge) prefix += 'w';
    else if (BR.x - point.x <= edge) prefix += 'e';
    if (prefix !== '') prefix += '-resize';
    elem.style.cursor = prefix;
  }

  function drawbox(map, e) {
    if (!boxDiv || !box) return;
    var br = map.locationPoint(box[1]),
      tl = map.locationPoint(box[0]),
      style = boxDiv.style;

    style.display = 'block';
    style.height = 'auto';
    style.width = 'auto';
    style.left = Math.max(0, tl.x) + 'px';
    style.top = Math.max(0, tl.y) + 'px';
    style.right = Math.max(0, map.dimensions.x - br.x) + 'px';
    style.bottom = Math.max(0, map.dimensions.y - br.y) + 'px';
  }

  boxselector.addCallback = function (event, callback) {
    callbackManager.addCallback(event, callback);
    return boxselector;
  };

  boxselector.removeCallback = function (event, callback) {
    callbackManager.removeCallback(event, callback);
    return boxselector;
  };

  boxselector.extent = function (x, silent) {
    if (!x) return box;

    box = [
      new MM.Location(
        Math.max(x[0].lat, x[1].lat),
        Math.min(x[0].lon, x[1].lon)),
      new MM.Location(
        Math.min(x[0].lat, x[1].lat),
        Math.max(x[0].lon, x[1].lon))
    ];

    drawbox(map);

    if (!silent) callbackManager.dispatchCallback('change', box);
  };
  boxDiv = document.createElement('div');
  boxDiv.className = 'boxselector-box';
  style = boxDiv.style;

  boxselector.add = function () {
    boxDiv.id = map.parent.id + '-boxselector-box';
    map.parent.appendChild(boxDiv);
    borderWidth = parseInt(window.getComputedStyle(boxDiv).borderWidth, 10);

    addEvent(map.parent, 'mousedown', mouseDown);
    addEvent(boxDiv, 'mousedown', mouseDownResize);
    addEvent(map.parent, 'mousemove', mouseMoveCursor);
    map.addCallback('drawn', drawbox);
    return boxselector;
  };

  boxselector.map = function (x) {
    if (!arguments.length) return map;
    map = x;
    return boxselector;
  };

  boxselector.remove = function () {
    map.parent.removeChild(boxDiv);

    removeEvent(map.parent, 'mousedown', mouseDown);
    removeEvent(boxDiv, 'mousedown', mouseDownResize);
    removeEvent(map.parent, 'mousemove', mouseMoveCursor);

    map.removeCallback('drawn', drawbox);
    return boxselector;
  };

  return boxselector;
};
wax = wax || {};
wax.mm = wax.mm || {};
wax._ = {};

wax.mm.bwdetect = function (map, options) {
  options = options || {};
  var lowpng = options.png || '.png128',
    lowjpg = options.jpg || '.jpg70',
    bw = false;

  wax._.bw_png = lowpng;
  wax._.bw_jpg = lowjpg;

  return wax.bwdetect(options, function (x) {
    wax._.bw = !x;
    for (var i = 0; i < map.layers.length; i++) {
      if (map.getLayerAt(i).provider instanceof wax.mm.connector) {
        map.getLayerAt(i).setProvider(map.getLayerAt(i).provider);
      }
    }
  });
};
wax = wax || {};
wax.mm = wax.mm || {};

// Add zoom links, which can be styled as buttons, to a `modestmaps.Map`
// control. This function can be used chaining-style with other
// chaining-style controls.
wax.mm.fullscreen = function () {
  // true: fullscreen
  // false: minimized
  var fullscreened = false,
    fullscreen = {},
    a = document.createElement('a'),
    map,
    body = document.body,
    dimensions;

  a.className = 'map-fullscreen';
  a.href = '#fullscreen';
  // a.innerHTML = 'fullscreen';

  function click(e) {
    if (e) e.stop();
    if (fullscreened) {
      fullscreen.original();
    } else {
      fullscreen.full();
    }
  }

  fullscreen.map = function (x) {
    if (!arguments.length) return map;
    map = x;
    return fullscreen;
  };

  // Modest Maps demands an absolute height & width, and doesn't auto-correct
  // for changes, so here we save the original size of the element and
  // restore to that size on exit from fullscreen.
  fullscreen.add = function () {
    bean.add(a, 'click', click);
    map.parent.appendChild(a);
    return fullscreen;
  };

  fullscreen.remove = function () {
    bean.remove(a, 'click', click);
    if (a.parentNode) a.parentNode.removeChild(a);
    return fullscreen;
  };

  fullscreen.full = function () {
    if (fullscreened) { return; } else { fullscreened = true; }
    dimensions = map.dimensions;
    map.parent.className += ' map-fullscreen-map';
    body.className += ' map-fullscreen-view';
    map.dimensions = { x: map.parent.offsetWidth, y: map.parent.offsetHeight };
    map.draw();
    return fullscreen;
  };

  fullscreen.original = function () {
    if (!fullscreened) { return; } else { fullscreened = false; }
    map.parent.className = map.parent.className.replace(' map-fullscreen-map', '');
    body.className = body.className.replace(' map-fullscreen-view', '');
    map.dimensions = dimensions;
    map.draw();
    return fullscreen;
  };

  fullscreen.fullscreen = function (x) {
    if (!arguments.length) {
      return fullscreened;
    } else {
      if (x && !fullscreened) {
        fullscreen.full();
      } else if (!x && fullscreened) {
        fullscreen.original();
      }
      return fullscreen;
    }
  };

  fullscreen.element = function () {
    return a;
  };

  fullscreen.appendTo = function (elem) {
    wax.u.$(elem).appendChild(a);
    return fullscreen;
  };

  return fullscreen;
};
wax = wax || {};
wax.mm = wax.mm || {};

wax.mm.hash = function () {
  var map;
  var hash = wax.hash({
    getCenterZoom: function () {
      var center = map.getCenter(),
        zoom = map.getZoom(),
        precision = Math.max(
          0,
          Math.ceil(Math.log(zoom) / Math.LN2));

      return [zoom.toFixed(2),
      center.lat.toFixed(precision),
      center.lon.toFixed(precision)
      ].join('/');
    },
    setCenterZoom: function setCenterZoom(args) {
      map.setCenterZoom(
        new MM.Location(args[1], args[2]),
        args[0]);
    },
    bindChange: function (fn) {
      map.addCallback('drawn', fn);
    },
    unbindChange: function (fn) {
      map.removeCallback('drawn', fn);
    }
  });

  hash.map = function (x) {
    if (!arguments.length) return map;
    map = x;
    return hash;
  };

  return hash;
};
wax = wax || {};
wax.mm = wax.mm || {};

wax.mm.interaction = function () {
  var dirty = false,
    _grid,
    map,
    clearingEvents = ['zoomed', 'panned', 'centered',
      'extentset', 'resized', 'drawn'];

  function grid() {
    if (!dirty && _grid !== undefined && _grid.length) {
      return _grid;
    } else {
      var tiles;
      for (var i = 0; i < map.getLayers().length; i++) {
        var levels = map.getLayerAt(i).levels;
        var zoomLayer = levels && levels[Math.round(map.zoom())];
        if (zoomLayer !== undefined) {
          tiles = map.getLayerAt(i).tileElementsInLevel(zoomLayer);
          if (tiles.length) break;
        }
      }
      _grid = (function (t) {
        var o = [];
        for (var key in t) {
          if (t[key].parentNode === zoomLayer) {
            var offset = wax.u.offset(t[key]);
            o.push([
              offset.top,
              offset.left,
              t[key]
            ]);
          }
        }
        return o;
      })(tiles);
      return _grid;
    }
  }

  function setdirty() { dirty = true; }

  function attach(x) {
    if (!arguments.length) return map;
    map = x;
    for (var i = 0; i < clearingEvents.length; i++) {
      map.addCallback(clearingEvents[i], setdirty);
    }
  }

  function detach(x) {
    for (var i = 0; i < clearingEvents.length; i++) {
      map.removeCallback(clearingEvents[i], setdirty);
    }
  }

  return wax.interaction()
    .attach(attach)
    .detach(detach)
    .parent(function () {
      return map.parent;
    })
    .grid(grid);
};
wax = wax || {};
wax.mm = wax.mm || {};

wax.mm.legend = function () {
  var map,
    l = {};

  var container = document.createElement('div');
  container.className = 'wax-legends map-legends';

  var element = container.appendChild(document.createElement('div'));
  element.className = 'wax-legend map-legend';
  element.style.display = 'none';

  l.content = function (x) {
    if (!arguments.length) return element.innerHTML;

    element.innerHTML = wax.u.sanitize(x);
    element.style.display = 'block';
    if (element.innerHTML === '') {
      element.style.display = 'none';
    }
    return l;
  };

  l.element = function () {
    return container;
  };

  l.map = function (x) {
    if (!arguments.length) return map;
    map = x;
    return l;
  };

  l.add = function () {
    if (!map) return false;
    l.appendTo(map.parent);
    return l;
  };

  l.remove = function () {
    if (container.parentNode) {
      container.parentNode.removeChild(container);
    }
    return l;
  };

  l.appendTo = function (elem) {
    wax.u.$(elem).appendChild(container);
    return l;
  };

  return l;
};
wax = wax || {};
wax.mm = wax.mm || {};

// This takes an object of options:
//
// * `callback`: a function called with an array of `com.modestmaps.Location`
//   objects when the map is edited
//
// It also exposes a public API function: `addLocation`, which adds a point
// to the map as if added by the user.
wax.mm.pointselector = function () {
  var map,
    mouseDownPoint = null,
    mouseUpPoint = null,
    callback = null,
    tolerance = 5,
    overlayDiv,
    pointselector = {},
    callbackManager = new MM.CallbackManager(pointselector, ['change']),
    locations = [];

  // Create a `MM.Point` from a screen event, like a click.
  function makePoint(e) {
    var coords = wax.u.eventoffset(e);
    var point = new MM.Point(coords.x, coords.y);
    // correct for scrolled document

    // and for the document
    var body = {
      x: parseFloat(MM.getStyle(document.documentElement, 'margin-left')),
      y: parseFloat(MM.getStyle(document.documentElement, 'margin-top'))
    };

    if (!isNaN(body.x)) point.x -= body.x;
    if (!isNaN(body.y)) point.y -= body.y;

    // TODO: use wax.util.offset
    // correct for nested offsets in DOM
    for (var node = map.parent; node; node = node.offsetParent) {
      point.x -= node.offsetLeft;
      point.y -= node.offsetTop;
    }
    return point;
  }

  // Currently locations in this control contain circular references to elements.
  // These can't be JSON encoded, so here's a utility to clean the data that's
  // spit back.
  function cleanLocations(locations) {
    var o = [];
    for (var i = 0; i < locations.length; i++) {
      o.push(new MM.Location(locations[i].lat, locations[i].lon));
    }
    return o;
  }

  // Attach this control to a map by registering callbacks
  // and adding the overlay

  // Redraw the points when the map is moved, so that they stay in the
  // correct geographic locations.
  function drawPoints() {
    var offset = new MM.Point(0, 0);
    for (var i = 0; i < locations.length; i++) {
      var point = map.locationPoint(locations[i]);
      if (!locations[i].pointDiv) {
        locations[i].pointDiv = document.createElement('div');
        locations[i].pointDiv.className = 'map-point-div';
        locations[i].pointDiv.style.position = 'absolute';
        locations[i].pointDiv.style.display = 'block';
        // TODO: avoid circular reference
        locations[i].pointDiv.location = locations[i];
        // Create this closure once per point
        bean.add(locations[i].pointDiv, 'mouseup',
          (function selectPointWrap(e) {
            var l = locations[i];
            return function (e) {
              MM.removeEvent(map.parent, 'mouseup', mouseUp);
              pointselector.deleteLocation(l, e);
            };
          })());
        map.parent.appendChild(locations[i].pointDiv);
      }
      locations[i].pointDiv.style.left = point.x + 'px';
      locations[i].pointDiv.style.top = point.y + 'px';
    }
  }

  function mouseDown(e) {
    mouseDownPoint = makePoint(e);
    bean.add(map.parent, 'mouseup', mouseUp);
  }

  // Remove the awful circular reference from locations.
  // TODO: This function should be made unnecessary by not having it.
  function mouseUp(e) {
    if (!mouseDownPoint) return;
    mouseUpPoint = makePoint(e);
    if (MM.Point.distance(mouseDownPoint, mouseUpPoint) < tolerance) {
      pointselector.addLocation(map.pointLocation(mouseDownPoint));
      callbackManager.dispatchCallback('change', cleanLocations(locations));
    }
    mouseDownPoint = null;
  }

  // API for programmatically adding points to the map - this
  // calls the callback for ever point added, so it can be symmetrical.
  // Useful for initializing the map when it's a part of a form.
  pointselector.addLocation = function (location) {
    locations.push(location);
    drawPoints();
    callbackManager.dispatchCallback('change', cleanLocations(locations));
    return pointselector;
  };

  // TODO set locations
  pointselector.locations = function () {
    if (!arguments.length) return locations;
  };

  pointselector.addCallback = function (event, callback) {
    callbackManager.addCallback(event, callback);
    return pointselector;
  };

  pointselector.removeCallback = function (event, callback) {
    callbackManager.removeCallback(event, callback);
    return pointselector;
  };

  pointselector.map = function (x) {
    if (!arguments.length) return map;
    map = x;
    return pointselector;
  };

  pointselector.add = function () {
    bean.add(map.parent, 'mousedown', mouseDown);
    map.addCallback('drawn', drawPoints);
    return pointselector;
  };

  pointselector.remove = function () {
    bean.remove(map.parent, 'mousedown', mouseDown);
    map.removeCallback('drawn', drawPoints);
    for (var i = locations.length - 1; i > -1; i--) {
      pointselector.deleteLocation(locations[i]);
    }
    return pointselector;
  };

  pointselector.deleteLocation = function (location, e) {
    if (!e || confirm('Delete this point?')) {
      location.pointDiv.parentNode.removeChild(location.pointDiv);
      for (var i = 0; i < locations.length; i++) {
        if (locations[i] === location) {
          locations.splice(i, 1);
          break;
        }
      }
      callbackManager.dispatchCallback('change', cleanLocations(locations));
    }
  };

  return pointselector;
};
wax = wax || {};
wax.mm = wax.mm || {};

wax.mm.zoombox = function () {
  // TODO: respond to resize
  var zoombox = {},
    map,
    drawing = false,
    box = document.createElement('div'),
    mouseDownPoint = null;

  function getMousePoint(e) {
    // start with just the mouse (x, y)
    var point = new MM.Point(e.clientX, e.clientY);
    // correct for scrolled document
    point.x += document.body.scrollLeft + document.documentElement.scrollLeft;
    point.y += document.body.scrollTop + document.documentElement.scrollTop;

    // correct for nested offsets in DOM
    for (var node = map.parent; node; node = node.offsetParent) {
      point.x -= node.offsetLeft;
      point.y -= node.offsetTop;
    }
    return point;
  }

  function mouseUp(e) {
    if (!drawing) return;

    drawing = false;
    var point = getMousePoint(e);

    var l1 = map.pointLocation(point),
      l2 = map.pointLocation(mouseDownPoint);

    map.setExtent([l1, l2]);

    box.style.display = 'none';
    MM.removeEvent(map.parent, 'mousemove', mouseMove);
    MM.removeEvent(map.parent, 'mouseup', mouseUp);

    map.parent.style.cursor = 'auto';
  }

  function mouseDown(e) {
    if (!(e.shiftKey && !this.drawing)) return;

    drawing = true;
    mouseDownPoint = getMousePoint(e);

    box.style.left = mouseDownPoint.x + 'px';
    box.style.top = mouseDownPoint.y + 'px';

    MM.addEvent(map.parent, 'mousemove', mouseMove);
    MM.addEvent(map.parent, 'mouseup', mouseUp);

    map.parent.style.cursor = 'crosshair';
    return MM.cancelEvent(e);
  }

  function mouseMove(e) {
    if (!drawing) return;

    var point = getMousePoint(e);
    box.style.display = 'block';
    if (point.x < mouseDownPoint.x) {
      box.style.left = point.x + 'px';
    } else {
      box.style.left = mouseDownPoint.x + 'px';
    }
    box.style.width = Math.abs(point.x - mouseDownPoint.x) + 'px';
    if (point.y < mouseDownPoint.y) {
      box.style.top = point.y + 'px';
    } else {
      box.style.top = mouseDownPoint.y + 'px';
    }
    box.style.height = Math.abs(point.y - mouseDownPoint.y) + 'px';
    return MM.cancelEvent(e);
  }

  zoombox.map = function (x) {
    if (!arguments.length) return map;
    map = x;
    return zoombox;
  };

  zoombox.add = function () {
    if (!map) return false;
    // Use a flag to determine whether the zoombox is currently being
    // drawn. Necessary only for IE because `mousedown` is triggered
    // twice.
    box.id = map.parent.id + '-zoombox-box';
    box.className = 'zoombox-box';
    map.parent.appendChild(box);
    MM.addEvent(map.parent, 'mousedown', mouseDown);
    return this;
  };

  zoombox.remove = function () {
    if (!map) return false;
    if (box.parentNode) box.parentNode.removeChild(box);
    MM.removeEvent(map.parent, 'mousedown', mouseDown);
    return zoombox;
  };

  return zoombox;
};
wax = wax || {};
wax.mm = wax.mm || {};

wax.mm.zoomer = function () {
  var zoomer = {},
    smooth = true,
    map;

  var zoomin = document.createElement('a'),
    zoomout = document.createElement('a');

  function stopEvents(e) {
    e.stop();
  }

  function zIn(e) {
    e.stop();
    if (smooth && map.ease) {
      map.ease.zoom(map.zoom() + 1).run(50);
    } else {
      map.zoomIn();
    }
  }

  function zOut(e) {
    e.stop();
    if (smooth && map.ease) {
      map.ease.zoom(map.zoom() - 1).run(50);
    } else {
      map.zoomOut();
    }
  }

  zoomin.innerHTML = '+';
  zoomin.href = '#';
  zoomin.className = 'zoomer zoomin';
  zoomout.innerHTML = '-';
  zoomout.href = '#';
  zoomout.className = 'zoomer zoomout';

  function updateButtons(map, e) {
    if (map.coordinate.zoom === map.coordLimits[0].zoom) {
      zoomout.className = 'zoomer zoomout zoomdisabled';
    } else if (map.coordinate.zoom === map.coordLimits[1].zoom) {
      zoomin.className = 'zoomer zoomin zoomdisabled';
    } else {
      zoomin.className = 'zoomer zoomin';
      zoomout.className = 'zoomer zoomout';
    }
  }

  zoomer.map = function (x) {
    if (!arguments.length) return map;
    map = x;
    return zoomer;
  };

  zoomer.add = function () {
    if (!map) return false;
    map.addCallback('drawn', updateButtons);
    zoomer.appendTo(map.parent);
    bean.add(zoomin, 'mousedown dblclick', stopEvents);
    bean.add(zoomout, 'mousedown dblclick', stopEvents);
    bean.add(zoomout, 'touchstart click', zOut);
    bean.add(zoomin, 'touchstart click', zIn);
    return zoomer;
  };

  zoomer.remove = function () {
    if (!map) return false;
    map.removeCallback('drawn', updateButtons);
    if (zoomin.parentNode) zoomin.parentNode.removeChild(zoomin);
    if (zoomout.parentNode) zoomout.parentNode.removeChild(zoomout);
    bean.remove(zoomin, 'mousedown dblclick', stopEvents);
    bean.remove(zoomout, 'mousedown dblclick', stopEvents);
    bean.remove(zoomout, 'touchstart click', zOut);
    bean.remove(zoomin, 'touchstart click', zIn);
    return zoomer;
  };

  zoomer.appendTo = function (elem) {
    wax.u.$(elem).appendChild(zoomin);
    wax.u.$(elem).appendChild(zoomout);
    return zoomer;
  };

  zoomer.smooth = function (x) {
    if (!arguments.length) return smooth;
    smooth = x;
    return zoomer;
  };

  return zoomer;
};
var wax = wax || {};
wax.mm = wax.mm || {};

// A layer connector for Modest Maps conformant to TileJSON
// https://github.com/mapbox/tilejson
wax.mm._provider = function (options) {
  this.options = {
    tiles: options.tiles,
    scheme: options.scheme || 'xyz',
    minzoom: options.minzoom || 0,
    maxzoom: options.maxzoom || 22,
    bounds: options.bounds || [-180, -90, 180, 90]
  };
};

wax.mm._provider.prototype = {
  outerLimits: function () {
    return [
      this.locationCoordinate(
        new MM.Location(
          this.options.bounds[0],
          this.options.bounds[1])).zoomTo(this.options.minzoom),
      this.locationCoordinate(
        new MM.Location(
          this.options.bounds[2],
          this.options.bounds[3])).zoomTo(this.options.maxzoom)
    ];
  },
  getTile: function (c) {
    var coord;
    if (!(coord = this.sourceCoordinate(c))) return null;
    if (coord.zoom < this.options.minzoom || coord.zoom > this.options.maxzoom) return null;

    coord.row = (this.options.scheme === 'tms') ?
      Math.pow(2, coord.zoom) - coord.row - 1 :
      coord.row;

    var u = this.options.tiles[parseInt(Math.pow(2, coord.zoom) * coord.row + coord.column, 10) %
      this.options.tiles.length]
      .replace('{z}', coord.zoom.toFixed(0))
      .replace('{x}', coord.column.toFixed(0))
      .replace('{y}', coord.row.toFixed(0));

    if (wax._ && wax._.bw) {
      u = u.replace('.png', wax._.bw_png)
        .replace('.jpg', wax._.bw_jpg);
    }

    return u;
  }
};

if (MM) {
  MM.extend(wax.mm._provider, MM.MapProvider);
}

wax.mm.connector = function (options) {
  var x = new wax.mm._provider(options);
  return new MM.Layer(x);
};
; (function (context, MM) {
  var easey = function () {
    var easey = {},
      running = false,
      abort = false, // killswitch for transitions
      abortCallback; // callback called when aborted

    var easings = {
      easeIn: function (t) { return t * t; },
      easeOut: function (t) { return Math.sin(t * Math.PI / 2); },
      easeInOut: function (t) { return (1 - Math.cos(Math.PI * t)) / 2; },
      linear: function (t) { return t; }
    };
    var easing = easings.easeOut;

    // to is the singular coordinate that any transition is based off
    // three dimensions:
    //
    // * to
    // * time
    // * path
    var from, to, map;

    easey.stop = function (callback) {
      abort = true;
      from = undefined;
      abortCallback = callback;
    };

    easey.running = function () {
      return running;
    };

    easey.point = function (x) {
      to = map.pointCoordinate(x);
      return easey;
    };

    easey.zoom = function (x) {
      if (!to) to = map.coordinate.copy();
      to = map.enforceZoomLimits(to.zoomTo(x));
      return easey;
    };

    easey.location = function (x) {
      to = map.locationCoordinate(x);
      return easey;
    };

    easey.from = function (x) {
      if (!arguments.length) return from ? from.copy() : from;
      from = x.copy();
      return easey;
    };

    easey.to = function (x) {
      if (!arguments.length) return to.copy();
      to = map.enforceZoomLimits(x.copy());
      return easey;
    };

    easey.path = function (x) {
      path = paths[x];
      return easey;
    };

    easey.easing = function (x) {
      easing = easings[x];
      return easey;
    };

    easey.map = function (x) {
      if (!arguments.length) return map;
      map = x;
      return easey;
    };

    function interp(a, b, p) {
      if (p === 0) return a;
      if (p === 1) return b;
      return a + ((b - a) * p);
    }

    var paths = {},
      static_coord = new MM.Coordinate(0, 0, 0);

    // The screen path simply moves between
    // coordinates in a non-geographical way
    paths.screen = function (a, b, t, static_coord) {
      var zoom_lerp = interp(a.zoom, b.zoom, t);
      if (static_coord) {
        static_coord.row = interp(
          a.row,
          b.row * Math.pow(2, a.zoom - b.zoom),
          t) * Math.pow(2, zoom_lerp - a.zoom);
        static_coord.column = interp(
          a.column,
          b.column * Math.pow(2, a.zoom - b.zoom),
          t) * Math.pow(2, zoom_lerp - a.zoom);
        static_coord.zoom = zoom_lerp;
      } else {
        return new MM.Coordinate(
          interp(a.row,
            b.row * Math.pow(2, a.zoom - b.zoom),
            t) * Math.pow(2, zoom_lerp - a.zoom),
          interp(a.column,
            b.column * Math.pow(2, a.zoom - b.zoom),
            t) * Math.pow(2, zoom_lerp - a.zoom),
          zoom_lerp);
      }
    };

    // The screen path means that the b
    // coordinate should maintain its point on screen
    // throughout the transition, but the map
    // should move to its zoom level
    paths.about = function (a, b, t, static_coord) {
      var zoom_lerp = interp(a.zoom, b.zoom, t);

      // center x, center y
      var cx = map.dimensions.x / 2,
        cy = map.dimensions.y / 2,
        // tilesize
        tx = map.tileSize.x,
        ty = map.tileSize.y;

      var startx = cx + tx * ((b.column * Math.pow(2, a.zoom - b.zoom)) - a.column);
      var starty = cy + ty * ((b.row * Math.pow(2, a.zoom - b.zoom)) - a.row);

      var endx = cx + tx * ((b.column * Math.pow(2, zoom_lerp - b.zoom)) -
        (a.column * Math.pow(2, zoom_lerp - a.zoom)));
      var endy = cy + ty * ((b.row * Math.pow(2, zoom_lerp - b.zoom)) - (a.row *
        Math.pow(2, zoom_lerp - a.zoom)));

      if (static_coord) {
        static_coord.column = (a.column * Math.pow(2, zoom_lerp - a.zoom)) - ((startx - endx) / tx);
        static_coord.row = (a.row * Math.pow(2, zoom_lerp - a.zoom)) - ((starty - endy) / ty);
        static_coord.zoom = zoom_lerp;
      } else {
        return new MM.Coordinate(
          (a.column * Math.pow(2, zoom_lerp - a.zoom)) - ((startx - endx) / tx),
          (a.row * Math.pow(2, zoom_lerp - a.zoom)) - ((starty - endy) / ty),
          zoom_lerp);
      }
    };

    var path = paths.screen;

    easey.t = function (t) {
      path(from, to, easing(t), static_coord);
      map.coordinate = static_coord;
      map.draw();
      return easey;
    };

    easey.future = function (parts) {
      var futures = [];
      for (var t = 0; t < parts; t++) {
        futures.push(path(from, to, t / (parts - 1)));
      }
      return futures;
    };

    var start;
    easey.resetRun = function () {
      start = (+ new Date());
      return easey;
    };

    easey.run = function (time, callback) {

      if (running) return easey.stop(function () {
        easey.run(time, callback);
      });

      if (!from) from = map.coordinate.copy();
      if (!to) to = map.coordinate.copy();
      time = time || 1000;
      start = (+new Date());
      running = true;

      function tick() {
        var delta = (+new Date()) - start;
        if (abort) {
          abort = running = false;
          abortCallback();
          return (abortCallback = undefined);
        } else if (delta > time) {
          if (to.zoom != from.zoom) map.dispatchCallback('zoomed', to.zoom - from.zoom);
          running = false;
          path(from, to, 1, static_coord);
          map.coordinate = static_coord;
          to = from = undefined;
          map.draw();
          if (callback) return callback(map);
        } else {
          path(from, to, easing(delta / time), static_coord);
          map.coordinate = static_coord;
          map.draw();
          MM.getFrame(tick);
        }
      }

      MM.getFrame(tick);
    };

    // Optimally smooth (constant perceived velocity) and
    // efficient (minimal path distance) zooming and panning.
    //
    // Based on "Smooth and efficient zooming and panning"
    // by Jarke J. van Wijk and Wim A.A. Nuij
    //
    // Model described in section 3, equations 1 through 5
    // Derived equation (9) of optimal path implemented below
    easey.optimal = function (V, rho, callback) {

      if (running) return easey.stop(function () {
        easey.optimal(V, rho, callback);
      });

      // Section 6 describes user testing of these tunable values
      V = V || 0.9;
      rho = rho || 1.42;

      function sqr(n) { return n * n; }
      function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
      function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
      function tanh(n) { return sinh(n) / cosh(n); }

      if (from) map.coordinate = from; // For when `from` not current coordinate
      else from = map.coordinate.copy();

      // Width is measured in coordinate units at zoom 0
      var TL = map.pointCoordinate(new MM.Point(0, 0)).zoomTo(0),
        BR = map.pointCoordinate(map.dimensions).zoomTo(0),
        w0 = Math.max(BR.column - TL.column, BR.row - TL.row),
        w1 = w0 * Math.pow(2, from.zoom - to.zoom),
        start = from.zoomTo(0),
        end = to.zoomTo(0),
        c0 = { x: start.column, y: start.row },
        c1 = { x: end.column, y: end.row },
        u0 = 0,
        u1 = Math.sqrt(sqr(c1.x - c0.x) + sqr(c1.y - c0.y));

      function b(i) {
        var n = sqr(w1) - sqr(w0) + (i ? -1 : 1) * Math.pow(rho, 4) * sqr(u1 - u0),
          d = 2 * (i ? w1 : w0) * sqr(rho) * (u1 - u0);
        return n / d;
      }

      function r(i) {
        return Math.log(-b(i) + Math.sqrt(sqr(b(i)) + 1));
      }

      var r0 = r(0),
        r1 = r(1),
        S = (r1 - r0) / rho;

      // Width
      var w = function (s) {
        return w0 * cosh(r0) / cosh(rho * s + r0);
      };

      // Zoom
      var u = function (s) {
        return (w0 / sqr(rho)) * cosh(r0) * tanh(rho * s + r0) - (w0 / sqr(rho)) * sinh(r0) + u0;
      };

      // Special case, when no panning necessary
      if (Math.abs(u1) < 0.000001) {
        if (Math.abs(w0 - w1) < 0.000001) return;

        // Based on section 4
        var k = w1 < w0 ? -1 : 1;
        S = Math.abs(Math.log(w1 / w0)) / rho;
        u = function (s) {
          return u0;
        };
        w = function (s) {
          return w0 * Math.exp(k * rho * s);
        };
      }

      var oldpath = path;
      path = function (a, b, t, static_coord) {
        if (t == 1) {
          if (static_coord) {
            static_coord.row = to.row;
            static_coord.column = to.column;
            static_coord.zoom = to.zoom;
          }
          return to;
        }
        var s = t * S,
          us = u(s),
          z = a.zoom + (Math.log(w0 / w(s)) / Math.LN2),
          x = interp(c0.x, c1.x, us / u1 || 1),
          y = interp(c0.y, c1.y, us / u1 || 1);

        var power = Math.pow(2, z);
        if (static_coord) {
          static_coord.row = y * power;
          static_coord.column = x * power;
          static_coord.zoom = z;
        } else {
          return new MM.Coordinate(y * power, x * power, z);
        }
      };

      easey.run(S / V * 1000, function (m) {
        path = oldpath;
        if (callback) callback(m);
      });
    };

    return easey;
  };

  this.easey = easey;
  if (typeof this.mapbox == 'undefined') this.mapbox = {};
  this.mapbox.ease = easey;
})(this, MM);
; (function (context, MM) {

  var easey_handlers = {};

  easey_handlers.TouchHandler = function () {
    var handler = {},
      map,
      panner,
      maxTapTime = 250,
      maxTapDistance = 30,
      maxDoubleTapDelay = 350,
      locations = {},
      taps = [],
      wasPinching = false,
      lastPinchCenter = null,
      p0 = new MM.Point(0, 0),
      p1 = new MM.Point(0, 0);

    function focusMap(e) {
      map.parent.focus();
    }

    function clearLocations() {
      for (var loc in locations) {
        if (locations.hasOwnProperty(loc)) {
          delete locations[loc];
        }
      }
    }

    function updateTouches(e) {
      for (var i = 0; i < e.touches.length; i += 1) {
        var t = e.touches[i];
        if (t.identifier in locations) {
          var l = locations[t.identifier];
          l.x = t.clientX;
          l.y = t.clientY;
          l.scale = e.scale;
        } else {
          locations[t.identifier] = {
            scale: e.scale,
            startPos: { x: t.clientX, y: t.screenY },
            startZoom: map.zoom(),
            x: t.clientX,
            y: t.clientY,
            time: new Date().getTime()
          };
        }
      }
    }

    function touchStartMachine(e) {
      if (!panner) panner = panning(map, 0.10);
      MM.addEvent(e.touches[0].target, 'touchmove',
        touchMoveMachine);
      MM.addEvent(e.touches[0].target, 'touchend',
        touchEndMachine);
      if (e.touches[1]) {
        MM.addEvent(e.touches[1].target, 'touchmove',
          touchMoveMachine);
        MM.addEvent(e.touches[1].target, 'touchend',
          touchEndMachine);
      }
      updateTouches(e);
      panner.down(e.touches[0]);
      return MM.cancelEvent(e);
    }

    function touchMoveMachine(e) {
      switch (e.touches.length) {
        case 1:
          panner.move(e.touches[0]);
          break;
        case 2:
          onPinching(e);
          break;
      }
      updateTouches(e);
      return MM.cancelEvent(e);
    }

    // Handle a tap event - mainly watch for a doubleTap
    function onTap(tap) {
      if (taps.length &&
        (tap.time - taps[0].time) < maxDoubleTapDelay) {
        onDoubleTap(tap);
        taps = [];
        return;
      }
      taps = [tap];
    }

    // Handle a double tap by zooming in a single zoom level to a
    // round zoom.
    function onDoubleTap(tap) {
      // zoom in to a round number
      easey().map(map)
        .to(map.pointCoordinate(tap).zoomTo(map.getZoom() + 1))
        .path('about').run(200, function () {
          map.dispatchCallback('zoomed');
          clearLocations();
        });
    }

    function onPinching(e) {
      // use the first two touches and their previous positions
      var t0 = e.touches[0],
        t1 = e.touches[1];
      p0.x = t0.clientX;
      p0.y = t0.clientY;
      p1.x = t1.clientX;
      p1.y = t1.clientY;
      l0 = locations[t0.identifier],
        l1 = locations[t1.identifier];

      // mark these touches so they aren't used as taps/holds
      l0.wasPinch = true;
      l1.wasPinch = true;

      // scale about the center of these touches
      var center = MM.Point.interpolate(p0, p1, 0.5);

      map.zoomByAbout(
        Math.log(e.scale) / Math.LN2 - Math.log(l0.scale) / Math.LN2,
        center);

      // pan from the previous center of these touches
      prevX = l0.x + (l1.x - l0.x) * 0.5;
      prevY = l0.y + (l1.y - l0.y) * 0.5;
      map.panBy(center.x - prevX,
        center.y - prevY);
      wasPinching = true;
      lastPinchCenter = center;
    }

    // When a pinch event ends, round the zoom of the map.
    function onPinched(touch) {
      var z = map.getZoom(), // current zoom
        tz = locations[touch.identifier].startZoom > z ? Math.floor(z) : Math.ceil(z);
      easey().map(map).point(lastPinchCenter).zoom(tz)
        .path('about').run(300);
      clearLocations();
      wasPinching = false;
    }

    function touchEndMachine(e) {
      MM.removeEvent(e.target, 'touchmove',
        touchMoveMachine);
      MM.removeEvent(e.target, 'touchend',
        touchEndMachine);
      var now = new Date().getTime();

      // round zoom if we're done pinching
      if (e.touches.length === 0 && wasPinching) {
        onPinched(e.changedTouches[0]);
      }

      panner.up();

      // Look at each changed touch in turn.
      for (var i = 0; i < e.changedTouches.length; i += 1) {
        var t = e.changedTouches[i],
          loc = locations[t.identifier];
        // if we didn't see this one (bug?)
        // or if it was consumed by pinching already
        // just skip to the next one
        if (!loc || loc.wasPinch) {
          continue;
        }

        // we now know we have an event object and a
        // matching touch that's just ended. Let's see
        // what kind of event it is based on how long it
        // lasted and how far it moved.
        var pos = { x: t.clientX, y: t.clientY },
          time = now - loc.time,
          travel = MM.Point.distance(pos, loc.startPos);
        if (travel > maxTapDistance) {
          // we will to assume that the drag has been handled separately
        } else if (time > maxTapTime) {
          // close in space, but not in time: a hold
          pos.end = now;
          pos.duration = time;
        } else {
          // close in both time and space: a tap
          pos.time = now;
          onTap(pos);
        }
      }

      // Weird, sometimes an end event doesn't get thrown
      // for a touch that nevertheless has disappeared.
      // Still, this will eventually catch those ids:

      var validTouchIds = {};
      for (var j = 0; j < e.touches.length; j++) {
        validTouchIds[e.touches[j].identifier] = true;
      }
      for (var id in locations) {
        if (!(id in validTouchIds)) {
          delete validTouchIds[id];
        }
      }

      return MM.cancelEvent(e);
    }

    handler.init = function (x) {
      map = x;

      MM.addEvent(map.parent, 'touchstart',
        touchStartMachine);
    };

    handler.remove = function () {
      if (!panner) return;
      MM.removeEvent(map.parent, 'touchstart',
        touchStartMachine);
      panner.remove();
    };

    return handler;
  };

  easey_handlers.DoubleClickHandler = function () {
    var handler = {},
      map;

    function doubleClick(e) {
      // Ensure that this handler is attached once.
      // Get the point on the map that was double-clicked
      var point = MM.getMousePoint(e, map);
      z = map.getZoom() + (e.shiftKey ? -1 : 1);
      // use shift-double-click to zoom out
      easey().map(map)
        .to(map.pointCoordinate(MM.getMousePoint(e, map)).zoomTo(z))
        .path('about').run(100, function () {
          map.dispatchCallback('zoomed');
        });
      return MM.cancelEvent(e);
    }

    handler.init = function (x) {
      map = x;
      MM.addEvent(map.parent, 'dblclick', doubleClick);
      return handler;
    };

    handler.remove = function () {
      MM.removeEvent(map.parent, 'dblclick', doubleClick);
    };

    return handler;
  };

  easey_handlers.MouseWheelHandler = function () {
    var handler = {},
      map,
      _zoomDiv,
      ea = easey(),
      prevTime,
      precise = false;

    function mouseWheel(e) {
      var delta = 0;
      prevTime = prevTime || new Date().getTime();

      try {
        _zoomDiv.scrollTop = 1000;
        _zoomDiv.dispatchEvent(e);
        delta = 1000 - _zoomDiv.scrollTop;
      } catch (error) {
        delta = e.wheelDelta || (-e.detail * 5);
      }

      // limit mousewheeling to once every 200ms
      var timeSince = new Date().getTime() - prevTime;

      function dispatchZoomed() {
        map.dispatchCallback('zoomed');
      }

      if (!ea.running()) {
        var point = MM.getMousePoint(e, map),
          z = map.getZoom();
        ea.map(map)
          .easing('easeOut')
          .to(map.pointCoordinate(MM.getMousePoint(e, map)).zoomTo(z + (delta > 0 ? 1 : -1)))
          .path('about').run(100, dispatchZoomed);
        prevTime = new Date().getTime();
      } else if (timeSince > 150) {
        ea.zoom(ea.to().zoom + (delta > 0 ? 1 : -1)).from(map.coordinate).resetRun();
        prevTime = new Date().getTime();
      }

      // Cancel the event so that the page doesn't scroll
      return MM.cancelEvent(e);
    }

    handler.init = function (x) {
      map = x;
      _zoomDiv = document.body.appendChild(document.createElement('div'));
      _zoomDiv.style.cssText = 'visibility:hidden;top:0;height:0;width:0;overflow-y:scroll';
      var innerDiv = _zoomDiv.appendChild(document.createElement('div'));
      innerDiv.style.height = '2000px';
      MM.addEvent(map.parent, 'mousewheel', mouseWheel);
      return handler;
    };

    handler.precise = function (x) {
      if (!arguments.length) return precise;
      precise = x;
      return handler;
    };

    handler.remove = function () {
      MM.removeEvent(map.parent, 'mousewheel', mouseWheel);
      _zoomDiv.parentNode.removeChild(_zoomDiv);
    };

    return handler;
  };

  easey_handlers.DragHandler = function () {
    var handler = {},
      map,
      panner;

    function focusMap(e) {
      map.parent.focus();
    }

    function mouseDown(e) {
      if (e.shiftKey || e.button == 2) return;
      MM.addEvent(document, 'mousemove', mouseMove);
      MM.addEvent(document, 'mouseup', mouseUp);
      panner.down(e);
      map.parent.style.cursor = 'move';
      return MM.cancelEvent(e);
    }

    function mouseMove(e) {
      panner.move(e);
      return MM.cancelEvent(e);
    }

    function mouseUp(e) {
      MM.removeEvent(document, 'mousemove', mouseMove);
      MM.removeEvent(document, 'mouseup', mouseUp);
      panner.up();
      map.parent.style.cursor = '';
      return MM.cancelEvent(e);
    }

    handler.init = function (x) {
      map = x;
      MM.addEvent(map.parent, 'click', focusMap);
      MM.addEvent(map.parent, 'mousedown', mouseDown);
      panner = panning(map);
    };

    handler.remove = function () {
      MM.removeEvent(map.parent, 'click', focusMap);
      MM.removeEvent(map.parent, 'mousedown', mouseDown);
      panner.up();
      panner.remove();
    };

    return handler;
  };


  function panning(map, drag) {

    var p = {};
    drag = drag || 0.15;

    var speed = { x: 0, y: 0 },
      dir = { x: 0, y: 0 },
      removed = false,
      nowPoint = null,
      oldPoint = null,
      moveTime = null,
      prevMoveTime = null,
      animatedLastPoint = true,
      t,
      prevT = new Date().getTime();

    p.down = function (e) {
      nowPoint = oldPoint = MM.getMousePoint(e, map);
      moveTime = prevMoveTime = +new Date();
    };

    p.move = function (e) {
      if (nowPoint) {
        if (animatedLastPoint) {
          oldPoint = nowPoint;
          prevMoveTime = moveTime;
          animatedLastPoint = false;
        }
        nowPoint = MM.getMousePoint(e, map);
        moveTime = +new Date();
      }
    };

    p.up = function () {
      if (+new Date() - prevMoveTime < 50) {
        dt = Math.max(1, moveTime - prevMoveTime);
        dir.x = nowPoint.x - oldPoint.x;
        dir.y = nowPoint.y - oldPoint.y;
        speed.x = dir.x / dt;
        speed.y = dir.y / dt;
      } else {
        speed.x = 0;
        speed.y = 0;
      }
      nowPoint = oldPoint = null;
      moveTime = null;
    };

    p.remove = function () {
      removed = true;
    };

    function animate(t) {
      var dt = Math.max(1, t - prevT);
      if (nowPoint && oldPoint) {
        if (!animatedLastPoint) {
          dir.x = nowPoint.x - oldPoint.x;
          dir.y = nowPoint.y - oldPoint.y;
          map.panBy(dir.x, dir.y);
          animatedLastPoint = true;
        }
      } else {
        // Rough time based animation accuracy
        // using a linear approximation approach
        speed.x *= Math.pow(1 - drag, dt * 60 / 1000);
        speed.y *= Math.pow(1 - drag, dt * 60 / 1000);
        if (Math.abs(speed.x) < 0.001) {
          speed.x = 0;
        }
        if (Math.abs(speed.y) < 0.001) {
          speed.y = 0;
        }
        if (speed.x || speed.y) {
          map.panBy(speed.x * dt, speed.y * dt);
        }
      }
      prevT = t;
      if (!removed) MM.getFrame(animate);
    }

    MM.getFrame(animate);
    return p;
  }


  this.easey_handlers = easey_handlers;

})(this, MM);
if (typeof mapbox == 'undefined') mapbox = {};
if (typeof mapbox.markers == 'undefined') mapbox.markers = {};
mapbox.markers.layer = function () {

  var m = {},
    // external list of geojson features
    features = [],
    // internal list of markers
    markers = [],
    // internal list of callbacks
    callbackManager = new MM.CallbackManager(m, ['drawn', 'markeradded']),
    // the absolute position of the parent element
    position = null,
    // a factory function for creating DOM elements out of
    // GeoJSON objects
    factory = mapbox.markers.simplestyle_factory,
    // a sorter function for sorting GeoJSON objects
    // in the DOM
    sorter = function (a, b) {
      return b.geometry.coordinates[1] -
        a.geometry.coordinates[1];
    },
    // a list of urls from which features can be loaded.
    // these can be templated with {z}, {x}, and {y}
    urls,
    // map bounds
    left = null,
    right = null,
    // a function that filters points
    filter = function () {
      return true;
    },
    _seq = 0,
    keyfn = function () {
      return ++_seq;
    },
    index = {};

  // The parent DOM element
  m.parent = document.createElement('div');
  m.parent.style.cssText = 'position: absolute; top: 0px;' +
    'left:0px; width:100%; height:100%; margin:0; padding:0; z-index:0;pointer-events:none;';
  m.name = 'markers';

  // reposition a single marker element
  function reposition(marker) {
    // remember the tile coordinate so we don't have to reproject every time
    if (!marker.coord) marker.coord = m.map.locationCoordinate(marker.location);
    var pos = m.map.coordinatePoint(marker.coord);
    var pos_loc, new_pos;

    // If this point has wound around the world, adjust its position
    // to the new, onscreen location
    if (pos.x < 0) {
      pos_loc = new MM.Location(marker.location.lat, marker.location.lon);
      pos_loc.lon += Math.ceil((left.lon - marker.location.lon) / 360) * 360;
      new_pos = m.map.locationPoint(pos_loc);
      if (new_pos.x < m.map.dimensions.x) {
        pos = new_pos;
        marker.coord = m.map.locationCoordinate(pos_loc);
      }
    } else if (pos.x > m.map.dimensions.x) {
      pos_loc = new MM.Location(marker.location.lat, marker.location.lon);
      pos_loc.lon -= Math.ceil((marker.location.lon - right.lon) / 360) * 360;
      new_pos = m.map.locationPoint(pos_loc);
      if (new_pos.x > 0) {
        pos = new_pos;
        marker.coord = m.map.locationCoordinate(pos_loc);
      }
    }

    pos.scale = 1;
    pos.width = pos.height = 0;
    MM.moveElement(marker.element, pos);
  }

  // Adding and removing callbacks is mainly a way to enable mmg_interaction to operate.
  // I think there are better ways to do this, by, for instance, having mmg be able to
  // register 'binders' to markers, but this is backwards-compatible and equivalent
  // externally.
  m.addCallback = function (event, callback) {
    callbackManager.addCallback(event, callback);
    return m;
  };

  m.removeCallback = function (event, callback) {
    callbackManager.removeCallback(event, callback);
    return m;
  };

  // Draw this layer - reposition all markers on the div. This requires
  // the markers library to be attached to a map, and will noop otherwise.
  m.draw = function () {
    if (!m.map) return;
    left = m.map.pointLocation(new MM.Point(0, 0));
    right = m.map.pointLocation(new MM.Point(m.map.dimensions.x, 0));
    for (var i = 0; i < markers.length; i++) {
      reposition(markers[i]);
    }
    callbackManager.dispatchCallback('drawn', m);
  };

  // Add a fully-formed marker to the layer. This fires a `markeradded` event.
  // This does not require the map element t be attached.
  m.add = function (marker) {
    if (!marker || !marker.element) return null;
    m.parent.appendChild(marker.element);
    markers.push(marker);
    callbackManager.dispatchCallback('markeradded', marker);
    return marker;
  };

  // Remove a fully-formed marker - which must be the same exact marker
  // object as in the markers array - from the layer.
  m.remove = function (marker) {
    if (!marker) return null;
    m.parent.removeChild(marker.element);
    for (var i = 0; i < markers.length; i++) {
      if (markers[i] === marker) {
        markers.splice(i, 1);
        return marker;
      }
    }
    return marker;
  };

  m.markers = function (x) {
    if (!arguments.length) return markers;
  };

  // Add a GeoJSON feature to the markers layer.
  m.add_feature = function (x) {
    return m.features(m.features().concat([x]));
  };

  m.sort = function (x) {
    if (!arguments.length) return sorter;
    sorter = x;
    return m;
  };

  // Public data interface
  m.features = function (x) {
    // Return features
    if (!arguments.length) return features;

    // Set features
    if (!x) x = [];
    features = x.slice();

    features.sort(sorter);

    for (var j = 0; j < markers.length; j++) {
      markers[j].touch = false;
    }

    for (var i = 0; i < features.length; i++) {
      if (filter(features[i])) {
        var id = keyfn(features[i]);
        if (index[id]) {
          // marker is already on the map, needs to be moved or rebuilt
          index[id].location = new MM.Location(
            features[i].geometry.coordinates[1],
            features[i].geometry.coordinates[0]);
          index[id].coord = null;
          reposition(index[id]);
        } else {
          // marker needs to be added to the map
          index[id] = m.add({
            element: factory(features[i]),
            location: new MM.Location(
              features[i].geometry.coordinates[1],
              features[i].geometry.coordinates[0]),
            data: features[i]
          });
        }
        if (index[id]) index[id].touch = true;
      }
    }

    for (var k = markers.length - 1; k >= 0; k--) {
      if (markers[k].touch === false) {
        m.remove(markers[k]);
      }
    }

    if (m.map && m.map.coordinate) m.map.draw();

    return m;
  };

  // Request features from a URL - either a local URL or a JSONP call.
  // Expects GeoJSON-formatted features.
  m.url = function (x, callback) {
    if (!arguments.length) return urls;
    if (typeof reqwest === 'undefined') throw 'reqwest is required for url loading';
    if (typeof x === 'string') x = [x];

    urls = x;
    function add_features(err, x) {
      if (err && callback) return callback(err);
      var features = typeof x !== 'undefined' && x.features ? x.features : null;
      if (features) m.features(features);
      if (callback) callback(err, features, m);
    }

    reqwest((urls[0].match(/geojsonp$/)) ? {
      url: urls[0] + (~urls[0].indexOf('?') ? '&' : '?') + 'callback=?',
      type: 'jsonp',
      success: function (resp) { add_features(null, resp); },
      error: add_features
    } : {
      url: urls[0],
      type: 'json',
      success: function (resp) { add_features(null, resp); },
      error: add_features
    });
    return m;
  };

  m.id = function (x, callback) {
    return m.url('http://a.tiles.mapbox.com/v3/' + x + '/markers.geojsonp', callback);
  };

  m.csv = function (x) {
    return m.features(mapbox.markers.csv_to_geojson(x));
  };

  m.extent = function () {
    var ext = [{
      lat: Infinity,
      lon: Infinity
    }, {
      lat: -Infinity,
      lon: -Infinity
    }];
    var ft = m.features();
    for (var i = 0; i < ft.length; i++) {
      var coords = ft[i].geometry.coordinates;
      if (coords[0] < ext[0].lon) ext[0].lon = coords[0];
      if (coords[1] < ext[0].lat) ext[0].lat = coords[1];
      if (coords[0] > ext[1].lon) ext[1].lon = coords[0];
      if (coords[1] > ext[1].lat) ext[1].lat = coords[1];
    }
    return ext;
  };

  m.key = function (x) {
    if (!arguments.length) return keyfn;
    if (x === null) {
      keyfn = function () { return ++_seq; };
    } else {
      keyfn = x;
    }
    return m;
  };

  // Factory interface
  m.factory = function (x) {
    if (!arguments.length) return factory;
    factory = x;
    // re-render all features
    m.features(m.features());
    return m;
  };

  m.filter = function (x) {
    if (!arguments.length) return filter;
    filter = x;
    // Setting a filter re-sets the features into a new array.
    // This does _not_ change the actual output of .features()
    m.features(m.features());
    return m;
  };

  m.destroy = function () {
    if (m.parent.parentNode) {
      m.parent.parentNode.removeChild(m.parent);
    }
  };

  // Get or set this layer's name
  m.named = function (x) {
    if (!arguments.length) return m.name;
    m.name = x;
    return m;
  };

  m.enabled = true;

  m.enable = function () {
    this.enabled = true;
    this.parent.style.display = '';
    return m;
  };

  m.disable = function () {
    this.enabled = false;
    this.parent.style.display = 'none';
    return m;
  };

  return m;
};

mmg = mapbox.markers.layer; // Backwards compatibility
mapbox.markers.interaction = function (mmg) {
  // Make markersLayer.interaction a singleton and this an accessor.
  if (mmg && mmg.interaction) return mmg.interaction;

  var mi = {},
    tooltips = [],
    exclusive = true,
    hideOnMove = true,
    showOnHover = true,
    close_timer = null,
    on = true,
    formatter;

  mi.formatter = function (x) {
    if (!arguments.length) return formatter;
    formatter = x;
    return mi;
  };
  mi.formatter(function (feature) {
    var o = '',
      props = feature.properties;

    // Tolerate markers without properties at all.
    if (!props) return null;

    if (props.title) {
      o += '<div class="marker-title">' + props.title + '</div>';
    }
    if (props.description) {
      o += '<div class="marker-description">' + props.description + '</div>';
    }

    if (typeof html_sanitize !== undefined) {
      o = html_sanitize(o,
        function (url) {
          if (/^(https?:\/\/|data:image)/.test(url)) return url;
        },
        function (x) { return x; });
    }

    return o;
  });

  mi.hideOnMove = function (x) {
    if (!arguments.length) return hideOnMove;
    hideOnMove = x;
    return mi;
  };

  mi.exclusive = function (x) {
    if (!arguments.length) return exclusive;
    exclusive = x;
    return mi;
  };

  mi.showOnHover = function (x) {
    if (!arguments.length) return showOnHover;
    showOnHover = x;
    return mi;
  };

  mi.hideTooltips = function () {
    while (tooltips.length) mmg.remove(tooltips.pop());
    for (var i = 0; i < markers.length; i++) {
      delete markers[i].clicked;
    }
    return mi;
  };

  mi.add = function () {
    on = true;
    return mi;
  };

  mi.remove = function () {
    on = false;
    return mi;
  };

  mi.bindMarker = function (marker) {
    var delayed_close = function () {
      if (showOnHover === false) return;
      if (!marker.clicked) close_timer = window.setTimeout(function () {
        mi.hideTooltips();
      }, 200);
    };

    var show = function (e) {
      if (e && e.type == 'mouseover' && showOnHover === false) return;
      if (!on) return;
      var content = formatter(marker.data);
      // Don't show a popup if the formatter returns an
      // empty string. This does not do any magic around DOM elements.
      if (!content) return;

      if (exclusive && tooltips.length > 0) {
        mi.hideTooltips();
        // We've hidden all of the tooltips, so let's not close
        // the one that we're creating as soon as it is created.
        if (close_timer) window.clearTimeout(close_timer);
      }

      var tooltip = document.createElement('div');
      tooltip.className = 'marker-tooltip';
      tooltip.style.width = '100%';

      var wrapper = tooltip.appendChild(document.createElement('div'));
      wrapper.style.cssText = 'position: absolute; pointer-events: none;';

      var popup = wrapper.appendChild(document.createElement('div'));
      popup.className = 'marker-popup';
      popup.style.cssText = 'pointer-events: auto;';

      if (typeof content == 'string') {
        popup.innerHTML = content;
      } else {
        popup.appendChild(content);
      }

      // Align the bottom of the tooltip with the top of its marker
      wrapper.style.bottom = marker.element.offsetHeight / 2 + 20 + 'px';

      // Block mouse and touch events
      function stopPropagation(e) {
        e.cancelBubble = true;
        if (e.stopPropagation) { e.stopPropagation(); }
        return false;
      }
      MM.addEvent(popup, 'mousedown', stopPropagation);
      MM.addEvent(popup, 'touchstart', stopPropagation);

      if (showOnHover) {
        tooltip.onmouseover = function () {
          if (close_timer) window.clearTimeout(close_timer);
        };
        tooltip.onmouseout = delayed_close;
      }

      var t = {
        element: tooltip,
        data: {},
        interactive: false,
        location: marker.location.copy()
      };
      tooltips.push(t);
      marker.tooltip = t;
      mmg.add(t);
      mmg.draw();
    };

    marker.showTooltip = show;

    marker.element.onclick = marker.element.ontouchstart = function () {
      show();
      marker.clicked = true;
    };

    marker.element.onmouseover = show;
    marker.element.onmouseout = delayed_close;
  };

  function bindPanned() {
    mmg.map.addCallback('panned', function () {
      if (hideOnMove) {
        while (tooltips.length) {
          mmg.remove(tooltips.pop());
        }
      }
    });
  }

  if (mmg) {
    // Remove tooltips on panning
    mmg.addCallback('drawn', bindPanned);

    // Bind present markers
    var markers = mmg.markers();
    for (var i = 0; i < markers.length; i++) {
      mi.bindMarker(markers[i]);
    }

    // Bind future markers
    mmg.addCallback('markeradded', function (_, marker) {
      // Markers can choose to be not-interactive. The main example
      // of this currently is marker bubbles, which should not recursively
      // give marker bubbles.
      if (marker.interactive !== false) mi.bindMarker(marker);
    });

    // Save reference to self on the markers instance.
    mmg.interaction = mi;
  }

  return mi;
};

mmg_interaction = mapbox.markers.interaction;
mapbox.markers.csv_to_geojson = function (x) {
  // Extracted from d3
  function csv_parse(text) {
    var header;
    return csv_parseRows(text, function (row, i) {
      if (i) {
        var o = {}, j = -1, m = header.length;
        while (++j < m) o[header[j]] = row[j];
        return o;
      } else {
        header = row;
        return null;
      }
    });
  }

  function csv_parseRows(text, f) {
    var EOL = {}, // sentinel value for end-of-line
      EOF = {}, // sentinel value for end-of-file
      rows = [], // output rows
      re = /\r\n|[,\r\n]/g, // field separator regex
      n = 0, // the current line number
      t, // the current token
      eol; // is the current token followed by EOL?

    re.lastIndex = 0; // work-around bug in FF 3.6

    /** @private Returns the next token. */
    function token() {
      if (re.lastIndex >= text.length) return EOF; // special case: end of file
      if (eol) { eol = false; return EOL; } // special case: end of line

      // special case: quotes
      var j = re.lastIndex;
      if (text.charCodeAt(j) === 34) {
        var i = j;
        while (i++ < text.length) {
          if (text.charCodeAt(i) === 34) {
            if (text.charCodeAt(i + 1) !== 34) break;
            i++;
          }
        }
        re.lastIndex = i + 2;
        var c = text.charCodeAt(i + 1);
        if (c === 13) {
          eol = true;
          if (text.charCodeAt(i + 2) === 10) re.lastIndex++;
        } else if (c === 10) {
          eol = true;
        }
        return text.substring(j + 1, i).replace(/""/g, "\"");
      }

      // common case
      var m = re.exec(text);
      if (m) {
        eol = m[0].charCodeAt(0) !== 44;
        return text.substring(j, m.index);
      }
      re.lastIndex = text.length;
      return text.substring(j);
    }

    while ((t = token()) !== EOF) {
      var a = [];
      while ((t !== EOL) && (t !== EOF)) {
        a.push(t);
        t = token();
      }
      if (f && !(a = f(a, n++))) continue;
      rows.push(a);
    }

    return rows;
  }

  var features = [];
  var parsed = csv_parse(x);
  if (!parsed.length) return features;

  var latfield = '',
    lonfield = '';

  for (var f in parsed[0]) {
    if (f.match(/^Lat/i)) latfield = f;
    if (f.match(/^Lon/i)) lonfield = f;
  }

  if (!latfield || !lonfield) {
    throw 'CSV: Could not find latitude or longitude field';
  }

  for (var i = 0; i < parsed.length; i++) {
    if (parsed[i][lonfield] !== undefined &&
      parsed[i][lonfield] !== undefined) {
      features.push({
        type: 'Feature',
        properties: parsed[i],
        geometry: {
          type: 'Point',
          coordinates: [
            parseFloat(parsed[i][lonfield]),
            parseFloat(parsed[i][latfield])]
        }
      });
    }
  }
  return features;
};
mapbox.markers.simplestyle_factory = function (feature) {

  var sizes = {
    small: [20, 50],
    medium: [30, 70],
    large: [35, 90]
  };

  var fp = feature.properties || {};

  var size = fp['marker-size'] || 'medium';
  var symbol = (fp['marker-symbol']) ? '-' + fp['marker-symbol'] : '';
  var color = fp['marker-color'] || '7e7e7e';
  color = color.replace('#', '');

  var d = document.createElement('img');
  d.width = sizes[size][0];
  d.height = sizes[size][1];
  d.className = 'simplestyle-marker';
  d.alt = fp.title || '';
  d.src = (mapbox.markers.marker_baseurl || 'http://a.tiles.mapbox.com/v3/marker/') +
    'pin-' +
    // Internet Explorer does not support the `size[0]` syntax.
    size.charAt(0) + symbol + '+' + color +
    ((window.devicePixelRatio === 2) ? '@2x' : '') +
    '.png';
  // Support retina markers for 2x devices

  var ds = d.style;
  ds.position = 'absolute';
  ds.clip = 'rect(auto auto ' + (sizes[size][1] * 0.75) + 'px auto)';
  ds.marginTop = -((sizes[size][1]) / 2) + 'px';
  ds.marginLeft = -(sizes[size][0] / 2) + 'px';
  ds.cursor = 'pointer';
  ds.pointerEvents = 'all';

  return d;
};
if (typeof mapbox === 'undefined') mapbox = {};

mapbox.MAPBOX_URL = 'http://a.tiles.mapbox.com/v3/';

// a `mapbox.map` is a modestmaps object with the
// easey handlers as defaults
mapbox.map = function (el, layer, dimensions, eventhandlers) {
  var m = new MM.Map(el, layer, dimensions,
    eventhandlers || [
      easey_handlers.TouchHandler(),
      easey_handlers.DragHandler(),
      easey_handlers.DoubleClickHandler(),
      easey_handlers.MouseWheelHandler()
    ]);

  // Set maxzoom to 17, highest zoom level supported by MapBox streets
  m.setZoomRange(0, 17);

  // Attach easey, ui, and interaction
  m.ease = easey().map(m);
  m.ui = mapbox.ui(m);
  m.interaction = mapbox.interaction().map(m);

  // Autoconfigure map with sensible defaults
  m.auto = function () {
    this.ui.zoomer.add();
    this.ui.zoombox.add();
    this.ui.legend.add();
    this.ui.attribution.add();
    this.ui.refresh();
    this.interaction.auto();

    for (var i = 0; i < this.layers.length; i++) {
      if (this.layers[i].tilejson) {
        var tj = this.layers[i].tilejson(),
          center = tj.center || new MM.Location(0, 0),
          zoom = tj.zoom || 0;
        this.setCenterZoom(center, zoom);
        break;
      }
    }
    return this;
  };

  m.refresh = function () {
    this.ui.refresh();
    this.interaction.refresh();
    return this;
  };

  var smooth_handlers = [
    easey_handlers.TouchHandler,
    easey_handlers.DragHandler,
    easey_handlers.DoubleClickHandler,
    easey_handlers.MouseWheelHandler
  ];

  var default_handlers = [
    MM.TouchHandler,
    MM.DragHandler,
    MM.DoubleClickHandler,
    MM.MouseWheelHandler
  ];

  MM.Map.prototype.smooth = function (_) {
    while (this.eventHandlers.length) {
      this.eventHandlers.pop().remove();
    }

    var handlers = _ ? smooth_handlers : default_handlers;
    for (var j = 0; j < handlers.length; j++) {
      var h = handlers[j]();
      this.eventHandlers.push(h);
      h.init(this);
    }
    return m;
  };

  m.setPanLimits = function (locations) {
    if (!(locations instanceof MM.Extent)) {
      locations = new MM.Extent(
        new MM.Location(
          locations[0].lat,
          locations[0].lon),
        new MM.Location(
          locations[1].lat,
          locations[1].lon));
    }
    locations = locations.toArray();
    this.coordLimits = [
      this.locationCoordinate(locations[0]).zoomTo(this.coordLimits[0].zoom),
      this.locationCoordinate(locations[1]).zoomTo(this.coordLimits[1].zoom)
    ];
    return m;
  };

  m.center = function (location, animate) {
    if (location && animate) {
      this.ease.location(location).zoom(this.zoom())
        .optimal(null, null, animate.callback);
    } else {
      return MM.Map.prototype.center.call(this, location);
    }
  };

  m.zoom = function (zoom, animate) {
    if (zoom !== undefined && animate) {
      this.ease.to(this.coordinate).zoom(zoom).run(600);
    } else {
      return MM.Map.prototype.zoom.call(this, zoom);
    }
  };

  m.centerzoom = function (location, zoom, animate) {
    if (location && zoom !== undefined && animate) {
      this.ease.location(location).zoom(zoom).optimal(null, null, animate.callback);
    } else if (location && zoom !== undefined) {
      return this.setCenterZoom(location, zoom);
    }
  };

  // Insert a tile layer below marker layers
  m.addTileLayer = function (layer) {
    for (var i = m.layers.length; i > 0; i--) {
      if (!m.layers[i - 1].features) {
        return this.insertLayerAt(i, layer);
      }
    }
    return this.insertLayerAt(0, layer);
  };

  // We need to redraw after removing due to compositing
  m.removeLayerAt = function (index) {
    MM.Map.prototype.removeLayerAt.call(this, index);
    MM.getFrame(this.getRedraw());
    return this;
  };

  // We need to redraw after removing due to compositing
  m.swapLayersAt = function (a, b) {
    MM.Map.prototype.swapLayersAt.call(this, a, b);
    MM.getFrame(this.getRedraw());
    return this;
  };

  return m;
};

this.mapbox = mapbox;
if (typeof mapbox === 'undefined') mapbox = {};

// Simplest way to create a map. Just provide an element id and
// a tilejson url (or an array of many) and an optional callback
// that takes one argument, the map.
mapbox.auto = function (elem, url, callback) {
  mapbox.load(url, function (tj) {

    var opts = tj instanceof Array ? tj : [tj];

    var tileLayers = [],
      markerLayers = [];
    for (var i = 0; i < opts.length; i++) {
      if (opts[i].layer) tileLayers.push(opts[i].layer);
      if (opts[i].markers) markerLayers.push(opts[i].markers);
    }

    var map = mapbox.map(elem, tileLayers.concat(markerLayers)).auto();
    if (callback) callback(map, tj);
  });
};


// mapbox.load pulls a [TileJSON](http://mapbox.com/wax/tilejson.html)
// object from a server and uses it to configure a map and various map-related
// objects
mapbox.load = function (url, callback) {

  // Support multiple urls
  if (url instanceof Array) {
    return mapbox.util.asyncMap(url, mapbox.load, callback);
  }

  // Support bare IDs as well as fully-formed URLs
  if (url.indexOf('http') !== 0) {
    url = mapbox.MAPBOX_URL + url;
  }

  wax.tilejson(url, function (tj) {
    // Pull zoom level out of center
    tj.zoom = tj.center[2];

    // Instantiate center as a Modest Maps-compatible object
    tj.center = {
      lat: tj.center[1],
      lon: tj.center[0]
    };

    tj.thumbnail = mapbox.MAPBOX_URL + tj.id + '/thumb.png';

    // Instantiate tile layer
    tj.layer = mapbox.layer().tilejson(tj);

    // Instantiate markers layer
    if (tj.data) {
      tj.markers = mapbox.markers.layer();
      tj.markers.url(tj.data, function () {
        mapbox.markers.interaction(tj.markers);
        callback(tj);
      });
    } else {
      callback(tj);
    }
  });
};
if (typeof mapbox === 'undefined') mapbox = {};

mapbox.ui = function (map) {
  var ui = {
    zoomer: wax.mm.zoomer().map(map).smooth(true),
    pointselector: wax.mm.pointselector().map(map),
    hash: wax.mm.hash().map(map),
    zoombox: wax.mm.zoombox().map(map),
    fullscreen: wax.mm.fullscreen().map(map),
    legend: wax.mm.legend().map(map),
    attribution: wax.mm.attribution().map(map)
  };

  function unique(x) {
    var u = {}, l = [];
    for (var i = 0; i < x.length; i++) u[x[i]] = true;
    for (var a in u) { if (a) l.push(a); }
    return l;
  }

  ui.refresh = function () {
    if (!map) return console && console.error('ui not attached to map');

    var attributions = [], legends = [];
    for (var i = 0; i < map.layers.length; i++) {
      if (map.layers[i].enabled && map.layers[i].tilejson) {
        var attribution = map.layers[i].tilejson().attribution;
        if (attribution) attributions.push(attribution);
        var legend = map.layers[i].tilejson().legend;
        if (legend) legends.push(legend);
      }
    }

    var unique_attributions = unique(attributions);
    var unique_legends = unique(legends);

    ui.attribution.content(unique_attributions.length ? unique_attributions.join('<br />') : '');
    ui.legend.content(unique_legends.length ? unique_legends.join('<br />') : '');

    ui.attribution.element().style.display = unique_attributions.length ? '' : 'none';
    ui.legend.element().style.display = unique_legends.length ? '' : 'none';
  };

  return ui;
};
if (typeof mapbox === 'undefined') mapbox = {};


mapbox.util = {

  // Asynchronous map that groups results maintaining order
  asyncMap: function (values, func, callback) {
    var remaining = values.length,
      results = [];

    function next(index) {
      return function (result) {
        results[index] = result;
        remaining--;
        if (!remaining) callback(results);
      };
    }

    for (var i = 0; i < values.length; i++) {
      func(values[i], next(i));
    }
  }
};
if (typeof mapbox === 'undefined') mapbox = {};

mapbox.interaction = function () {

  var interaction = wax.mm.interaction(),
    auto = false;

  interaction.refresh = function () {
    var map = interaction.map();
    if (!auto || !map) return interaction;
    for (var i = map.layers.length - 1; i >= 0; i--) {
      if (map.layers[i].enabled) {
        var tj = map.layers[i].tilejson && map.layers[i].tilejson();
        if (tj && tj.template) return interaction.tilejson(tj);
      }
    }
    return interaction.tilejson({});
  };

  interaction.auto = function () {
    auto = true;
    interaction.on(wax.tooltip()
      .animate(true)
      .parent(interaction.map().parent)
      .events()).on(wax.location().events());
    return interaction.refresh();
  };

  return interaction;
};
if (typeof mapbox === 'undefined') mapbox = {};

mapbox.layer = function () {
  if (!(this instanceof mapbox.layer)) {
    return new mapbox.layer();
  }
  // instance variables
  this._tilejson = {};
  this._url = '';
  this._id = '';
  this._composite = true;

  this.name = '';
  this.parent = document.createElement('div');
  this.parent.style.cssText = 'position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; margin: 0; padding: 0; z-index: 0';
  this.levels = {};
  this.requestManager = new MM.RequestManager();
  this.requestManager.addCallback('requestcomplete', this.getTileComplete());
  this.requestManager.addCallback('requesterror', this.getTileError());
  this.setProvider(new wax.mm._provider({
    tiles: ['data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7']
  }));
};

mapbox.layer.prototype.refresh = function (callback) {
  var that = this;
  // When the async request for a TileJSON blob comes back,
  // this resets its own tilejson and calls setProvider on itself.
  wax.tilejson(this._url, function (o) {
    that.tilejson(o);
    if (callback) callback(that);
  });
  return this;
};

mapbox.layer.prototype.url = function (x, callback) {
  if (!arguments.length) return this._url;
  this._mapboxhosting = x.indexOf(mapbox.MAPBOX_URL) == 0;
  this._url = x;
  return this.refresh(callback);
};

mapbox.layer.prototype.id = function (x, callback) {
  if (!arguments.length) return this._id;
  this.named(x);
  this._id = x;
  return this.url(mapbox.MAPBOX_URL + x, callback);
};

mapbox.layer.prototype.named = function (x) {
  if (!arguments.length) return this.name;
  this.name = x;
  return this;
};

mapbox.layer.prototype.tilejson = function (x) {
  if (!arguments.length) return this._tilejson;

  if (!this._composite || !this._mapboxhosting) this.setProvider(new wax.mm._provider(x));

  this._tilejson = x;

  this.name = this.name || x.id;
  this._id = this._id || x.id;

  if (x.bounds) {
    var proj = new MM.MercatorProjection(0,
      MM.deriveTransformation(
        -Math.PI, Math.PI, 0, 0,
        Math.PI, Math.PI, 1, 0,
        -Math.PI, -Math.PI, 0, 1));

    this.provider.tileLimits = [
      proj.locationCoordinate(new MM.Location(x.bounds[3], x.bounds[0]))
        .zoomTo(x.minzoom ? x.minzoom : 0),
      proj.locationCoordinate(new MM.Location(x.bounds[1], x.bounds[2]))
        .zoomTo(x.maxzoom ? x.maxzoom : 18)
    ];
  }

  return this;
};

mapbox.layer.prototype.draw = function () {
  if (!this.enabled || !this.map) return;

  if (this._composite && this._mapboxhosting) {

    // Get index of current layer
    var i = 0;
    for (i; i < this.map.layers.length; i++) {
      if (this.map.layers[i] == this) break;
    }

    // If layer is composited by layer below it, don't draw
    for (var j = i - 1; j >= 0; j--) {
      if (this.map.getLayerAt(j).enabled) {
        if (this.map.getLayerAt(j)._composite) {
          this.parent.style.display = 'none';
          this.compositeLayer = false;
          return this;
        }
        else break;
      }
    }

    // Get map IDs for all consecutive composited layers
    var ids = [];
    for (var k = i; k < this.map.layers.length; k++) {
      var l = this.map.getLayerAt(k);
      if (l.enabled) {
        if (l._composite && l._mapboxhosting) ids.push(l.id());
        else break;
      }
    }
    ids = ids.join(',');

    if (this.compositeLayer !== ids) {
      this.compositeLayer = ids;
      var that = this;
      wax.tilejson(mapbox.MAPBOX_URL + ids, function (tiledata) {
        that.setProvider(new wax.mm._provider(tiledata));
        // setProvider calls .draw()
      });
      this.parent.style.display = '';
      return this;
    }

  } else {
    this.parent.style.display = '';
    // Set back to regular provider
    if (this.compositeLayer) {
      this.compositeLayer = false;
      this.setProvider(new wax.mm._provider(this.tilejson()));
      // .draw() called by .tilejson()
    }
  }

  return MM.Layer.prototype.draw.call(this);
};

mapbox.layer.prototype.composite = function (x) {
  if (!arguments.length) return this._composite;
  if (x) this._composite = true;
  else this._composite = false;
  return this;
};

// we need to redraw map due to compositing
mapbox.layer.prototype.enable = function (x) {
  MM.Layer.prototype.enable.call(this, x);
  if (this.map) this.map.draw();
  return this;
};

// we need to redraw map due to compositing
mapbox.layer.prototype.disable = function (x) {
  MM.Layer.prototype.disable.call(this, x);
  if (this.map) this.map.draw();
  return this;
};

MM.extend(mapbox.layer, MM.Layer);
// Double Driver App

var APP_VERSION_NUM = "3.188";
var APP_BUILD_NUM = parseInt("188");
var IS_ROBOT_MODE = false;
var IS_DEV_MODE = (APP_VERSION_NUM.indexOf("{" + "version_number" + "}") >= 0);
var kDRCookieDomain = "." + ROOT_DOMAIN;
var isTouchDevice = "ontouchstart" in document.documentElement;
var pingInterval = null;

var kDRBlueColor = "rgb(23, 143, 236)";
var kDRGreenColor = "rgb(23, 198, 10)";
var kDROrangeColor = "#F07B06";
var kDRRedColor = "rgb(234, 34, 44)";

var kDRRoleUnknown = 0;
var kDRRoleRobot = 1;
var kDRRoleDriver = 2;
var kDRRoleViewer = 3;

var kDREndTypeUnknown = 0;
var kDREndTypeLocal = 1;
var kDREndTypeRemote = 2;

var kDRRoutingMethodUnknown = 0;
var kDRRoutingMethodRelayed = 1;
var kDRRoutingMethodRouted = 2;
var securityLevel = kDRRoutingMethodRelayed;

var inSession = false;
var sessionBeginDate = null;
var lastShownMessageId = null;

// commands
var kDRCommandDriverToRobotHello = 1;
var kDRCommandRobotToDriverHello = 2;
var kDRCommandDriverToRobotGoodbye = 3;
var kDRCommandGoodbye = 4;
var kDRCommandControlDrive = 8;
var kDRCommandControlPole = 9;
var kDRCommandKickstandDeploy = 10;
var kDRCommandKickstandRetract = 11;
var kDRCommandRobotIsAvailable = 19;
var kDRCommandRobotIsBusy = 20;
var kDRCommandDriverIsReady = 21;
var kDRCommandRequestListOfRobots = 22;
var kDRCommandListOfRobots = 23;
var kDRCommandRequestOpenTokSession = 24;
var kDRCommandOpenTokSession = 25;
var kDRCommandFlipCamera = 26;
// var = kDRCommandRequestBatteryLevel 27;
// var = kDRCommandBatteryLevel 28;
var kDRCommandRequestStatusData = 29;
var kDRCommandStatusData = 30;
// var kDRCommandStartChargingiPad = 31;
// var kDRCommandStopChargingiPad = 32;
var kDRCommandRobotIsAway = 33;
var kDRCommandPing = 34;
var kDRCommandPingResponse = 35;
var kDRCommandTurnBy = 36;
var kDRCommandPoleStand = 37;
var kDRCommandPoleSit = 38;
var kDRCommandPoleStop = 39;
var kDRCommandPoleMoving = 40;
var kDRCommandVolumeChanged = 41;
var kDRCommandRequestLiveSessions = 42;
var kDRCommandLiveSessions = 43;
var kDRCommandRequestRobotiPadOrientation = 44;
var kDRCommandRobotiPadOrientation = 45;
var kDRCommandLogSessionError = 50;
var kDRRequestFirmwareConstants = 51;
var kDRFirmwareConstantsSent = 52;
var kDRSetFirmwareConstants = 53;
var kDRCommandRemoteVideoFroze = 54;
var kDRCommandRemoteVideoUnfroze = 55;
var kDRCommandFlashlightOn = 56;
var kDRCommandFlashlightOff = 57;
var kDRCommandTakePhoto = 58;
var kDRCommandPhoto = 59;
var kDRCommandZoom = 60;
var kDRCommandResetVideoLink = 61;
var kDRCommandDidFinishFlipping = 62;
var kDRCommandJoinSession = 63;
var kDRCommandRequestJoinKey = 64;
var kDRCommandJoinKey = 65;
var kDRCommandViewerDidLeaveSession = 66;
var kDRCommandSetRobotScreenBrightness = 67;
var kDRCommandLowLightModeOn = 68;
var kDRCommandLowLightModeOff = 69;
var kDRCommandKnockKnock = 70;
var kDRCommandFocusOnPoint = 71;
var kDRCommandRobotFrameRate = 72;
var kDRCommandKickDriver = 73;
var kDRCommandKickAndBlockDriver = 74;
var kDRCommandUnblockDriver = 75;
var kDRCommandWebURLShow = 76;
var kDRCommandWebURLHide = 77;
var kDRCommandVideoStabilizationOn = 78;
var kDRCommandVideoStabilizationOff = 79;
var kDRCommandReloadConfiguration = 80;
var kDRCommandGACycle = 81;
var kDRCommandSetPreferences = 82;
var kDRCommandViewerDidJoinSession = 83;
var kDRCommandViewerDidPublishAudio = 84;
var kDRCommandMultipartyViewers = 85;
var kDRCommandCameraKitSettings = 86;
var kDRCommandCameraKitStartVideo = 87;
var kDRCommandCameraKitStopVideo = 88;
var kDRCommandCameraKitCyclePower = 89;
var kDRCommandCameraKitWhiteBalance = 90;
var kDRCommandCameraKitExposure = 91;
var kDRCommandCameraKitLED = 92;
var kDRCommandAdaptiveHDEnable = 93;
var kDRCommandAdaptiveHDDisable = 94;
var kDRCommandDebugString = 95;
var kDRCommandBeginAngleCalibration = 96;
var kDRCommandRequestBatteryDebug = 97;
var kDRCommandFloorViewEnable = 98;
var kDRCommandFloorViewDisable = 99;
var kDRCommandCameraKitEnable = 100;
var kDRCommandCameraKitDisable = 101;
var kDRCommandColorFiltersEnable = 102;
var kDRCommandColorFiltersDisable = 103;
var kDRCommandLensCorrectionEnable = 104;
var kDRCommandLensCorrectionDisable = 105;
var kDRCommandAspectRatio = 106;
var kDRCommandSetFloorViewPosition = 107;
var kDRCommandSetRelayServer = 108;
var kDRCommandSharpenFilterEnable = 109;
var kDRCommandSharpenFilterDisable = 110;
var kDRCommandSessionStatus = 111;
var kDRCommandAudioBoostLevel = 112;
var kDRCommandAdminPacket = 113;
var kDRCommandSetNickname = 114;
var kDRCommandWebRTCSignal = 115;
var kDRCommandPreheat = 116;
var kDRCommandTilt = 117;
var kDRCommandTargetDrive = 118;
var kDRCommandFrame = 119;
var kDRCommandHop = 120;
var kDRCommandPTZMove = 121;
var kDRCommandPTZStop = 122;
var kDRCommandPTZIn = 123;
var kDRCommandPTZOut = 124;
var kDRCommandPose = 125;
var kDRCommandNewTarget = 126;
var kDRCommandTarget = 127;
var kDRCommandCancelTarget = 128;
var kDRCommandTargetCanceled = 129;
var kDRCommandTargetArrived = 130;
var kDRCommandModifyDriveControls = 131;
var kDRCommandDebugPassthrough = 132;
var kDRCommandGrid = 133;
var kDRCommandSetGraphicsLevel = 134;
var kDRCommandObstacleGridEnable = 135;
var kDRCommandObstacleGridDisable = 136;
var kDRCommandWebRTCScreenSharingSignal = 137;
var kDRCommandWebRTCLog = 138;
var kDRCommandUpdateIdentity = 139;
var kDRCommandDocks = 140;
var kDRCommandSetObstacleAvoidanceLevel = 141;
var kDRCommandRequestAdminData = 142;
var kDRCommandAdminData = 143;
var kDRCommandRequestLocation = 144;
var kDRCommandSetAdminData = 145;
var kDRCommandMessageToSidebar = 146;
var kDRCommandMessageToAccessoryWebView = 147;
var kDRCommandStartApp = 148;
var kDRCommandStopApp = 149;
var kDRCommandHitTest = 150;
var kDRCommandHitResult = 151;
var kDRCommandMultipartyEnd = 152;
var kDRCommandRobotSpeakerMute = 153;
var kDRCommandRobotSpeakerUnmute = 154;
var kDRCommandTagDetectorEnable = 155;
var kDRCommandTagDetectorDisable = 156;
var kDRCommandTags = 157;
var kDRCommandErrorMessage = 158;
var kDRCommandRoomMessage = 159;
var kDRCommandReloadUserData = 160;

var kDRFloorViewPositionBottomLeft = 0;
var kDRFloorViewPositionTopLeft = 1;

var kDRCommandDebug = 999;

// Kickstand states
var kDRKickstand_stateNone = 0;
var kDRKickstand_stateDeployed = 1;
var kDRKickstand_stateRetracted = 2;
var kDRKickstand_stateDeployWaiting = 3;
var kDRKickstand_stateDeployBeginning = 4;
var kDRKickstand_stateDeployMiddle = 5;
var kDRKickstand_stateDeployEnd = 6;
var kDRKickstand_stateDeployAbortMiddle = 7;
var kDRKickstand_stateDeployAbortEnd = 8;
var kDRKickstand_stateRetractBeginning = 9;
var kDRKickstand_stateRetractMiddle = 10;
var kDRKickstand_stateRetractEnd = 11;

// robot status
var kDRRobotStatusAvailable = 0;
var kDRRobotStatusInUse = 1;
var kDRRobotStatusAway = 2;
var isFlipped = false;
var isMuted = false;
var speakerIsMuted = false;
var kickstandState = kDRKickstand_stateNone;
var poleIsMoving = false;
var flipKeyDidRelease = true;
var statusValues = {};
var lastVolume = 0;
var justGotVolume = false;
var robotiPadOrientation = 0;
var powerDriveOn = false;

// stats
var sessionStatsInterval = null;
var externalPingSentTime = null;
var lastExternalPingTime = -1;
var externalPingLastKey = Math.random();
var lastFrameRate = 0;
var lastFrameWidth = 0;
var lastFrameHeight = 0;
var lastBytesReceivedVideo = 0;
var lastBytesReceivedAudio = 0;
var lastBytesReceived = 0;
var lastStatsTimestamp = 0;
var lastBandwidthVideo = 0;
var lastBandwidthAudio = 0;
var lastBandwidth = 0;
var lastPacketLossVideo = 0;
var lastPacketLossAudio = 0;
var lastPacketLoss = 0;
var lastPacketsReceivedVideo = 0;
var lastPacketsLostVideo = 0;
var lastPacketsReceivedAudio = 0;
var lastPacketsLostAudio = 0;
var statsDrive = 0;
var statsPowerDrive = 0;
var statsTurn = 0;
var statsPole = 0;
var lastMicPeak = -1;

var configuration = { data: {} };
var sidebarApps = [];

var opentokAPIKey = 10772502;
var opentokSession;
var opentokPublisher;
var opentokSubscriber = undefined;
var opentokViewSubscribers = [];
var opentokAudioSourceDeviceId = null;
var opentokVideoSourceDeviceId = null;
var opentokAudioSourceDeviceName = "";
var opentokVideoSourceDeviceName = "";
var doubleSessionId = -1;

var blinkArray = [];

var forwardState = 0;
var backwardState = 0;
var leftState = 0;
var rightState = 0;
var throttleSpeed = 0;
var turnSpeed = 0;
var poleUpState = 0;
var poleDownState = 0;
var tiltSpeed = 0;
var lastTiltSpeed = 0;
var ptzStates = {
  left: false,
  right: false,
  up: false,
  down: false,
  didSend: false
};
var ctrlKeyDown = false;
var shiftKeyDown = false;
var ctrlMenuWasVisible = false;
var ctrlMenuDiv = null;
var ctrlMenuArrowContainerDiv = null;
var ctrlMenuMouseX = 0;
var ctrlMenuMouseY = 0;
var ctrlMenuCenterX = 0;
var ctrlMenuCenterY = 0;
var ctrlMenuDiffenceX = 0;
var ctrlMenuDiffenceY = 0;
var ctrlMenuTouchStartDistanceBetweenTouches = 0;
var cKeyDown = false;
var rightClickDown = false;
var rightClickDownDate = null;
var shouldZoomAfterLoadingRobots = true;
var zoomLevel = 1.0;
var zoomCenter = [0.5, 0.5];
var nextZoomCenter = null;
var sessionIsMultipartyHost = false;
var sessionIsViewer = false;
var multipartyViewerName = "Viewer";
var multipartyViewerId = null;
var multipartyLink = null;
var multipartyViewers = [];
var centerRemoteVideoInterval = null;
var sessionRobotInstallationId = undefined;
var sessionVisitorPass = null;
var neutralDriveCommandsSent = 0;
var neutralPoleCommandsSent = 0;
var poleToSend = -1;
var allowPoleUpdate = true;
var allowRobotSpeakerUpdate = true;
var allowRobotSpeakerUpdateTimeout = null;
var robotSpeakerVolumeToSend = -1;
var sharpenFilterEnabled = false;
var lastQualitySettingCameraKit = -1;
var lastQualitySettingiPad = -1;
var showToolbar = true;
var showMap = true;

var showingWebPage = false;

var sessionBatteryButton = null;

var drivingTallTimeout = null;
var drivingTallInterval = null;

// Socket.io
var socket;
var relaySocket = undefined;
var isConnected = false;
var nodeServer = "operator." + ROOT_DOMAIN;
var nodePort = 443;

// OpenTok
var opentokSessionId;
var opentokSessionToken;
var audioBoostLevel = 0.0;

// WebRTC
var iceConfig = {
  sdpSemantics: "unified-plan",
  iceTransportPolicy: "all", // relay
  "iceServers": [
    {
      urls: [
        "turn:rtc-frankfurt.doublerobotics.com:443?transport=udp",
        "turn:rtc-frankfurt.doublerobotics.com:443?transport=tcp",
        "turns:rtc-frankfurt.doublerobotics.com:443?transport=tcp"
      ],
      username: "open",
      credential: "open"
    }
  ]
};
if (ROOT_DOMAIN == "doublerobotics-eu.com") {
  iceConfig = {
    sdpSemantics: "unified-plan",
    iceTransportPolicy: "all", // relay
    "iceServers": [
      {
        urls: [
          "turn:rtc-frankfurt.doublerobotics.com:443?transport=udp",
          "turn:rtc-frankfurt.doublerobotics.com:443?transport=tcp",
          "turns:rtc-frankfurt.doublerobotics.com:443?transport=tcp"
        ],
        username: "open",
        credential: "open"
      }
    ]
  };
}
var testIceConfigs = [
  // 0 = old
  {
    sdpSemantics: "unified-plan",
    iceTransportPolicy: "all",
    "iceServers": [
      { urls: ["stun:rtc-oregon.doublerobotics.com:443"] },
      {
        urls: [
          "turn:rtc-oregon.doublerobotics.com:443?transport=udp",
          "turn:rtc-oregon.doublerobotics.com:443?transport=tcp"
        ],
        username: "open",
        credential: "open"
      }
    ]
  },
  // 1 = relay
  {
    sdpSemantics: "unified-plan",
    iceTransportPolicy: "relay",
    "iceServers": [
      { urls: ["stun:rtc-paris.doublerobotics.com:443"] },
      {
        urls: ["turn:rtc-paris.doublerobotics.com:443?transport=udp"],
        username: "open",
        credential: "open"
      },
      {
        urls: ["turn:rtc-paris.doublerobotics.com:443?transport=tcp"],
        username: "open",
        credential: "open"
      }
    ]
  },
  // 2 = relay and udp
  {
    sdpSemantics: "unified-plan",
    iceTransportPolicy: "relay",
    "iceServers": [
      {
        urls: ["turn:rtc-paris.doublerobotics.com:443?transport=udp"],
        username: "open",
        credential: "open"
      }
    ]
  },
  // 3 = tcp
  {
    sdpSemantics: "unified-plan",
    iceTransportPolicy: "all",
    "iceServers": [
      {
        urls: ["turn:rtc-paris.doublerobotics.com:443?transport=tcp"],
        username: "open",
        credential: "open"
      }
    ]
  },
  // 4 = turns
  {
    sdpSemantics: "unified-plan",
    iceTransportPolicy: "all",
    "iceServers": [
      {
        urls: ["turns:rtc-paris.doublerobotics.com:443?transport=udp"],
        username: "open",
        credential: "open"
      },
      {
        urls: ["turns:rtc-paris.doublerobotics.com:443?transport=tcp"],
        username: "open",
        credential: "open"
      }
    ]
  },
  // 5 = turns
  {
    sdpSemantics: "unified-plan",
    iceTransportPolicy: "relay",
    "iceServers": [
      {
        urls: ["turns:rtc-paris.doublerobotics.com:443?transport=tcp"],
        username: "open",
        credential: "open"
      }
    ]
  },
  // 6 = turns oregon
  {
    sdpSemantics: "unified-plan",
    iceTransportPolicy: "relay",
    "iceServers": [
      {
        urls: ["turns:rtc-oregon.doublerobotics.com:443?transport=tcp"],
        username: "open",
        credential: "open"
      }
    ]
  },
  // 7 = multi-region
  {
    sdpSemantics: "unified-plan",
    iceTransportPolicy: "all", // relay
    "iceServers": [
      {
        urls: [
          "turn:rtc-oregon.doublerobotics.com:443?transport=udp",
          "turn:rtc-oregon.doublerobotics.com:443?transport=tcp",
          "turns:rtc-oregon.doublerobotics.com:443?transport=tcp"
        ],
        username: "open",
        credential: "open"
      },
      {
        urls: [
          "turn:rtc-frankfurt.doublerobotics.com:443?transport=udp",
          "turn:rtc-frankfurt.doublerobotics.com:443?transport=tcp",
          "turns:rtc-frankfurt.doublerobotics.com:443?transport=tcp"
        ],
        username: "open",
        credential: "open"
      }
    ]
  },
  // 8 = tokyo
  {
    sdpSemantics: "unified-plan",
    iceTransportPolicy: "all", // relay
    "iceServers": [
      {
        urls: [
          "turn:rtc-tokyo.doublerobotics.com:443?transport=udp",
          "turn:rtc-tokyo.doublerobotics.com:443?transport=tcp",
          "turns:rtc-tokyo.doublerobotics.com:443?transport=tcp"
        ],
        username: "open",
        credential: "open"
      }
    ]
  }
];
var runningIceConfigTest = false;
if (getURLParameter("test").length == 1 && parseInt(getURLParameter("test")) !== NaN) {
  var testIceConfigIndex = parseInt(getURLParameter("test"));
  if (testIceConfigIndex < testIceConfigs.length) {
    iceConfig = testIceConfigs[testIceConfigIndex];
    runningIceConfigTest = true;
  }
}
var nativeWebRTC = new DRDriverWebRTC(iceConfig);
var screenSharingWebRTC = new DRDriverWebRTCScreenSharing(iceConfig);
var pendingNativeWebRTCSignals = null;
var graphicsLevel = -1;
var obstacleAvoidanceLevel = -1;

// map
var mapboxMap;
var markerLayer;
var kDRClusterDistance = 64.0;
var panTimeout;
var robots = [];
var robotsPrivate = [];
var robotsPublic = [];
var robotsList = [];
var lastRobotsString = "";

// driving
var commandsTimer;
var mouseMoveInterval;
var mouseMoveCountdown;
var mouseMoved = false;
var mouseY = 0;

var leftKeyDownStartTime = 0;
var leftTurnTimeout;
var rightKeyDownStartTime = 0;
var rightTurnTimeout;

var freezeDetectionTimer = null;

// client types
var kDRClientTypeUnknown = 0;
var kDRClientTypeiPad = 1;
var kDRClientTypeiPhone = 2;
var kDRClientTypeWeb = 3;

var nightVisionEnabled = false;
var tagsEnabled = false;
var lastBrightnessSent = -1;

var publicRobotsSwitch = 0;

var geocoder;
var geocoderCache = {};

var statsInterval;

var calendarEvents = [];
var calendarEventsInterval;

var alwaysOnFloorViewEnabled = true;
var cameraKitEnabled = false;
var stats;

// D3 Grid
var drawDepth = null;
var drawMinimap = null;

$(document).keydown(function (e) {
  processKeyDown(e);
});

function processKeyDown(e) {
  if (!$("#session").is(":visible") || $("#showWebPage").is(":visible")) {
    return;
  }
  if ((e.target.tagName.toLowerCase() === 'input' && (e.target.type != "submit" && e.target.type != "button"))
    || e.target.tagName.toLowerCase() === 'textarea') {
    // ignore text boxes
    return;
  }

  ctrlKeyDown = !!(e.ctrlKey);
  shiftKeyDown = !!(e.shiftKey);
  updateCtrlMenu(e);

  if (e.shiftKey) {
    powerDriveOn = true;
  } else {
    powerDriveOn = false;
  }

  switch (e.keyCode) {
    case 37: // left, arrow
    case 65: // left, a

      // If key down is less than 200ms, do turn by degree
      // So we are firing a timer here after 200ms to update leftState for firing driver commands
      if (leftKeyDownStartTime == 0) {
        leftKeyDownStartTime = Date.now();
        leftTurnTimeout = window.setTimeout(function () {
          leftState = 1;
          fireDriveCommands();
        }, 200);
      }

      return false;

    case 39: // right, arrow
    case 68: // right, d

      // If key down is less than 200ms, do turn by degree
      // So we are firing a timer here after 200ms to update leftState for firing driver commands
      if (rightKeyDownStartTime == 0) {
        rightKeyDownStartTime = Date.now();
        rightTurnTimeout = window.setTimeout(function () {
          rightState = 1;
          fireDriveCommands();
        }, 200);
      }

      return false;

    case 38: // forward, arrow
    case 87: // forward, w
      if (forwardState == 0 && kickstandState == kDRKickstand_stateDeployed) {
        parkAction();
      }
      forwardState = 1;
      return false;

    case 40: // backward, arrow
    case 83: // backward, s
      backwardState = 1;
      return false;

    case 82: // pole up, r
      poleUpState = 1;
      return true;

    case 70: // pole down, f
      poleDownState = 1;
      return false;

    case 32: // flip, space bar
      if (flipKeyDidRelease) {
        flipAction();
        flipKeyDidRelease = false;
      }
      return false;

    case 90: // zoom in for D3, z
      if (drawDepth) {
        drawDepth.zoomIn();
      }
      return false;
    case 88: // zoom out for D3, x
      if (drawDepth) {
        drawDepth.zoomOut();
      }
      return false;

    case 67: // allow mouse target circle
      cKeyDown = true;
      return false;
  }
  return; //using "return" other attached events will execute
};

$(document).keyup(function (e) {
  processKeyUp(e);
});

function processKeyUp(e) {
  if ($("#showWebPage").is(":visible")) {
    return;
  }
  if (!$("#session").is(":visible")) {
    if (e.keyCode != 27) { // allow esc
      return;
    }
  }
  if ((e.target.tagName.toLowerCase() === 'input' && (e.target.type != "submit" && e.target.type != "button"))
    || e.target.tagName.toLowerCase() === 'textarea') {
    // ignore text boxes
    return;
  }

  ctrlKeyDown = !!(e.ctrlKey);
  shiftKeyDown = !!(e.shiftKey);
  updateCtrlMenu(e);

  if (e.shiftKey) {
    powerDriveOn = true;
  } else {
    powerDriveOn = false;
  }

  switch (e.keyCode) {
    case 35: // end call, end
      disconnect();
      return false;

    case 37: // left, arrow
    case 65: // left, a
      window.clearTimeout(leftTurnTimeout);
      var diff = Date.now() - leftKeyDownStartTime;
      //console.log("keyup " + diff + "ms");
      if (diff < 100) {
        //console.log("turn by 5 degrees");
        var degree = 5.0;
        sendCommandWithData(kDRCommandTurnBy, { "degrees": degree, "degreesWhileDriving": degree / 2.0 });
      } else if (diff < 200) {
        //console.log("Turn 8 degrees");
        var degree = 8.0;
        sendCommandWithData(kDRCommandTurnBy, { "degrees": degree, "degreesWhileDriving": degree / 2.0 });
      }
      leftKeyDownStartTime = 0;
      leftState = 0;
      return false;

    // case 67: // capture photo, c
    // 	takePhoto();
    // 	break;

    case 39: // right, arrow
    case 68: // right, d

      window.clearTimeout(rightTurnTimeout);
      var diff = Date.now() - rightKeyDownStartTime;
      //console.log("keyup " + diff + "ms");
      if (diff < 100) {
        //console.log("turn by -5 degrees");
        var degree = -5.0;
        sendCommandWithData(kDRCommandTurnBy, { "degrees": degree, "degreesWhileDriving": degree / 2.0 });
      } else if (diff < 200) {
        //console.log("Turn -8 degrees");
        var degree = -8.0;
        sendCommandWithData(kDRCommandTurnBy, { "degrees": degree, "degreesWhileDriving": degree / 2.0 });
      }
      rightKeyDownStartTime = 0;
      rightState = 0;
      return false;

    case 38: // forward, arrow
    case 87: // forward, w
      forwardState = 0;
      return false;

    case 40: // backward, arrow
    case 83: // backward, s
      backwardState = 0;
      return false;

    case 82: // pole up, r
      poleUpState = 0;
      return false;

    case 70: // pole down, f
      poleDownState = 0;
      return false;

    case 32: // flip, space bar
      flipKeyDidRelease = true;
      return false;

    case 79: // O
      togglePictureInPicture();
      return false;

    case 80: // park, p
      parkAction();
      return false;

    case 27: // end call, esc
      // disconnect();
      if (drawDepth) {
        drawDepth.cancelPendingClickToDrive();
      }
      cancelTarget();
      hideLastShownMessageId();
      return false;

    case 77: // mute, m
      muteAction();
      return false;

    case 78: // speaker mute, n
      speakerMuteAction();
      return false;

    case 219: // speaker volume down, []
      speakerVolumeDown();
      return false;

    case 221: // speaker volume up, ]
      speakerVolumeUp();
      return false;

    case 187:
      if (e.shiftKey) {
        // volume up, + key
        volumeUp();
      }
      return false;

    case 189:
      if (e.shiftKey) {
        // volume down, - key
        volumeDown();
      }
      return false;

    case 107:
      // volume up, num pad + key
      volumeUp();
      return false;

    case 109:
      // volume down, num pad - key
      volumeDown();
      return false;

    case 73: // info/quality stats, i
      toggleQualityStats();
      saveSettings();
      return false;

    case 66:
      if (remoteRobotSupports("audioBoost")) {
        if (audioBoostLevel == 0.0) {
          audioBoostLevel = 0.5;
        } else {
          audioBoostLevel = 0.0;
        }
        sendCommandWithData(kDRCommandAudioBoostLevel, { "level": audioBoostLevel });
      }
      return false;

    case 67: // allow mouse target circle
      cKeyDown = false;
      return false;

  }
  return; // using "return" other attached events will execute
};

window.addEventListener('blur', function () {
  clearKeyboardCommands();
});

function clearKeyboardCommands() {
  leftState = 0;
  forwardState = 0;
  rightState = 0;
  backwardState = 0;
  poleUpState = 0;
  poleDownState = 0;
  tiltSpeed = 0;
  flipKeyDidRelease = true;
  throttleSpeed = 0;
  turnSpeed = 0;

  ctrlKeyDown = false;
  shiftKeyDown = false;
  updateCtrlMenu();
}

// functions
$(document).ready(function () {
  setup();
  DBLGamepadManager();
  window.onerror = function (message, url, line) {
    sendCommandWithData(kDRCommandLogSessionError, { type: "javascript", message: message, url: url, line: line });
    return false;
  };
});

function isMobileSafari() {
  return navigator.userAgent.match(/(iPod|iPhone|iPad)/) && navigator.userAgent.match(/AppleWebKit/);
}

function checkForNativeApp() {
  if (isMobileSafari()) {
    // To avoid the "protocol not supported" alert, fail must open itunes store to dl the app, add a link to your app on the store
    // var appstorefail = "https://itunes.apple.com/us/app/double/id589230178?mt=8";
    // var loadedAt = +new Date;
    // setTimeout(function() {
    // 	if (+new Date - loadedAt < 2000){
    // 		window.location = appstorefail;
    // 	}
    // }, 100);

    var queryString = "";

    if (getURLParameter("join").length >= 8) {
      // multiparty
      queryString = "?join=" + getURLParameter("join");
    } else if (getURLParameter("tls").length >= 8) {
      // visitor
      queryString = "?tls=" + getURLParameter("tls");
    }

    // Launch the element in your app if it's already installed on the phone
    window.open("doublerobotics://" + queryString, "_self");
  }
}

function setup() {
  console.log("App version " + APP_VERSION_NUM + ", Build " + APP_BUILD_NUM);

  setupBlink();

  // setup map
  map = new RobotsMap();
  mapboxMap = map.setupMapboxWithId("map");

  if (!videoIsSupported()) {
    $("#incompatible").show();
    if (navigator.userAgent.indexOf("iPhone") > 0 || navigator.userAgent.indexOf("iPad") > 0 || navigator.userAgent.indexOf("iOS") > 0) {
      $("#incompatibleWeb").hide();
      $("#incompatibleiOS").show();
      checkForNativeApp();
    }
    if (isIE()) {
      OT.upgradeSystemRequirements();
    }
    return;
  } else {

  }

  // Check for no webcam flag
  var requireCamera = getURLParameter("webcam");
  if (requireCamera != "" && (requireCamera == "0" || requireCamera == "false") && nativeWebRTC) {
    preCallAllowed = false;
    nativeWebRTC.useCamera = false;
  } else {
    preCallAllowed = true;
    nativeWebRTC.useCamera = true;
  }

  // Check for no toolbar flag
  var toolbar = getURLParameter("toolbar");
  showToolbar = !(toolbar != "" && (toolbar == "0" || toolbar == "false"));

  // Check for sidebar content URL
  var content = getURLParameter("content");
  sidebarURL = (content != "") ? decodeURIComponent(content) : null;

  // Check for sidebar sidebar start open
  var sidebar = getURLParameter("sidebar");
  sidebarStartOpen = !(sidebar != "" && (sidebar == "0" || sidebar == "false"));

  // User setup
  loadConfiguration(() => {
    getCurrentInstallation().save();
    loadSettings();

    getCurrentUser();

    // automatic visitor pass login
    var hasTls = getURLParameter("tls").length > 0;
    var hasJoin = getURLParameter("join").length > 0;
    var hasWatch = getURLParameter("watch").length > 0;
    if ((!currentUser || !currentUser.isLoggedIn()) && (hasTls || hasJoin || hasWatch)) {
      window.setTimeout(function () {
        $("#loginForm")[0].elements["username"].value = "public";
        $("#loginForm")[0].elements["password"].value = "public";
        login();
        showPublicRobots();
      }, 100);
    }

    if (configuration && configuration.data && configuration.data.allow_native) {
      q("#loginForm .accessories").style.display = "block";
    } else {
      q("#loginForm .accessories").style.display = "none";
    }
    if (currentUser && currentUser.isLoggedIn()) {
      // logged in
      if (currentUser.username == "public") {
        if (getURLParameter("public_key").length == 0 && getURLParameter("tls").length == 0) {
          logOut();
        } else {
          showPublicRobots();
        }
      } else if (getURLParameter("public_key").length > 0) {
        showPublicRobots();
      }
    } else {
      // show the signup or login page
      var create = getURLParameter("create");
      if (ISOLATION_MODE || create) {
        if (create && configuration && configuration.data && configuration.data.allow_native !== false) {
          switchToCreateAccount();
          $("#usernameCreateAccountField").select();
        } else {
          switchToLogin();
          $("#usernameLoginField").select();
        }
      } else {
        switchToLogin();
        $("#usernameLoginField").select();
      }
    }

    setupSocket();
    startCalendarEvents();
  });

  window.oncontextmenu = function (event) {
    event.preventDefault();
    event.stopPropagation();
    return false;
  };

  if (isChromeAndroid()) {
    var metaElement = document.createElement("meta");
    metaElement.rel = "manifest";
    metaElement.href = "android/manifest.json";
    document.head.append();
  }

  // Setup touch driving controls
  if (isTouchDevice) {
    $("#driveControlsForward").bind('touchstart mousedown', function (e) {
      e.stopPropagation();
      forwardState = 1;
      $("#driveControlsForward").css({ opacity: 0.9 });
    }).bind('touchend mouseup', function (e) {
      e.stopPropagation();
      forwardState = 0;
      $("#driveControlsForward").css({ opacity: 1.0 });
    });
    $("#driveControlsBackward").bind('touchstart mousedown', function (e) {
      e.stopPropagation();
      backwardState = 1;
      $("#driveControlsBackward").css({ opacity: 0.9 });
    }).bind('touchend mouseup', function (e) {
      e.stopPropagation();
      backwardState = 0;
      $("#driveControlsBackward").css({ opacity: 1.0 });
    });
    $("#driveControlsLeft").bind('touchstart mousedown', function (e) {
      e.stopPropagation();
      leftState = 1;
      $("#driveControlsLeft").css({ opacity: 0.9 });
    }).bind('touchend mouseup', function (e) {
      e.stopPropagation();
      leftState = 0;
      $("#driveControlsLeft").css({ opacity: 1.0 });
    });
    $("#driveControlsRight").bind('touchstart mousedown', function (e) {
      e.stopPropagation();
      rightState = 1;
      $("#driveControlsRight").css({ opacity: 0.9 });
    }).bind('touchend mouseup', function (e) {
      e.stopPropagation();
      rightState = 0;
      $("#driveControlsRight").css({ opacity: 1.0 });
    });

    // $("#configButton").bind("click", function(e){
    // 	e.stopPropagation();
    // 	$("#configButton").toggleClass("on");
    // 	$("#sidebarAppsButton").removeClass("on");
    // });
    // $("#sidebarAppsButton").bind("click", function(e){
    // 	e.stopPropagation();
    // 	$("#configButton").removeClass("on");
    // 	$("#sidebarAppsButton").toggleClass("on");
    // });

    // Move the toolbar buttons into a flex container
    // var leftButtons = document.querySelector("#sessionHeader .leftButtons");
    // var rightButtons = document.querySelector("#sessionHeader .rightButtons");
    // var flexToolbar = document.querySelector("#sessionHeader .flexToolbarContainer");
    // var configButton = document.querySelector("#configButton");
    // var leftNodes = Array.from(leftButtons.childNodes);
    // var rightNodes = Array.from(rightButtons.childNodes);
    // for (var i = 0; i < leftNodes.length; i++) {
    // 	flexToolbar.appendChild(leftNodes[i]);
    // }
    // for (var i = rightNodes.length - 1; i >= 0; i--) {
    // 	if (rightNodes[i] != configButton) {
    // 		flexToolbar.appendChild(rightNodes[i]);
    // 	}
    // }
  }

  window.setTimeout(() => {
    if (getURLParameter("forgot") == "true") {
      switchToForgot();
    }
  }, 1000);
}

function setupSocket() {
  // setup socket.io
  socket = io.connect(nodeServer, { secure: ('https:' == document.location.protocol), forceNew: true, 'force new connection': true });
  $("#statusBulb").removeClass().addClass("yellow");
  $("#statusBulb span.label").text("Connecting...");
  socket.on('connect', function () {
    isConnected = true;
    if (currentUser) {
      if (currentUser && currentUser.isLoggedIn()) {
        didLogin();
      } else {
        console.log("failed to get user");
      }
    }
    $("#statusBulb").removeClass().addClass("green");
    $("#statusBulb span.label").text("Connected");

    if (getURLParameter("robot") == "true") {
      window.setTimeout(becomeRobot, 3000);
    }

    // TODO:DEBUG - moved the visitor pass stuff to didLogin() as a temporary fix

    // multiparty session participant
    if (getURLParameter("join").length >= 8) {
      promptToJoinMultipartySession();
    }
    // multiparty session watcher
    if (getURLParameter("watch").length >= 8) {
      promptToJoinMultipartySession();
    }

    // start regular external pings
    if (pingInterval) {
      window.clearInterval(pingInterval);
    }
    pingInterval = window.setInterval(sendPing, 5000 + Math.round(Math.random() * 4000));
    sendPing();

    fireCalendarEvents();
  });
  socket.on('disconnect', function () {
    isConnected = false;
    console.log("socket.io did disconnect");
    $("#statusBulb").removeClass().addClass("red");
    $("#statusBulb span.label").text("Not Connected");
    disconnect();
  });
  socket.on('connect_failed', function () {
    isConnected = false;
    console.log("socket.io failed to connect");
    $("#statusBulb").removeClass().addClass("red");
    $("#statusBulb span.label").text("Not Connected");
  });
  socket.on("message", function (data) {
    if (!currentUser) { return; }

    // console.log("received: "+ JSON.stringify(data));
    var command = data["c"];
    var values = data["d"];
    switch (command) {
      case kDRCommandListOfRobots:
        if (currentUser.username == "public" && getURLParameter("tls").length > 0) {
          // don't show robots beacuse we're doing a visitor pass on the public account
        } else {
          if (values.robots) {
            robotsList = values.robots.sort(function (a, b) { return (a.nickname > b.nickname) ? 1 : ((b.nickname > a.nickname) ? -1 : 0); });
          } else {
            robotsList = [];
          }
        }

        if (document.hidden) {
          document.addEventListener("visibilitychange", function vchange() {
            document.removeEventListener("visibilitychange", vchange, false);
            if (!document.hidden) {
              updateRobotsOnMap();
            }
          }, false);
        } else {
          updateRobotsOnMap();
        }

        break;

      case kDRCommandDriverToRobotHello:
        console.log("Hello from driver.");
        if (IS_ROBOT_MODE) {
          beginSession();
          sendCommand(kDRCommandRobotToDriverHello);
          window.setTimeout(function () {
            sendRobotStatus();
          }, 500);
        }
        break;

      case kDRCommandRequestStatusData:
        if (IS_ROBOT_MODE) {
          sendRobotStatus();
        }
        break;

      case kDRCommandRobotToDriverHello:
        console.log("Hello from robot.");

        if (values && (values.nativeWebRTC == true || remoteRobotSupports("nativeWebRTC"))) {
          // Double's Native WebRTC
          setupNativeWebRTCSessionInterface(values.apps);
          nativeWebRTC.begin();
          centerRemoteVideo();

          // var pendingSignalsTimeout = null;
          // var processPendingSignals = () => {
          // 	if (nativeWebRTC.ready) {
          // 		if (pendingNativeWebRTCSignals && Array.isArray(pendingNativeWebRTCSignals)) {
          // 			for (var i = 0; i < pendingNativeWebRTCSignals.length; i++) {
          // 				nativeWebRTC.processSignal(pendingNativeWebRTCSignals[i]);
          // 			}
          // 		}
          // 		pendingSignalsTimeout = null;
          // 	} else {
          // 		pendingSignalsTimeout = window.setTimeout(processPendingSignals, 100);
          // 	}
          // };
          // pendingSignalsTimeout = window.setTimeout(processPendingSignals, 100);

        } else {
          // OpenTok
          setupOpentokSessionInterface();
          if (securityLevel == kDRRoutingMethodRouted) {
            sendCommandWithData(kDRCommandRequestOpenTokSession, { "multiparty": true });
          } else {
            sendCommand(kDRCommandRequestOpenTokSession);
          }
          sendCommand(kDRCommandRequestStatusData);
          window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 1000);
          window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 3000);
          window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 5000);
        }
        break;

      case kDRCommandGoodbye:
        console.log("Goodbye from robot.", values);
        window.setTimeout(endSession, 100);
        if (values && values["error"]) {
          nonModalAlert("Error", values["error"]);
        }
        sendSessionLog(kDREndTypeRemote);
        break;

      case kDRCommandOpenTokSession:
        // start opentok
        console.log("Got session: ", values);
        opentokSessionId = values.openTokSessionId;
        opentokSessionToken = values.openTokSessionToken;

        if (nativeWebRTC && nativeWebRTC.isActive()) {
          // Wait for the join key
        } else {
          opentokConnect();
        }
        centerRemoteVideo();

        if (sessionIsViewer || sessionIsMultipartyHost) {
          sendCommand(kDRCommandRequestJoinKey);
          if (sessionIsViewer) {
            sendCommandWithData(kDRCommandViewerDidJoinSession, { "name": multipartyViewerName, "viewerId": multipartyViewerId });
          }
        }
        break;

      case kDRCommandJoinKey:
        if (sessionIsMultipartyHost && values["key"]) {
          var link = location.protocol + '//' + location.host + location.pathname;
          if (getURLParameter("server")) {
            link = addQueryStringParameter(link, "server", getURLParameter("server"));
          }
          if (getURLParameter("api")) {
            link = addQueryStringParameter(link, "api", getURLParameter("api"));
          }
          link = addQueryStringParameter(link, "join", values["key"]);
          console.log("Multiparty: " + link);
          multipartyLink = link;
          if (nativeWebRTC && nativeWebRTC.isActive()) {
            if (sessionIsMultipartyHost) {
              startSidebarAppByKey("multiviewer");
            }
          } else {
            showMultipartyLink(link);
          }
        }
        break;

      case kDRCommandStatusData:
        /* 				console.log("status: "+ JSON.stringify(values)); */
        kickstandState = values.kickstand;
        statusValues = values;
        updateUserInterface();
        break;

      case kDRCommandPoleMoving:
        // TODO: implement pole button flashing
        break;

      case kDRCommandRobotiPadOrientation:
        robotiPadOrientation = values.robot_ipad_orientation;
        updateUserInterface();

        if (values.robot_ipad_orientation == 1) {
          // don't flip upside down
          $("#subscribers .remoteVideo video").addClass("videoRightSideUp");
          nonModalAlert("Unavailable", $("#stringDownwardCameraNotAvailable").html());
        } else {
          // leave as default css
          $("#subscribers .remoteVideo video").removeClass("videoRightSideUp");
        }
        break;

      case kDRCommandPhoto:
        downloadBase64(values["photo"], "image/jpg");
        displayHoverMessage("Taking Photo", "Downloaded.");
        window.setTimeout(hideHoverMessage, 2000);
        break;

      case kDRCommandResetVideoLink:
        resetVideoLink();
        break;

      case kDRCommandViewerDidJoinSession:
        // received by driver
        console.log("Viewer did join: ", values);

        if (values && values.viewerId) {
          addViewer(values.viewerId, values.name);
        }

        break;

      case kDRCommandViewerDidPublishAudio:
        // received by driver
        console.log("Viewer did publish audio: ", values);

        if (values && values.viewerId && values.streamId) {
          attachAudioToViewer(values.viewerId, values.streamId);
        }

        break;

      case kDRCommandViewerDidLeaveSession:
        // reveived by driver
        console.log("Viewer did leave: ", values);

        if (values && values.viewerId) {
          removeViewer(values.viewerId);
        }

        break;

      case kDRCommandMultipartyViewers:
        // received by viewers
        if (values && values.viewers) {
          console.log("Viewers: ", values.viewers);

          multipartyViewers = values.viewers;
          redrawMultipartyViewers();
        }
        break;

      case kDRCommandMultipartyEnd:
        if (sessionIsViewer) {
          endSession();
        }
        break;

      case kDRCommandSessionStatus:
        doubleSessionId = values.id;
        sendSessionLog();
        break;

      case kDRCommandPingResponse:
        if (values && values.key == externalPingLastKey) {
          lastExternalPingTime = new Date() - externalPingSentTime;
          externalPingLastKey = Math.random();
        }
        break;

      case kDRCommandDebug:
        console.log("kDRCommandDebug");
        break;

      case kDRCommandWebRTCSignal:
        if (nativeWebRTC && values) {
          nativeWebRTC.receiveSignal(values);
          // if (nativeWebRTC.began) {
          // 	// window.setTimeout( () => {
          // 		nativeWebRTC.processSignal(values);
          // 	// }, 1000);
          // } else {
          // 	if (!pendingNativeWebRTCSignals) {
          // 		pendingNativeWebRTCSignals = [];
          // 	}
          // 	pendingNativeWebRTCSignals.push(values);
          // 	console.log("pendingNativeWebRTCSignals, nativeWebRTC", pendingNativeWebRTCSignals, nativeWebRTC.peerConnection);
          // }
        }
        break;

      case kDRCommandWebRTCScreenSharingSignal:
        if (screenSharingWebRTC && inSession && values) {
          screenSharingWebRTC.processSignal(values);
        }
        break;

      case kDRCommandFrame:
        if (values && values.detectors && drawMinimap) {
          drawMinimap.drawFrame(values);
          if (statusValues && statusValues.undockable && !$("#targetMessage").is(":visible")) {
            $("#exitDockMessage").show();
          } else {
            $("#exitDockMessage").hide();
          }
        }
        break;

      case kDRCommandDocks:
        if (values) {
          drawDepth.setDocks(values);
        }
        break;

      case kDRCommandGrid:
        if (drawDepth && values) {
          drawDepth.processGlobalGrid(values);
        }
        break;

      case kDRCommandHop:
        if (values) {
          console.log("hop", values);
          $("#qualityStatsAccessPoint").html("AP: " + values.bssid);
          $("#qualityStatsAccessPoint").removeClass("quickFlash");
          setTimeout(function () {
            $("#qualityStatsAccessPoint").addClass("quickFlash");
          }, 10);
        }
        break;

      case kDRCommandPose:
        if (drawDepth && values) {
          drawDepth.setPose(values);
          checkView(values);
        }
        break;

      case kDRCommandNewTarget:
        showTargetMessage(values);
        if (drawMinimap && values) {
          drawMinimap.showTargetIcon(values.relative.x, values.relative.y);
        }
        break;

      case kDRCommandTarget:
        if (drawMinimap && values) {
          drawMinimap.moveTargetIcon(values.relative.x, values.relative.y);
        }
        break;

      case kDRCommandTargetCanceled:
        hideTargetMessage();
        if (drawMinimap) {
          drawMinimap.hideTargetIcon();
        }
        break;

      case kDRCommandTargetArrived:
        hideTargetMessage();
        if (drawMinimap) {
          drawMinimap.targetArrived();
        }
        break;

      case kDRCommandModifyDriveControls:
        if (drawMinimap && values) {
          drawMinimap.setModifyDriveControls(values);
        }
        break;

      case kDRCommandMessageToSidebar:
        var iframe = document.getElementById("sidebarIframe");
        if (iframe && iframe.contentWindow && values && values.message) {
          iframe.contentWindow.postMessage(values.message, values.targetOrigin || "*");
        }
        break;

      case kDRCommandStartApp:
        if (Array.isArray(values.apps)) {
          sidebarApps = values.apps;
        }
        startSidebarAppByKey(values.key);
        break;

      case kDRCommandStopApp:
        forceStopSidebarApp();
        break;

      case kDRCommandHitResult:
        processHit(values);
        break;

      case kDRCommandTags:
        if (values) {
          drawDepth.setTags(values);
        }
        break;

      case kDRCommandErrorMessage:
        if (values && values.message) {
          window.setTimeout(() => {
            nonModalAlert(values.title, values.message);
          }, 1000);
        }
        break;

      case kDRCommandReloadUserData:
        getCurrentUserData();
        break;
    }
  });

  var target = $('#session')[0]; // Get DOM element from jQuery collection
  $('#fullscreenButton').click(function () {
    lockPointer();
  });

  window.onresize = centerRemoteVideo;
  centerRemoteVideo();
}

function centerRemoteVideo() {
  if ($("#session").hasClass("webrtc") || sessionIsViewer) {
    // Native WebRTC
    var videoEl = q("#webrtcRemoteVideo");
    if (!videoEl) {
      videoEl = q("#subscribers video");
    }
    var graphicsEl = q("#graphicsContainer");
    var overlayEl = q("#videoOverlay");
    var sidebarEl = q("#session #sidebar");
    var subscribersEl = q("#subscribers");
    var sessionHeaderEl = q("#sessionHeader");

    var ratio = 1.6;
    var w = -1;
    var h = -1;
    var x = -1;
    var y = 0;
    if (sessionHeaderEl.offsetParent) {
      y = sessionHeaderEl.offsetHeight;
    }

    var sidebarWidth = false;
    if (sidebarEl && sidebarEl.offsetParent) {
      // Show sidebar
      sidebarEl.style.width = sidebarAppWidth + "px";
      overlayEl.style.height = h + "px";
      sidebarWidth = sidebarEl.offsetWidth;
      subscribersEl.style.left = "0px";
      subscribersEl.style.width = "calc(100% - " + sidebarWidth + "px)";
    } else {
      subscribersEl.style.left = "0px";
      subscribersEl.style.width = "100%";
    }

    var videoWidth = 0;
    if (videoEl && videoEl.videoWidth) {
      videoWidth = videoEl.videoWidth;
    }
    if (videoWidth > 0) {
      ratio = videoEl.videoWidth / videoEl.videoHeight;
      w = Math.round(videoEl.offsetHeight * ratio);
      x = Math.round((videoEl.offsetWidth - w) / 2);
      h = Math.round(w / ratio);
    } else {
      var subscribersRatio = $("#subscribers").width() / $("#subscribers").height();
      if (subscribersRatio > 1.6) {
        h = $("#subscribers").height();
        w = Math.round(h * 1.6);
        x = Math.round(($("#subscribers").width() - w) / 2);
      } else {
        w = $("#subscribers").width();
        h = Math.round(w / 1.6);
        x = 0;
      }
    }

    if (sidebarWidth > 0) {
      sidebarEl.style.height = h + "px";
    }

    if (w > 0) {
      graphicsEl.style.width = w + "px";
      graphicsEl.style.height = h + "px";
      graphicsEl.style.top = y + "px";
      graphicsEl.style.left = x + "px";
      graphicsEl.style.display = "block";
    } else {
      graphicsEl.style.display = "none";
    }

    overlayEl.style.width = w + "px";
    overlayEl.style.height = h + "px";
    overlayEl.style.top = y + "px";
    overlayEl.style.left = x + "px";
    overlayEl.style.display = "block";

    if (drawDepth) {
      drawDepth.updateCanvasSize();
    }

    $("#screenSharingPublisher video").css({ width: "100%", height: "100%", left: 0 });

    if (sessionIsViewer) {
      $("#localVideo").hide();
      $("#multipartyAudioLevels").hide();
    }

  } else {
    // OpenTok
    var w = $(window).width();
    var h = $(window).height();

    // var videoTop = 0;
    // if (isTouchDevice) {
    // 	videoTop = $("#sessionHeader").height();
    // 	h -= videoTop;
    // }

    if (isTouchDevice) {
      // Top aligned
      if (opentokSubscriber && opentokSubscriber.videoWidth()) {
        var videoWidth = opentokSubscriber.videoWidth();
        var videoHeight = opentokSubscriber.videoHeight();
        var videoRatio = videoWidth / videoHeight;
        var videoRatioPercent = parseInt(Math.round(1 / videoRatio * 100));
      }

      $("#subscribers").css({ paddingBottom: videoRatioPercent + "%" });
      $("#videoOverlay").css({ paddingBottom: videoRatioPercent + "%" });
      $("#remoteVideoOverlay").css({ left: "0px", bottom: "0px" });
      // top: parseInt(Math.round(w * videoRatioPercent)) +"px", paddingBottom: videoRatioPercent +"%"

    } else {
      // Vertically centered

      // remote video overlay
      var videoHeight = h;
      var videoWidth = w;
      $("#remoteVideoOverlay").css({ left: 0.0, width: Math.round(videoWidth) });
    }

    $("#screenSharingPublisher .OT_video-container").css({ width: "100%", height: "100%", left: 0 });

    var overlayEl = q("#videoOverlay");
    overlayEl.style.width = "";
    overlayEl.style.height = "";
    overlayEl.style.top = "";
    overlayEl.style.left = "";
    overlayEl.style.display = "";
    $("#videoOverlay").show();
  }

  if (sessionIsViewer) {
    $("#multipartyViewerControls").show();
  } else {
    $("#multipartyViewerControls").hide();
  }
}

var flipResizeCounter = 0;
var flipResizeInterval = null;

function repeatCenterRemoteVideo() {
  // fix for opentok v2.0.14.1 - after flip, video element was 1px x 1px, so we have to re-position it
  flipResizeCounter = 0;
  window.clearInterval(flipResizeInterval);
  flipResizeInterval = window.setInterval(function () {
    centerRemoteVideo();

    flipResizeCounter++;
    if (flipResizeCounter > 50) {
      window.clearInterval(flipResizeInterval);
    }
  }, 250);
}

function socketIsConnected() {
  return isConnected;
}

function isIframe() {
  return window.self !== window.parent;
}

function isCustomDomain() {
  return getURLParameter("domain")
    && getURLParameter("domain").indexOf("." + ROOT_DOMAIN) > -1
    && !getURLParameter("public_key");
}

function getCustomDriveUrl() {
  if (!isCustomDomain()) {
    return "drive." + ROOT_DOMAIN;
  }
  return getURLParameter("domain");
}

var googleSso = false;
var samlSso = false;

function showLoginForm() {
  if (isIframe() && (isCustomDomain() || configuration.data.is_fleet)) {
    var title = "";
    if (configuration.data.fleet_name) {
      title = configuration.data.fleet_name;
    }
    if (configuration.data.allow_native) {
      document.querySelector("#loginForm .accessories").style.display = "block";
    }
    $("#ssoTitle").text(title);
    googleSso = configuration.data.google_sso_configured;
    samlSso = configuration.data.idp_realm;
    native = configuration.data.show_native_button;
    if (googleSso) {
      $("#googleSsoNext").val("//admin." + ROOT_DOMAIN + "/login-sso-callback?next=" + encodeURIComponent("//" + getCustomDriveUrl()));
      $("#googleSsoSection").show();
    } else {
      $("#googleSsoSection").hide();
    }
    if (samlSso) {
      $("#samlSsoNext").val("//api." + ROOT_DOMAIN + "/api/v1/user/saml/login/" + encodeURIComponent(samlSso));
      $("#samlSsoNextNext").val("//admin." + ROOT_DOMAIN + "/login-sso-callback?next=" + encodeURIComponent("//" + getCustomDriveUrl()));
      $("#samlSsoSection").show();
      if (configuration.data.idp_button_text) {
        $("#samlSsoSection input[type=submit]").val(configuration.data.idp_button_text);
      }
    } else {
      $("#samlSsoSection").hide();
    }
    if (native) {
      $("#doubleLoginSection").show();
    } else {
      $("#doubleLoginSection").hide();
    }
    if (googleSso || samlSso) {
      $("#ssoButtons").show();
      $("#ssoBack").hide();
      $("#loginForm").hide();
    } else if (native) {
      showDoubleLoginForm();
    } else {
      $("#loginForm").hide();
    }
    $("#ssoSection").show();
    $("#login").show();
  } else {
    $("#login").show();
    $("#ssoSection").hide();
    showDoubleLoginForm();
  }
}

function showDoubleLoginForm() {
  if (googleSso || samlSso) {
    $("#ssoBack").show();
  } else {
    $("#ssoBack").hide();
  }
  $("#googleSsoNext").val("");
  $("#ssoButtons").hide();
  $("#loginForm").show();
}

function matchFleet() {
  var email = q("#usernameLoginField").value;
  if (email && email.indexOf("@") >= 0 && email.indexOf(".") > email.indexOf("@")) {
    DBLUserMatch(email, (data) => {
      var url;
      try {
        url = new URL("https://" + data.subdomain + "." + ROOT_DOMAIN);
        url.search = window.location.search;
      } catch (e) { }
      if (url && data.subdomain && data.name) {
        q("#matchedFleetButton").value = "Go to " + data.name;
        q("#matchedFleetButton").onclick = () => {
          window.location = url.href;
        };
        q("#matchedFleetButton").style.display = "block";
      } else {
        q("#matchedFleetButton").style.display = "none";
      }
    }, (data) => {
      // fail
      q("#matchedFleetButton").value = "";
      q("#matchedFleetButton").onclick = null;
      q("#matchedFleetButton").style.display = "none";
    });
  }
}

function login() {
  var username = $("#loginForm")[0].elements["username"].value.toLowerCase();
  var password = $("#loginForm")[0].elements["password"].value;

  $("#content").hide();
  $("#login").hide();
  $("#loginForm")[0].elements["username"].value = "";
  $("#loginForm")[0].elements["password"].value = "";

  DBLUserLogin(username, password);
}

function createAccount() {
  var username = $("#createAccountForm")[0].elements["username"].value.toLowerCase();
  var email = $("#createAccountForm")[0].elements["email"].value.toLowerCase();
  var password = $("#createAccountForm")[0].elements["password"].value;
  var password2 = $("#createAccountForm")[0].elements["password2"].value;

  if (password != password2) {
    nonModalAlert("Error", "Password fields don't match.");
    return;
  }
  if (!DBLUserValidateUsername(username)) {
    nonModalAlert("Error", "Username is not valid. Minimum 3 characters. Characters allowed: a-z, 0-9, and _");
    return;
  }

  $("#content").hide();
  $("#createAccount").hide();
  $("#createAccountForm")[0].elements["username"].value = "";
  $("#createAccountForm")[0].elements["email"].value = "";
  $("#createAccountForm")[0].elements["password"].value = "";
  $("#createAccountForm")[0].elements["password2"].value = "";

  DBLUserCreateAccount(username, email, password);
}

function sendForgotPasswordLink() {
  var email = $("#forgotPasswordForm")[0].elements["email"].value;

  $("#content").hide();
  $("#forgot").hide();
  $("#forgotPasswordForm")[0].elements["email"].value = "";

  DBLUserSendForgotPasswordLink(email);
}

function sendSetPassword() {
  var token = $("#setPasswordForm")[0].elements["token"].value;
  var password = $("#setPasswordForm")[0].elements["password"].value;
  var password2 = $("#setPasswordForm")[0].elements["password2"].value;

  $("#content").hide();
  $("#setPassword").hide();
  $("#setPasswordForm")[0].elements["token"].value = "";
  $("#setPasswordForm")[0].elements["password"].value = "";
  $("#setPasswordForm")[0].elements["password2"].value = "";

  DBLUserSetPassword(token, password, password2);
}

function didLogin(justAuthenticated = false) {
  if (currentUser) {

    if (justAuthenticated) {
      if (socket) {
        socket.disconnect();
      }
      setupSocket();
      return;
    }

    if (getURLParameter("next")) {
      var url = decodeURIComponent(getURLParameter("next"));
      var destination;
      try {
        destination = new URL(url);
      } catch (e) { }
      if (destination && destination.protocol === window.location.protocol && destination.hostname.endsWith("." + ROOT_DOMAIN) >= 0) {
        window.location = url;
      }
    }

    $("#content").hide();
    $("#login").hide();
    if (currentUser.username == "public") {
      $("#currentUsername .company").html("");
      $("#currentUsername .company").hide();
      $("#currentUsername .username").html("&nbsp;");
      $("#accountOrganization").html("&nbsp;");
      $("#accountUsername").html("&nbsp;");
      $("#accountEmail").html("&nbsp;");
    } else {
      $("#currentUsername .company").html("");
      $("#currentUsername .company").hide();
      $("#currentUsername .username").html(currentUser.resolvedDisplayName());
      $("#accountOrganization").html("(None)");
      $("#accountUsername").html(currentUser.displayName || currentUser.username);
      $("#accountEmail").html(currentUser.email);
    }
    $("#currentUser").show();
    $("#settingsButton").show();
    $("#supportButton").hide();

    if (currentUser.canChangePassword()) {
      $("#changePasswordButton").show();
    } else {
      $("#changePasswordButton").hide();
    }

    if (isChromeAndroid()) {
      $("#warning").hide();
    } else {
      // $("#warning").show();
    }

    if (getURLParameter("domain") && getURLParameter("public_key")) {
      $("#warning").hide();
      $("#segmentedRobots").hide();
      $("#currentUsername").css({ opacity: 0 });
      $("#currentUser .popover .private").hide();
      showPublicRobots();
    } else {
      $("#segmentedRobots").show();
    }

    var options = { "userId": null, "installationId": getCurrentInstallation().getKey(), "clientType": 3 };
    if (getURLParameter("public_key").length > 0) {
      options.public_key = getURLParameter("public_key");
    }
    sendCommandWithData(kDRCommandDriverIsReady, options);

    shouldZoomAfterLoadingRobots = true;
    getListOfRobots(true);
    fireCalendarEvents();

    if (getURLParameter("connectTo").length > 10) {
      connectTo(getURLParameter("connectTo"));
      window.history.pushState("clean", window.title, "/");
    } else if (getURLParameter("invite-accept").length > 10) {
      prepareToShowInvitation(getURLParameter("invite-accept"));
    }

    loadConfiguration();

    // visitor pass
    // if (isMobileSafari()) {
    // 	showMessage("visitorPassPrompt");
    // } else {
    checkForVisitorPass();
    // }

    // Pre-authorize webcam
    // if (nativeWebRTC) {
    // 	nativeWebRTC.startWebcam();
    // }
  }
}

function checkForVisitorPass() {
  if (getURLParameter("tls").length > 10) {
    var tlsKey = getURLParameter("tls");

    var request = getSharedDBLHTTPClient().request("GET", kAPIEndpointTLS, { access_key: tlsKey });
    var success = function (data) {
      // success
      console.log("got response: " + data.robot);

      if (data.success == true && data.robot) {
        sessionVisitorPass = data;
        connectTo(data.robot, tlsKey);
      } else {
        if (currentUser && currentUser.username == "public") {
          logOut();
        }
        window.setTimeout(function () {
          nonModalAlert("Invalid", $("#stringInvalidTempLink").html());
        }, 100);
      }
    };
    var fail = function (data) {
      // failure
      if (currentUser && currentUser.username == "public") {
        logOut();
      }
      window.setTimeout(function () {
        nonModalAlert("Invalid", $("#stringInvalidTempLink").html());
      }, 100);
    };
    request.send(success, fail);
  }
}

function prepareToShowInvitation(key) {
  if (currentUser && !currentUser.canHandleInvite()) {
    nonModalAlert("Already on Fleet", "You are already a member of a fleet via SSO, so you cannot join a different fleet.");
    return;
  }
  var client = MakeDBLHTTPClient("https://admin." + ROOT_DOMAIN + "/");
  var params = { "key": key };
  var request = client.request("GET", "invite-accept", params);
  request.send(function (data) {
    // success
    if (data && data.company_name && data.admin_email) {
      $("#acceptInvitationName").html(data.company_name);
      $("#acceptInvitationAdminEmail").html(data.admin_email);
      $("#acceptInvitationUsername").html(currentUser.username);
      $("#acceptInvitationUserEmail").html(currentUser.email);
      showMessage("acceptInvitation");
      getCurrentUserData(function () {
        $("#acceptInvitationUserEmail").html(currentUser.email);
      });
    }
  }, function () {
    // failure
    console.log("failed to load invitation");
  });
}

function acceptInvitation(key) {
  var client = MakeDBLHTTPClient("https://admin." + ROOT_DOMAIN + "/");
  var params = {
    "key": key
  };
  var request = client.request("POST", "invite-accept", params);
  request.send(function (data) {
    // success
    console.log(data);
    if (data && data.success == true) {
      hideMessage("acceptInvitation");
    } else {
      nonModalAlert("Failed", "Failed to accept invitation.");
    }
  }, function () {
    // failure
    nonModalAlert("Failed", "Failed to accept invitation.");
  });
}

function didLogOut() {
  $("#content").show();
  switchToLogin();
  $("#currentUsername .company").html("");
  $("#currentUsername .username").html("");
  $("#currentUser").hide();
  $("#robots").hide();
  $("#noLocationBubble").hide();
  $("#segmentedRobots").hide();
  $("#settingsButton").hide();
  $("#supportButton").show();
  map.removeAllMarkers();
  $("#list .robotsList").html("");
  robots = [];
  robotsPrivate = [];
  robotsPublic = [];
  $("#usernameField").select();
  currentUser = null;
  loadConfiguration();
  if (socket) {
    socket.disconnect();
  }
  window.setTimeout(setupSocket, 200);
}

function getListOfRobots(preheat) {
  sendCommandWithData(kDRCommandRequestListOfRobots, { preheat: (preheat) ? true : false });
}

function deployKickstands() {
  sendCommand(kDRCommandKickstandDeploy);
}

function retractKickstands() {
  sendCommand(kDRCommandKickstandRetract);
}

function flip() {
  if (!isFlipped) {
    resetZoom();
  }

  isFlipped = !isFlipped;
  updateUserInterface();
  sendCommand(kDRCommandFlipCamera);

  if (remoteRobotSupports("preflippedDownCamera")) {
    // do nothing
  } else {
    if (isFlipped) {
      window.setTimeout(function () {
        $("#subscribers .remoteVideo video").addClass("flipped");
      }, 1000);
      $(".remoteVideo").css("z-index", "1");
    } else {
      window.setTimeout(function () {
        $("#subscribers .remoteVideo video").removeClass("flipped");
      }, 1000);
      $(".remoteVideo").css("z-index", "1");
    }

    // dim the video for a second
    $("#shade").css("display", "block");
    window.setTimeout(function () {
      $("#shade").css("display", "none");
    }, 1500);
  }

  repeatCenterRemoteVideo();
}

function zoomIn() {
  mapboxMap.zoomBy(1);
}

function zoomOut() {
  mapboxMap.zoomBy(-1);
}

function logOut() {
  currentUser.logout(() => {
    didLogOut();
  });
  currentUser = null;
}

function logOutConfirm() {
  $('#settings').hide();
  logOut();
}

function sendCommand(commandId) {
  if (socket) {
    var out = new Object;
    out.c = commandId;
    socket.emit("message", out);

    if (commandId == kDRCommandPoleStand || commandId == kDRCommandPoleSit) {
      statsPole = 1;
    }
  }
}

function sendCommandWithData(commandId, data) {
  if (!remoteRobotSupports("nativeWebRTC") && (commandId == kDRCommandControlDrive || commandId == kDRCommandTurnBy) && $("#peerToPeerDriving").is(':checked')) {
    // send peer to peer driving commands
    var signalType = (commandId == kDRCommandControlDrive) ? "kDRCommandControlDrive" : ((commandId == kDRCommandTurnBy) ? "kDRCommandTurnBy" : "");
    if (opentokSession != undefined && opentokSubscriber != undefined) {
      opentokSession.signal({
        type: signalType,
        data: JSON.stringify(data),
      }, function (error) {
        if (error) {
          console.log("signal error: " + error.reason);
        }
      });
    }
  } else if (!remoteRobotSupports("nativeWebRTC") && (commandId == kDRCommandControlDrive || commandId == kDRCommandTurnBy) && relaySocket != undefined) {
    var out = new Object;
    out.c = commandId;
    data.toInstallationId = sessionRobotInstallationId;
    out.d = data;
    relaySocket.emit("message", out);
  } else {
    // regular commands via node server
    if (socket) {
      var out = new Object;
      out.c = commandId;
      out.d = data;
      socket.emit("message", out);
    }
  }
}

function connectTo(installationId, access_key, mediaStream) {
  if (!mediaStream && preCallAllowed) {
    showPreCallWebcam(installationId, access_key);
    return;
  }

  var options = { "robotInstallationId": installationId };
  if (access_key) {
    options.access_key = access_key;
  }
  if (nativeWebRTC) {
    options.qualityPreference = d3DefaultQualityPreference;
  } else {
    options.qualityPreference = defaultQualityPreference;
  }
  if (currentUser && currentUser.isLoggedIn()) {
    if (currentUser.username) {
      options.username = currentUser.username;
    }
    if (currentUser.email) {
      options.email = currentUser.email;
    }
  }
  if (nativeWebRTC && nativeWebRTC.iceConfig) {
    options.iceServers = nativeWebRTC.iceConfig;
  }
  sendCommandWithData(kDRCommandDriverToRobotHello, options);
  sessionRobotInstallationId = installationId;
  beginSession();

  // relay server
  // var s = $("#settingsForm input[name='relayServer']:checked").val();
  // if (s != "") {
  // 	setRelayServer(s);
  // }

  for (var i = 0; i < robots.length; i++) {
    var r = robots[i];
    if (r.dictionary.installationId == installationId) {
      $("#robotName").html(r.dictionary.nickname);
      if (r.dictionary.locationLabel) {
        q(".robotLocation").innerText = r.dictionary.locationLabel;
      } else {
        var lat = roundToPlaces(r.dictionary.latitude, 5);
        var lng = roundToPlaces(r.dictionary.longitude, 5);
        reverseGeocodeLatLng("robotLocation", lat, lng);
      }
    }
  }
}

function disconnect() {
  if (sessionIsViewer) {
    sendCommandWithData(kDRCommandViewerDidLeaveSession, { viewerId: multipartyViewerId });
    console.log("disconnected, was viewer");
  } else {
    window.setTimeout(function () {
      sendCommand(kDRCommandGoodbye);
      console.log("disconnected, sending goodbye");
    }, 1000);
  }
  sendSessionLog(kDREndTypeLocal);
  endSession();

  map.removeAllMarkers();
  $("#list .robotsList").html("");
  lastRobotsString = null;
}

function resetSessionVariables() {
  inSession = false;
  isFlipped = false;
  isMuted = false;
  speakerIsMuted = false;
  kickstandState = kDRKickstand_stateNone;
  poleIsMoving = false;
  statusValues = {};
  lastVolume = 0;
  justGotVolume = false;
  blinkArray = [];
  pendingNativeWebRTCSignals = null;
  nightVisionEnabled = false;
  tagsEnabled = false;
  sessionBeginDate = null;
  sidebarApps = [];
  sidebarAppWidth = 300;
  sidebarAppDefaultWidth = 300;
  sidebarAppMinWidth = 250;
  sidebarAppMaxWidth = 450;
  sidebarAppInterceptStop = false;
  clearKeyboardCommands();
}

function beginSession() {
  // if (currentUser == null) { return; }

  centerRemoteVideo();

  $("#connecting").show();
  $("#resetZoomButton").hide();
  $("#resetExposureButton").hide();
  $("#localVideo .audioLevel").hide();
  $("#remoteVideoOverlay").hide();
  $("#videoOverlay").hide();
  $("#session").show();
  $("#map").hide();
  $("#header").hide();
  $("#zoomers").hide();
  $("#noLocationBubble").hide();

  resetSessionVariables();
  sessionBeginDate = Date.now();
  window.setTimeout(() => {
    inSession = true;
  }, 3000);

  updateUserInterface();

  if (statsInterval) {
    window.clearInterval(statsInterval);
  }
  statsInterval = window.setInterval(updateStats, 500);

  if (sessionIsViewer) {
    $("#sessionButtons").hide();
    $("#session #sessionHeader").hide();
    $("#session").addClass("touchControlsHidden");
    if (getURLParameter("viewerAudioOnly")) {
      $("#session").addClass("audioOnly");
    } else {
      $("#session").removeClass("audioOnly");
    }
  } else {
    $("#session").removeClass("touchControlsHidden");
    $("#session").removeClass("audioOnly");
    if (!showToolbar) {
      $("#session").addClass("hiddenToolbar");
    } else {
      $("#session").removeClass("hiddenToolbar");
      $("#sessionButtons").show();
      $("#session #sessionHeader").show();
    }

    window.clearInterval(commandsTimer);
    commandsTimer = window.setInterval(fireDriveCommands, 200);

    // window.setTimeout(beginFreezeDetection, 5000);

    if (drivingTallInterval) {
      window.clearInterval(drivingTallInterval);
    }
    drivingTallInterval = window.setInterval(checkDrivingTall, 1000);

    if (!isChromeAndroid()) {
      mouseMoveInterval = window.setInterval(function () {
        if (mouseMoveCountdown == 0) {
          if (!$("#sessionHeader .popover").is(":visible") && mouseY > 80) {
            $("#session #sessionHeader").css({ opacity: 0.0 });
            $("#remoteVideoOverlay .button").addClass("hidden");
            // $("#localVideoOverlay .button").addClass("hidden");
          }
          mouseMoveCountdown = -1;
        } else {
          mouseMoveCountdown--;
        }
        if (mouseMoved) {
          $("#session #sessionHeader").css({ opacity: 1.0 });
          $("#remoteVideoOverlay .button").removeClass("hidden");
          // $("#localVideoOverlay .button").removeClass("hidden");
          mouseMoved = false;
        }
      }, 100);
      $("#session").mousemove(function (e) {
        mouseMoveCountdown = 30;
        mouseMoved = true;
        mouseY = e.pageY;
      });
      $("#session").mouseleave(function (e) {
        mouseMoveCountdown = 0;
        mouseMoved = false;

        $("#session #sessionHeader").css({ opacity: 0.0 });
        $("#remoteVideoOverlay .button").addClass("hidden");
        // $("#localVideoOverlay .button").addClass("hidden");
      });
    }
  }

  if (!sessionStatsInterval) {
    sessionStatsInterval = window.setInterval(function () {
      sendSessionLog(false);
    }, 10000);
  }

  // centerRemoteVideoInterval = window.setInterval(function () {
  // 	centerRemoteVideo();
  // }, 100);
}

window.onmessage = function (event) {
  // messages from sidebar iframe
  if (event.data) {
    switch (event.data.c) {
      case "gui.accessoryWebView.message.to":
        if (event.data.d == "_requestToStartMultiViewer") {
          resetVideoLink(true);
        } else {
          sendCommandWithData(kDRCommandMessageToAccessoryWebView, event.data.d);
        }
        break;
      case "interceptStop":
        sidebarAppInterceptStop = !!event.data.d;
        break;
      case "keydown":
        processKeyDown(event.data.d);
        break;
      case "keyup":
        processKeyUp(event.data.d);
        break;
      case "disableParentAudio":
        if (nativeWebRTC && nativeWebRTC.isActive()) {
          nativeWebRTC.mutePublisher();
          nativeWebRTC.muteRemote();
          sidebarAppDisabledAudio = true;
          updateUserInterface();
        }
        break;
      case "enableParentAudio":
        if (nativeWebRTC && nativeWebRTC.isActive()) {
          nativeWebRTC.unmutePublisher();
          nativeWebRTC.unmuteRemote();
          updateUserInterface();
        }
        break;
      case "reset":
        if (sidebarApp && sidebarApp.key) {
          startSidebarAppByKey(sidebarApp.key);
        }
        break;
      case "resetRemote":
        if (sidebarApp && sidebarApp.key) {
          sidebarLoaded();
        }
        break;
      case "requestIceConfig":
        var iframe = document.getElementById("sidebarIframe");
        if (iframe && iframe.contentWindow) {
          iframe.contentWindow.postMessage({ c: "iceConfig", d: iceConfig }, "*");
        }
        break;
      case "stop":
        if (sidebarApp) {
          forceStopSidebarApp();
        }
        break;
    }
  }
};

function setupNativeWebRTCSessionInterface(apps) {
  $("#session").addClass("webrtc");
  $("#session").removeClass("legacy");
  loadSidebarURL(sidebarURL, sidebarStartOpen);
  centerRemoteVideo();
  if (mouseMoveInterval) {
    window.clearInterval(mouseMoveInterval);
    mouseMoveInterval = null;
  }
  window.onmousewheel = document.onmousewheel = null;
  $("#session").unbind("mousemove");
  $("#session").unbind("mouseleave");
  $("#session #sessionHeader").css({ opacity: 1.0 });
  hideTargetMessage();
  if (!drawDepth) {
    drawDepth = new DRDrawDepth();
    setupCtrlMenu();

  } else {
    drawDepth.updateCanvasSize();
  }

  if (!drawMinimap) {
    drawMinimap = new DRDrawMinimap();
  }
  if (drawDepth) {
    drawDepth.mouseTargetAllowed = false;
    drawDepth.setDocks(null);
    drawDepth.setTags(null);
  }

  $("#graphicsLevelOption").show();
  $("#obstacleViewOption").show();
  $("#opentokStats").hide();
  $("#webrtcStats").show();

  if (apps && Array.isArray(apps)) {
    sidebarApps = apps;
    html = "";
    for (var i = 0; i < apps.length; i++) {
      if (apps[i].hidden) {
        continue;
      }
      if (apps[i].sidebar && Array.isArray(apps[i].sidebar.requires)) {
        if (apps[i].sidebar.requires.indexOf("getDisplayMedia") >= 0
          && !("mediaDevices" in navigator && "getDisplayMedia" in navigator.mediaDevices)) {
          // requires screen capture and we don't have it
          continue;
        }
        if (apps[i].sidebar.requires.indexOf("multipleGetUserMedia") >= 0 && isTouchDevice) {
          continue;
        }
      }
      var iconClass = "";
      var iconStyle = "";
      if (apps[i].sidebar && apps[i].sidebar.iconUrl) {
        iconStyle = `background: url('${apps[i].sidebar.iconUrl}'); background-size: 100% 100%;`;
      } else {
        iconClass = apps[i].iconClass ? apps[i].iconClass : "genericAppIcon";
      }
      html += `<div class="button" id="appButton_${apps[i].key}" onclick="toggleAppByKey('${apps[i].key}');" title="${apps[i].description}">
				<div class="icon ${iconClass}" style="${iconStyle}"></div>
				<div class="name">${apps[i].name}</div>
			</div>`;
    }
    q("#appList").innerHTML = html;
    if (html == "") {
      q("#sidebarAppsButton").style.display = "none";
    } else {
      q("#sidebarAppsButton").style.display = "inline";
    }
  } else {
    sidebarApps = [];
    q("#appList").innerHTML = "";
    q("#sidebarAppsButton").style.display = "none";
  }

  window.setTimeout(() => {
    centerRemoteVideo();
    if (drawDepth) {
      if (obstacleAvoidanceLevel == 2) {
        drawDepth.mouseTargetAllowed = true;
      }
    }
  }, 3000);
}

function setupOpentokSessionInterface() {
  if (nativeWebRTC) {
    nativeWebRTC.end();
  }

  $("#localVideo").show();
  $("#session").removeClass("webrtc");
  $("#session").addClass("legacy");
  $("#session").removeClass("hiddenToolbar");
  $("#opentokStats").show();
  $("#webrtcStats").hide();

  sidebarClose();
  $("#sidebarOpener").addClass("hidden");
  $("#sidebarIframe").attr("src", "");
  centerRemoteVideo();

  drawDepth = null;
  drawMinimap = null;

  $("#graphicsLevelOption").hide();
  $("#obstacleViewOption").hide();

  loadSidebarURL(null, null);
}

function beginFreezeDetection() {
  // freeze detection
  var videoCanvas = null;
  var videoContext = null;
  var lastVideoCanvas = null;
  var lastVideoContext = null;
  var remoteVideoIsFrozen = false;
  var videoMetaDataLoaded = false;
  window.clearInterval(freezeDetectionTimer);
  freezeDetectionTimer = window.setInterval(function () {
    var videoElement = $("#subscribers video");
    if (videoElement.length > 0) {
      videoElement = videoElement[0];

      $("#subscribers video").bind("loadedmetadata", function () {
        videoMetaDataLoaded = true;
      });
    }

    if (videoElement.nodeName == "VIDEO" && videoMetaDataLoaded) {
      // new video canvas
      if (!videoCanvas) {
        videoCanvas = document.createElement("canvas");
        videoCanvas.width = videoElement.videoWidth;
        videoCanvas.height = videoElement.videoHeight;
        videoContext = videoCanvas.getContext("2d");
      }
      videoContext.drawImage(videoElement, 0, 0);

      // compare the two frames
      if (lastVideoCanvas) {
        if (videoCanvas.toDataURL() == lastVideoCanvas.toDataURL()) {
          // FREEZE DETECTED
          if (!remoteVideoIsFrozen) {
            console.log("Freeze detected");
            remoteVideoIsFrozen = true;
            sendCommandWithData(kDRCommandRemoteVideoFroze, {
              driverClientDescription: navigator.userAgent
            });
            displayHoverMessage($("#stringReconnecting").html() + "...", $("#stringTheVideoSignalFroze").html());
          }
        } else if (remoteVideoIsFrozen && opentokSubscriber != undefined && opentokSubscriber.stream.hasVideo == true) {
          console.log("Unfrozen detected");
          remoteVideoIsFrozen = false;
          sendCommand(kDRCommandRemoteVideoUnfroze);
          hideHoverMessage();
        }
      }

      // save the frame for next time
      if (!lastVideoCanvas) {
        lastVideoCanvas = document.createElement("canvas");
        lastVideoCanvas.width = videoElement.videoWidth;
        lastVideoCanvas.height = videoElement.videoHeight;
        lastVideoContext = lastVideoCanvas.getContext("2d");
      }
      lastVideoContext.drawImage(videoElement, 0, 0);
    }

  }, 2000);
}

function endSession() {
  if (!inSession) {
    return;
  }
  inSession = false;
  doubleSessionId = -1;
  hideHoverMessage();
  $("#robots").show();
  $("#session").hide();
  $("#connecting").hide();
  $("#map").show();
  $("#header").show();
  $("#zoomers").show();
  if (commandsTimer) {
    window.clearInterval(commandsTimer);
    commandsTimer = null;
  }
  if (freezeDetectionTimer) {
    window.clearInterval(freezeDetectionTimer);
    freezeDetectionTimer = null;
  }
  if (mouseMoveInterval) {
    window.clearInterval(mouseMoveInterval);
    mouseMoveInterval = null;
  }
  if (centerRemoteVideoInterval) {
    window.clearInterval(centerRemoteVideoInterval);
    centerRemoteVideoInterval = null;
  }
  if (sessionStatsInterval) {
    window.clearInterval(sessionStatsInterval);
    sessionStatsInterval = null;
  }
  window.onmousewheel = document.onmousewheel = null;
  $("#session").unbind("mousemove");
  $("#session").unbind("mouseleave");

  q("#toolbarButtonsWithApps").style.display = "none";
  q("#toolbarButtonsLegacy").style.display = "none";
  q("#photoButton2").style.display = "none";

  $("#multipartyAudioLevels").hide();
  $("#multipartyAudioLevels .viewer").remove();
  $("#multipartyViewerControls").hide();
  sessionIsViewer = false;
  multipartyViewerId = null;
  multipartyViewers = [];

  $("#session").removeClass("webrtc");
  hideTargetMessage();

  document.title = "Double";

  opentokDisconnect();
  if (nativeWebRTC) {
    nativeWebRTC.end();
  }
  if (screenSharingWebRTC && screenSharingWebRTC.isActive()) {
    screenSharingWebRTC.end();
  }

  alwaysOnFloorViewEnabled = true;
  cameraKitEnabled = false;
  sessionRobotInstallationId = undefined;
  clearRelayServer();

  if (drawDepth) {
    drawDepth.endSession();
  }
  if (drawMinimap) {
    drawMinimap.hide();
  }

  sidebarClose();
  $("#sidebarOpener").addClass("hidden");
  $("#sidebarIframe").attr("src", "");
  highlightSidebarAppKey(null);

  if (statsInterval) {
    window.clearInterval(statsInterval);
    statsInterval = undefined;
  }

  if (currentUser && currentUser.username == "public" && getURLParameter("tls").length > 0) {
    logOut();
  }

  hideAllMessages();

  resetSessionVariables();

  window.setTimeout(() => { sendCommand(kDRCommandRequestListOfRobots); }, 500);
  window.setTimeout(() => { sendCommand(kDRCommandRequestListOfRobots); }, 1000);
  window.setTimeout(() => { sendCommand(kDRCommandRequestListOfRobots); }, 3000);

  // Optional redirect after Visitor Pass
  if (sessionVisitorPass && sessionVisitorPass.after_url) {
    try {
      var destination = new URL(sessionVisitorPass.after_url);
      if (destination && destination.protocol !== "javascript:" && destination.protocol !== "file:") {
        window.location = destination.href;
      }
    } catch (e) {
      try {
        var destination = new URL("https://" + sessionVisitorPass.after_url);
        if (destination && destination.protocol !== "javascript:" && destination.protocol !== "file:") {
          window.location = destination.href;
        }
      } catch (e) { }
    }
  }
  sessionVisitorPass = null;
}

function fireDriveCommands() {
  var drive = (forwardState == 1) ? -100 : ((backwardState) ? 100 : 0);
  var turn = (leftState == 1) ? 100 : ((rightState) ? -100 : 0);
  var pole = (poleUpState == 1) ? 200 : ((poleDownState) ? -200 : 0);

  if (forwardState == 0 && backwardState == 0 && throttleSpeed != 0) {
    drive = throttleSpeed * 100;
  }
  if (leftState == 0 && rightState == 0 && turnSpeed != 0) {
    turn = turnSpeed * 100 * -1;
  }

  // Only send neutral drive/turn commands 10 times then stop
  if (drive == 0 && turn == 0) {
    neutralDriveCommandsSent++;
  } else {
    neutralDriveCommandsSent = 0;
  }

  if (neutralDriveCommandsSent < 10) {
    //console.log("drive: " + drive + ", turn: " + turn);
    sendCommandWithData(kDRCommandControlDrive, { "drive": drive, "turn": turn, "powerDrive": powerDriveOn });
  }

  if (robotSpeakerVolumeToSend != -1) {
    sendCommandWithData(kDRCommandVolumeChanged, { volume: robotSpeakerVolumeToSend });
    robotSpeakerVolumeToSend = -1;
  }

  if (poleToSend != -1) {
    if (remoteRobotSupports("poleTargets")) {
      sendCommandWithData(kDRCommandControlPole, { "target": poleToSend });
    }
    poleToSend = -1;
  } else {
    // Only send neutral pole commands 10 times then stop
    if (pole == 0) {
      neutralPoleCommandsSent++;
    } else {
      neutralPoleCommandsSent = 0;
    }

    if (neutralPoleCommandsSent < 10) {
      //console.log("pole: " + pole);
      sendCommandWithData(kDRCommandControlPole, { "pole": pole });
    }
  }

  if (nextZoomCenter) {
    sendZoom();
  }

  // send brightness
  var value = $("#brightnessSlider").val() / 100;
  if (lastBrightnessSent != -1 && lastBrightnessSent != value) {
    sendCommandWithData(kDRCommandSetRobotScreenBrightness, { "brightness": value });
    lastBrightnessSent = value;
  }

  if (tiltSpeed != 0 || lastTiltSpeed != tiltSpeed) {
    sendCommandWithData(kDRCommandTilt, { speed: tiltSpeed });
    lastTiltSpeed = tiltSpeed;
  }

  sendPtz();

  if (drive != 0) {
    statsDrive = 1;
  }
  if (powerDriveOn) {
    statsPowerDrive = 1;
  }
  if (turn != 0) {
    statsTurn = 1;
  }
  if (pole != 0) {
    statsPole = 1;
  }
}

function sendPtz() {
  var ptz = null;
  var ctrlMenuPtz = ctrlMenuPtzData();
  if (ctrlMenuPtz) {
    ptz = ctrlMenuPtz;
  }
  if (ptzStates.left) {
    ptz = ptzData(-1, 0);
  } else if (ptzStates.right) {
    ptz = ptzData(1, 0);
  } else if (ptzStates.up) {
    ptz = ptzData(0, -1);
  } else if (ptzStates.down) {
    ptz = ptzData(0, 1);
  }
  if (ptz) {
    sendCommandWithData(kDRCommandPTZMove, ptz);
    ptzStates.didSend = true;
  } else if (ptzStates.didSend) {
    sendCommand(kDRCommandPTZStop);
    ptzStates.didSend = false;
  }
}

function ptzData(x, y) {
  return {
    x: x * 2.0,
    y: y * 2.0,
    allowTurn: true
  };
}

function setupCtrlMenu() {
  ctrlMenuDiv = $("#ctrlMenu");
  ctrlMenuArrowContainerDiv = $("#ctrlMenu .arrowContainer");
  $(document).mousemove(function (e) {
    ctrlMenuMouseX = e.pageX;
    ctrlMenuMouseY = e.pageY;
    updateCtrlMenu();
  });
  $("#ctrlMenu .centerDot").mousedown(function (e) {
    e.preventDefault();
    e.stopPropagation();

    if (shiftKeyDown) {
      if (drawDepth) {
        drawDepth.zoomOut();
      }

      $("#ctrlMenu .burst").removeClass("shrink");
      window.setTimeout(() => {
        $("#ctrlMenu .burst")
          .on("animationend", function () { $(this).removeClass("shrink"); })
          .addClass("shrink");
      }, 1);

    } else {

      var g = $("#graphicsContainer");
      var percent = {
        x: ((ctrlMenuMouseX - g.offset().left) / g.width() - 0.5) * 2,
        y: ((ctrlMenuMouseY - g.offset().top) / g.height() - 0.5) * 2
      };
      if (drawDepth) {
        drawDepth.zoomIn(percent.x, percent.y);
      }

      $("#ctrlMenu .burst").removeClass("grow");
      window.setTimeout(() => {
        $("#ctrlMenu .burst")
          .on("animationend", function () { $(this).removeClass("grow"); })
          .addClass("grow");
      }, 1);
    }
  });
  $("#ctrlMenu .centerDot").mouseup(function (e) {
    rightClickDown = false;
    updateCtrlMenu();
  });
  $("#ctrlMenu .arrowContainer").mouseup(function (e) {
    rightClickDown = false;
    updateCtrlMenu();
  });
  $("#ctrlMenu").mouseup(function (e) {
    rightClickDown = false;
    updateCtrlMenu();
  });
}

function ctrlMenuPtzData() {
  if (!ctrlMenuDiv || !ctrlMenuDiv.is(":visible") || (ctrlMenuDiffenceX == 0 && ctrlMenuDiffenceY == 0)) {
    return null;
  }
  return {
    x: Math.max(-1.0, Math.min(1.0, ctrlMenuDiffenceX / 100)) * 0.7,
    y: Math.max(-1.0, Math.min(1.0, ctrlMenuDiffenceY / 100)) * 0.7,
    allowTurn: true
  };
}

function ctrlMenuVisible() {
  return (ctrlMenuDiv && ctrlMenuDiv.is(":visible"));
}

function updateCtrlMenu(keyEvent, touchEvent) {
  if (!ctrlMenuDiv) { return; }

  if (!ctrlMenuWasVisible && ((keyEvent && keyEvent.ctrlKey) || touchEvent || rightClickDown)) {
    // ctrl key down, so reset
    ctrlMenuDiffenceX = 0;
    ctrlMenuDiffenceY = 0;
    ctrlMenuCenterX = 0;
    ctrlMenuCenterY = 0;
  }

  var showing = ctrlMenuVisible();

  var isTouchEvent = false;
  var isTouchEndEvent = false;
  if (isTouchDevice) {
    if (touchEvent) {
      isTouchEvent = true;
      var touches = touchEvent.targetTouches;
      if (touches.length === 2) {
        ctrlMenuMouseX = (touches[1].pageX + touches[0].pageX) / 2;
        ctrlMenuMouseY = (touches[1].pageY + touches[0].pageY) / 2;

        var distanceBetweenTouches = distanceBetween({
          x: touches[0].pageX,
          y: touches[0].pageY
        }, {
          x: touches[1].pageX,
          y: touches[1].pageY
        });
        var distanceFromCenter = distanceBetween({
          x: ctrlMenuCenterX,
          y: ctrlMenuCenterY
        }, {
          x: ctrlMenuMouseX,
          y: ctrlMenuMouseY
        });
        if (!showing) {
          // start
          ctrlMenuTouchStartDistanceBetweenTouches = distanceBetweenTouches;
        } else if (ctrlMenuTouchStartDistanceBetweenTouches > 0) {
          if (distanceFromCenter < 50 && ctrlMenuTouchStartDistanceBetweenTouches > 0) {
            if (distanceBetweenTouches - ctrlMenuTouchStartDistanceBetweenTouches > 100) {
              var g = $("#graphicsContainer");
              var percent = {
                x: ((ctrlMenuCenterX - g.offset().left) / g.width() - 0.5) * 2,
                y: ((ctrlMenuCenterY - g.offset().top) / g.height() - 0.5) * 2
              };
              if (drawDepth) {
                drawDepth.zoomIn(percent.x, percent.y);
              }
              $("#ctrlMenu .burst").removeClass("grow");
              window.setTimeout(() => {
                $("#ctrlMenu .burst")
                  .on("animationend", function () { $(this).removeClass("grow"); })
                  .addClass("grow");
              }, 1);
              ctrlMenuTouchStartDistanceBetweenTouches = 0;
            } else if (distanceBetweenTouches - ctrlMenuTouchStartDistanceBetweenTouches < -50) {
              if (drawDepth) {
                drawDepth.zoomOut();
              }
              $("#ctrlMenu .burst").removeClass("shrink");
              window.setTimeout(() => {
                $("#ctrlMenu .burst")
                  .on("animationend", function () { $(this).removeClass("shrink"); })
                  .addClass("shrink");
              }, 1);
              ctrlMenuTouchStartDistanceBetweenTouches = 0;
            }
          }
        }
      }
    } else {
      isTouchEndEvent = true;
    }
  }

  // Decide to show the circle
  if ((ctrlKeyDown || isTouchEvent || rightClickDown)
    && !showing && ctrlMenuMouseX > 0 && ctrlMenuMouseY > 0 && (!isTouchDevice || isTouchEvent)) {
    $("#ctrlMenu .arrowContainer").hide();
    var graphicsOffset = $("#graphicsContainer").offset();
    ctrlMenuDiv.css({ left: (ctrlMenuMouseX - graphicsOffset.left - 70) + "px", top: (ctrlMenuMouseY - graphicsOffset.top - 70) + "px" });
    ctrlMenuDiv.show();
    ctrlMenuCenterX = ctrlMenuMouseX;
    ctrlMenuCenterY = ctrlMenuMouseY;
  } else if (showing && ((isTouchDevice && isTouchEndEvent) || (!isTouchDevice && !ctrlKeyDown && !rightClickDown))) {
    ctrlMenuDiv.hide();
    ctrlMenuCenterX = 0;
    ctrlMenuCenterY = 0;
    $("#ctrlMenu .burst").removeClass("grow");
    $("#ctrlMenu .burst").removeClass("shrink");
  }

  // Decide to show the rotating arrow
  if (showing) {
    ctrlMenuDiffenceX = ctrlMenuMouseX - ctrlMenuCenterX;
    ctrlMenuDiffenceY = ctrlMenuMouseY - ctrlMenuCenterY;

    // Snap to left/right/up/down
    if (Math.abs(ctrlMenuDiffenceX) < 30) {
      ctrlMenuMouseX = ctrlMenuCenterX;
      ctrlMenuDiffenceX = 0;
    } else {
      ctrlMenuMouseX = ctrlMenuMouseX;
    }
    if (Math.abs(ctrlMenuDiffenceY) < 30) {
      ctrlMenuMouseY = ctrlMenuCenterY;
      ctrlMenuDiffenceY = 0;
    } else {
      ctrlMenuMouseY = ctrlMenuMouseY;
    }

    var distance = distanceBetween({ x: ctrlMenuCenterX, y: ctrlMenuCenterY }, { x: ctrlMenuMouseX, y: ctrlMenuMouseY });
    if ((isTouchEvent && distance > 50) || (!isTouchEvent && distance > 10)) {
      var opposite = ctrlMenuMouseY - ctrlMenuCenterY;
      var angle = Math.asin(opposite / distance);
      if (ctrlMenuMouseX < ctrlMenuCenterX) {
        angle = degreesToRadians(180) - angle;
      }
      scale = Math.max(0.7, Math.min(1.0, distance / 100));
      ctrlMenuArrowContainerDiv.css({ transform: "rotate(" + angle + "rad) scale(" + scale + ")", display: "block" });
    } else {
      ctrlMenuDiffenceX = 0;
      ctrlMenuDiffenceY = 0;

      ctrlMenuArrowContainerDiv.css({ display: "none" });
    }
  }

  ctrlMenuWasVisible = ctrlMenuVisible();
}

function showTargetMessage(target) {
  if (target.dock) {
    $("#targetMessage p").text("Docking...");
  } else {
    $("#targetMessage p").text("Navigating to target...");
  }
  $("#targetMessage").show();
}

function hideTargetMessage() {
  $("#targetMessage").hide();
}

function cancelTarget() {
  sendCommand(kDRCommandCancelTarget);
}

function distanceBetween(a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function updateZoomers() {
  var level = mapboxMap.zoom();
  if (level == kDRMapZoomMin) {
    $("#zoomOut").addClass("disabled");
    $("#zoomIn").removeClass("disabled");
  } else if (level == kDRMapZoomMax) {
    $("#zoomOut").removeClass("disabled");
    $("#zoomIn").addClass("disabled");
  } else {
    // enable both
    $("#zoomOut").removeClass("disabled");
    $("#zoomIn").removeClass("disabled");
  }
}

function getURLParameter(name) {
  try {
    let params = new URLSearchParams(window.location.search);
    return params.get(name) || "";
  } catch (e) {
    return "";
  }
}

function addQueryStringParameter(theURL, name, value) {
  var re = new RegExp("([?&]" + name + "=)[^&]+", "");

  function add(sep) {
    theURL += sep + name + "=" + encodeURIComponent(value);
  }

  function change() {
    theURL = theURL.replace(re, "$1" + encodeURIComponent(value));
  }

  if (theURL.indexOf("?") === -1) {
    add("?");
  } else {
    if (re.test(theURL)) {
      change();
    } else {
      add("&");
    }
  }

  return theURL;
}

function clickedConnectionStatus() {

}

function showNoRobotsConnectedMessage() {
  $("#noLocationBubble").show();
  $("#noLocationBubble h1").show();
  $("#noLocationRobotsList").html("");
  $("#noLocationBubble").height(84);
}

function hideNoRobotsConnectedMessage() {
  $("#noLocationBubble h1").hide();
}

// Blink

function setupBlink() {
  window.setInterval(fireBlink, 250);
}

function addBlink(o) {
  if (blinkArray.indexOf(o) < 0) {
    blinkArray.push(o);
  }
}

function removeBlink(o) {
  var counter = 0;
  for (var i = 0; i < blinkArray.length; i++) {
    if (blinkArray[i] == o) {
      blinkArray.splice(i, 1);
      i--;
      counter++;
    }
  }
  if (counter > 0) {
    updateUserInterface();
  }
}

function fireBlink() {
  for (var i = 0; i < blinkArray.length; i++) {
    $(blinkArray[i]).toggleClass("on");
  }
}

// Button Actions

var delayingUserInterface = false;
function delayUpdateUserInterface() {
  delayingUserInterface = true;
  window.setTimeout(function () {
    delayingUserInterface = false;
  }, 2.0);
}

function updateUserInterface() {
  if (delayingUserInterface) {
    return;
  }

  // park
  switch (kickstandState) {
    case kDRKickstand_stateDeployed:
      removeBlink("#parkButton");
      $("#parkButton").addClass("on");
      q("#kickstandButtonText").innerText = "Parked";
      break;

    case kDRKickstand_stateDeployWaiting: // It's retracted, but waiting to be deployed
    case kDRKickstand_stateDeployBeginning:
    case kDRKickstand_stateDeployMiddle:
    case kDRKickstand_stateDeployEnd:
      addBlink("#parkButton");
      q("#kickstandButtonText").innerText = "Parking...";
      break;

    case kDRKickstand_stateRetractBeginning:
    case kDRKickstand_stateRetractMiddle:
    case kDRKickstand_stateRetractEnd:
    case kDRKickstand_stateDeployAbortMiddle:
    case kDRKickstand_stateDeployAbortEnd:
      addBlink("#parkButton");
      q("#kickstandButtonText").innerText = "Not Parked";
      break;

    case kDRKickstand_stateRetracted:
    case kDRKickstand_stateNone:
    default:
      removeBlink("#parkButton");
      $("#parkButton").removeClass("on");
      q("#kickstandButtonText").innerText = "Not Parked";
      break;
  }

  // flip
  if (robotiPadOrientation == 1
/*		|| (remoteRobotSupports("cameraKitIsConnected") && !("cameraKitEnabled" in statusValues))
		|| (remoteRobotSupports("cameraKitIsConnected") && "cameraKitEnabled" in statusValues && statusValues.cameraKitEnabled) */) {
    $("#flipButton").addClass("disabled");
    $("#flipButton").removeClass("on");
  } else if (robotiPadOrientation == 2) {
    $("#flipButton").removeClass("disabled");
    if (isFlipped) {
      $("#flipButton").addClass("on");
    } else {
      $("#flipButton").removeClass("on");
    }
  } else if (remoteRobotSupports("nativeWebRTC")) {
    $("#obstacleViewCheckbox").prop("checked", isFlipped);
  } else {
    $("#flipButton").addClass("disabled");
    $("#flipButton").removeClass("on");
  }
  if (remoteRobotSupports("cameraKitIsConnected") && "cameraKitEnabled" in statusValues) {
    $("#ckButton").removeClass("disabled");
    if (statusValues.cameraKitEnabled) {
      $("#ckButton").addClass("on");
    } else {
      $("#ckButton").removeClass("on");
    }
  } else {
    $("#ckButton").addClass("disabled");
  }

  if (remoteRobotSupports("robot")) {
    // robot connected
    $("#batteryButton").show();
    $("#parkButton").show();
    $("#poleButton").show();
    $("#missingRobotButton").hide();
  } else {
    // missing robot
    $("#batteryButton").hide();
    $("#parkButton").hide();
    $("#poleButton").hide();
    if (statusValues.hasOwnProperty("supports")) {
      $("#missingRobotButton").show();
    } else {
      $("#missingRobotButton").hide();
    }
  }

  // Microphone mute
  if (remoteRobotSupports("nativeWebRTC") && nativeWebRTC) {
    if (sidebarApp && sidebarApp.key && sidebarApp.key == "multiviewer") {
      // Trust the isMuted flag
    } else {
      // isMuted = nativeWebRTC.publisherIsMuted();
    }
  }
  if (isMuted) {
    $("#muteButton").addClass("on");
  } else {
    $("#muteButton").removeClass("on");
  }

  // Microphone volume slider
  if (allowRobotSpeakerUpdate && statusValues.volume != undefined) {
    $("#nativeVolumeSlider").val(statusValues.volume * 100);
    $("#localVideo .audioLevel").width(Math.round(statusValues.volume * 100) + "%");
  }
  if (remoteRobotSupports("nativeWebRTC") && nativeWebRTC) {
    nativeWebRTC.setHalfDuplex(statusValues.speakerBoosted);
    if (remoteRobotSupports("speakerBoost")) {
      q("#volumeSliderPopover").classList.add("boosted");
    } else {
      q("#volumeSliderPopover").classList.remove("boosted");
    }
  }

  // Speaker mute
  if (speakerIsMuted) {
    $("#speakerMuteButton").addClass("on");
  } else {
    $("#speakerMuteButton").removeClass("on");
  }

  // pole
  if (allowPoleUpdate && statusValues.pole !== undefined) {
    $("#nativePoleSlider").val(Math.round(statusValues.pole * 100));
  }

  // update battery level
  if (!sessionBatteryButton) {
    sessionBatteryButton = BatteryButtonWithParentId("sessionBatteryButton");
  }
  sessionBatteryButton.robotBatteryLevel = statusValues.robot_battery;
  sessionBatteryButton.iPadBatteryLevel = statusValues.ipad_battery;
  sessionBatteryButton.supportsiPadMeter = !remoteRobotSupports("nativeWebRTC");
  sessionBatteryButton.showChargingIcon = statusValues.is_robot_charging;
  sessionBatteryButton.barContentSize = { "width": 38.0, "height": 16.0 };
  sessionBatteryButton.strokeThickness = 2.0;
  if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    // dark mode
    sessionBatteryButton.fillColor = "rgba(180, 180, 180, 1.0)";
    // sessionBatteryButton.secondaryFillColor = "rgba(20, 20, 20, 1.0)";
  } else {
    sessionBatteryButton.fillColor = "rgba(40, 40, 40, 1.0)";
    // sessionBatteryButton.secondaryFillColor = "rgba(255, 255, 255, 1.0)";
  }
  if (statusValues.is_robot_charging) {
    if (statusValues.robot_battery == 1.0 || statusValues.is_robot_fully_charged) {
      sessionBatteryButton.fillColor = kDRGreenColor;
    } else {
      sessionBatteryButton.fillColor = kDROrangeColor;
    }
  }
  sessionBatteryButton.redraw();
  $("#robotBatteryLevel").html(Math.round(statusValues.robot_battery * 100));
  $("#iPadBatteryLevel").html(Math.round(statusValues.ipad_battery * 100));
  if (remoteRobotSupports("nativeWebRTC") && nativeWebRTC) {
    $("#sessionBatteryButton").prop("title", (!isNaN(statusValues.robot_battery)) ? Math.round(statusValues.robot_battery * 100) + "%" : "");
  }

  if (remoteRobotSupports("warnIfUndocked")
    && (!statusValues.is_robot_charging || (statusValues.navigateStatus && statusValues.navigateStatus.docking))) {
    q("#endButton").classList.add("intercept");
  } else {
    q("#endButton").classList.remove("intercept");
  }

  // update warning message about driving while too tall
  checkDrivingTall();

  // enable picture in picture button
  if (pictureInPictureAvailable()) {
    $("#pipButton").removeClass("disabled");
    $("#pipButton2").removeClass("disabled");
    $("#pipButton").show();
    $("#pipButton2").removeClass("hidden");
    if (pictureInPictureIsEnabled()) {
      $("#pipButton").addClass("on");
      $("#pipButton2").addClass("on");
    } else {
      $("#pipButton").removeClass("on");
      $("#pipButton2").removeClass("on");
    }
  } else {
    $("#pipButton").addClass("disabled");
    $("#pipButton2").addClass("disabled");
    $("#pipButton").hide();
    $("#pipButton2").addClass("hidden");
    $("#pipButton").removeClass("on");
    $("#pipButton2").removeClass("on");
  }

  // enable multiparty button
  if (remoteRobotSupports("multiparty") || (remoteRobotSupports("nativeWebRTC") && isTouchDevice)) {
    if (remoteRobotSupports("nativeWebRTC")
      && ((screenSharingWebRTC && screenSharingWebRTC.isActive()) || isShowingWebPage())) {
      $("#multipartyButton").addClass("disabled");
      $("#multipartyButton2").addClass("disabled");
    } else {
      $("#multipartyButton").removeClass("disabled");
      $("#multipartyButton2").removeClass("disabled");
      $("#multipartyButton").show();
      $("#multipartyButton2").removeClass("hidden");
      if (sessionIsMultipartyHost) {
        $("#multipartyButton").addClass("on");
        $("#multipartyButton2").addClass("on");
      } else {
        $("#multipartyButton").removeClass("on");
        $("#multipartyButton2").removeClass("on");
      }
    }
  } else {
    $("#multipartyButton").addClass("disabled");
    $("#multipartyButton2").addClass("disabled");
    $("#multipartyButton").hide();
    $("#multipartyButton2").addClass("hidden");
  }

  // enable screenSharing button
  if (("mediaDevices" in navigator && "getDisplayMedia" in navigator.mediaDevices)) {
    $("#screenSharingButton").show();
    $("#screenSharingButton2").css({ visibility: "visible" });
    if (remoteRobotSupports("screensharing")
      && (!getURLParameter("domain") || getURLParameter("domain").indexOf("." + ROOT_DOMAIN) > -1)
      && (!remoteRobotSupports("nativeWebRTC") || (remoteRobotSupports("nativeWebRTC") && !sessionIsMultipartyHost))
      && !isShowingWebPage()) {
      $("#screenSharingButton").removeClass("disabled");
      $("#screenSharingButton2").removeClass("disabled");
      if (screenSharingIsActive()
        || (screenSharingWebRTC
          && (screenSharingWebRTC.isActive() || (sidebarApp && sidebarApp.key == "screensharing")))) {
        $("#screenSharingButton").addClass("on");
        $("#screenSharingButton2").addClass("on");
      } else {
        $("#screenSharingButton").removeClass("on");
        $("#screenSharingButton2").removeClass("on");
      }
    } else {
      $("#screenSharingButton").addClass("disabled");
      $("#screenSharingButton2").addClass("disabled");
    }
  } else {
    $("#screenSharingButton").hide();
    $("#screenSharingButton2").css({ visibility: "hidden" });
  }

  // display web page (we didn't have an entry prior to D3)
  if (remoteRobotSupports("nativeWebRTC")
    && (!remoteRobotSupports("webpage")
      || sessionIsMultipartyHost
      || (screenSharingWebRTC && screenSharingWebRTC.isActive()))) {
    $("#displayWebPageButton").addClass("disabled");
    $("#displayWebPageButton2").addClass("disabled");
  } else {
    $("#displayWebPageButton").removeClass("disabled");
    $("#displayWebPageButton2").removeClass("disabled");
  }
  if (isShowingWebPage()) {
    $("#displayWebPageButton").addClass("on");
    $("#displayWebPageButton2").addClass("on");
  } else {
    $("#displayWebPageButton").removeClass("on");
    $("#displayWebPageButton2").removeClass("on");
  }

  // enable photo button
  if (remoteRobotSupports("photo")) {
    $("#photoButton").removeClass("disabled");
    $("#photoButton2").removeClass("disabled");
    $("#photoButton").show();
    $("#photoButton2").show();
  } else {
    $("#photoButton").addClass("disabled");
    $("#photoButton2").addClass("disabled");
    $("#photoButton").hide();
    $("#photoButton2").hide();
  }

  // quality
  if (remoteRobotSupports("qualityPreference")) {
    if (!isUsingCameraKit() && !remoteRobotSupports("nativeWebRTC")) {
      // don't allow AHD when not using a Camera Kit
      statusValues.qualityPreference = Math.min(2, statusValues.qualityPreference);
    }

    // supports quality preference
    $("#qualityPreference").removeClass("disabled");
    $("#qualityPreference0").removeClass("selected");
    $("#qualityPreference1").removeClass("selected");
    $("#qualityPreference2").removeClass("selected");
    $("#qualityPreference3").removeClass("selected");
    $("#qualityPreference" + Math.min(statusValues.qualityPreference, 3)).addClass("selected");

    // Disable options based on remote iPad capabilites
    if (remoteRobotSupports("nativeWebRTC")) {
      $("#qualityPreference3").text("1080");
      $("#qualityPreference0").attr("title", "1 Mbps, 480 x 300");
      $("#qualityPreference1").attr("title", "2 Mbps, 768 x 480");
      $("#qualityPreference2").attr("title", "4 Mbps, 1152 x 720");
      $("#qualityPreference3").attr("title", "6 Mbps, 1728 x 1080");
      if (sessionIsMultipartyHost || sidebarAppBlocksVideoQualityChange()) {
        $("#qualityPreference").addClass("disabled");
        $("#qualityPreference3").addClass("disabled");
        $("#qualityPreference2").addClass("disabled");
        $("#qualityPreference1").addClass("disabled");
        $("#qualityPreference0").addClass("disabled");
      } else if ("maxQualityPreference" in statusValues) {
        for (var i = 0; i < 4; i++) {
          if (i <= statusValues.maxQualityPreference) {
            $("#qualityPreference" + i).removeClass("disabled");
          } else {
            $("#qualityPreference" + i).addClass("disabled");
          }
        }
      } else {
        $("#qualityPreference3").removeClass("disabled");
        $("#qualityPreference2").removeClass("disabled");
        $("#qualityPreference1").removeClass("disabled");
        $("#qualityPreference0").removeClass("disabled");
      }
    } else if ("qualityPreference" in statusValues && statusValues.maxQualityPreference <= 1) {
      // iPad Air or lower
      $("#qualityPreference3").addClass("disabled");
      if (statusValues.maxQualityPreference <= 0 && isUsingCameraKit()) {
        // iPad 4 or lower
        $("#qualityPreference2").addClass("disabled");
        $("#qualityPreference1").addClass("disabled");
      } else {
        $("#qualityPreference2").removeClass("disabled");
        $("#qualityPreference1").removeClass("disabled");
      }
      $("#qualityPreference3").text("AHD");
      $("#qualityPreference0").attr("title", "640 x 480, 15 FPS");
      $("#qualityPreference1").attr("title", "640 x 480");
      $("#qualityPreference2").attr("title", "768 x 576");
      $("#qualityPreference3").attr("title", "Adaptive HD, 1280 x 960 at rest");
    } else {
      // iPad Air 2 or newer
      $("#qualityPreference3").text("AHD");
      $("#qualityPreference0").attr("title", "640 x 480, 15 FPS");
      $("#qualityPreference1").attr("title", "640 x 480");
      $("#qualityPreference2").attr("title", "768 x 576");
      $("#qualityPreference3").attr("title", "Adaptive HD, 1280 x 960 at rest");
      if (isUsingCameraKit()) {
        // allow AHD only when using a Camera Kit
        $("#qualityPreference3").removeClass("disabled");
      } else {
        $("#qualityPreference3").addClass("disabled");
      }
      $("#qualityPreference2").removeClass("disabled");
      $("#qualityPreference1").removeClass("disabled");
    }

    if ("qualityPreference" in statusValues) {
      if (isUsingCameraKit() && lastQualitySettingCameraKit < 0) {
        lastQualitySettingCameraKit = (statusValues.maxQualityPreference == 2) ? 3 : statusValues.maxQualityPreference;
      }
      if (!isUsingCameraKit() && lastQualitySettingiPad < 0) {
        lastQualitySettingiPad = statusValues.maxQualityPreference;
      }
    }

  } else {
    // no quality preference
    $("#qualityPreference").addClass("disabled");
  }

  // audioBoost
  if (remoteRobotSupports("audioBoost") && "audioBoostLevel" in statusValues) {
    audioBoostLevel = statusValues.audioBoostLevel;
    switch (audioBoostLevel) {
      case 0: {
        $("#audioBoostNormal").addClass("selected");
        $("#audioBoostBoost").removeClass("selected");
        $("#audioBoostMax").removeClass("selected");
        break;
      }
      case 0.5:
      case 0.7: {
        $("#audioBoostNormal").removeClass("selected");
        $("#audioBoostBoost").addClass("selected");
        $("#audioBoostMax").removeClass("selected");
        break;
      }
      case 1.0: {
        $("#audioBoostNormal").removeClass("selected");
        $("#audioBoostBoost").removeClass("selected");
        $("#audioBoostMax").addClass("selected");
        break;
      }
      default: {
        $("#audioBoostNormal").removeClass("selected");
        $("#audioBoostBoost").removeClass("selected");
        $("#audioBoostMax").removeClass("selected");
        break;
      }
    }
    $("#audioBoost").removeClass("disabled");
  } else {
    $("#audioBoostNormal").addClass("selected");
    $("#audioBoostBoost").removeClass("selected");
    $("#audioBoostMax").removeClass("selected");
    $("#audioBoost").addClass("disabled");
  }

  // graphicsLevel
  if (remoteRobotSupports("graphics") && "graphicsLevel" in statusValues) {
    graphicsLevel = statusValues.graphicsLevel;
    $("#graphicsLevel").removeClass("disabled");
  } else {
    graphicsLevel = -1;
    $("#graphicsLevel").addClass("disabled");
  }
  setGraphicsLevel(graphicsLevel, $("#graphicsLevel"), true);

  if (remoteRobotSupports("tags")) {
    $("#tagsOption").show();
  } else {
    $("#tagsOption").hide();
  }

  if (remoteRobotSupports("sidebarApps")) {
    // use list from robot
    q("#toolbarButtonsWithApps").style.display = "inline";
    q("#toolbarButtonsLegacy").style.display = "none";
    q("#photoButton2").style.display = "none";
  } else if (Object.keys(statusValues).length > 0) {
    // use old behavior
    q("#toolbarButtonsWithApps").style.display = "none";
    q("#toolbarButtonsLegacy").style.display = "inline";
    q("#photoButton2").style.display = "block";
  } else {
    q("#toolbarButtonsWithApps").style.display = "none";
    q("#toolbarButtonsLegacy").style.display = "none";
    q("#photoButton2").style.display = "none";
  }

  // obstacleAvoidance
  if (remoteRobotSupports("allowDisablingObstacleAvoidance") && "obstacleAvoidanceLevel" in statusValues) {
    obstacleAvoidanceLevel = statusValues.obstacleAvoidanceLevel;
    if (remoteRobotSupports("nativeWebRTC")) {
      setObstacleAvoidanceLevel(obstacleAvoidanceLevel, $("#obstacleAvoidanceLevel"), true);
    }
    $("#obstacleAvoidanceOption").show();
  } else {
    obstacleAvoidanceLevel = 2;
    if (remoteRobotSupports("nativeWebRTC")) {
      setObstacleAvoidanceLevel(obstacleAvoidanceLevel, $("#obstacleAvoidanceLevel"), true);
    }
    $("#obstacleAvoidanceOption").hide();
  }

  // brightness
  if (remoteRobotSupports("brightness")) {
    $("#brightnessSlider").prop('disabled', false);
    $("#brightnessSlider").val(statusValues.brightness * 100);
    lastBrightnessSent = statusValues.brightness;
  } else {
    $("#brightnessSlider").prop('disabled', true);
  }

  if (remoteRobotSupports("cameraKitIsConnected")) {
    if ("floorViewEnabled" in statusValues) {
      if (statusValues.floorViewEnabled) {
        showAlwaysOnFloorView();
      } else {
        hideAlwaysOnFloorView();
      }
    }
    if ("cameraKitEnabled" in statusValues) {
      if (statusValues.cameraKitEnabled) {
        enterCameraKitMode();
      } else {
        exitCameraKitMode();
      }
    } else {
      enterCameraKitMode();
      cameraKitEnabled = true;
    }
  } else {
    exitCameraKitMode();
  }

  if ("sharpenFilterEnabled" in statusValues) {
    sharpenFilterEnabled = statusValues.sharpenFilterEnabled;
  }

  if (remoteRobotSupports("webcamSwitching")) {
    $("#webcamSetupButton").show();
  } else {
    $("#webcamSetupButton").hide();
  }

  if (remoteRobotSupports("nativeWebRTC")) {
    $("#floorViewOption").hide();
    $("#peerToPeerDrivingOption").hide();
  } else {
    $("#floorViewOption").show();
    $("#peerToPeerDrivingOption").show();
  }
  if (remoteRobotSupports("qualityPreference")) {
    $("#qualityPreferenceOption").show();
  } else {
    $("#qualityPreferenceOption").hide();
  }

  // Night Vision checkbox
  $("#nightVisionCheckbox").prop("checked", !!nightVisionEnabled);

  // Tags checkbox
  tagsEnabled = statusValues.tags;
  $("#tagsCheckbox").prop("checked", !!tagsEnabled);

  if ("performanceModel" in statusValues) {
    $("#webrtcPerformance").text("Performance Model: " + statusValues.performanceModel);
  }

  // Speaker volume slider - keep this as the last one in the function
  try {
    if (opentokSubscriber != undefined && opentokSubscriber.getAudioVolume != undefined) {
      // $("#speakerVolumeSlider").simpleSlider("setValue", opentokSubscriber.getAudioVolume() / 100);
      // $("#nativeSpeakerVolumeSlider").val(opentokSubscriber.getAudioVolume());
    }
  } catch (err) {

  }
}

function isUsingCameraKit() {
  return (remoteRobotSupports("cameraKitIsConnected") && ("cameraKitEnabled" in statusValues && statusValues.cameraKitEnabled == true));
}

function checkDrivingTall() {
  if (statusValues.pole >= 0.5 && (forwardState == 1 || $("#targetMessage").is(":visible"))) {
    if (!drivingTallTimeout) {
      drivingTallTimeout = window.setTimeout(function () {
        // show the warning
        if (!$("#drivingTallWarning").is(":visible")) {
          if (!$("#poleButton .popover").is(":visible")) {
            $("#drivingTallWarning").fadeIn(100);
          }
        }
        drivingTallTimeout = null;
      }, 3000);
    }
  } else {
    window.clearTimeout(drivingTallTimeout);
    drivingTallTimeout = null;
    if ($("#drivingTallWarning").is(":visible")) {
      $("#drivingTallWarning").fadeOut(100);
    }
  }
}

function endAction(force) {
  if (!force && remoteRobotSupports("warnIfUndocked") && !statusValues.is_robot_charging) {
    // warning because not docked
  } else {
    disconnect();
    updateUserInterface();
  }
}

function parkAction() {
  switch (kickstandState) {
    case kDRKickstand_stateDeployed:
      retractKickstands();
      break;

    case kDRKickstand_stateDeployWaiting: // It's retracted, but waiting to be deployed
    case kDRKickstand_stateDeployBeginning:
    case kDRKickstand_stateDeployMiddle:
    case kDRKickstand_stateDeployEnd:
    case kDRKickstand_stateRetractBeginning:
    case kDRKickstand_stateRetractMiddle:
    case kDRKickstand_stateRetractEnd:
    case kDRKickstand_stateDeployAbortMiddle:
    case kDRKickstand_stateDeployAbortEnd:
      break;

    case kDRKickstand_stateRetracted:
    case kDRKickstand_stateNone:
    default:
      deployKickstands();
      break;
      break;
  }
  updateUserInterface();
}

function flipAction() {
  if (drawMinimap) {
    drawMinimap.toggle();
    if (drawMinimap.paused) {
      sendCommand(kDRCommandObstacleGridDisable);
    } else {
      sendCommand(kDRCommandObstacleGridEnable);
    }
  } else if (robotiPadOrientation != 1 /* && (!remoteRobotSupports("cameraKitIsConnected") || !cameraKitEnabled) */) {
    flip();
  }
}

var ckActionDisabled = false;

function ckAction() {
  if (ckActionDisabled) { return; }

  if (remoteRobotSupports("cameraKitIsConnected") && cameraKitEnabled) {
    sendCommand(kDRCommandCameraKitDisable);
  } else {
    sendCommand(kDRCommandCameraKitEnable);
  }
  ckActionDisabled = true;
  window.setTimeout(function () {
    ckActionDisabled = false;
  }, 2000);
}

// Microphone Actions

function muteAction(event) {
  if (event && event.target && event.target.tagName.toLowerCase() != "div") {
    return;
  }

  if (isMuted) {
    document.title = "Double";
    muteDisable();
    q("#viewerMuteButton").classList.remove("on");
  } else {
    document.title = "Double [Muted]";
    muteEnable();
    q("#viewerMuteButton").classList.add("on");
  }
}

function muteEnable() {
  if (remoteRobotSupports("nativeWebRTC") && nativeWebRTC) {
    if (sidebarApp && sidebarApp.key && sidebarApp.key == "multiviewer") {
      var iframe = document.getElementById("sidebarIframe");
      if (iframe && iframe.contentWindow) {
        iframe.contentWindow.postMessage({ c: "MuteDriverMic" }, "*");
      }
    } else {
      nativeWebRTC.mutePublisher();
      isMuted = nativeWebRTC.publisherIsMuted();
    }
  } else if (opentokPublisher) {
    opentokPublisher.publishAudio(false);
  }
  isMuted = true;
  updateUserInterface();
}

function muteDisable() {
  if (remoteRobotSupports("nativeWebRTC") && nativeWebRTC) {
    if (sidebarApp && sidebarApp.key && sidebarApp.key == "multiviewer") {
      var iframe = document.getElementById("sidebarIframe");
      if (iframe && iframe.contentWindow) {
        iframe.contentWindow.postMessage({ c: "UnmuteDriverMic" }, "*");
      }
    } else {
      nativeWebRTC.unmutePublisher();
      isMuted = nativeWebRTC.publisherIsMuted();
    }
  } else if (opentokPublisher) {
    opentokPublisher.publishAudio(true);
  }
  isMuted = false;
  updateUserInterface();
}

var volumeTimeout;
function volumeSliderDidChange(theValue) {
  if (justGotVolume == true) { return; }

  if (volumeTimeout) {
    window.clearTimeout(volumeTimeout);
  }

  volumeTimeout = window.setTimeout(function () {
    sendCommandWithData(kDRCommandVolumeChanged, { volume: theValue });
  }, 100);
}

function volumeUp() {
  if (isMuted) {
    muteDisable();
  }
  robotSpeakerVolumeToSend = Math.min(1, statusValues.volume + 0.1);
  statusValues.volume = robotSpeakerVolumeToSend;
  $("#localVideo .audioLevel").width(Math.round(robotSpeakerVolumeToSend * 100) + "%");
  updateUserInterface();
  temporarilyBlockSpeakerSliderUpdate();
}

function volumeDown() {
  robotSpeakerVolumeToSend = Math.max(0, statusValues.volume - 0.1);
  statusValues.volume = robotSpeakerVolumeToSend;
  if (statusValues.volume <= 0.01) {
    muteEnable();
  }
  $("#localVideo .audioLevel").width(Math.round(robotSpeakerVolumeToSend * 100) + "%");
  updateUserInterface();
  temporarilyBlockSpeakerSliderUpdate();
}

function temporarilyBlockSpeakerSliderUpdate() {
  allowRobotSpeakerUpdate = false;
  window.clearTimeout(allowRobotSpeakerUpdateTimeout);
  allowRobotSpeakerUpdateTimeout = window.setTimeout(function () {
    allowRobotSpeakerUpdate = true;
  }, 2500);
}

// Speaker Actions

function speakerMuteAction() {
  if (speakerIsMuted) {
    speakerMuteDisable();
  } else {
    speakerMuteEnable();
  }
}

function speakerMuteEnable() {
  if (opentokSubscriber) {
    opentokSubscriber.subscribeToAudio(false);
    speakerIsMuted = true;
    updateUserInterface();
  }
}

function speakerMuteDisable() {
  if (opentokSubscriber) {
    opentokSubscriber.subscribeToAudio(true);
    speakerIsMuted = false;
    updateUserInterface();
  }
}

function speakerVolumeSliderDidChange(theValue) {
  if (opentokSubscriber != undefined) {
    opentokSubscriber.setAudioVolume(Math.round(theValue * 100));
  }
}

function speakerVolumeUp() {
  if (opentokSubscriber != undefined) {
    if (speakerIsMuted) {
      speakerMuteDisable();
    }
    opentokSubscriber.setAudioVolume(Math.min(100, opentokSubscriber.getAudioVolume() + 10));
    $("#speakerVolumeSlider").simpleSlider("setValue", opentokSubscriber.getAudioVolume() / 100);
    updateUserInterface();
  }
}

function speakerVolumeDown() {
  if (opentokSubscriber != undefined) {
    opentokSubscriber.setAudioVolume(Math.max(0, opentokSubscriber.getAudioVolume() - 10));
    $("#speakerVolumeSlider").simpleSlider("setValue", opentokSubscriber.getAudioVolume() / 100);
    if (opentokSubscriber.getAudioVolume() <= 0.01) {
      speakerMuteEnable();
    }
    updateUserInterface();
  }
}

var defaultQualityPreference = 3;
var d3DefaultQualityPreference = 2;

function setDefaultQualityPreference(value) {
  defaultQualityPreference = parseInt(value);
  $("#defaultQualityPreference0").removeClass("selected");
  $("#defaultQualityPreference1").removeClass("selected");
  $("#defaultQualityPreference2").removeClass("selected");
  $("#defaultQualityPreference3").removeClass("selected");
  $("#defaultQualityPreference" + Math.min(defaultQualityPreference, 3)).addClass("selected");
  saveSettings();
}

function setD3DefaultQualityPreference(value) {
  d3DefaultQualityPreference = parseInt(value);
  $("#d3DefaultQualityPreference0").removeClass("selected");
  $("#d3DefaultQualityPreference1").removeClass("selected");
  $("#d3DefaultQualityPreference2").removeClass("selected");
  $("#d3DefaultQualityPreference3").removeClass("selected");
  $("#d3DefaultQualityPreference" + Math.min(d3DefaultQualityPreference, 3)).addClass("selected");
  saveSettings();
}

function setSecurityLevel(value) {
  securityLevel = parseInt(value);
  $("#securityLevel1").removeClass("selected");
  $("#securityLevel2").removeClass("selected");
  $("#securityLevel" + Math.min(securityLevel, 2)).addClass("selected");
  saveSettings();
}

function saveSettings() {
  clearKeyboardCommands();
  var dict = {
    peerToPeerDriving: $("#peerToPeerDriving").is(':checked'),
    securityLevel: securityLevel,
    // relayServer: $(".relayServer input[name=relayServer]:checked").val(),
    defaultQualityPreference: defaultQualityPreference,
    d3DefaultQualityPreference: d3DefaultQualityPreference
  };
  if (opentokAudioSourceDeviceId) {
    dict.audioDeviceId = opentokAudioSourceDeviceId;
  }
  if (opentokVideoSourceDeviceId) {
    dict.videoDeviceId = opentokVideoSourceDeviceId;
  }
  if (preCallCurrentCameraId) {
    dict.preCallCurrentCameraId = preCallCurrentCameraId;
  }
  if (preCallCurrentCameraLabel) {
    dict.preCallCurrentCameraLabel = preCallCurrentCameraLabel;
  }
  if (preCallCurrentMicId) {
    dict.preCallCurrentMicId = preCallCurrentMicId;
  }
  if (preCallCurrentMicLabel) {
    dict.preCallCurrentMicLabel = preCallCurrentMicLabel;
  }
  dict.qualityStats = ($("#qualityStats") && $("#qualityStats").is(":visible"));
  setCookie("settings", JSON.stringify(dict), {
    expires: 10000,
    secure: ('https:' == document.location.protocol),
    domain: kDRCookieDomain,
    sameSite: "None"
  });
}

function loadSettings() {
  var dict = getCookie("settings");
  if (dict && dict != null && dict != "null") {
    dict = JSON.parse(dict);
    $('#peerToPeerDriving').prop('checked', dict.peerToPeerDriving);
    if (dict.audioDeviceId) {
      opentokAudioSourceDeviceId = dict.audioDeviceId;
    }
    if (dict.videoDeviceId) {
      opentokVideoSourceDeviceId = dict.videoDeviceId;
    }
    if (dict.qualityStats) {
      showQualityStats();
    }
    if ("securityLevel" in dict) {
      if (dict.securityLevel == "endToEnd") {
        securityLevel = kDRRoutingMethodRelayed;
      } else if (dict.securityLevel == "clientToServer") {
        securityLevel = kDRRoutingMethodRouted;
      } else if (parseInt(dict.securityLevel) != NaN) {
        securityLevel = parseInt(dict.securityLevel);
      }
    }
    if ("defaultQualityPreference" in dict && parseInt(dict.defaultQualityPreference) != NaN) {
      defaultQualityPreference = parseInt(dict.defaultQualityPreference);
    }
    if ("d3DefaultQualityPreference" in dict && parseInt(dict.d3DefaultQualityPreference) != NaN) {
      d3DefaultQualityPreference = parseInt(dict.d3DefaultQualityPreference);
    }
    if (dict.preCallCurrentCameraId) {
      preCallLastCameraId = dict.preCallCurrentCameraId;
    }
    if (dict.preCallCurrentCameraLabel) {
      preCallLastCameraLabel = dict.preCallCurrentCameraLabel;
    }
    if (dict.preCallCurrentMicId) {
      preCallLastMicId = dict.preCallCurrentMicId;
    }
    if (dict.preCallCurrentMicLabel) {
      preCallLastMicLabel = dict.preCallCurrentMicLabel;
    }
  }
  $("#securityLevel1").removeClass("selected");
  $("#securityLevel2").removeClass("selected");
  $("#securityLevel" + Math.min(securityLevel, 2)).addClass("selected");
  $("#defaultQualityPreference0").removeClass("selected");
  $("#defaultQualityPreference1").removeClass("selected");
  $("#defaultQualityPreference2").removeClass("selected");
  $("#defaultQualityPreference3").removeClass("selected");
  $("#defaultQualityPreference" + Math.min(defaultQualityPreference, 3)).addClass("selected");
  $("#d3DefaultQualityPreference0").removeClass("selected");
  $("#d3DefaultQualityPreference1").removeClass("selected");
  $("#d3DefaultQualityPreference2").removeClass("selected");
  $("#d3DefaultQualityPreference3").removeClass("selected");
  $("#d3DefaultQualityPreference" + Math.min(d3DefaultQualityPreference, 3)).addClass("selected");
}

function showRobotsSharedWithMe() {
  $("#robotsSharedWithMe").show();
  loadRobotsSharedWithMe();
}

function loadRobotsSharedWithMe() {
  $("#robotsSharedWithMeRows").html("<tr><td>Loading...</td></tr>");

  var request = getSharedDBLHTTPClient().request("GET", kAPIEndpointUserSharedRobots, {});
  request.send(function (data) {
    // success
    var html = "";
    if (data.robots && data.robots.length > 0) {
      for (var i = 0; i < data.robots.length; i++) {
        var r = data.robots[i];
        var isOnline = false;
        for (var k = 0; k < robots.length; k++) {
          if (robots[k].dictionary.installationId == r.robot_installation_key) {
            isOnline = true;
          }
        }
        html += "<tr><td>" + r.robot_nickname + ((!isOnline) ? " (offline)" : "") + "</td><td class=\"right\">" + r.robot_user + "</td></tr>";
      }
    } else {
      $("#robotsSharedWithMeRows").html("<tr><td>None</td></tr>");
    }
    $("#robotsSharedWithMeRows").html(html);
  }, function () {
    // failure
    console.log("failed to load robots shared with me");
  });
}

function switchToCreateAccount() {
  $("#content").show();
  $("#login").hide();
  $("#forgot").hide();
  $("#setPassword").hide();
  $("#createAccount").show();
  $("#usernameCreateAccountField").select();
  if ($("#usernameLoginField").val() != "") {
    $("#usernameCreateAccountField").val($("#usernameLoginField").val());
    $("#emailCreateAccountField").select();
  }
  if ($("#passwordLoginField").val() != "") {
    $("#passwordCreateAccountField").val($("#passwordLoginField").val());
    $("#passwordCreateAccountField2").val($("#passwordLoginField").val());
  }
}

function switchToLogin() {
  $("#content").show();
  $("#createAccount").hide();
  $("#forgot").hide();
  $("#setPassword").hide();
  showLoginForm();
  $("#usernameLoginField").select();
}

function switchToForgot(email) {
  if (!email && currentUser && currentUser.email) {
    email = currentUser.email;
    $("#forgot .accessories a")[0].onclick = () => {
      $("#content").hide();
    };
    $("#setPassword .accessories a")[0].onclick = () => {
      $("#content").hide();
    };
  } else {
    $("#forgot .accessories a")[0].onclick = switchToLogin;
    $("#setPassword .accessories a")[0].onclick = switchToLogin;
  }
  $("#content").show();
  $("#login").hide();
  $("#createAccount").hide();
  $("#setPassword").hide();
  if (email) {
    $("#emailForgotPasswordField").val(email);
  } else {
    $("#emailForgotPasswordField").val("");
  }
  $("#forgot").show();
  $("#emailForgotPasswordField").select();
}

function switchToSetPassword() {
  $("#content").show();
  $("#login").hide();
  $("#createAccount").hide();
  $("#forgot").hide();
  $("#setPassword").show();
  $("#tokenSetPasswordField").select();
}

function displayHoverMessage(title, subtitle) {
  $("#hoverMessage h1").html(title);
  if (subtitle) {
    $("#hoverMessage h2").html(subtitle);
  } else {
    $("#hoverMessage h2").html("");
  }
  $("#hoverMessage").fadeIn(150);
}

function hideHoverMessage() {
  $("#hoverMessage").fadeOut(10);
}

function prettyDuration(input) {
  var sec_num = parseInt(input, 10); // don't forget the second param
  var hours = Math.floor(sec_num / 3600);
  var minutes = Math.ceil((sec_num - (hours * 3600)) / 60);
  var time = "";
  if (hours > 0) {
    time += hours + "h ";
  }
  time += minutes + "m";
  if (hours == 0 && minutes == 0) {
    time = "-";
  }
  return time;
}

function loadConfiguration(callback) {
  var client = getSharedDBLHTTPClient();
  var params = {};
  if (getURLParameter("domain")) {
    params["domain"] = getURLParameter("domain");
  }
  var request = client.request("GET", kAPIEndpointConfiguration, params);
  request.send(function (data) {
    // success
    if (data.data.ISOLATION_MODE) {
      ISOLATION_MODE = data.data.ISOLATION_MODE;
    }
    if (data.data.logo) {
      if (navigator.userAgent.indexOf("Firefox") >= 0) {
        $("#logo").css("background-image", "url(\"" + data.data.logo + "\")");
      } else {
        $("#logo").css("background-image", "-webkit-image-set(url(\"" + data.data.logo + "\") 1x, url(\"" + data.data.logo_2x + "\") 2x)");
      }
    }
    if (data.data.logo_link) {
      $("#logo").attr("href", data.data.logo_link);
    }
    if (data.data.company) {
      $("#currentUsername .company").text(data.data.company.name);
      $("#currentUsername .company").show();
    }
    if (!runningIceConfigTest) {
      if (data.data.company && data.data.company.turn) {
        nativeWebRTC.setIceConfig(data.data.company.turn, "fleet");
      } else if (data.data.turn) {
        var firstTurn = data.data.turn;
        if (Array.isArray(data.data.turn)) {
          firstTurn = data.data.turn[0];
          if (data.data.turn.length > 1) {
            DRTURNFinder(data.data.turn, (betterIceConfig, ms) => {
              nativeWebRTC.setIceConfig(betterIceConfig, "clientConfig", ms);
            });
          }
        }
        nativeWebRTC.setIceConfig(firstTurn, "clientConfig");
      }
    }
    if (currentUser && currentUser.username == "public") {
      $("#navLinks").hide();
      $("#currentUsername .company").text("");
      $("#currentUsername .company").hide();
    } else {
      if (data.data.company) {
        $("#navLinks").show();
        $("#calendarLink").show();
        $("#fmLink").hide();
        if (data.data.company.role == 1 || data.data.company.role == 2) {
          $("#adminLink").show();
        } else {
          $("#adminLink").hide();
        }
        // } else if (currentUser && currentUser.isLoggedIn()) {
        // 	$("#navLinks").show();
        // 	$("#adminLink").hide();
        // 	$("#calendarLink").hide();
        // 	$("#fmLink").show();
      } else {
        $("#navLinks").hide();
      }
    }
    if (data.data.blurb_login) {
      $("#loginBlurb").html(data.data.blurb_login);
      $("#loginBlurb").show();
    } else {
      $("#loginBlurb").html("");
      $("#loginBlurb").hide();
    }
    configuration = data;
    if (callback) {
      callback();
    }
  }, function () {
    // failure
    console.log("failed to load configuration");
  });
}

function b64toBlob(b64Data, contentType, sliceSize) {
  contentType = contentType || '';
  sliceSize = sliceSize || 512;

  var byteCharacters = atob(b64Data);
  var byteArrays = [];

  for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
    var slice = byteCharacters.slice(offset, offset + sliceSize);

    var byteNumbers = new Array(slice.length);
    for (var i = 0; i < slice.length; i++) {
      byteNumbers[i] = slice.charCodeAt(i);
    }

    var byteArray = new Uint8Array(byteNumbers);

    byteArrays.push(byteArray);
  }

  var blob = new Blob(byteArrays, { type: contentType });
  return blob;
}

function downloadBase64(base64, contentType) {
  // if (isTouchDevice) {
  // 	var dataURI = 'data:' + contentType + ';base64,' + base64;
  // 	document.getElementById("photoElement").src = dataURI;
  // 	showMessage("showPhoto");
  // } else {
  var blob = b64toBlob(base64, "image/jpg");
  var d = new Date();
  var options = { dateStyle: "short", timeStyle: "short" };
  var str = "Double Photo " +
    d.toLocaleDateString(options).replaceAll("/", "-") +
    " at " + d.toLocaleTimeString(options).replaceAll(":", "_") + ".jpg";
  downloadBlob(blob, str);
  // }
}

function downloadBlob(blob, fileName) {
  var url = window.URL.createObjectURL(blob);

  if (navigator.userAgent.indexOf("Firefox") >= 0) {
    window.open(url, '_blank');
    return;
  }

  var link = document.createElement("a");
  document.body.appendChild(link);
  link.style = "display: none;";
  link.href = url;
  link.download = fileName;
  link.click();
  window.URL.revokeObjectURL(url);
}

function takePhoto() {
  if (!remoteRobotSupports("photo")) {
    nonModalAlert("Unavailable", "Capturing a photo is not available.");
    return;
  }

  var flash = document.createElement("div");
  document.getElementById("subscribers").appendChild(flash);
  flash.id = "photoFlash";
  flash.style.background = "white";
  flash.style.width = "100%";
  flash.style.height = $(document).height();
  flash.style.left = "0px";
  flash.style.top = "0px";
  flash.style.position = "fixed";
  window.setTimeout(function () {
    $("#photoFlash").fadeOut(1000);
    window.setTimeout(function () {
      $("#photoFlash").remove();
    }, 1500);
  }, 20);

  window.setTimeout(function () {
    sendCommand(kDRCommandTakePhoto);
  }, 50);

  displayHoverMessage($("#stringTakingPhoto").html(), $("#stringCapturing").html() + "...");
  window.setTimeout(function () {
    displayHoverMessage($("#stringTakingPhoto").html(), $("#stringDownloading").html() + "...");
  }, 1500);
}

function remoteRobotSupports(key) {
  return (statusValues && statusValues.supports && statusValues.supports.indexOf(key) >= 0);
}

function appIndexForKey(key) {
  var index = -1;
  if (sidebarApps && Array.isArray(sidebarApps)) {
    for (var i = 0; i < sidebarApps.length; i++) {
      if (sidebarApps[i].key == key) {
        index = i;
      }
    }
  }
  return index;
}

function resetVideoLink(multiparty) {
  if (nativeWebRTC && nativeWebRTC.isActive()) {
    sendCommandWithData(kDRCommandRequestOpenTokSession, { "multiparty": true });
    sessionIsMultipartyHost = true;
    sendCommand(kDRCommandRequestStatusData);

  } else {
    if (multiparty) {
      // switch to multiparty
      opentokDisconnect();
      window.setTimeout(function () {
        sendCommandWithData(kDRCommandRequestOpenTokSession, { "multiparty": true });
        sessionIsMultipartyHost = true;
        sendCommand(kDRCommandRequestStatusData);
      }, 500);
    } else {
      // normal
      opentokStopPublishing();
      window.setTimeout(function () {
        sendCommand(kDRCommandRequestOpenTokSession);
        sendCommand(kDRCommandRequestStatusData);
      }, 500);
    }
  }

  // displayHoverMessage("Reconnecting...", " ");
  updateUserInterface();
}

function toggleNightVision(el) {
  clearKeyboardCommands();
  if (el && el.checked) {
    sendCommand(kDRCommandLowLightModeOn);
    nightVisionEnabled = true;
  } else {
    sendCommand(kDRCommandLowLightModeOff);
    nightVisionEnabled = false;
  }
}

function toggleTags(el) {
  clearKeyboardCommands();
  if (el && el.checked) {
    sendCommand(kDRCommandTagDetectorEnable);
    tagsEnabled = true;
  } else {
    sendCommand(kDRCommandTagDetectorDisable);
    tagsEnabled = false;
  }
}

function toggleFloorView() {
  clearKeyboardCommands();
  if (alwaysOnFloorViewEnabled) {
    sendCommand(kDRCommandFloorViewDisable);
    hideAlwaysOnFloorView();
  } else {
    sendCommand(kDRCommandFloorViewEnable);
    showAlwaysOnFloorView();
  }
}

function configAction(event, element) {

}

function qualityPreferenceDidChange() {
  sendCommandWithData(kDRCommandResetVideoLink, { "qualityPreference": $("#qualityPreference").val() });
}

function setQualityPreference(value, el) {
  if (el !== null && $(el).hasClass("disabled")) {
    return;
  }
  $("#qualityPreference0").removeClass("selected");
  $("#qualityPreference1").removeClass("selected");
  $("#qualityPreference2").removeClass("selected");
  $("#qualityPreference3").removeClass("selected");
  $("#qualityPreference" + Math.min(value, 3)).addClass("selected");
  if (value >= 3) {
    sendCommand(kDRCommandAdaptiveHDEnable);
  } else {
    sendCommand(kDRCommandAdaptiveHDDisable);
  }
  if (el) {
    if (isUsingCameraKit()) {
      lastQualitySettingCameraKit = value;
    } else {
      lastQualitySettingiPad = value;
    }
  }
  sendCommandWithData(kDRCommandResetVideoLink, { "qualityPreference": value });
  window.setTimeout(() => {
    sendCommand(kDRCommandRequestStatusData);
  }, 200);
}

function setAudioBoost(value, el) {
  if (el !== null && $(el).hasClass("disabled")) {
    return;
  }
  switch (value) {
    case 0: {
      $("#audioBoostNormal").addClass("selected");
      $("#audioBoostBoost").removeClass("selected");
      $("#audioBoostMax").removeClass("selected");
      break;
    }
    case 0.5: {
      $("#audioBoostNormal").removeClass("selected");
      $("#audioBoostBoost").addClass("selected");
      $("#audioBoostMax").removeClass("selected");
      break;
    }
    case 1.0: {
      $("#audioBoostNormal").removeClass("selected");
      $("#audioBoostBoost").removeClass("selected");
      $("#audioBoostMax").addClass("selected");
      break;
    }
    default: {
      $("#audioBoostNormal").removeClass("selected");
      $("#audioBoostBoost").removeClass("selected");
      $("#audioBoostMax").removeClass("selected");
      break;
    }
  }
  sendCommandWithData(kDRCommandAudioBoostLevel, { "level": value });
  delayUpdateUserInterface();
}

function setGraphicsLevel(value, el, dontSendCommand) {
  if (el !== null && $(el).hasClass("disabled")) {
    return;
  }
  switch (value) {
    case 0: {
      $("#graphicsLevel0").addClass("selected");
      $("#graphicsLevel1").removeClass("selected");
      $("#graphicsLevel2").removeClass("selected");
      break;
    }
    case 1: {
      $("#graphicsLevel0").removeClass("selected");
      $("#graphicsLevel1").addClass("selected");
      $("#graphicsLevel2").removeClass("selected");
      break;
    }
    case 2: {
      $("#graphicsLevel0").removeClass("selected");
      $("#graphicsLevel1").removeClass("selected");
      $("#graphicsLevel2").addClass("selected");
      break;
    }
    default: {
      $("#graphicsLevel0").removeClass("selected");
      $("#graphicsLevel1").removeClass("selected");
      $("#graphicsLevel2").removeClass("selected");
      break;
    }
  }
  if (!dontSendCommand) {
    sendCommandWithData(kDRCommandSetGraphicsLevel, { "level": value });
    delayUpdateUserInterface();
  }
}

function setObstacleAvoidanceLevel(value, el, dontSendCommand) {
  if (el !== null && $(el).hasClass("disabled")) {
    return;
  }
  switch (value) {
    case 0: {
      $("#obstacleAvoidanceLevel0").addClass("selected");
      $("#obstacleAvoidanceLevel1").removeClass("selected");
      $("#obstacleAvoidanceLevel2").removeClass("selected");
      if (drawDepth) {
        drawDepth.mouseTargetAllowed = false;
      }
      break;
    }
    case 1: {
      $("#obstacleAvoidanceLevel0").removeClass("selected");
      $("#obstacleAvoidanceLevel1").addClass("selected");
      $("#obstacleAvoidanceLevel2").removeClass("selected");
      if (drawDepth) {
        drawDepth.mouseTargetAllowed = true;
      }
      break;
    }
    case 2: {
      $("#obstacleAvoidanceLevel0").removeClass("selected");
      $("#obstacleAvoidanceLevel1").removeClass("selected");
      $("#obstacleAvoidanceLevel2").addClass("selected");
      if (drawDepth) {
        drawDepth.mouseTargetAllowed = true;
      }
      break;
    }
    default: {
      $("#obstacleAvoidanceLevel0").removeClass("selected");
      $("#obstacleAvoidanceLevel1").removeClass("selected");
      $("#obstacleAvoidanceLevel2").removeClass("selected");
      if (drawDepth) {
        drawDepth.mouseTargetAllowed = false;
      }
      break;
    }
  }
  if (!dontSendCommand) {
    sendCommandWithData(kDRCommandSetObstacleAvoidanceLevel, { "level": value });
    delayUpdateUserInterface();
  }
}

var volumeTimeout;
function nativeVolumeSliderDidChange(event) {
  clearKeyboardCommands();

  robotSpeakerVolumeToSend = $("#nativeVolumeSlider").val() / 100;
  $("#localVideo .audioLevel").width($("#nativeVolumeSlider").val() + "%");
  temporarilyBlockSpeakerSliderUpdate();
}

function nativeSpeakerVolumeSliderDidChange() {
  clearKeyboardCommands();

  if (opentokSubscriber != undefined) {
    opentokSubscriber.setAudioVolume(Math.round($("#nativeSpeakerVolumeSlider").val()));
  }
}

function nativePoleSliderDidChange() {
  clearKeyboardCommands();

  poleToSend = $("#nativePoleSlider").val() / 100;
  allowPoleUpdate = false;
}

function becomeRobot() {
  IS_ROBOT_MODE = true;
  var dict = {
    "missingRobot": true,
    "userId": null,
    "installationId": getCurrentInstallation().installation_key,
    "nickname": "Test Robot"
  };
  sendCommandWithData(kDRCommandRobotIsAvailable, dict);
}

function sendRobotStatus() {
  var dict = {};
  sendCommandWithData(kDRCommandStatusData, dict);
}

function showAlwaysOnFloorView() {
  alwaysOnFloorViewEnabled = true;
  $("#floorViewCheckbox").prop("checked", true);
}

function hideAlwaysOnFloorView() {
  alwaysOnFloorViewEnabled = false;
  $("#floorViewCheckbox").prop("checked", false);
}

function enterCameraKitMode() {
  if (cameraKitEnabled) {
    return;
  };
  cameraKitEnabled = true;
  $("#floorViewCheckbox").prop("disabled", false);
  $("#floorViewCheckbox").parent().css({ opacity: 1.0 });
  if (!remoteRobotSupports("nightVision")) {
    $("#nightVisionCheckbox").prop("disabled", true);
    $("#nightVisionCheckbox").parent().css({ opacity: 0.5 });
  }

  // disable night vision
  sendCommand(kDRCommandLowLightModeOff);
  $("#nightVisionCheckbox").prop("checked", false);

  if (lastQualitySettingCameraKit >= 0) {
    window.setTimeout(function () { setQualityPreference(lastQualitySettingCameraKit); }, 500);
  }
}

function exitCameraKitMode() {
  if (!cameraKitEnabled) {
    return;
  };
  cameraKitEnabled = false;
  $("#floorViewCheckbox").prop("disabled", true);
  $("#floorViewCheckbox").parent().css({ opacity: 0.5 });
  $("#nightVisionCheckbox").prop("disabled", false);
  $("#nightVisionCheckbox").parent().css({ opacity: 1.0 });

  // disable night vision
  sendCommand(kDRCommandLowLightModeOff);
  $("#nightVisionCheckbox").prop("checked", false);

  if (lastQualitySettingiPad >= 0) {
    window.setTimeout(function () { setQualityPreference(lastQualitySettingiPad); }, 500);
  }
}

function disableCameraKit() {
  sendCommand(kDRCommandCameraKitDisable);
}

function enableCameraKit() {
  sendCommand(kDRCommandCameraKitEnable);
}

function onFullscreenChange() {
  if (!document.webkitFullscreenElement && !document.mozFullScreenElement) {

  }
}

function getScript(url, success) {
  var script = document.createElement('script');
  script.src = url;
  var head = document.getElementsByTagName('head')[0], done = false;
  script.onload = script.onreadystatechange = function () {
    if (!done && (!this.readyState || this.readyState == 'loaded' || this.readyState == 'complete')) {
      done = true;
      success();
      script.onload = script.onreadystatechange = null;
      head.removeChild(script);
    }
  };
  head.appendChild(script);
}

function byId(id) {
  return document.getElementById(id);
}

function degreesToRadians(degrees) {
  return degrees * Math.PI / 180;
};

function radiansToDegrees(radians) {
  return radians * 180 / Math.PI;
};

function prettyTime(seconds) {
  var hours = Math.floor(seconds / 3600);
  var minutes = Math.floor((seconds - (hours * 3600)) / 60);
  var seconds = seconds - (hours * 3600) - (minutes * 60);
  var str = "";
  if (hours > 0) {
    str += hours + "h";
  }
  if (minutes > 0) {
    if (str != "") {
      str += " ";
    }
    str += minutes + "m";
  }
  if (seconds > 0) {
    if (str != "") {
      str += " ";
    }
    str += seconds + "s";
  }
  return str;
}

function updateRobotsOnMap() {
  var hash = JSON.stringify(robotsList) + "-" + publicRobotsSwitch + "-" + JSON.stringify(calendarEvents);
  if (lastRobotsString != "" && lastRobotsString === hash) {
    // private robotsList is the same, so skipping
    return;
  } else {
    // robotsList is different, so updating
    lastRobotsString = hash;
  }

  robots = [];
  robotsPrivate = [];
  robotsPublic = [];

  if (robotsList.length > 0) {
    // add all robots, since we're getting rid of the private/public switch
    for (var i = 0; i < robotsList.length; i++) {
      robots.push(RobotWithSetup(robotsList[i].longitude, robotsList[i].latitude, robotsList[i]));
    }

    // Update list view
    var listHTML = "";
    for (var i = 0; i < robots.length; i++) {
      listHTML += robots[i].getHTML();
    }
    $("#list .robotsList").html(listHTML);

    if (robots.length > 0) {
      map.calculateMarkers();
      if (shouldZoomAfterLoadingRobots) {
        var locations = markerLayer.extent();
        if (JSON.stringify(locations[0]["lat"]) == "null") {
          // don't zoom, but let us zoom on the next one, if a robot appears
          shouldZoomAfterLoadingRobots = true;
        } else {
          self.mapboxMap.setExtent(locations);

          if (markerLayer.DRMarkersCount == 1) {
            self.mapboxMap.zoomBy(2);
            var extent = self.mapboxMap.getExtent();
            var height = extent.north - extent.south;
            var width = extent.west - extent.east;
            var newNorth = extent.north + height / 4;
            var widthDivisor = (isChromeAndroid()) ? 1 : 4;
            var newWest = extent.west + width / widthDivisor;
            self.mapboxMap.setExtent(new MM.Extent(newNorth, newWest, extent.south + height / 4, extent.east + width / 4));
            shouldZoomAfterLoadingRobots = false;
          }
        }

        updateZoomers();
        map.calculateMarkers();
      }

      hideNoRobotsConnectedMessage();
    } else {
      map.removeAllMarkers();
      showNoRobotsConnectedMessage();
      $("#list .robotsList").html("<div class=\"noRobots\">No Robots Online</div>");
    }
  } else {
    map.removeAllMarkers();
    showNoRobotsConnectedMessage();
    $("#list .robotsList").html("<div class=\"noRobots\">No Robots Online</div>");
  }
}

function showMessage(id) {
  $("#" + id + " .shade").hide();
  $("#" + id + " .message").css({ top: "-500px" });
  $("#" + id).show();
  // $("#" + id).addClass("visible");
  // window.setTimeout(() => {
  // 	$("#" + id + " .message").addClass("visible");
  // }, 50);
  $("#" + id + " .shade").fadeIn(200);
  $("#" + id + " .message").animate({ top: "70px" }, 200);
  try {
    q("#" + id + " .header .doneButton").focus();
  } catch (err) { }
  lastShownMessageId = id;
}

function hideMessage(id) {
  if (!id) {
    return;
  }
  $("#" + id + " .shade").fadeOut(200);
  $("#" + id + " .message").animate({ top: "-500px" }, 200, function () {
    $("#" + id).hide();
  });
}

function hideLastShownMessageId() {
  switch (lastShownMessageId) {
    case "preCallWebcam":
      hidePreCallWebcam();
      break;
    case "webcamSetup":
      hideWebcamSetup(true);
      break;
    default:
      hideMessage(lastShownMessageId);
  }
}

function hideAllMessages() {
  $(".shadedOverlay .shade").fadeOut(200);
  $(".shadedOverlay .message").animate({ top: "-500px" }, 200, function () {
    $(this).parent().hide();
  });
}

function showPublicRobots() {
  publicRobotsSwitch = 1;
  shouldZoomAfterLoadingRobots = true;
  $("#segmentedPrivate").removeClass("selected");
  $("#segmentedPublic").addClass("selected");
  window.location.hash = "#public";
}

function isShowingWebPage() {
  if (getSidebarAppByKey("webpage")) {
    return (sidebarApp && sidebarApp.key == "webpage");
  }
  return showingWebPage;
}

function showWebPageDialog() {
  if (isShowingWebPage()) {
    hideWebPage();
    return;
  }
  showMessage("showWebPage");
  $('#showWebPageURL').focus();
}

function toggleDisplayWebPage() {
  if (getSidebarAppByKey("webpage")) {
    if (isShowingWebPage()) {
      stopSidebarApp();
    } else {
      startSidebarAppByKey("webpage");
    }
  } else {
    if (isShowingWebPage()) {
      hideWebPage();
    } else {
      showWebPageDialog();
    }
  }
}

function showWebPage() {
  endScreenSharing();
  if (screenSharingWebRTC && screenSharingWebRTC.isActive()) {
    screenSharingWebRTC.end();
  }

  var URL = $("#showWebPageURL").val();
  URL = (URL.indexOf('://') == -1) ? 'http://' + URL : URL;
  sendCommandWithData(kDRCommandWebURLShow, { "URL": URL });
  $("#showWebPage").hide();
  $("#displayWebPageButton").addClass("on");
  $("#displayWebPageButton2").addClass("on");
  $("#displayWebPageContainer").show();
  showingWebPage = true;
  window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 300);
  window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 1000);
}

function hideWebPage() {
  sendCommandWithData(kDRCommandWebURLHide);
  $("#displayWebPageButton").removeClass("on");
  $("#displayWebPageButton2").removeClass("on");
  $("#displayWebPageContainer").hide();
  showingWebPage = false;
  window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 300);
  window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 1000);
}

function showSettings() {
  showMessage("settings");
  getCurrentUserData(function () {
    if (configuration && configuration.data && configuration.data.company && configuration.data.company.name) {
      $("#accountOrganization").html(configuration.data.company.name);
    } else {
      $("#accountOrganization").html("(None) <a href='https://www.doublerobotics.com/fleet-management.html' class='blueButton small bordered' style='margin-left: 5px;' target='_blank'>Try Fleet Management</a>");
    }
    $("#accountEmail").html(currentUser.email);
  });
}

function toggleScreenSharing() {
  if (getSidebarAppByKey("screensharing")) {
    if (sidebarApp && sidebarApp.key == "screensharing") {
      stopSidebarApp();
    } else {
      startSidebarAppByKey("screensharing");
    }
  } else {
    if (remoteRobotSupports("nativeWebRTC")) {
      if (screenSharingWebRTC) {
        if (screenSharingWebRTC.isActive()) {
          screenSharingWebRTC.end();
        } else {
          if (isShowingWebPage()) {
            hideWebPage();
          }
          screenSharingWebRTC.begin();
        }
      }
    } else {
      opentokToggleScreenSharing();
    }
  }
}

function endScreenSharing() {
  if (remoteRobotSupports("nativeWebRTC")) {
    if (screenSharingWebRTC) {
      screenSharingWebRTC.end();
    }
  } else {
    opentokStopScreenSharing();
  }
}

function isChromeAndroid() {
  return (navigator.userAgent.toLowerCase().indexOf("chrome") >= 0 && navigator.userAgent.toLowerCase().indexOf("android") >= 0);
}

function isIE() {
  var userAgent = window.navigator.userAgent.toLowerCase();
  var appName = window.navigator.appName;
  return (appName === 'Microsoft Internet Explorer' ||                     		// IE <= 10
    (appName === 'Netscape' && userAgent.indexOf('trident') > -1));     // IE >= 11
}

function toggleMultiparty() {
  if (sessionIsMultipartyHost) {
    endMultiparty();
  } else {
    if (remoteRobotSupports("sidebarApps") && getSidebarAppByKey("multiviewer")) {
      startSidebarAppByKey("multiviewer");
    } else {
      showMultiparty();
    }
  }
  updateUserInterface();
}

function showMultiparty() {
  $("#multipartyStep1").show();
  $("#multipartyStep2").hide();
  $("#multipartyStep3").hide();
  showMessage("multipartyMessage");
}

function beginMultiparty() {
  $("#multipartyStep1").hide();
  $("#multipartyStep2").show();
  $("#multipartyStep3").hide();
  showMessage("multipartyMessage");
  if (remoteRobotSupports("nativeWebRTC") && nativeWebRTC) {
    $("#multipartyAudioLevels").hide();
    $("#multipartyAudioLevels .heading a").hide();
  } else {
    $("#multipartyAudioLevels").show();
    $("#multipartyAudioLevels .heading a").show();
  }
  resetVideoLink(true);
  window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 300);
  window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 1000);
}

function showMultipartyLink(link) {
  $("#multipartyLink").val(link);
  $("#multipartyStep1").hide();
  $("#multipartyStep2").hide();
  $("#multipartyStep3").show();
  $("#multipartyLink").focus();
}

function endMultiparty() {
  $("#multipartyStep1").hide();
  $("#multipartyStep2").hide();
  $("#multipartyStep3").hide();
  hideMessage("multipartyMessage");
  $("#multipartyAudioLevels .viewer").hide();
  $("#multipartyAudioLevels").hide();
  sessionIsMultipartyHost = false;
  multipartyLink = null;
  multipartyViewers = [];

  if (nativeWebRTC && nativeWebRTC.isActive()) {
    if (sidebarApp && sidebarApp.key == "multiviewer") {
      stopSidebarApp();
    }
    sendCommand(kDRCommandMultipartyEnd);
  } else {
    resetVideoLink();
    opentokDisconnect();
    nativeWebRTC.end();
  }

  window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 300);
  window.setTimeout(() => { sendCommand(kDRCommandRequestStatusData); }, 1000);
}

function sortObject(o) {
  var sorted = {},
    key, a = [];

  for (key in o) {
    if (o.hasOwnProperty(key)) {
      a.push(key);
    }
  }

  a.sort();

  for (key = 0; key < a.length; key++) {
    sorted[a[key]] = o[a[key]];
  }

  return sorted;
}

function promptToJoinMultipartySession() {
  if (currentUser && currentUser.isLoggedIn()) {
    console.log("join = " + getURLParameter("join"));
    showMessage("joinMultiparty");
    $("#joinMultipartyName").focus();
  }
}

function joinMultipartySession(key, name) {
  hideMessage("joinMultiparty");
  window.setTimeout(function () {
    sessionIsViewer = true;
    multipartyViewerId = makeInstallationId();
    multipartyViewerName = name;
    beginSession();
    $("#multipartyAudioLevels").show();
    $("#multipartyAudioLevels .heading a").hide();
    sendCommandWithData(kDRCommandJoinSession, { "key": key, "viewerId": multipartyViewerId });
  }, 500);
}

function promptToWatchBroadcast() {
  console.log("watch = " + getURLParameter("watch"));
  showMessage("watchBroadcast");
  $("#watchBroadcastButton").focus();
}

function addViewer(viewerId, name) {
  if (sidebarApp && sidebarApp.key && sidebarApp.key == "multiviewer") {
    var iframe = document.getElementById("sidebarIframe");
    if (iframe && iframe.contentWindow) {
      iframe.contentWindow.postMessage({
        c: "ViewerName",
        d: {
          viewerId: viewerId,
          name: name
        }
      }, "*");
    }
    return;
  }

  var viewer = {
    viewerId: viewerId,
    name: name
  };

  var foundViewer = false;
  for (var i = 0; i < multipartyViewers.length; i++) {
    var v = multipartyViewers[i];
    if (v && v.viewerId && v.viewerId == viewerId) {
      foundViewer = true;
    }
  }

  if (!foundViewer) {
    multipartyViewers.push(viewer);
  }

  $("#multipartyAudioLevels").append("<div id=\"multiparty_" + sanitizedString(viewerId) + "\" class=\"viewer\"><div class=\"name\">" + sanitizedString(name) + "</div><div class=\"audioLevel\"><div class=\"bar\"></div></div></div>");
  broadcastMultipartyViewersList();
}

function attachAudioToViewer(viewerId, streamId) {
  if (sidebarApp && sidebarApp.key && sidebarApp.key == "multiviewer") {
    var iframe = document.getElementById("sidebarIframe");
    if (iframe && iframe.contentWindow) {
      iframe.contentWindow.postMessage({
        c: "ViewerId",
        d: {
          viewerId: viewerId,
          streamId: streamId
        }
      }, "*");
    }
    return;
  }

  for (var i = 0; i < multipartyViewers.length; i++) {
    var v = multipartyViewers[i];
    if (v && v.viewerId && v.viewerId == viewerId) {
      multipartyViewers[i].streamId = streamId;
    }
  }
  $("#multiparty_" + sanitizedString(viewerId) + " .audioLevel").attr("id", "stream_" + sanitizedString(streamId));
  broadcastMultipartyViewersList();
}

function removeViewer(viewerId) {
  if (sidebarApp && sidebarApp.key && sidebarApp.key == "multiviewer") {
    var iframe = document.getElementById("sidebarIframe");
    if (iframe && iframe.contentWindow) {
      iframe.contentWindow.postMessage({
        c: "ViewerDidLeave",
        d: {
          viewerId: viewerId
        }
      }, "*");
    }
    return;
  }

  $("#multiparty_" + sanitizedString(viewerId)).remove();
}

function removeViewerByStreamId(streamId) {
  $("#stream_" + streamId).parent().remove();
}

function copyMultipartyLink() {
  prompt("Copy and send this link to your guests:", multipartyLink);
}

function broadcastMultipartyViewersList() {
  if (sessionIsMultipartyHost) {
    sendCommandWithData(kDRCommandMultipartyViewers, { viewers: multipartyViewers });
  }
}

function redrawMultipartyViewers() {
  $("#multipartyAudioLevels .viewer").remove();

  for (var i = 0; i < multipartyViewers.length; i++) {
    var v = multipartyViewers[i];
    if (v && v.viewerId) {
      addViewer(v.viewerId, v.name);
      if (v.streamId) {
        attachAudioToViewer(v.viewerId, v.streamId);
      }
    }
  }
}

function sanitizedString(text) {
  var map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  };
  return text.replace(/[&<>"']/g, function (m) { return map[m]; });
}

function setRelayServer(server) {
  if (server && server.length > 5) {
    sendCommandWithData(kDRCommandSetRelayServer, { server: server });
    relaySocket = io.connect(server, { secure: ('https:' == document.location.protocol), forceNew: true, 'force new connection': true, reconnect: false, reconnection: false });

    relaySocket.on('disconnect', function () {
      if (relaySocket != undefined) {
        relaySocket.reconnect();
      }
    });

    console.log("Connecting to relay server: " + server);
  }
}

function clearRelayServer() {
  sendCommand(kDRCommandSetRelayServer);
  if (relaySocket) {
    var temp = relaySocket;
    relaySocket = undefined;
    temp.disconnect();
    temp = undefined;
  }
}

function updateStats() {
  var subscriberSize;
  if (opentokSubscriber) {
    // opentokSubscriber.getStats(function (error, stats) {
    // 	console.log("Video packets lost: "+ stats.video.packetsLost);
    // });
    subscriberSize = opentokSubscriber.stream.videoDimensions;
  }

  var out = "";
  if (subscriberSize) {
    lastFrameWidth = subscriberSize.width;
    lastFrameHeight = subscriberSize.height;
    out += lastFrameWidth + " x " + lastFrameHeight;
  }
  $("#qualityStatsResolution").html(out);

  if (opentokSubscriber) {
    opentokSubscriber.getStats(function (error, stats) {
      if (stats && stats.video) {
        // fps
        lastFrameRate = Math.round(stats.video.frameRate);
        $("#qualityStatsFps").html(lastFrameRate + " FPS");

        // bandwidth
        var time = Date.now();
        var bytesVideo = stats.video.bytesReceived - lastBytesReceivedVideo;
        var bytesAudio = stats.audio.bytesReceived - lastBytesReceivedAudio;
        var bytes = (stats.video.bytesReceived + stats.audio.bytesReceived) - lastBytesReceived;
        var interval = (time - lastStatsTimestamp) / 1000; // stats.timestamp is in milliseconds
        var newBandwidthVideo = bytesVideo / interval / 125000;
        var newBandwidthAudio = bytesAudio / interval / 125000;
        var newBandwidth = bytes / interval / 125000;
        lastBandwidthVideo = lastBandwidthVideo * 0.6 + newBandwidthVideo * 0.4;
        lastBandwidthAudio = lastBandwidthAudio * 0.6 + newBandwidthAudio * 0.4;
        lastBandwidth = lastBandwidth * 0.6 + newBandwidth * 0.4;
        var bytesDisplay = lastBandwidth.toFixed(1) + " Mbit/s";
        $("#qualityStatsBytes").html(bytesDisplay);
        if (lastBandwidth == NaN) {
          lastBandwidth = 0;
        }
        lastBytesReceivedVideo = stats.video.bytesReceived;
        lastBytesReceivedAudio = stats.audio.bytesReceived;
        lastBytesReceived = stats.video.bytesReceived + stats.audio.bytesReceived;
        lastStatsTimestamp = time + 0.0;
        // console.log(bytes +" - "+ interval);

        // packet loss
        if (stats.video.packetsReceived == NaN || stats.audio.packetsReceived == NaN) {
          $("#qualityStatsPacketLoss").html("-- Packet Loss");
        } else {
          var receivedVideo = stats.video.packetsReceived - lastPacketsReceivedVideo;
          var receivedAudio = stats.audio.packetsReceived - lastPacketsReceivedAudio;
          var received = receivedVideo + receivedAudio - lastPacketsReceivedVideo - lastPacketsReceivedAudio;
          var lostVideo = stats.video.packetsLost - lastPacketsLostVideo;
          var lostAudio = stats.audio.packetsLost - lastPacketsLostAudio;
          var lost = lostVideo + lostAudio;
          var lostPercentVideo = (receivedVideo > 0) ? lostVideo / (receivedVideo + lostVideo) : 0;
          var lostPercentAudio = (receivedVideo > 0) ? lostAudio / (receivedAudio + lostAudio) : 0;
          var lostPercent = (received > 0) ? lost / (received + lost) : 0;
          lastPacketLossVideo = lastPacketLossVideo * 0.6 + lostPercentVideo * 0.4;
          lastPacketLossAudio = lastPacketLossAudio * 0.6 + lostPercentAudio * 0.4;
          lastPacketLoss = lastPacketLoss * 0.6 + lostPercent * 0.4;
          var lostDisplay = Math.round(lostPercent * 100) + "% Packet Loss";
          $("#qualityStatsPacketLoss").html(lostDisplay);
          lastPacketsReceivedVideo = stats.video.packetsReceived;
          lastPacketsLostVideo = stats.video.packetsLost;
          lastPacketsReceivedAudio = stats.audio.packetsReceived;
          lastPacketsLostAudio = stats.audio.packetsLost;
        }
      }
    });
  }

  if (sessionBeginDate) {
    // var seconds = Math.round((Date.now() - sessionBeginDate) / 1000);
    // var minutes = Math.floor(seconds / 60);
    // var hours = Math.floor(seconds / 60 / 60);
    // minutes = hours > 0 ? minutes % (hours * 60) : minutes;
    // seconds = minutes > 0 ? seconds % (minutes * 60) : seconds;
    // var timeString = seconds + "s";
    // if (minutes > 0) {
    // 	timeString = minutes + "m " + timeString;
    // }
    // if (hours > 0) {
    // 	timeString = hours + "h " + timeString;
    // }
    timeString = "Call Time: " + prettyTime(Math.round((Date.now() - sessionBeginDate) / 1000));
    $("#endButton").attr("title", "End Call (" + timeString + ")");
    $("#qualityStatsCallTime").text(timeString);
    $("#webrtcCallTime").text(timeString);
  }
}

function toggleQualityStats() {
  if ($("#qualityStats").is(":visible")) {
    hideQualityStats();
  } else {
    showQualityStats();
  }
}

function showQualityStats() {
  $("#qualityStats").show();
}

function hideQualityStats() {
  $("#qualityStats").hide();
}

function showWebcamSetup() {
  opentokHardwareSetupShow(q("#webcamSetupContainer"));
  showMessage('webcamSetup');
}

function hideWebcamSetup(apply) {
  hideMessage("webcamSetup");
  window.setTimeout(function () {
    opentokHardwareSetupHide(apply);
  }, 500);
}

function sendPing() {
  if (isConnected) {
    externalPingSentTime = new Date();
    externalPingLastKey = Math.random();
    sendCommandWithData(kDRCommandPing, { key: externalPingLastKey });
  }
}

function sendSessionLog(withEndAction) {
  if (!doubleSessionId || !parseInt(doubleSessionId) || doubleSessionId <= 0 || !currentUser) {
    return;
  }
  if (withEndAction === undefined) {
    withEndAction = 0;
  }

  var browser = getBrowserDetails();
  var values = {
    statsVersion: 4,
    sessionId: doubleSessionId,
    role: (sessionIsViewer) ? kDRRoleViewer : kDRRoleDriver,
    fps: lastFrameRate,
    frameWidth: lastFrameWidth,
    frameHeight: lastFrameHeight,
    bitrate: lastBandwidth,
    packetLoss: lastPacketLoss,
    audioBitrate: lastBandwidthAudio,
    audioPacketLoss: lastPacketLossAudio,
    videoBitrate: lastBandwidthVideo,
    videoPacketLoss: lastPacketLossVideo,
    throttle: statsDrive,
    powerDrive: statsPowerDrive,
    turn: statsTurn,
    pole: statsPole,
    screensharing: (opentokScreenSharingPublisher || (screenSharingWebRTC && screenSharingWebRTC.isActive())) ? 1 : 0,
    multiviewer: (sessionIsMultipartyHost || sessionIsViewer) ? 1 : 0,
    os: browser.os,
    platform: browser.browser + " " + browser.majorVersion,
    robotIsConnected: remoteRobotSupports("robot"),
    audioKitConnected: remoteRobotSupports("audioKitIsConnected"),
    cameraKitConnected: remoteRobotSupports("cameraKitIsConnected"),
    micMuted: isMuted,
    micUsage: lastMicPeak,
    speakerIsMuted: speakerIsMuted,
    endAction: (withEndAction) ? 1 : 0,
    floorView: alwaysOnFloorViewEnabled,
    webpage: isShowingWebPage(),
    doubleType: (remoteRobotSupports("powerDrive")) ? 2 : 1,
    routing: (securityLevel == kDRRoutingMethodRouted) ? kDRRoutingMethodRouted : kDRRoutingMethodRelayed,
    cameraDevice: opentokVideoSourceDeviceName,
    micDevice: opentokAudioSourceDeviceName,
    audioBoostLevel: audioBoostLevel,
    graphicsLevel: graphicsLevel,
    installationKey: getCurrentInstallation().getKey(),
    parent: window != window.parent ? document.referrer : null
  };
  statsDrive = 0;
  statsPowerDrive = 0;
  statsTurn = 0;
  statsPole = 0;
  lastMicPeak = null;
  if ("qualityPreference" in statusValues) { values.qualityPreference = statusValues.qualityPreference; }
  if ("maxQualityPreference" in statusValues) { values.maxQualityPreference = statusValues.maxQualityPreference; }
  if ("pole" in statusValues) { values.poleHeight = statusValues.pole; }
  if ("kickstand" in statusValues) { values.kickstand = statusValues.kickstand; }
  if ("robot_dock_state" in statusValues) { values.dock = statusValues.robot_dock_state; }
  if ("cameraKitEnabled" in statusValues) { values.cameraKitEnabled = statusValues.cameraKitEnabled; }
  if ("volume" in statusValues) { values.volume = statusValues.volume; }
  if ("guidedAccessMode" in statusValues) { values.guidedAccess = statusValues.guidedAccessMode; }
  if ("robot_battery" in statusValues) { values.robotBattery = statusValues.robot_battery; }
  if ("ipad_battery" in statusValues) { values.iPadBattery = statusValues.ipad_battery; }

  if (nativeWebRTC && remoteRobotSupports("nativeWebRTC") && nativeWebRTC.stats && nativeWebRTC.stats.recv) {
    values.fps = nativeWebRTC.stats.recv.fps;
    values.frameWidth = nativeWebRTC.stats.recv.frameWidth;
    values.frameHeight = nativeWebRTC.stats.recv.frameHeight;
    values.bitrate = (nativeWebRTC.stats.recv.bitrate / 1000000).toFixed(2);
    // values.packetLoss = nativeWebRTC.stats.recv.packetLoss;
    // values.audioBitrate = nativeWebRTC.stats.recv.audioBitrate;
    // values.audioPacketLoss = nativeWebRTC.stats.recv.audioPacketLoss;
    // values.videoBitrate = nativeWebRTC.stats.recv.videoBitrate;
    // values.videoPacketLoss = nativeWebRTC.stats.recv.videoPacketLoss;
    values.latency = nativeWebRTC.stats.recv.latency;
    values.codec = nativeWebRTC.stats.recv.codec;
    values.transport = nativeWebRTC.stats.recv.transport;
  }

  if (lastExternalPingTime >= 0) {
    values.externalPing = lastExternalPingTime;
    lastExternalPingTime = -1;
  }
  var request = getSharedDBLHTTPClient().request("POST", kAPIEndpointSessionStat, values);
  var success = function (data) {
    // success
    // console.log("Stat: "+ data);

    if (data && data.success == true) {

    } else {

    }
  };
  var fail = function (data) {
    // failure

  };
  request.send(success, fail);

  if (nativeWebRTC && remoteRobotSupports("nativeWebRTC")) {
    nativeWebRTC.log("sessionStats", values);
  }
}

function startCalendarEvents() {
  calendarEventsInterval = window.setInterval(fireCalendarEvents, 60000);
}

function fireCalendarEvents() {
  if (isConnected && currentUser && currentUser.isLoggedIn() && !$("#session").is(":visible")) {
    var values = {
      "start": "now",
      "robots": "all",
      "timezone": "UTC",
      "_": Math.random()
    };
    var request = getSharedAdminDBLHTTPClient().request("GET", kAdminEndpointCalendarEvents, values);
    var success = function (data) {
      // success
      if (data.constructor === Array) {
        calendarEvents = data;
        updateRobotsOnMap();
      }
    };
    var fail = function (data) {
      // failure
      console.log("Failed to get events: ", data);
    };
    request.send(success, fail);
  }
}

var blockResetView = false;

function checkView(pose) {
  if (pose.wideCamera && pose.wideCamera.viewport && pose.wideCamera.viewport.zoom > 1.3) {
    var obj = $("#resetViewMessage");
    if (!obj.is(":visible") && !blockResetView) {
      obj.show();
    }
  } else {
    var obj = $("#resetViewMessage");
    if (obj.is(":visible")) {
      obj.hide();
    }
  }
}

function resetView() {
  sendCommandWithData(kDRCommandPTZOut, { by: 10 });
  blockResetView = true;
  window.setTimeout(function () {
    blockResetView = false;
  }, 2000);
  $("#resetViewMessage").hide();
}

// Picture in Picture

var qualityPreferenceBeforePip = -1;

function pictureInPictureAvailable() {
  return ("pictureInPictureEnabled" in document && !isTouchDevice);
}

function pictureInPictureIsEnabled() {
  return !!(document.pictureInPictureElement);
}

function enablePictureInPicture() {
  var el = q("#subscribers video");
  if (pictureInPictureAvailable() && el && typeof el.requestPictureInPicture === "function") {
    if (remoteRobotSupports("qualityPreference") && statusValues.hasOwnProperty("qualityPreference")
      && (statusValues && !statusValues.cameraKitEnabled)
      && (!sidebarApp || !sidebarApp.key || !sidebarApp.key == "multiviewer")) {
      qualityPreferenceBeforePip = statusValues.qualityPreference;
      setQualityPreference(0);
    } else {
      qualityPreferenceBeforePip = -1;
    }
    el.addEventListener("leavepictureinpicture", onLeavePictureInPicture);
    el.requestPictureInPicture();
    window.setTimeout(() => {
      updateUserInterface();
    }, 500);
  }
}

function disablePictureInPicture() {
  if (pictureInPictureAvailable()) {
    document.exitPictureInPicture();
    window.setTimeout(() => {
      updateUserInterface();
    }, 500);
  }
}

function onLeavePictureInPicture() {
  if (qualityPreferenceBeforePip >= 0) {
    setQualityPreference(qualityPreferenceBeforePip);
    qualityPreferenceBeforePip = -1;
  }

  window.setTimeout(() => {
    updateUserInterface();
  }, 500);

  var el = q("#subscribers video");
  if (el) {
    el.removeEventListener("leavepictureinpicture", onLeavePictureInPicture);
    el.play();
    window.setTimeout(() => {
      el.play();
    }, 500);
  }
}

function togglePictureInPicture() {
  if (pictureInPictureIsEnabled()) {
    disablePictureInPicture();
  } else {
    enablePictureInPicture();
  }
}

// Pre-Call Webcam

var preCallAllowed = true;
var preCallCameras = null;
var preCallMics = null;
var preCallVideo = null;
var preCallInstallationId = null;
var preCallAccessKey = null;
var preCallCurrentCameraId = null;
var preCallCurrentCameraLabel = null;
var preCallCurrentMicId = null;
var preCallCurrentMicLabel = null;
var preCallLastCameraId = null;
var preCallLastCameraLabel = null;
var preCallLastMicId = null;
var preCallLastMicLabel = null;
var preCallAudioContext = null;
var preCallListedWebcams = null;

function showPreCallWebcam(installationId, access_key) {
  if (installationId) {
    // Connecting to a robot
    preCallInstallationId = installationId;
    preCallAccessKey = access_key;
    $("#preCallWebcam input[name=done]").val("Connect");
    $("#preCallWebcam input[name=cancel]").show();
  } else {
    // Coming from Settings
    preCallInstallationId = null;
    preCallAccessKey = null;
    $("#preCallWebcam input[name=done]").val("Done");
    $("#preCallWebcam input[name=cancel]").hide();
  }
  preCallCameras = document.getElementById("preCallCameras");
  preCallMics = document.getElementById("preCallMics");
  preCallVideo = document.getElementById("preCallVideo");
  showMessage("preCallWebcam");
  listPreCallWebcams();
}

function stopPreCallWebcam() {
  if (preCallVideo && preCallVideo.srcObject) {
    preCallVideo.srcObject.getTracks().forEach(function (track) { track.stop(); });
    preCallVideo.srcObject = null;
  }
  preCallCurrentCameraId = null;
  preCallCurrentCameraLabel = null;
  preCallCurrentMicId = null;
  preCallCurrentMicLabel = null;
  preCallStopMicMeter();
}

function clearPreCallSelects() {
  preCallCameras.innerHTML = "";
  preCallMics.innerHTML = "";
}

function listPreCallWebcams(dontStop) {
  if (!dontStop) {
    stopPreCallWebcam();
  }
  clearPreCallSelects();
  navigator.mediaDevices.enumerateDevices()
    .then(function (devices) {
      var foundLastCameraId = false;
      var foundLastMicId = false;
      var foundDefaultCamera = false;
      var foundDefaultMic = false;
      devices.forEach(function (device) {
        var option = document.createElement("option");
        option.value = device.deviceId;
        option.innerText = device.label || device.deviceId;
        if (device.label) {
          // We don't get the labels on the first request (until we have permission)
          preCallListedWebcams = true;
        }
        if (device.kind == "videoinput") {
          preCallCameras.appendChild(option);
          if (preCallLastCameraId && device.deviceId == preCallLastCameraId) {
            foundLastCameraId = true;
          } else if (preCallLastCameraLabel && device.label == preCallLastCameraLabel) {
            foundLastCameraId = true;
            preCallLastCameraId = device.deviceId;
          } else if (device.deviceId == "default") {
            foundDefaultCamera = true;
          }
        } else if (device.kind == "audioinput") {
          preCallMics.appendChild(option);
          if (preCallLastMicId && device.deviceId == preCallLastMicId) {
            foundLastMicId = true;
          } else if (preCallLastMicLabel && device.label == preCallLastMicLabel) {
            foundLastMicId = true;
            preCallLastMicId = device.deviceId;
          } else if (device.deviceId == "default") {
            foundDefaultMic = true;
          }
        }
      });

      if (foundLastCameraId) {
        preCallCameras.value = preCallLastCameraId;
      } else {
        preCallLastCameraId = null;
        preCallLastCameraLabel = null;
        if (foundDefaultCamera) {
          preCallCameras.value = "default";
        }
      }
      if (foundLastMicId) {
        preCallMics.value = preCallLastMicId;
      } else {
        preCallLastMicId = null;
        preCallLastMicLabel = null;
        if (foundDefaultMic) {
          preCallMics.value = "default";
        }
      }

      if (preCallCameras.childElementCount == 0) {
        var option = document.createElement("option");
        option.value = "None";
        option.innerText = "None";
        preCallCameras.appendChild(option);
      }

      updatePreCallWebcam();
    })
    .catch(function (err) {
      console.log(err.name + ": " + err.message);
    });
}

function hidePreCallWebcam() {
  stopPreCallWebcam();
  clearPreCallSelects();
  hideMessage("preCallWebcam");
}

async function updatePreCallWebcam() {
  var constraints = {
    audio: { deviceId: preCallMics.value }
  };
  if (preCallCameras.value == "None") {
    constraints.video = false;
  } else {
    constraints.video = {
      deviceId: preCallCameras.value,
      width: 640,
      height: 480,
      frameRate: 30
    };
  }
  var stream = await navigator.mediaDevices.getUserMedia(constraints).catch(e => {
    nonModalAlert("Unavailable", "Could not access camera and microphone.");
  });
  if (stream) {
    if (preCallVideo && preCallVideo.srcObject) {
      preCallVideo.srcObject.getTracks().forEach(function (track) { track.stop(); });
    }
    preCallVideo.srcObject = stream;
    preCallCurrentCameraId = preCallCameras.value;
    preCallCurrentCameraLabel = preCallCameras.options[preCallCameras.selectedIndex].text;
    preCallCurrentMicId = preCallMics.value;
    preCallCurrentMicLabel = preCallMics.options[preCallMics.selectedIndex].text;
    preCallStartMicMeter(stream);
    if (!preCallListedWebcams) {
      window.setTimeout(() => {
        listPreCallWebcams(true);
      }, 100);
    }

    preCallLastCameraId = preCallCurrentCameraId;
    preCallLastCameraLabel = preCallCurrentCameraLabel;
    preCallLastMicId = preCallCurrentMicId;
    preCallLastMicLabel = preCallCurrentMicLabel;
    saveSettings();
  }
}

function preCallStartMicMeter(mediaStream) {
  preCallStopMicMeter();

  preCallAudioContext = new (window.AudioContext || window.webkitAudioContext);
  var analyser = preCallAudioContext.createAnalyser();
  var microphone = preCallAudioContext.createMediaStreamSource(mediaStream);
  var javascriptNode = preCallAudioContext.createScriptProcessor(2048, 1, 1);

  analyser.smoothingTimeConstant = 0.5;
  analyser.fftSize = 1024;

  var segments = document.querySelectorAll("#preCallWebcam .meter .segment");

  microphone.connect(analyser);
  analyser.connect(javascriptNode);
  javascriptNode.connect(preCallAudioContext.destination);
  javascriptNode.onaudioprocess = function () {
    var array = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(array);
    var values = 0;
    var length = array.length;
    for (var i = 0; i < length; i++) {
      values += (array[i]);
    }
    var average = values / length;

    var segmentsOn = Math.round(average / 130 * segments.length);
    for (var i = 0; i < segments.length; i++) {
      if (i < segmentsOn) {
        segments[i].classList.add("on");
      } else {
        segments[i].classList.remove("on");
      }
    }
  };
}

function preCallStopMicMeter() {
  if (preCallAudioContext) {
    preCallAudioContext.close();
    preCallAudioContext = null;
    var segments = document.querySelectorAll("#preCallWebcam .meter .segment");
    for (var i = 0; i < segments.length; i++) {
      segments[i].classList.remove("on");
    }
  }
}

function connectAfterPreCallWebcam() {
  var mediaStream = null;
  if (preCallVideo && preCallVideo.srcObject) {
    mediaStream = preCallVideo.srcObject;
    preCallLastCameraId = preCallCameras.value;
    preCallLastMicId = preCallMics.value;
    nativeWebRTC.localVideoCameraId = preCallLastCameraId;
    nativeWebRTC.localVideoMicId = preCallLastMicId;
    nativeWebRTC.localVideoMediaStream = mediaStream;
    opentokVideoSourceDeviceId = preCallLastCameraId;
    opentokAudioSourceDeviceId = preCallLastMicId;
    preCallVideo.srcObject = null;
    preCallCurrentCameraId = null;
    preCallCurrentCameraLabel = null;
    preCallCurrentMicId = null;
    preCallCurrentMicLabel = null;
  }
  hidePreCallWebcam();
  if (preCallInstallationId && mediaStream) {
    window.setTimeout(() => {
      connectTo(preCallInstallationId, preCallAccessKey, mediaStream);
      mediaStream = null;
    }, 500);
  } else if (mediaStream) {
    mediaStream.getTracks().forEach(function (track) { track.stop(); });
    mediaStream = null;
  } else if (preCallInstallationId && !mediaStream) {
    nonModalAlert("Unavailable", "Camera and microphone not found.");
  }
}

var sidebarURL = null;
var sidebarStartOpen = true;
var sidebarApp = null;
var sidebarIndex = null;
var sidebarAppDisabledAudio = false;
var sidebarAppInterceptStop = false;
var pendingSidebarAppIndex = null;

function sidebarOpen() {
  q("#session").classList.add("withSidebar");
  centerRemoteVideo();
}

function sidebarClose() {
  q("#session").classList.remove("withSidebar");
  centerRemoteVideo();
}

function loadSidebarURL(url, open, xClassName, allow) {
  if (url) {
    // var urlObj = new URL(url, window.location.toString());
    // var baseUrl = urlObj.protocol + "//" + urlObj.hostname;
    // var allow = "camera " + baseUrl + "; microphone "+ baseUrl;
    if (!allow) {
      allow = "";
    }
    $("#sidebarIframe").attr("allow", allow);
    $("#sidebarIframe").attr("src", url);
    $("#sidebarOpener").removeClass("hidden");
    if (xClassName) {
      q("#sidebarX").classList.remove("darken");
      q("#sidebarX").classList.remove("lighten");
      q("#sidebarX").classList.add(xClassName);
    }
    if (open) {
      sidebarOpen();
    } else {
      sidebarClose();
    }
  } else {
    sidebarClose();
    $("#sidebarOpener").addClass("hidden");
    $("#sidebarIframe").attr("src", "");
    sidebarURL = null;
    sidebarApp = null;
    sidebarAppIndex = null;
  }
}

function sidebarLoaded() {
  if (!sidebarApp) { return; }

  sendCommandWithData(kDRCommandStartApp, { index: sidebarIndex, baseUrl: window.location.toString() });

  if (sidebarApp && sidebarApp.key && sidebarApp.key == "multiviewer") {
    if (sessionIsMultipartyHost && opentokSessionId && opentokSessionToken && opentokAPIKey) {
      var iframe = document.getElementById("sidebarIframe");
      if (iframe && iframe.contentWindow) {
        if (isMuted) {
          iframe.contentWindow.postMessage({ c: "MuteDriverMic" }, "*");
        } else {
          iframe.contentWindow.postMessage({ c: "UnmuteDriverMic" }, "*");
        }

        iframe.contentWindow.postMessage({
          c: "Connect",
          d: {
            apiKey: opentokAPIKey,
            sessionId: opentokSessionId,
            token: opentokSessionToken,
            link: multipartyLink
          }
        }, "*");
      }
    }
  }
}

function forceStopSidebarApp() {
  sendCommand(kDRCommandStopApp);
  if (sidebarAppDisabledAudio) {
    if (nativeWebRTC && nativeWebRTC.isActive()) {
      nativeWebRTC.unmutePublisher();
      nativeWebRTC.unmuteRemote();
      updateUserInterface();
    }
    sidebarAppDisabledAudio = false;
  }
  if (sidebarApp && sidebarApp.key == "multiviewer" && sessionIsMultipartyHost && sidebarAppInterceptStop) {
    sessionIsMultipartyHost = false;
  }
  highlightSidebarAppKey(null);
  sidebarAppInterceptStop = false;
  if (!isNaN(parseInt(pendingSidebarAppIndex))) {
    startSidebarApp(pendingSidebarAppIndex, true);
    pendingSidebarAppIndex = null;
  } else {
    loadSidebarURL(null);
  }
}

function stopSidebarApp() {
  if (sidebarAppInterceptStop) {
    var iframe = document.getElementById("sidebarIframe");
    if (iframe && iframe.contentWindow) {
      iframe.contentWindow.postMessage("stop", "*");
      return false;
    }
  } else {
    forceStopSidebarApp();
  }
  return true;
}

function getSidebarAppByKey(key) {
  if (Array.isArray(sidebarApps)) {
    for (var i = 0; i < sidebarApps.length; i++) {
      if (key && sidebarApps[i].key == key) {
        return sidebarApps[i];
      }
    }
  }
  return null;
}

function startSidebarAppByKey(key) {
  if (Array.isArray(sidebarApps)) {
    for (var i = 0; i < sidebarApps.length; i++) {
      if (key && sidebarApps[i].key == key) {
        startSidebarApp(i);
        return;
      }
    }
  }
}

function toggleAppByKey(key) {
  if (sidebarApp && sidebarApp.key && sidebarApp.key == key) {
    stopSidebarApp();
  } else {
    startSidebarAppByKey(key);
  }
}

function startSidebarApp(index, bypassStop) {
  hideAppsButtonPopover();
  if (sidebarApp && !bypassStop) {
    if (!stopSidebarApp()) {
      pendingSidebarAppIndex = index;
      return;
    }
  }
  if (sidebarApps && Array.isArray(sidebarApps) && sidebarApps.length > index) {
    sidebarIndex = index;
    var config = sidebarApps[index];
    var url;
    if (config.sidebar && config.sidebar.url) {
      sidebarApp = config;
      if (config.rootUrl) {
        url = config.rootUrl + config.sidebar.url;
        try {
          var urlObj = new URL(url, window.location.toString());
          urlObj.searchParams.append("_version", config.version || Math.round(Math.random() * 1000000));
          url = urlObj.toString();
        } catch (err) { }
      } else {
        url = config.sidebar.url;
      }
    }
    if (url) {
      var allow = "";
      var xClassName = "";
      if (config.sidebar) {
        if (config.sidebar.allow) {
          allow = config.sidebar.allow;
        }
        if (config.sidebar.xClassName) {
          xClassName = config.sidebar.xClassName;
        }
        if (!isNaN(parseInt(config.sidebar.width))) {
          sidebarAppDefaultWidth = Math.max(50, Math.min(500, parseInt(config.sidebar.width)));
        } else {
          sidebarAppDefaultWidth = 300;
        }
        sidebarAppWidth = sidebarAppDefaultWidth;
        if (!isNaN(parseInt(config.sidebar.minWidth))) {
          sidebarAppMinWidth = Math.min(sidebarAppDefaultWidth, parseInt(config.sidebar.minWidth));
        } else {
          sidebarAppMinWidth = Math.min(sidebarAppDefaultWidth, 250);
        }
        if (!isNaN(parseInt(config.sidebar.maxWidth))) {
          sidebarAppMaxWidth = Math.max(sidebarAppDefaultWidth, parseInt(config.sidebar.maxWidth));
        } else {
          sidebarAppMaxWidth = Math.max(sidebarAppDefaultWidth, 450);
        }
        sidebarAppInterceptStop = false;
      }
      loadSidebarURL(url, true, xClassName, allow);
      highlightSidebarAppKey(config.key);
    } else {
      loadSidebarURL(null);
    }
  } else {
    sidebarApp = null;
    sidebarIndex = null;
  }
  updateUserInterface();
}

function sidebarAppBlocksVideoQualityChange() {
  return (sidebarApp && sidebarApp.blockVideoQualityChanges);
}

function highlightSidebarAppKey(key) {
  if (Array.isArray(sidebarApps)) {
    for (var i = 0; i < sidebarApps.length; i++) {
      var el = q("#appButton_" + sidebarApps[i].key);
      if (el) {
        if (sidebarApps[i].key == key) {
          el.classList.add("on");
        } else {
          el.classList.remove("on");
        }
      }
      var gridEl = q("#sidebarAppsButton .iconsGrid .key_" + sidebarApps[i].key);
      if (gridEl) {
        if (sidebarApps[i].key == key) {
          gridEl.classList.add("on");
        } else {
          gridEl.classList.remove("on");
        }
      }
    }
  }
}

function hideAppsButtonPopover() {
  q("#sidebarAppsButton .popover").style.display = "none";
  window.setTimeout(() => {
    q("#sidebarAppsButton .popover").style.display = "";
  }, 100);
}

var sidebarAppWidth = 300;
var sidebarAppDefaultWidth = 300;
var sidebarAppMinWidth = 250;
var sidebarAppMaxWidth = 450;
var sidebarDragging = false;
var sidebarDraggedBeyondDefault = false;
var sidebarDragDownMouseX = -1;
var sidebarDragDownSidebarWidth = -1;
function sidebarDragDown(event) {
  event.preventDefault();
  sidebarDragging = true;
  sidebarDraggedBeyondDefault = false;
  q("#sidebar").style.pointerEvents = "none";
  sidebarDragDownMouseX = event.pageX;
  sidebarDragDownSidebarWidth = q("#sidebar").offsetWidth;
}
function sidebarDragMove(event) {
  if (sidebarDragging) {
    sidebarAppWidth = sidebarDragDownSidebarWidth - (event.pageX - sidebarDragDownMouseX);
    var shouldSnap = (Math.abs(sidebarAppWidth - sidebarAppDefaultWidth) <= 7);
    if (shouldSnap) {
      if (sidebarDraggedBeyondDefault) {
        sidebarAppWidth = sidebarAppDefaultWidth;
      }
    } else {
      sidebarDraggedBeyondDefault = true;
    }
    sidebarAppWidth = Math.min(sidebarAppMaxWidth, Math.max(sidebarAppMinWidth, sidebarAppWidth));
    centerRemoteVideo();
    event.preventDefault();
  }
}
function sidebarDragUp(event) {
  if (sidebarDragging) {
    sidebarDragMove(event);
    sidebarDragDownMouseX = -1;
    sidebarDragDownSidebarWidth = -1;
    q("#sidebar").style.pointerEvents = "all";
    event.preventDefault();
  }
  sidebarDragging = false;
}
function sidebarDragSetDefault(event) {
  sidebarAppWidth = sidebarAppDefaultWidth;
  centerRemoteVideo();
  if (event) {
    event.preventDefault();
  }
}
window.addEventListener("mousemove", (event) => {
  return sidebarDragMove(event);
});
window.addEventListener("mouseup", (event) => {
  return sidebarDragUp(event);
});

function nonModalAlert(title, message) {
  $("#nonModalAlert h2").text(title || "");
  $("#nonModalAlert .content").html(message || "");
  window.setTimeout(() => {
    showMessage("nonModalAlert");
  }, 500);
}

function processHit(hit) {
  if (hit && hit.hit && hit.info1 && !hit.action) {
    // this is a hit result object, so find the tag
    if (Array.isArray(drawDepth.lastTags)) {
      for (var i = 0; i < drawDepth.lastTags.length; i++) {
        if (drawDepth.lastTags[i].content == hit.info1) {
          hit = drawDepth.lastTags[i];
        }
      }
    }
  }
  if (hit && hit.action) {
    if (hit.action == "sidebarApp") {
      if (isTouchDevice) {
        nonModalAlert("Not Supported", "Sidebar apps aren't supported on this device.");
      } else {
        // TODO launch app
      }
    } else if (hit.action == "text") {
      nonModalAlert("QR Code", hit.content);
    } else {
      var destination;
      try {
        destination = new URL(hit.content);
      } catch (e) {
        try {
          destination = new URL("https://" + hit.content);
        } catch (e) { }
      }
      if (destination && destination.protocol !== "javascript:" && destination.protocol !== "file:") {
        if (hit.action == "sidebarLink" && !isTouchDevice) {
          stopSidebarApp();
          loadSidebarURL(destination.href, true, "darken", null);
        } else if (isTouchDevice) {
          nonModalAlert("Open Link", "<input type='button' class='blueButton' onclick=\"window.open('" + hit.content + "', '_blank')\" value='Open Link'>");
        } else {
          var result = window.open(destination.href, "_blank");
          console.log("window.open result", result);
        }
      } else {
        nonModalAlert("QR Code", "Unable to open: " + hit.content);
      }
    }
  }
}

function getCookie(name) {
  return $.cookie(COOKIE_PREFIX + name);
}

function setCookie(name, value, params) {
  return $.cookie(COOKIE_PREFIX + name, value, params);
}

function deleteCookie(name, params) {
  return $.removeCookie(COOKIE_PREFIX + name, params);
}

function q(q) {
  return document.querySelector(q);
}
